System.register(['./deprecated-8ebd570c.js'], function (exports) {
    'use strict';
    var makeEditorClassDecoratorFn, makeSmartEditorClassDecorator, property, _createClass, _classCallCheck, legacyCC, Vec3, _inherits, _possibleConstructorReturn, _getPrototypeOf, ccenum, Mat4, Mat3, EPSILON, Vec4, Enum, CCClass, clamp, pingPong, repeat, inverseLerp, replaceProperty, removeProperty, ccclass, _applyDecoratedDescriptor, serializable, editable, _initializerDefineProperty, _defineProperty, sys, warnID, _get, _createForOfIteratorHelperLoose, Asset, IDGenerator, _assertThisInitialized, errorID, type, BitMask, assertIsNonNullable, _toConsumableArray, warn, assertIsTrue, nextPow2, log2, Quat, Vec2, Rect, Size, rangeMin, rangeMax, Event, assertID, logID, CCObject, CallbacksInvoker, error$1, mixin, log, _typeof, getError, isChildClassOf, Component, EDITOR, getClassByName, executeInEditMode, help, menu, displayOrder, tooltip, clamp01, Pool, Color, toRadian, lerp, markAsWarning, displayName, formerlySerializedAs, visible, playOnFocus, inspector, icon, integer, _float, _boolean, string, editorOnly, BUILTIN_CLASSID_RE, _getClassById, Pool$1, clear, getClassAttrs, TEST, createMap, DELIMETER, value, _getClassId, getClassName, ValueType, obsolete, BASE64_VALUES, pushToMap, js, callInNextTick, RawAsset, downloadAudio, DEBUG, CCString, nextPow2$1, rect, setDisplayStats, _resetDebugSetting, EventTarget, CCFloat, slide, range, rangeStep, array, MutableForwardIterator;
    return {
        setters: [function (module) {
            makeEditorClassDecoratorFn = module.aJ;
            makeSmartEditorClassDecorator = module.aK;
            property = module.aL;
            _createClass = module.j;
            _classCallCheck = module.d;
            legacyCC = module.l;
            Vec3 = module.V;
            _inherits = module.b;
            _possibleConstructorReturn = module.e;
            _getPrototypeOf = module.f;
            ccenum = module.E;
            Mat4 = module.M;
            Mat3 = module.O;
            EPSILON = module.$;
            Vec4 = module.K;
            Enum = module.aj;
            CCClass = module.ar;
            clamp = module.k;
            pingPong = module.ae;
            repeat = module.ad;
            inverseLerp = module.af;
            replaceProperty = module.ao;
            removeProperty = module.ap;
            ccclass = module.c;
            _applyDecoratedDescriptor = module._;
            serializable = module.s;
            editable = module.F;
            _initializerDefineProperty = module.g;
            _defineProperty = module.aM;
            sys = module.aI;
            warnID = module.x;
            _get = module.aN;
            _createForOfIteratorHelperLoose = module.D;
            Asset = module.aC;
            IDGenerator = module.aO;
            _assertThisInitialized = module.i;
            errorID = module.y;
            type = module.t;
            BitMask = module.ai;
            assertIsNonNullable = module.aP;
            _toConsumableArray = module.aQ;
            warn = module.w;
            assertIsTrue = module.aR;
            nextPow2 = module.aS;
            log2 = module.aT;
            Quat = module.Q;
            Vec2 = module.H;
            Rect = module.W;
            Size = module.T;
            rangeMin = module.aU;
            rangeMax = module.aV;
            Event = module.ay;
            assertID = module.z;
            logID = module.v;
            CCObject = module.as;
            CallbacksInvoker = module.aW;
            error$1 = module.p;
            mixin = module.aX;
            log = module.o;
            _typeof = module.aY;
            getError = module.aZ;
            isChildClassOf = module.a_;
            Component = module.C;
            EDITOR = module.a$;
            getClassByName = module.b0;
            executeInEditMode = module.b1;
            help = module.h;
            menu = module.m;
            displayOrder = module.b2;
            tooltip = module.a;
            clamp01 = module.a2;
            Pool = module.P;
            Color = module.Y;
            toRadian = module.a4;
            lerp = module.a3;
            markAsWarning = module.aq;
            displayName = module.b3;
            formerlySerializedAs = module.b4;
            visible = module.b5;
            playOnFocus = module.b6;
            inspector = module.b7;
            icon = module.b8;
            integer = module.b9;
            _float = module.ba;
            _boolean = module.bb;
            string = module.bc;
            editorOnly = module.bd;
            BUILTIN_CLASSID_RE = module.be;
            _getClassById = module.bf;
            Pool$1 = module.bg;
            clear = module.bh;
            getClassAttrs = module.bi;
            TEST = module.bj;
            createMap = module.bk;
            DELIMETER = module.bl;
            value = module.bm;
            _getClassId = module.bn;
            getClassName = module.bo;
            ValueType = module.ak;
            obsolete = module.bp;
            BASE64_VALUES = module.bq;
            pushToMap = module.br;
            js = module.n;
            callInNextTick = module.bs;
            RawAsset = module.aB;
            downloadAudio = module.bt;
            DEBUG = module.bu;
            CCString = module.ax;
            nextPow2$1 = module.ac;
            rect = module.X;
            setDisplayStats = module.aH;
            _resetDebugSetting = module.bv;
            EventTarget = module.az;
            CCFloat = module.av;
            slide = module.bw;
            range = module.r;
            rangeStep = module.bx;
            array = module.by;
            MutableForwardIterator = module.bz;
        }],
        execute: function () {

            exports({
                B: void 0,
                D: void 0,
                E: void 0,
                F: void 0,
                G: void 0,
                H: void 0,
                O: ColorTemperatureToRGB,
                P: void 0,
                U: void 0,
                _: _normalize,
                a: changeBasename,
                a3: void 0,
                a4: void 0,
                a5: void 0,
                aA: createMesh,
                aD: isUnicodeCJK,
                aE: isUnicodeSpace,
                aF: safeMeasureText,
                aG: fragmentText,
                aI: murmurhash2_32_gc,
                aJ: WorldNode3DToLocalNodeUI,
                aK: WorldNode3DToWorldNodeUI,
                aN: deserialize,
                aO: instantiate,
                af: getDefaultFromType,
                ag: overrideMacros,
                ah: void 0,
                ak: void 0,
                am: genSamplerHash,
                ao: nearestPOT,
                av: isPropertyPath,
                aw: isCustomPath,
                az: evaluatePath,
                b: basename,
                bA: void 0,
                bB: void 0,
                bC: void 0,
                bD: void 0,
                bE: void 0,
                bF: void 0,
                bG: void 0,
                bH: void 0,
                bI: void 0,
                bJ: void 0,
                bK: void 0,
                bL: void 0,
                bM: void 0,
                bN: void 0,
                bO: void 0,
                bP: void 0,
                bQ: void 0,
                bR: void 0,
                bS: void 0,
                bT: void 0,
                bU: void 0,
                bV: void 0,
                bW: void 0,
                b_: void 0,
                bg: void 0,
                bu: void 0,
                bw: void 0,
                bx: void 0,
                by: void 0,
                bz: void 0,
                c: changeExtname,
                c4: void 0,
                c8: GFXFormatSize,
                c9: GFXFormatSurfaceSize,
                cC: IsPowerOf2,
                cZ: find,
                ca: GFXGetTypeSize,
                cb: getTypedArrayConstructor,
                cc: void 0,
                cd: void 0,
                d: dirname,
                d5: getPathFromRoot,
                d6: getWorldTransformUntilRoot,
                dG: void 0,
                dL: readMesh,
                dM: readBuffer,
                dN: writeBuffer,
                dO: mapBuffer,
                dQ: void 0,
                dR: void 0,
                dT: isLerpable,
                dU: void 0,
                dW: void 0,
                dZ: void 0,
                df: void 0,
                dj: void 0,
                dk: void 0,
                dm: void 0,
                dp: void 0,
                dq: void 0,
                ds: autoRelease,
                e: extname,
                f: void 0,
                g: getSeperator,
                h: void 0,
                i: void 0,
                j: join,
                k: selectJointsMediumFormat,
                m: mainFileName,
                o: getWorldMatrix,
                p: getTransform,
                q: deleteTransform,
                s: stripSep,
                t: void 0,
                v: cylinder,
                w: applyDefaultGeometryOptions,
                x: box,
                y: plane$1,
                z: capsule
            });

            /**
             * @category decorator
             */
            /**
             * @en Declare that the current component relies on another type of component. 
             * If the required component doesn't exist, the engine will create a new empty instance of the required component and add to the node.
             * @zh 为声明为 CCClass 的组件添加依赖的其它组件。当组件添加到节点上时，如果依赖的组件不存在，引擎将会自动将依赖组件添加到同一个节点，防止脚本出错。该设置在运行时同样有效。
             * @param requiredComponent The required component type
             * @example
             * ```ts
             * import {_decorator, Sprite, Component} from cc;
             * import {ccclass, requireComponent} from _decorator;
             *
             * @ccclass
             * @requireComponent(Sprite)
             * class SpriteCtrl extends Component {
             *     // ...
             * }
             * ```
             */

            var requireComponent = exports('da', makeEditorClassDecoratorFn('requireComponent'));
            /**
             * @en Set the component priority, it decides at which order the life cycle functions of components will be invoked. Smaller priority get invoked before larger priority.
             * This will affect `onLoad`, `onEnable`, `start`, `update` and `lateUpdate`, but `onDisable` and `onDestroy` won't be affected.
             * @zh 设置脚本生命周期方法调用的优先级。优先级小于 0 的组件将会优先执行，优先级大于 0 的组件将会延后执行。优先级仅会影响 onLoad, onEnable, start, update 和 lateUpdate，而 onDisable 和 onDestroy 不受影响。
             * @param priority - The execution order of life cycle methods for Component. Smaller priority get invoked before larger priority.
             * @example
             * ```ts
             * import { _decorator, Component } from 'cc';
             * const {ccclass, executionOrder} = _decorator;
             *
             * @ccclass
             * @executionOrder(1)
             * class CameraCtrl extends Component {
             *     // ...
             * }
             * ```
             */

            var executionOrder = exports('dd', makeEditorClassDecoratorFn('executionOrder'));
            /**
             * @en Forbid add multiple instances of the component to the same node.
             * @zh 防止多个相同类型（或子类型）的组件被添加到同一个节点。
             * @example
             * ```ts
             * import { _decorator, Component } from 'cc';
             * const {ccclass, disallowMultiple} = _decorator;
             *
             * @ccclass
             * @disallowMultiple
             * class CameraCtrl extends Component {
             *     // ...
             * }
             * ```
             */

            var disallowMultiple = exports('d9',  makeSmartEditorClassDecorator('disallowMultiple'));

            /**
             * @category decorator
             */
            var override = exports('dP', function override(target, propertyKey, descriptor) {
              return property({
                __noImplicit: true,
                override: true
              })(target, propertyKey, descriptor);
            });

            /**
             * @category memop
             */

            /**
             * @en Recyclable object pool. It's designed to be entirely reused each time.
             * There is no put and get method, each time you get the [[data]], you can use all elements as new.
             * You shouldn't simultaneously use the same RecyclePool in more than two overlapped logic.
             * Its size can be automatically incremented or manually resized.
             * @zh 循环对象池。这种池子被设计为每次使用都完整复用。
             * 它没有回收和提取的函数，通过获取 [[data]] 可以获取池子中所有元素，全部都应该被当做新对象来使用。
             * 开发者不应该在相互交叉的不同逻辑中同时使用同一个循环对象池。
             * 池子尺寸可以在池子满时自动扩充，也可以手动调整。
             * @see [[Pool]]
             */
            var RecyclePool = exports('R', /*#__PURE__*/function () {
              /**
               * @en Constructor with the allocator of elements and initial pool size, all elements will be pre-allocated.
               * @zh 使用元素的构造器和初始大小的构造函数，所有元素都会被预创建。
               * @param fn The allocator of elements in pool, it's invoked directly without `new`
               * @param size Initial pool size
               */
              function RecyclePool(fn, size) {
                _classCallCheck(this, RecyclePool);

                this._fn = void 0;
                this._count = 0;
                this._data = void 0;
                this._fn = fn;
                this._data = new Array(size);

                for (var i = 0; i < size; ++i) {
                  this._data[i] = fn();
                }
              }
              /**
               * @en The length of the object pool.
               * @zh 对象池大小。
               */


              _createClass(RecyclePool, [{
                key: "reset",

                /**
                 * @en Resets the object pool. Only changes the length to 0
                 * @zh 清空对象池。目前仅仅会设置尺寸为 0
                 */
                value: function reset() {
                  this._count = 0;
                }
                /**
                 * @en Resize the object poo, and fills with new created elements.
                 * @zh 设置对象池大小，并填充新的元素。
                 * @param size The new size of the pool
                 */

              }, {
                key: "resize",
                value: function resize(size) {
                  if (size > this._data.length) {
                    for (var i = this._data.length; i < size; ++i) {
                      this._data[i] = this._fn();
                    }
                  }
                }
                /**
                 * @en Expand the object pool, the size will be increment to current size times two, and fills with new created elements.
                 * @zh 扩充对象池容量，会自动扩充尺寸到两倍，并填充新的元素。
                 * @param idx 
                 */

              }, {
                key: "add",
                value: function add() {
                  if (this._count >= this._data.length) {
                    this.resize(this._data.length * 2);
                  }

                  return this._data[this._count++];
                }
                /**
                 * @en Remove an element of the object pool. This will also decrease size of the pool
                 * @zh 移除对象池中的一个元素，同时会减小池子尺寸。
                 * @param idx The index of the element to be removed
                 */

              }, {
                key: "removeAt",
                value: function removeAt(idx) {
                  if (idx >= this._count) {
                    return;
                  }

                  var last = this._count - 1;
                  var tmp = this._data[idx];
                  this._data[idx] = this._data[last];
                  this._data[last] = tmp;
                  this._count -= 1;
                }
              }, {
                key: "length",
                get: function get() {
                  return this._count;
                }
                /**
                 * @en The underlying array of all pool elements.
                 * @zh 实际对象池数组。
                 */

              }, {
                key: "data",
                get: function get() {
                  return this._data;
                }
              }]);

              return RecyclePool;
            }());

            /**
             * @category memop
             */

            /**
             * @en
             * Cached array is a data structure for objects cache, it's designed for persistent data.
             * Its content array length will keep grow.
             * @zh
             * 适用于对象缓存的数组类型封装，一般用于不易被移除的常驻数据。
             * 它的内部数组长度会持续增长，不会减少。
             */
            var CachedArray = exports('C', /*#__PURE__*/function () {
              /**
               * @en
               * The array which stores actual content
               * @zh
               * 实际存储数据内容的数组
               */

              /**
               * @en
               * The actual count of data object
               * @zh
               * 实际数据内容数量
               */

              /**
               * @param length Initial length
               * @param compareFn Comparison function for sorting
               */
              function CachedArray(length, compareFn) {
                _classCallCheck(this, CachedArray);

                this.array = void 0;
                this.length = 0;
                this._compareFn = void 0;
                this.array = new Array(length);
                this.length = 0;

                if (compareFn !== undefined) {
                  this._compareFn = compareFn;
                } else {
                  this._compareFn = function (a, b) {
                    return a - b;
                  };
                }
              }
              /**
               * @en
               * Push an element to the end of the array
               * @zh
               * 向数组末尾添加一个元素
               * @param item The item to be added
               */


              _createClass(CachedArray, [{
                key: "push",
                value: function push(item) {
                  this.array[this.length++] = item;
                }
                /**
                 * @en
                 * Pop the last element in the array. The [[length]] will reduce, but the internal array will keep its size.
                 * @zh
                 * 弹出数组最后一个元素，CachedArray 的 [[length]] 会减少，但是内部数组的实际长度不变
                 * @return The last element.
                 */

              }, {
                key: "pop",
                value: function pop() {
                  return this.array[--this.length];
                }
                /**
                 * @en
                 * Get the element at the specified index of the array
                 * @zh
                 * 得到数组中指定位置的元素
                 * @param idx The index of the requested element
                 * @return The element at given index
                 */

              }, {
                key: "get",
                value: function get(idx) {
                  return this.array[idx];
                }
                /**
                 * @en
                 * Clear the cache. The [[length]] will be set to 0, but the internal array will keep its size.
                 * @zh
                 * 清空数组所有元素。[[length]] 会被设为 0，但内部数组的实际长度不变
                 */

              }, {
                key: "clear",
                value: function clear() {
                  this.length = 0;
                }
                /**
                 * @en
                 * Clear the cache. The [[length]] will be set to 0, and clear the internal array.
                 * @zh
                 * 清空数组所有元素。[[length]] 会被设为 0，并且清空内部数组
                 */

              }, {
                key: "destroy",
                value: function destroy() {
                  this.length = 0;
                  this.array.length = 0;
                }
                /**
                 * @en
                 * Sort the existing elements in cache
                 * @zh
                 * 排序所有现有元素
                 */

              }, {
                key: "sort",
                value: function sort() {
                  this.array.length = this.length;
                  this.array.sort(this._compareFn);
                }
                /**
                 * @en
                 * Add all elements of a given array to the end of the current array
                 * @zh
                 * 添加一个指定数组中的所有元素到当前数组末尾
                 * @param array The given array to be appended
                 */

              }, {
                key: "concat",
                value: function concat(array) {
                  for (var i = 0; i < array.length; ++i) {
                    this.array[this.length++] = array[i];
                  }
                }
                /**
                 * @en Delete the element at the specified location and move the last element to that location.
                 * @zh 删除指定位置的元素并将最后一个元素移动至该位置。
                 * @param idx The index of the element to be deleted
                 */

              }, {
                key: "fastRemove",
                value: function fastRemove(idx) {
                  if (idx >= this.length || idx < 0) {
                    return;
                  }

                  var last = --this.length;
                  this.array[idx] = this.array[last];
                }
                /**
                 * @en Returns the first index at which a given element can be found in the array.
                 * @zh 返回在数组中可以找到一个给定元素的第一个索引。
                 * @param val The element
                 */

              }, {
                key: "indexOf",
                value: function indexOf(val) {
                  return this.array.indexOf(val);
                }
              }]);

              return CachedArray;
            }());

            /*
             Copyright (c) 2013-2016 Chukong Technologies Inc.
             Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

             http://www.cocos.com

             Permission is hereby granted, free of charge, to any person obtaining a copy
             of this software and associated engine source code (the "Software"), a limited,
              worldwide, royalty-free, non-assignable, revocable and non-exclusive license
             to use Cocos Creator solely to develop games on your target platforms. You shall
              not use Cocos Creator software for developing other software or tools that's
              used for developing games. You are not granted to publish, distribute,
              sublicense, and/or sell copies of Cocos Creator.

             The software or tools in this License Agreement are licensed, not sold.
             Xiamen Yaji Software Co., Ltd. reserves all rights not expressly granted to you.

             THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
             THE SOFTWARE.
            */
            var EXTNAME_RE = /(\.[^\.\/\?\\]*)(\?.*)?$/;
            var DIRNAME_RE = /((.*)(\/|\\|\\\\))?(.*?\..*$)?/;
            var NORMALIZE_RE = /[^\.\/]+\/\.\.\//;
            /**
             * @en Join strings to be a path.
             * @zh 拼接字符串为路径。
             * @example {@link cocos/core/utils/CCPath/join.js}
             */

            function join() {
              var result = '';

              for (var _len = arguments.length, segments = new Array(_len), _key = 0; _key < _len; _key++) {
                segments[_key] = arguments[_key];
              }

              for (var _i = 0, _segments = segments; _i < _segments.length; _i++) {
                var segment = _segments[_i];
                result = (result + (result === '' ? '' : '/') + segment).replace(/(\/|\\\\)$/, '');
              }

              return result;
            }
            /**
             * @en Get the ext name of a path including '.', like '.png'.
             * @zh 返回 Path 的扩展名，包括 '.'，例如 '.png'。
             * @example {@link cocos/core/utils/CCPath/extname.js}
             */

            function extname(path) {
              var temp = EXTNAME_RE.exec(path);
              return temp ? temp[1] : '';
            }
            /**
             * @en Get the main name of a file name.
             * @zh 获取文件名的主名称。
             * @deprecated
             */

            function mainFileName(fileName) {
              if (fileName) {
                var idx = fileName.lastIndexOf('.');

                if (idx !== -1) {
                  return fileName.substring(0, idx);
                }
              }

              return fileName;
            }
            /**
             * @en Get the file name of a file path.
             * @zh 获取文件路径的文件名。
             * @example {@link cocos/core/utils/CCPath/basename.js}
             */

            function basename(path, extName) {
              var index = path.indexOf('?');

              if (index > 0) {
                path = path.substring(0, index);
              }

              var reg = /(\/|\\)([^\/\\]+)$/g;
              var result = reg.exec(path.replace(/(\/|\\)$/, ''));

              if (!result) {
                return '';
              }

              var baseName = result[2];

              if (extName && path.substring(path.length - extName.length).toLowerCase() === extName.toLowerCase()) {
                return baseName.substring(0, baseName.length - extName.length);
              }

              return baseName;
            }
            /**
             * @en Get dirname of a file path.
             * @zh 获取文件路径的目录名。
             * @example {@link cocos/core/utils/CCPath/dirname.js}
             */

            function dirname(path) {
              var temp = DIRNAME_RE.exec(path);
              return temp ? temp[2] : '';
            }
            /**
             * @en Change extname of a file path.
             * @zh 更改文件路径的扩展名。
             * @example {@link cocos/core/utils/CCPath/changeExtname.js}
             */

            function changeExtname(path, extName) {
              extName = extName || '';
              var index = path.indexOf('?');
              var tempStr = '';

              if (index > 0) {
                tempStr = path.substring(index);
                path = path.substring(0, index);
              }

              index = path.lastIndexOf('.');

              if (index < 0) {
                return path + extName + tempStr;
              }

              return path.substring(0, index) + extName + tempStr;
            }
            /**
             * @en Change file name of a file path.
             * @zh 更改文件路径的文件名。
             * @example {@link cocos/core/utils/CCPath/changeBasename.js}
             */

            function changeBasename(path, baseName, isSameExt) {
              if (baseName.indexOf('.') === 0) {
                return changeExtname(path, baseName);
              }

              var index = path.indexOf('?');
              var tempStr = '';
              var ext = isSameExt ? extname(path) : '';

              if (index > 0) {
                tempStr = path.substring(index);
                path = path.substring(0, index);
              }

              index = path.lastIndexOf('/');
              index = index <= 0 ? 0 : index + 1;
              return path.substring(0, index) + baseName + ext + tempStr;
            } // todo make public after verification

            function _normalize(url) {
              var oldUrl = url = String(url); // removing all ../

              do {
                oldUrl = url;
                url = url.replace(NORMALIZE_RE, '');
              } while (oldUrl.length !== url.length);

              return url;
            }
            function stripSep(path) {
              return path.replace(/[\/\\]$/, '');
            }
            function getSeperator() {
              return legacyCC.sys.os === legacyCC.sys.OS_WINDOWS ? '\\' : '/';
            }

            var path = /*#__PURE__*/Object.freeze({
                __proto__: null,
                join: join,
                extname: extname,
                mainFileName: mainFileName,
                basename: basename,
                dirname: dirname,
                changeExtname: changeExtname,
                changeBasename: changeBasename,
                _normalize: _normalize,
                stripSep: stripSep,
                getSeperator: getSeperator
            });
            exports('aB', path);

            /**
             * 几何工具模块
             * @category geometry
             */

            /**
             * @en
             * The enum type of basic geometry.
             * @zh
             * 形状的类型值。
             */
            var enums = exports('dt', {
              SHAPE_RAY: 1 << 0,
              SHAPE_LINE: 1 << 1,
              SHAPE_SPHERE: 1 << 2,
              SHAPE_AABB: 1 << 3,
              SHAPE_OBB: 1 << 4,
              SHAPE_PLANE: 1 << 5,
              SHAPE_TRIANGLE: 1 << 6,
              SHAPE_FRUSTUM: 1 << 7,
              SHAPE_FRUSTUM_ACCURATE: 1 << 8,
              SHAPE_CAPSULE: 1 << 9
            });

            /**
             * @category geometry
             */
            var X = new Vec3();
            var Y = new Vec3();
            var Z = new Vec3();
            var d = new Vec3();
            var min = new Vec3();
            var max = new Vec3();
            var u = new Array(3);
            var e = new Array(3);
            /**
             * @en
             * the distance between a point and a plane
             * @zh
             * 计算点和平面之间的距离。
             * @param {Vec3} point 点。
             * @param {plane} plane 平面。
             * @return 距离。
             */

            function point_plane(point, plane_) {
              return Vec3.dot(plane_.n, point) - plane_.d;
            }
            /**
             * @en
             * the closest point on plane to a given point
             * @zh
             * 计算平面上最接近给定点的点。
             * @param out 最近点。
             * @param point 给定点。
             * @param plane 平面。
             * @return 最近点。
             */

            function pt_point_plane(out, point, plane_) {
              var t = point_plane(point, plane_);
              return Vec3.subtract(out, point, Vec3.multiplyScalar(out, plane_.n, t));
            }
            /**
             * @en
             * the closest point on aabb to a given point
             * @zh
             * 计算 aabb 上最接近给定点的点。
             * @param {Vec3} out 最近点。
             * @param {Vec3} point 给定点。
             * @param {aabb} aabb 轴对齐包围盒。
             * @return {Vec3} 最近点。
             */

            function pt_point_aabb(out, point, aabb_) {
              Vec3.copy(out, point);
              Vec3.subtract(min, aabb_.center, aabb_.halfExtents);
              Vec3.add(max, aabb_.center, aabb_.halfExtents);
              out.x = out.x < min.x ? min.x : out.x;
              out.y = out.y < min.x ? min.y : out.y;
              out.z = out.z < min.x ? min.z : out.z;
              out.x = out.x > max.x ? max.x : out.x;
              out.y = out.y > max.x ? max.y : out.y;
              out.z = out.z > max.x ? max.z : out.z;
              return out;
            }
            /**
             * @en
             * the closest point on obb to a given point
             * @zh
             * 计算 obb 上最接近给定点的点。
             * @param {Vec3} out 最近点。
             * @param {Vec3} point 给定点。
             * @param {obb} obb 方向包围盒。
             * @return {Vec3} 最近点。
             */

            function pt_point_obb(out, point, obb_) {
              Vec3.set(X, obb_.orientation.m00, obb_.orientation.m01, obb_.orientation.m02);
              Vec3.set(Y, obb_.orientation.m03, obb_.orientation.m04, obb_.orientation.m05);
              Vec3.set(Z, obb_.orientation.m06, obb_.orientation.m07, obb_.orientation.m08);
              u[0] = X;
              u[1] = Y;
              u[2] = Z;
              e[0] = obb_.halfExtents.x;
              e[1] = obb_.halfExtents.y;
              e[2] = obb_.halfExtents.z;
              Vec3.subtract(d, point, obb_.center); // Start result at center of obb; make steps from there

              Vec3.set(out, obb_.center.x, obb_.center.y, obb_.center.z); // For each OBB axis...

              for (var i = 0; i < 3; i++) {
                // ...project d onto that axis to get the distance
                // along the axis of d from the obb center
                var dist = Vec3.dot(d, u[i]); // if distance farther than the obb extents, clamp to the obb

                if (dist > e[i]) {
                  dist = e[i];
                }

                if (dist < -e[i]) {
                  dist = -e[i];
                } // Step that distance along the axis to get world coordinate


                out.x += dist * u[i].x;
                out.y += dist * u[i].y;
                out.z += dist * u[i].z;
              }

              return out;
            }
            /**
             * @en
             * Calculate the nearest point on the line to the given point.
             * @zh
             * 计算给定点距离直线上最近的一点。
             * @param out 最近点
             * @param point 给定点
             * @param linePointA 线上的某点 A
             * @param linePointB 线上的某点 B
             */

            function pt_point_line(out, point, linePointA, linePointB) {
              Vec3.subtract(X, linePointA, linePointB);
              var dir = X;
              var dirSquaredLength = Vec3.lengthSqr(dir);

              if (dirSquaredLength == 0) {
                // The point is at the segment start.
                Vec3.copy(out, linePointA);
              } else {
                // Calculate the projection of the point onto the line extending through the segment.
                Vec3.subtract(X, point, linePointA);
                var t = Vec3.dot(X, dir) / dirSquaredLength;

                if (t < 0) {
                  // The point projects beyond the segment start.
                  Vec3.copy(out, linePointA);
                } else if (t > 1) {
                  // The point projects beyond the segment end.
                  Vec3.copy(out, linePointB);
                } else {
                  // The point projects between the start and end of the segment.
                  Vec3.scaleAndAdd(out, linePointA, dir, t);
                }
              }
            }

            var distance = /*#__PURE__*/Object.freeze({
                __proto__: null,
                point_plane: point_plane,
                pt_point_plane: pt_point_plane,
                pt_point_aabb: pt_point_aabb,
                pt_point_obb: pt_point_obb,
                pt_point_line: pt_point_line
            });
            exports('du', distance);

            /**
             * @en
             * Basic Geometry: ray.
             * @zh
             * 基础几何 射线。
             */
            // tslint:disable-next-line:class-name
            var ray = exports('dy', /*#__PURE__*/function () {
              _createClass(ray, [{
                key: "type",

                /**
                 * @en
                 * Gets the type of the shape.
                 * @zh
                 * 获取形状的类型。
                 */
                get: function get() {
                  return this._type;
                }
              }], [{
                key: "create",

                /**
                 * @en
                 * create a new ray
                 * @zh
                 * 创建一条射线。
                 * @param {number} ox 起点的 x 部分。
                 * @param {number} oy 起点的 y 部分。
                 * @param {number} oz 起点的 z 部分。
                 * @param {number} dx 方向的 x 部分。
                 * @param {number} dy 方向的 y 部分。
                 * @param {number} dz 方向的 z 部分。
                 * @return {ray} 射线。
                 */
                value: function create() {
                  var ox = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                  var oy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                  var oz = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
                  var dx = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
                  var dy = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
                  var dz = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
                  return new ray(ox, oy, oz, dx, dy, dz);
                }
                /**
                 * @en
                 * Creates a new ray initialized with values from an existing ray
                 * @zh
                 * 从一条射线克隆出一条新的射线。
                 * @param {ray} a 克隆的目标。
                 * @return {ray} 克隆出的新对象。
                 */

              }, {
                key: "clone",
                value: function clone(a) {
                  return new ray(a.o.x, a.o.y, a.o.z, a.d.x, a.d.y, a.d.z);
                }
                /**
                 * @en
                 * Copy the values from one ray to another
                 * @zh
                 * 将从一个 ray 的值复制到另一个 ray。
                 * @param {ray} out 接受操作的 ray。
                 * @param {ray} a 被复制的 ray。
                 * @return {ray} out 接受操作的 ray。
                 */

              }, {
                key: "copy",
                value: function copy(out, a) {
                  Vec3.copy(out.o, a.o);
                  Vec3.copy(out.d, a.d);
                  return out;
                }
                /**
                 * @en
                 * create a ray from two points
                 * @zh
                 * 用两个点创建一条射线。
                 * @param {ray} out 接受操作的射线。
                 * @param {Vec3} origin 射线的起点。
                 * @param {Vec3} target 射线上的一点。
                 * @return {ray} out 接受操作的射线。
                 */

              }, {
                key: "fromPoints",
                value: function fromPoints(out, origin, target) {
                  Vec3.copy(out.o, origin);
                  Vec3.normalize(out.d, Vec3.subtract(out.d, target, origin));
                  return out;
                }
                /**
                 * @en
                 * Set the components of a ray to the given values
                 * @zh
                 * 将给定射线的属性设置为给定的值。
                 * @param {ray} out 接受操作的射线。
                 * @param {number} ox 起点的 x 部分。
                 * @param {number} oy 起点的 y 部分。
                 * @param {number} oz 起点的 z 部分。
                 * @param {number} dx 方向的 x 部分。
                 * @param {number} dy 方向的 y 部分。
                 * @param {number} dz 方向的 z 部分。
                 * @return {ray} out 接受操作的射线。
                 */

              }, {
                key: "set",
                value: function set(out, ox, oy, oz, dx, dy, dz) {
                  out.o.x = ox;
                  out.o.y = oy;
                  out.o.z = oz;
                  out.d.x = dx;
                  out.d.y = dy;
                  out.d.z = dz;
                  return out;
                }
                /**
                 * @en
                 * The origin of the ray.
                 * @zh
                 * 起点。
                 */

              }]);

              /**
               * @en
               * Construct a ray;
               * @zh
               * 构造一条射线。
               * @param {number} ox 起点的 x 部分。
               * @param {number} oy 起点的 y 部分。
               * @param {number} oz 起点的 z 部分。
               * @param {number} dx 方向的 x 部分。
               * @param {number} dy 方向的 y 部分。
               * @param {number} dz 方向的 z 部分。
               */
              function ray() {
                var ox = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                var oy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                var oz = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
                var dx = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
                var dy = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
                var dz = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : -1;

                _classCallCheck(this, ray);

                this.o = void 0;
                this.d = void 0;
                this._type = void 0;
                this._type = enums.SHAPE_RAY;
                this.o = new Vec3(ox, oy, oz);
                this.d = new Vec3(dx, dy, dz);
              }
              /**
               * @en
               * Compute a point with the distance between the origin.
               * @zh
               * 根据给定距离计算出射线上的一点。
               * @param out 射线上的另一点。
               * @param distance 给定距离。
               */


              _createClass(ray, [{
                key: "computeHit",
                value: function computeHit(out, distance) {
                  Vec3.normalize(out, this.d);
                  Vec3.scaleAndAdd(out, this.o, out, distance);
                }
              }]);

              return ray;
            }());

            var _v3_tmp = new Vec3();

            var _offset = new Vec3();

            var _min = new Vec3();

            var _max = new Vec3();

            function maxComponent(v) {
              return Math.max(Math.max(v.x, v.y), v.z);
            }
            /**
             * @en
             * Basic Geometry: sphere.
             * @zh
             * 基础几何 轴对齐球。
             */
            // tslint:disable-next-line: class-name


            var sphere = exports('dA', /*#__PURE__*/function () {
              _createClass(sphere, [{
                key: "type",

                /**
                 * @en
                 * Gets the type of the shape.
                 * @zh
                 * 获取形状的类型。
                 */
                get: function get() {
                  return this._type;
                }
              }], [{
                key: "create",

                /**
                 * @en
                 * create a new sphere
                 * @zh
                 * 创建一个新的 sphere 实例。
                 * @param cx 形状的相对于原点的 X 坐标。
                 * @param cy 形状的相对于原点的 Y 坐标。
                 * @param cz 形状的相对于原点的 Z 坐标。
                 * @param r 球体的半径
                 * @return {sphere} 返回一个 sphere。
                 */
                value: function create(cx, cy, cz, r) {
                  return new sphere(cx, cy, cz, r);
                }
                /**
                 * @en
                 * clone a new sphere
                 * @zh
                 * 克隆一个新的 sphere 实例。
                 * @param {sphere} p 克隆的目标。
                 * @return {sphere} 克隆出的示例。
                 */

              }, {
                key: "clone",
                value: function clone(p) {
                  return new sphere(p.center.x, p.center.y, p.center.z, p.radius);
                }
                /**
                 * @en
                 * copy the values from one sphere to another
                 * @zh
                 * 将从一个 sphere 的值复制到另一个 sphere。
                 * @param {sphere} out 接受操作的 sphere。
                 * @param {sphere} a 被复制的 sphere。
                 * @return {sphere} out 接受操作的 sphere。
                 */

              }, {
                key: "copy",
                value: function copy(out, p) {
                  Vec3.copy(out.center, p.center);
                  out.radius = p.radius;
                  return out;
                }
                /**
                 * @en
                 * create a new bounding sphere from two corner points
                 * @zh
                 * 从两个点创建一个新的 sphere。
                 * @param out - 接受操作的 sphere。
                 * @param minPos - sphere 的最小点。
                 * @param maxPos - sphere 的最大点。
                 * @returns {sphere} out 接受操作的 sphere。
                 */

              }, {
                key: "fromPoints",
                value: function fromPoints(out, minPos, maxPos) {
                  Vec3.multiplyScalar(out.center, Vec3.add(_v3_tmp, minPos, maxPos), 0.5);
                  out.radius = Vec3.subtract(_v3_tmp, maxPos, minPos).length() * 0.5;
                  return out;
                }
                /**
                 * @en
                 * Set the components of a sphere to the given values
                 * @zh
                 * 将球体的属性设置为给定的值。
                 * @param {sphere} out 接受操作的 sphere。
                 * @param cx 形状的相对于原点的 X 坐标。
                 * @param cy 形状的相对于原点的 Y 坐标。
                 * @param cz 形状的相对于原点的 Z 坐标。
                 * @param {number} r 半径。
                 * @return {sphere} out 接受操作的 sphere。
                 * @function
                 */

              }, {
                key: "set",
                value: function set(out, cx, cy, cz, r) {
                  out.center.x = cx;
                  out.center.y = cy;
                  out.center.z = cz;
                  out.radius = r;
                  return out;
                }
                /**
                 * @zh
                 * 球跟点合并
                 */

              }, {
                key: "mergePoint",
                value: function mergePoint(out, s, point) {
                  if (s.radius < 0.0) {
                    out.center = point;
                    out.radius = 0.0;
                    return out;
                  }

                  Vec3.subtract(_offset, point, s.center);

                  var dist = _offset.length();

                  if (dist > s.radius) {
                    var half = (dist - s.radius) * 0.5;
                    out.radius += half;
                    Vec3.multiplyScalar(_offset, _offset, half / dist);
                    Vec3.add(out.center, out.center, _offset);
                  }

                  return out;
                }
                /**
                 * @zh
                 * 球跟立方体合并
                 */

              }, {
                key: "mergeAABB",
                value: function mergeAABB(out, s, a) {
                  a.getBoundary(_min, _max);
                  sphere.mergePoint(out, s, _min);
                  sphere.mergePoint(out, s, _max);
                  return out;
                }
                /**
                 * @en
                 * The center of this sphere.
                 * @zh
                 * 本地坐标的中心点。
                 */

              }]);

              /**
               * @en
               * Construct a sphere.
               * @zh
               * 构造一个球。
               * @param cx 该球的世界坐标的 X 坐标。
               * @param cy 该球的世界坐标的 Y 坐标。
               * @param cz 该球的世界坐标的 Z 坐标。
               * @param {number} r 半径。
               */
              function sphere() {
                var cx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                var cy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                var cz = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
                var r = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

                _classCallCheck(this, sphere);

                this.center = void 0;
                this.radius = void 0;
                this._type = void 0;
                this._type = enums.SHAPE_SPHERE;
                this.center = new Vec3(cx, cy, cz);
                this.radius = r;
              }
              /**
               * @en
               * Get a clone.
               * @zh
               * 获得克隆。
               */


              _createClass(sphere, [{
                key: "clone",
                value: function clone() {
                  return sphere.clone(this);
                }
                /**
                 * @en
                 * Copy a sphere.
                 * @zh
                 * 拷贝对象。
                 * @param a 拷贝的目标。
                 */

              }, {
                key: "copy",
                value: function copy(a) {
                  return sphere.copy(this, a);
                }
                /**
                 * @en
                 * Get the bounding points of this shape
                 * @zh
                 * 获取此形状的边界点。
                 * @param {Vec3} minPos 最小点。
                 * @param {Vec3} maxPos 最大点。
                 */

              }, {
                key: "getBoundary",
                value: function getBoundary(minPos, maxPos) {
                  Vec3.set(minPos, this.center.x - this.radius, this.center.y - this.radius, this.center.z - this.radius);
                  Vec3.set(maxPos, this.center.x + this.radius, this.center.y + this.radius, this.center.z + this.radius);
                }
                /**
                 * @en
                 * Transform this shape
                 * @zh
                 * 将 out 根据这个 sphere 的数据进行变换。
                 * @param m 变换的矩阵。
                 * @param pos 变换的位置部分。
                 * @param rot 变换的旋转部分。
                 * @param scale 变换的缩放部分。
                 * @param out 变换的目标。
                 */

              }, {
                key: "transform",
                value: function transform(m, pos, rot, scale, out) {
                  Vec3.transformMat4(out.center, this.center, m);
                  out.radius = this.radius * maxComponent(scale);
                }
                /**
                 * @en
                 * Translate and rotate this sphere.
                 * @zh
                 * 将 out 根据这个 sphere 的数据进行变换。
                 * @param m 变换的矩阵。
                 * @param rot 变换的旋转部分。
                 * @param out 变换的目标。
                 */

              }, {
                key: "translateAndRotate",
                value: function translateAndRotate(m, rot, out) {
                  Vec3.transformMat4(out.center, this.center, m);
                }
                /**
                 * @en
                 * Scaling this sphere.
                 * @zh
                 * 将 out 根据这个 sphere 的数据进行缩放。
                 * @param scale 缩放值。
                 * @param out 缩放的目标。
                 */

              }, {
                key: "setScale",
                value: function setScale(scale, out) {
                  out.radius = this.radius * maxComponent(scale);
                }
              }]);

              return sphere;
            }());

            /**
             * @en
             * Basic Geometry: triangle.
             * @zh
             * 基础几何 三角形。
             */
            // tslint:disable-next-line:class-name

            var triangle = exports('dz', /*#__PURE__*/function () {
              _createClass(triangle, [{
                key: "type",

                /**
                 * @en
                 * Gets the type of the shape.
                 * @zh
                 * 获取形状的类型。
                 */
                get: function get() {
                  return this._type;
                }
              }], [{
                key: "create",

                /**
                 * @en
                 * create a new triangle
                 * @zh
                 * 创建一个新的 triangle。
                 * @param {number} ax a 点的 x 部分。
                 * @param {number} ay a 点的 y 部分。
                 * @param {number} az a 点的 z 部分。
                 * @param {number} bx b 点的 x 部分。
                 * @param {number} by b 点的 y 部分。
                 * @param {number} bz b 点的 z 部分。
                 * @param {number} cx c 点的 x 部分。
                 * @param {number} cy c 点的 y 部分。
                 * @param {number} cz c 点的 z 部分。
                 * @return {triangle} 一个新的 triangle。
                 */
                value: function create() {
                  var ax = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
                  var ay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                  var az = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
                  var bx = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
                  var by = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
                  var bz = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
                  var cx = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
                  var cy = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
                  var cz = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;
                  return new triangle(ax, ay, az, bx, by, bz, cx, cy, cz);
                }
                /**
                 * @en
                 * clone a new triangle
                 * @zh
                 * 克隆一个新的 triangle。
                 * @param {triangle} t 克隆的目标。
                 * @return {triangle} 克隆出的新对象。
                 */

              }, {
                key: "clone",
                value: function clone(t) {
                  return new triangle(t.a.x, t.a.y, t.a.z, t.b.x, t.b.y, t.b.z, t.c.x, t.c.y, t.c.z);
                }
                /**
                 * @en
                 * copy the values from one triangle to another
                 * @zh
                 * 将一个 triangle 的值复制到另一个 triangle。
                 * @param {triangle} out 接受操作的 triangle。
                 * @param {triangle} t 被复制的 triangle。
                 * @return {triangle} out 接受操作的 triangle。
                 */

              }, {
                key: "copy",
                value: function copy(out, t) {
                  Vec3.copy(out.a, t.a);
                  Vec3.copy(out.b, t.b);
                  Vec3.copy(out.c, t.c);
                  return out;
                }
                /**
                 * @en
                 * Create a triangle from three points
                 * @zh
                 * 用三个点创建一个 triangle。
                 * @param {triangle} out 接受操作的 triangle。
                 * @param {Vec3} a a 点。
                 * @param {Vec3} b b 点。
                 * @param {Vec3} c c 点。
                 * @return {triangle} out 接受操作的 triangle。
                 */

              }, {
                key: "fromPoints",
                value: function fromPoints(out, a, b, c) {
                  Vec3.copy(out.a, a);
                  Vec3.copy(out.b, b);
                  Vec3.copy(out.c, c);
                  return out;
                }
                /**
                 * @en
                 * Set the components of a triangle to the given values
                 * @zh
                 * 将给定三角形的属性设置为给定值。
                 * @param {triangle} out 给定的三角形。
                 * @param {number} ax a 点的 x 部分。
                 * @param {number} ay a 点的 y 部分。
                 * @param {number} az a 点的 z 部分。
                 * @param {number} bx b 点的 x 部分。
                 * @param {number} by b 点的 y 部分。
                 * @param {number} bz b 点的 z 部分。
                 * @param {number} cx c 点的 x 部分。
                 * @param {number} cy c 点的 y 部分。
                 * @param {number} cz c 点的 z 部分。
                 * @return {triangle}
                 * @function
                 */

              }, {
                key: "set",
                value: function set(out, ax, ay, az, bx, by, bz, cx, cy, cz) {
                  out.a.x = ax;
                  out.a.y = ay;
                  out.a.z = az;
                  out.b.x = bx;
                  out.b.y = by;
                  out.b.z = bz;
                  out.c.x = cx;
                  out.c.y = cy;
                  out.c.z = cz;
                  return out;
                }
                /**
                 * @en
                 * Point a.
                 * @zh
                 * 点 a。
                 */

              }]);

              /**
               * @en
               * Construct a triangle.
               * @zh
               * 构造一个三角形。
               * @param {number} ax a 点的 x 部分。
               * @param {number} ay a 点的 y 部分。
               * @param {number} az a 点的 z 部分。
               * @param {number} bx b 点的 x 部分。
               * @param {number} by b 点的 y 部分。
               * @param {number} bz b 点的 z 部分。
               * @param {number} cx c 点的 x 部分。
               * @param {number} cy c 点的 y 部分。
               * @param {number} cz c 点的 z 部分。
               */
              function triangle() {
                var ax = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                var ay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                var az = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
                var bx = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
                var by = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
                var bz = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
                var cx = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
                var cy = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 1;
                var cz = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;

                _classCallCheck(this, triangle);

                this.a = void 0;
                this.b = void 0;
                this.c = void 0;
                this._type = void 0;
                this._type = enums.SHAPE_TRIANGLE;
                this.a = new Vec3(ax, ay, az);
                this.b = new Vec3(bx, by, bz);
                this.c = new Vec3(cx, cy, cz);
              }

              return triangle;
            }());

            /**
             * @category gfx
             */
            var GFX_MAX_VERTEX_ATTRIBUTES = exports('bq', 16);
            var GFX_MAX_TEXTURE_UNITS = exports('br', 16);
            var GFX_MAX_ATTACHMENTS = exports('bs', 4);
            var GFX_MAX_BUFFER_BINDINGS = exports('bt', 24);
            var GFXObjectType;
            /**
             * @en GFX base object.
             * @zh GFX 基类对象。
             */

            (function (GFXObjectType) {
              GFXObjectType[GFXObjectType["UNKNOWN"] = 0] = "UNKNOWN";
              GFXObjectType[GFXObjectType["BUFFER"] = 1] = "BUFFER";
              GFXObjectType[GFXObjectType["TEXTURE"] = 2] = "TEXTURE";
              GFXObjectType[GFXObjectType["RENDER_PASS"] = 3] = "RENDER_PASS";
              GFXObjectType[GFXObjectType["FRAMEBUFFER"] = 4] = "FRAMEBUFFER";
              GFXObjectType[GFXObjectType["SAMPLER"] = 5] = "SAMPLER";
              GFXObjectType[GFXObjectType["SHADER"] = 6] = "SHADER";
              GFXObjectType[GFXObjectType["DESCRIPTOR_SET_LAYOUT"] = 7] = "DESCRIPTOR_SET_LAYOUT";
              GFXObjectType[GFXObjectType["PIPELINE_LAYOUT"] = 8] = "PIPELINE_LAYOUT";
              GFXObjectType[GFXObjectType["PIPELINE_STATE"] = 9] = "PIPELINE_STATE";
              GFXObjectType[GFXObjectType["DESCRIPTOR_SET"] = 10] = "DESCRIPTOR_SET";
              GFXObjectType[GFXObjectType["INPUT_ASSEMBLER"] = 11] = "INPUT_ASSEMBLER";
              GFXObjectType[GFXObjectType["COMMAND_BUFFER"] = 12] = "COMMAND_BUFFER";
              GFXObjectType[GFXObjectType["FENCE"] = 13] = "FENCE";
              GFXObjectType[GFXObjectType["QUEUE"] = 14] = "QUEUE";
              GFXObjectType[GFXObjectType["WINDOW"] = 15] = "WINDOW";
            })(GFXObjectType || (GFXObjectType = exports('bu', {})));

            var GFXObject = exports('bv', /*#__PURE__*/function () {
              _createClass(GFXObject, [{
                key: "gfxType",
                get: function get() {
                  return this._gfxType;
                }
              }]);

              function GFXObject(gfxType) {
                _classCallCheck(this, GFXObject);

                this._gfxType = GFXObjectType.UNKNOWN;
                this._gfxType = gfxType;
              }

              return GFXObject;
            }());
            var GFXAttributeName;

            (function (GFXAttributeName) {
              GFXAttributeName["ATTR_POSITION"] = "a_position";
              GFXAttributeName["ATTR_NORMAL"] = "a_normal";
              GFXAttributeName["ATTR_TANGENT"] = "a_tangent";
              GFXAttributeName["ATTR_BITANGENT"] = "a_bitangent";
              GFXAttributeName["ATTR_WEIGHTS"] = "a_weights";
              GFXAttributeName["ATTR_JOINTS"] = "a_joints";
              GFXAttributeName["ATTR_COLOR"] = "a_color";
              GFXAttributeName["ATTR_COLOR1"] = "a_color1";
              GFXAttributeName["ATTR_COLOR2"] = "a_color2";
              GFXAttributeName["ATTR_TEX_COORD"] = "a_texCoord";
              GFXAttributeName["ATTR_TEX_COORD1"] = "a_texCoord1";
              GFXAttributeName["ATTR_TEX_COORD2"] = "a_texCoord2";
              GFXAttributeName["ATTR_TEX_COORD3"] = "a_texCoord3";
              GFXAttributeName["ATTR_TEX_COORD4"] = "a_texCoord4";
              GFXAttributeName["ATTR_TEX_COORD5"] = "a_texCoord5";
              GFXAttributeName["ATTR_TEX_COORD6"] = "a_texCoord6";
              GFXAttributeName["ATTR_TEX_COORD7"] = "a_texCoord7";
              GFXAttributeName["ATTR_TEX_COORD8"] = "a_texCoord8";
              GFXAttributeName["ATTR_BATCH_ID"] = "a_batch_id";
              GFXAttributeName["ATTR_BATCH_UV"] = "a_batch_uv";
            })(GFXAttributeName || (GFXAttributeName = exports('G', {})));

            var GFXType;

            (function (GFXType) {
              GFXType[GFXType["UNKNOWN"] = 0] = "UNKNOWN";
              GFXType[GFXType["BOOL"] = 1] = "BOOL";
              GFXType[GFXType["BOOL2"] = 2] = "BOOL2";
              GFXType[GFXType["BOOL3"] = 3] = "BOOL3";
              GFXType[GFXType["BOOL4"] = 4] = "BOOL4";
              GFXType[GFXType["INT"] = 5] = "INT";
              GFXType[GFXType["INT2"] = 6] = "INT2";
              GFXType[GFXType["INT3"] = 7] = "INT3";
              GFXType[GFXType["INT4"] = 8] = "INT4";
              GFXType[GFXType["UINT"] = 9] = "UINT";
              GFXType[GFXType["UINT2"] = 10] = "UINT2";
              GFXType[GFXType["UINT3"] = 11] = "UINT3";
              GFXType[GFXType["UINT4"] = 12] = "UINT4";
              GFXType[GFXType["FLOAT"] = 13] = "FLOAT";
              GFXType[GFXType["FLOAT2"] = 14] = "FLOAT2";
              GFXType[GFXType["FLOAT3"] = 15] = "FLOAT3";
              GFXType[GFXType["FLOAT4"] = 16] = "FLOAT4";
              GFXType[GFXType["MAT2"] = 17] = "MAT2";
              GFXType[GFXType["MAT2X3"] = 18] = "MAT2X3";
              GFXType[GFXType["MAT2X4"] = 19] = "MAT2X4";
              GFXType[GFXType["MAT3X2"] = 20] = "MAT3X2";
              GFXType[GFXType["MAT3"] = 21] = "MAT3";
              GFXType[GFXType["MAT3X4"] = 22] = "MAT3X4";
              GFXType[GFXType["MAT4X2"] = 23] = "MAT4X2";
              GFXType[GFXType["MAT4X3"] = 24] = "MAT4X3";
              GFXType[GFXType["MAT4"] = 25] = "MAT4";
              GFXType[GFXType["SAMPLER1D"] = 26] = "SAMPLER1D";
              GFXType[GFXType["SAMPLER1D_ARRAY"] = 27] = "SAMPLER1D_ARRAY";
              GFXType[GFXType["SAMPLER2D"] = 28] = "SAMPLER2D";
              GFXType[GFXType["SAMPLER2D_ARRAY"] = 29] = "SAMPLER2D_ARRAY";
              GFXType[GFXType["SAMPLER3D"] = 30] = "SAMPLER3D";
              GFXType[GFXType["SAMPLER_CUBE"] = 31] = "SAMPLER_CUBE";
              GFXType[GFXType["COUNT"] = 32] = "COUNT";
            })(GFXType || (GFXType = exports('bw', {})));

            var GFXFormat;

            (function (GFXFormat) {
              GFXFormat[GFXFormat["UNKNOWN"] = 0] = "UNKNOWN";
              GFXFormat[GFXFormat["A8"] = 1] = "A8";
              GFXFormat[GFXFormat["L8"] = 2] = "L8";
              GFXFormat[GFXFormat["LA8"] = 3] = "LA8";
              GFXFormat[GFXFormat["R8"] = 4] = "R8";
              GFXFormat[GFXFormat["R8SN"] = 5] = "R8SN";
              GFXFormat[GFXFormat["R8UI"] = 6] = "R8UI";
              GFXFormat[GFXFormat["R8I"] = 7] = "R8I";
              GFXFormat[GFXFormat["R16F"] = 8] = "R16F";
              GFXFormat[GFXFormat["R16UI"] = 9] = "R16UI";
              GFXFormat[GFXFormat["R16I"] = 10] = "R16I";
              GFXFormat[GFXFormat["R32F"] = 11] = "R32F";
              GFXFormat[GFXFormat["R32UI"] = 12] = "R32UI";
              GFXFormat[GFXFormat["R32I"] = 13] = "R32I";
              GFXFormat[GFXFormat["RG8"] = 14] = "RG8";
              GFXFormat[GFXFormat["RG8SN"] = 15] = "RG8SN";
              GFXFormat[GFXFormat["RG8UI"] = 16] = "RG8UI";
              GFXFormat[GFXFormat["RG8I"] = 17] = "RG8I";
              GFXFormat[GFXFormat["RG16F"] = 18] = "RG16F";
              GFXFormat[GFXFormat["RG16UI"] = 19] = "RG16UI";
              GFXFormat[GFXFormat["RG16I"] = 20] = "RG16I";
              GFXFormat[GFXFormat["RG32F"] = 21] = "RG32F";
              GFXFormat[GFXFormat["RG32UI"] = 22] = "RG32UI";
              GFXFormat[GFXFormat["RG32I"] = 23] = "RG32I";
              GFXFormat[GFXFormat["RGB8"] = 24] = "RGB8";
              GFXFormat[GFXFormat["SRGB8"] = 25] = "SRGB8";
              GFXFormat[GFXFormat["RGB8SN"] = 26] = "RGB8SN";
              GFXFormat[GFXFormat["RGB8UI"] = 27] = "RGB8UI";
              GFXFormat[GFXFormat["RGB8I"] = 28] = "RGB8I";
              GFXFormat[GFXFormat["RGB16F"] = 29] = "RGB16F";
              GFXFormat[GFXFormat["RGB16UI"] = 30] = "RGB16UI";
              GFXFormat[GFXFormat["RGB16I"] = 31] = "RGB16I";
              GFXFormat[GFXFormat["RGB32F"] = 32] = "RGB32F";
              GFXFormat[GFXFormat["RGB32UI"] = 33] = "RGB32UI";
              GFXFormat[GFXFormat["RGB32I"] = 34] = "RGB32I";
              GFXFormat[GFXFormat["RGBA8"] = 35] = "RGBA8";
              GFXFormat[GFXFormat["BGRA8"] = 36] = "BGRA8";
              GFXFormat[GFXFormat["SRGB8_A8"] = 37] = "SRGB8_A8";
              GFXFormat[GFXFormat["RGBA8SN"] = 38] = "RGBA8SN";
              GFXFormat[GFXFormat["RGBA8UI"] = 39] = "RGBA8UI";
              GFXFormat[GFXFormat["RGBA8I"] = 40] = "RGBA8I";
              GFXFormat[GFXFormat["RGBA16F"] = 41] = "RGBA16F";
              GFXFormat[GFXFormat["RGBA16UI"] = 42] = "RGBA16UI";
              GFXFormat[GFXFormat["RGBA16I"] = 43] = "RGBA16I";
              GFXFormat[GFXFormat["RGBA32F"] = 44] = "RGBA32F";
              GFXFormat[GFXFormat["RGBA32UI"] = 45] = "RGBA32UI";
              GFXFormat[GFXFormat["RGBA32I"] = 46] = "RGBA32I";
              GFXFormat[GFXFormat["R5G6B5"] = 47] = "R5G6B5";
              GFXFormat[GFXFormat["R11G11B10F"] = 48] = "R11G11B10F";
              GFXFormat[GFXFormat["RGB5A1"] = 49] = "RGB5A1";
              GFXFormat[GFXFormat["RGBA4"] = 50] = "RGBA4";
              GFXFormat[GFXFormat["RGB10A2"] = 51] = "RGB10A2";
              GFXFormat[GFXFormat["RGB10A2UI"] = 52] = "RGB10A2UI";
              GFXFormat[GFXFormat["RGB9E5"] = 53] = "RGB9E5";
              GFXFormat[GFXFormat["D16"] = 54] = "D16";
              GFXFormat[GFXFormat["D16S8"] = 55] = "D16S8";
              GFXFormat[GFXFormat["D24"] = 56] = "D24";
              GFXFormat[GFXFormat["D24S8"] = 57] = "D24S8";
              GFXFormat[GFXFormat["D32F"] = 58] = "D32F";
              GFXFormat[GFXFormat["D32F_S8"] = 59] = "D32F_S8";
              GFXFormat[GFXFormat["BC1"] = 60] = "BC1";
              GFXFormat[GFXFormat["BC1_ALPHA"] = 61] = "BC1_ALPHA";
              GFXFormat[GFXFormat["BC1_SRGB"] = 62] = "BC1_SRGB";
              GFXFormat[GFXFormat["BC1_SRGB_ALPHA"] = 63] = "BC1_SRGB_ALPHA";
              GFXFormat[GFXFormat["BC2"] = 64] = "BC2";
              GFXFormat[GFXFormat["BC2_SRGB"] = 65] = "BC2_SRGB";
              GFXFormat[GFXFormat["BC3"] = 66] = "BC3";
              GFXFormat[GFXFormat["BC3_SRGB"] = 67] = "BC3_SRGB";
              GFXFormat[GFXFormat["BC4"] = 68] = "BC4";
              GFXFormat[GFXFormat["BC4_SNORM"] = 69] = "BC4_SNORM";
              GFXFormat[GFXFormat["BC5"] = 70] = "BC5";
              GFXFormat[GFXFormat["BC5_SNORM"] = 71] = "BC5_SNORM";
              GFXFormat[GFXFormat["BC6H_UF16"] = 72] = "BC6H_UF16";
              GFXFormat[GFXFormat["BC6H_SF16"] = 73] = "BC6H_SF16";
              GFXFormat[GFXFormat["BC7"] = 74] = "BC7";
              GFXFormat[GFXFormat["BC7_SRGB"] = 75] = "BC7_SRGB";
              GFXFormat[GFXFormat["ETC_RGB8"] = 76] = "ETC_RGB8";
              GFXFormat[GFXFormat["ETC2_RGB8"] = 77] = "ETC2_RGB8";
              GFXFormat[GFXFormat["ETC2_SRGB8"] = 78] = "ETC2_SRGB8";
              GFXFormat[GFXFormat["ETC2_RGB8_A1"] = 79] = "ETC2_RGB8_A1";
              GFXFormat[GFXFormat["ETC2_SRGB8_A1"] = 80] = "ETC2_SRGB8_A1";
              GFXFormat[GFXFormat["ETC2_RGBA8"] = 81] = "ETC2_RGBA8";
              GFXFormat[GFXFormat["ETC2_SRGB8_A8"] = 82] = "ETC2_SRGB8_A8";
              GFXFormat[GFXFormat["EAC_R11"] = 83] = "EAC_R11";
              GFXFormat[GFXFormat["EAC_R11SN"] = 84] = "EAC_R11SN";
              GFXFormat[GFXFormat["EAC_RG11"] = 85] = "EAC_RG11";
              GFXFormat[GFXFormat["EAC_RG11SN"] = 86] = "EAC_RG11SN";
              GFXFormat[GFXFormat["PVRTC_RGB2"] = 87] = "PVRTC_RGB2";
              GFXFormat[GFXFormat["PVRTC_RGBA2"] = 88] = "PVRTC_RGBA2";
              GFXFormat[GFXFormat["PVRTC_RGB4"] = 89] = "PVRTC_RGB4";
              GFXFormat[GFXFormat["PVRTC_RGBA4"] = 90] = "PVRTC_RGBA4";
              GFXFormat[GFXFormat["PVRTC2_2BPP"] = 91] = "PVRTC2_2BPP";
              GFXFormat[GFXFormat["PVRTC2_4BPP"] = 92] = "PVRTC2_4BPP";
              GFXFormat[GFXFormat["ASTC_RGBA_4x4"] = 93] = "ASTC_RGBA_4x4";
              GFXFormat[GFXFormat["ASTC_RGBA_5x4"] = 94] = "ASTC_RGBA_5x4";
              GFXFormat[GFXFormat["ASTC_RGBA_5x5"] = 95] = "ASTC_RGBA_5x5";
              GFXFormat[GFXFormat["ASTC_RGBA_6x5"] = 96] = "ASTC_RGBA_6x5";
              GFXFormat[GFXFormat["ASTC_RGBA_6x6"] = 97] = "ASTC_RGBA_6x6";
              GFXFormat[GFXFormat["ASTC_RGBA_8x5"] = 98] = "ASTC_RGBA_8x5";
              GFXFormat[GFXFormat["ASTC_RGBA_8x6"] = 99] = "ASTC_RGBA_8x6";
              GFXFormat[GFXFormat["ASTC_RGBA_8x8"] = 100] = "ASTC_RGBA_8x8";
              GFXFormat[GFXFormat["ASTC_RGBA_10x5"] = 101] = "ASTC_RGBA_10x5";
              GFXFormat[GFXFormat["ASTC_RGBA_10x6"] = 102] = "ASTC_RGBA_10x6";
              GFXFormat[GFXFormat["ASTC_RGBA_10x8"] = 103] = "ASTC_RGBA_10x8";
              GFXFormat[GFXFormat["ASTC_RGBA_10x10"] = 104] = "ASTC_RGBA_10x10";
              GFXFormat[GFXFormat["ASTC_RGBA_12x10"] = 105] = "ASTC_RGBA_12x10";
              GFXFormat[GFXFormat["ASTC_RGBA_12x12"] = 106] = "ASTC_RGBA_12x12";
              GFXFormat[GFXFormat["ASTC_SRGBA_4x4"] = 107] = "ASTC_SRGBA_4x4";
              GFXFormat[GFXFormat["ASTC_SRGBA_5x4"] = 108] = "ASTC_SRGBA_5x4";
              GFXFormat[GFXFormat["ASTC_SRGBA_5x5"] = 109] = "ASTC_SRGBA_5x5";
              GFXFormat[GFXFormat["ASTC_SRGBA_6x5"] = 110] = "ASTC_SRGBA_6x5";
              GFXFormat[GFXFormat["ASTC_SRGBA_6x6"] = 111] = "ASTC_SRGBA_6x6";
              GFXFormat[GFXFormat["ASTC_SRGBA_8x5"] = 112] = "ASTC_SRGBA_8x5";
              GFXFormat[GFXFormat["ASTC_SRGBA_8x6"] = 113] = "ASTC_SRGBA_8x6";
              GFXFormat[GFXFormat["ASTC_SRGBA_8x8"] = 114] = "ASTC_SRGBA_8x8";
              GFXFormat[GFXFormat["ASTC_SRGBA_10x5"] = 115] = "ASTC_SRGBA_10x5";
              GFXFormat[GFXFormat["ASTC_SRGBA_10x6"] = 116] = "ASTC_SRGBA_10x6";
              GFXFormat[GFXFormat["ASTC_SRGBA_10x8"] = 117] = "ASTC_SRGBA_10x8";
              GFXFormat[GFXFormat["ASTC_SRGBA_10x10"] = 118] = "ASTC_SRGBA_10x10";
              GFXFormat[GFXFormat["ASTC_SRGBA_12x10"] = 119] = "ASTC_SRGBA_12x10";
              GFXFormat[GFXFormat["ASTC_SRGBA_12x12"] = 120] = "ASTC_SRGBA_12x12";
            })(GFXFormat || (GFXFormat = exports('f', {})));

            var GFXBufferUsageBit;

            (function (GFXBufferUsageBit) {
              GFXBufferUsageBit[GFXBufferUsageBit["NONE"] = 0] = "NONE";
              GFXBufferUsageBit[GFXBufferUsageBit["TRANSFER_SRC"] = 1] = "TRANSFER_SRC";
              GFXBufferUsageBit[GFXBufferUsageBit["TRANSFER_DST"] = 2] = "TRANSFER_DST";
              GFXBufferUsageBit[GFXBufferUsageBit["INDEX"] = 4] = "INDEX";
              GFXBufferUsageBit[GFXBufferUsageBit["VERTEX"] = 8] = "VERTEX";
              GFXBufferUsageBit[GFXBufferUsageBit["UNIFORM"] = 16] = "UNIFORM";
              GFXBufferUsageBit[GFXBufferUsageBit["STORAGE"] = 32] = "STORAGE";
              GFXBufferUsageBit[GFXBufferUsageBit["INDIRECT"] = 64] = "INDIRECT";
            })(GFXBufferUsageBit || (GFXBufferUsageBit = exports('h', {})));

            var GFXMemoryUsageBit;

            (function (GFXMemoryUsageBit) {
              GFXMemoryUsageBit[GFXMemoryUsageBit["NONE"] = 0] = "NONE";
              GFXMemoryUsageBit[GFXMemoryUsageBit["DEVICE"] = 1] = "DEVICE";
              GFXMemoryUsageBit[GFXMemoryUsageBit["HOST"] = 2] = "HOST";
            })(GFXMemoryUsageBit || (GFXMemoryUsageBit = exports('i', {})));

            var GFXBufferFlagBit;

            (function (GFXBufferFlagBit) {
              GFXBufferFlagBit[GFXBufferFlagBit["NONE"] = 0] = "NONE";
              GFXBufferFlagBit[GFXBufferFlagBit["BAKUP_BUFFER"] = 4] = "BAKUP_BUFFER";
            })(GFXBufferFlagBit || (GFXBufferFlagBit = exports('bx', {})));

            var GFXBufferAccessBit;

            (function (GFXBufferAccessBit) {
              GFXBufferAccessBit[GFXBufferAccessBit["NONE"] = 0] = "NONE";
              GFXBufferAccessBit[GFXBufferAccessBit["READ"] = 1] = "READ";
              GFXBufferAccessBit[GFXBufferAccessBit["WRITE"] = 2] = "WRITE";
            })(GFXBufferAccessBit || (GFXBufferAccessBit = exports('by', {})));

            var GFXPrimitiveMode;

            (function (GFXPrimitiveMode) {
              GFXPrimitiveMode[GFXPrimitiveMode["POINT_LIST"] = 0] = "POINT_LIST";
              GFXPrimitiveMode[GFXPrimitiveMode["LINE_LIST"] = 1] = "LINE_LIST";
              GFXPrimitiveMode[GFXPrimitiveMode["LINE_STRIP"] = 2] = "LINE_STRIP";
              GFXPrimitiveMode[GFXPrimitiveMode["LINE_LOOP"] = 3] = "LINE_LOOP";
              GFXPrimitiveMode[GFXPrimitiveMode["LINE_LIST_ADJACENCY"] = 4] = "LINE_LIST_ADJACENCY";
              GFXPrimitiveMode[GFXPrimitiveMode["LINE_STRIP_ADJACENCY"] = 5] = "LINE_STRIP_ADJACENCY";
              GFXPrimitiveMode[GFXPrimitiveMode["ISO_LINE_LIST"] = 6] = "ISO_LINE_LIST";
              GFXPrimitiveMode[GFXPrimitiveMode["TRIANGLE_LIST"] = 7] = "TRIANGLE_LIST";
              GFXPrimitiveMode[GFXPrimitiveMode["TRIANGLE_STRIP"] = 8] = "TRIANGLE_STRIP";
              GFXPrimitiveMode[GFXPrimitiveMode["TRIANGLE_FAN"] = 9] = "TRIANGLE_FAN";
              GFXPrimitiveMode[GFXPrimitiveMode["TRIANGLE_LIST_ADJACENCY"] = 10] = "TRIANGLE_LIST_ADJACENCY";
              GFXPrimitiveMode[GFXPrimitiveMode["TRIANGLE_STRIP_ADJACENCY"] = 11] = "TRIANGLE_STRIP_ADJACENCY";
              GFXPrimitiveMode[GFXPrimitiveMode["TRIANGLE_PATCH_ADJACENCY"] = 12] = "TRIANGLE_PATCH_ADJACENCY";
              GFXPrimitiveMode[GFXPrimitiveMode["QUAD_PATCH_LIST"] = 13] = "QUAD_PATCH_LIST";
            })(GFXPrimitiveMode || (GFXPrimitiveMode = exports('t', {})));

            var GFXPolygonMode;

            (function (GFXPolygonMode) {
              GFXPolygonMode[GFXPolygonMode["FILL"] = 0] = "FILL";
              GFXPolygonMode[GFXPolygonMode["POINT"] = 1] = "POINT";
              GFXPolygonMode[GFXPolygonMode["LINE"] = 2] = "LINE";
            })(GFXPolygonMode || (GFXPolygonMode = exports('bz', {})));

            var GFXShadeModel;

            (function (GFXShadeModel) {
              GFXShadeModel[GFXShadeModel["GOURAND"] = 0] = "GOURAND";
              GFXShadeModel[GFXShadeModel["FLAT"] = 1] = "FLAT";
            })(GFXShadeModel || (GFXShadeModel = exports('bA', {})));

            var GFXCullMode;

            (function (GFXCullMode) {
              GFXCullMode[GFXCullMode["NONE"] = 0] = "NONE";
              GFXCullMode[GFXCullMode["FRONT"] = 1] = "FRONT";
              GFXCullMode[GFXCullMode["BACK"] = 2] = "BACK";
            })(GFXCullMode || (GFXCullMode = exports('bB', {})));

            var GFXComparisonFunc;

            (function (GFXComparisonFunc) {
              GFXComparisonFunc[GFXComparisonFunc["NEVER"] = 0] = "NEVER";
              GFXComparisonFunc[GFXComparisonFunc["LESS"] = 1] = "LESS";
              GFXComparisonFunc[GFXComparisonFunc["EQUAL"] = 2] = "EQUAL";
              GFXComparisonFunc[GFXComparisonFunc["LESS_EQUAL"] = 3] = "LESS_EQUAL";
              GFXComparisonFunc[GFXComparisonFunc["GREATER"] = 4] = "GREATER";
              GFXComparisonFunc[GFXComparisonFunc["NOT_EQUAL"] = 5] = "NOT_EQUAL";
              GFXComparisonFunc[GFXComparisonFunc["GREATER_EQUAL"] = 6] = "GREATER_EQUAL";
              GFXComparisonFunc[GFXComparisonFunc["ALWAYS"] = 7] = "ALWAYS";
            })(GFXComparisonFunc || (GFXComparisonFunc = exports('bC', {})));

            var GFXStencilOp;

            (function (GFXStencilOp) {
              GFXStencilOp[GFXStencilOp["ZERO"] = 0] = "ZERO";
              GFXStencilOp[GFXStencilOp["KEEP"] = 1] = "KEEP";
              GFXStencilOp[GFXStencilOp["REPLACE"] = 2] = "REPLACE";
              GFXStencilOp[GFXStencilOp["INCR"] = 3] = "INCR";
              GFXStencilOp[GFXStencilOp["DECR"] = 4] = "DECR";
              GFXStencilOp[GFXStencilOp["INVERT"] = 5] = "INVERT";
              GFXStencilOp[GFXStencilOp["INCR_WRAP"] = 6] = "INCR_WRAP";
              GFXStencilOp[GFXStencilOp["DECR_WRAP"] = 7] = "DECR_WRAP";
            })(GFXStencilOp || (GFXStencilOp = exports('bD', {})));

            var GFXBlendOp;

            (function (GFXBlendOp) {
              GFXBlendOp[GFXBlendOp["ADD"] = 0] = "ADD";
              GFXBlendOp[GFXBlendOp["SUB"] = 1] = "SUB";
              GFXBlendOp[GFXBlendOp["REV_SUB"] = 2] = "REV_SUB";
              GFXBlendOp[GFXBlendOp["MIN"] = 3] = "MIN";
              GFXBlendOp[GFXBlendOp["MAX"] = 4] = "MAX";
            })(GFXBlendOp || (GFXBlendOp = exports('bE', {})));

            var GFXBlendFactor;

            (function (GFXBlendFactor) {
              GFXBlendFactor[GFXBlendFactor["ZERO"] = 0] = "ZERO";
              GFXBlendFactor[GFXBlendFactor["ONE"] = 1] = "ONE";
              GFXBlendFactor[GFXBlendFactor["SRC_ALPHA"] = 2] = "SRC_ALPHA";
              GFXBlendFactor[GFXBlendFactor["DST_ALPHA"] = 3] = "DST_ALPHA";
              GFXBlendFactor[GFXBlendFactor["ONE_MINUS_SRC_ALPHA"] = 4] = "ONE_MINUS_SRC_ALPHA";
              GFXBlendFactor[GFXBlendFactor["ONE_MINUS_DST_ALPHA"] = 5] = "ONE_MINUS_DST_ALPHA";
              GFXBlendFactor[GFXBlendFactor["SRC_COLOR"] = 6] = "SRC_COLOR";
              GFXBlendFactor[GFXBlendFactor["DST_COLOR"] = 7] = "DST_COLOR";
              GFXBlendFactor[GFXBlendFactor["ONE_MINUS_SRC_COLOR"] = 8] = "ONE_MINUS_SRC_COLOR";
              GFXBlendFactor[GFXBlendFactor["ONE_MINUS_DST_COLOR"] = 9] = "ONE_MINUS_DST_COLOR";
              GFXBlendFactor[GFXBlendFactor["SRC_ALPHA_SATURATE"] = 10] = "SRC_ALPHA_SATURATE";
              GFXBlendFactor[GFXBlendFactor["CONSTANT_COLOR"] = 11] = "CONSTANT_COLOR";
              GFXBlendFactor[GFXBlendFactor["ONE_MINUS_CONSTANT_COLOR"] = 12] = "ONE_MINUS_CONSTANT_COLOR";
              GFXBlendFactor[GFXBlendFactor["CONSTANT_ALPHA"] = 13] = "CONSTANT_ALPHA";
              GFXBlendFactor[GFXBlendFactor["ONE_MINUS_CONSTANT_ALPHA"] = 14] = "ONE_MINUS_CONSTANT_ALPHA";
            })(GFXBlendFactor || (GFXBlendFactor = exports('bF', {})));

            var GFXColorMask;

            (function (GFXColorMask) {
              GFXColorMask[GFXColorMask["NONE"] = 0] = "NONE";
              GFXColorMask[GFXColorMask["R"] = 1] = "R";
              GFXColorMask[GFXColorMask["G"] = 2] = "G";
              GFXColorMask[GFXColorMask["B"] = 4] = "B";
              GFXColorMask[GFXColorMask["A"] = 8] = "A";
              GFXColorMask[GFXColorMask["ALL"] = 15] = "ALL";
            })(GFXColorMask || (GFXColorMask = exports('bG', {})));

            var GFXFilter;

            (function (GFXFilter) {
              GFXFilter[GFXFilter["NONE"] = 0] = "NONE";
              GFXFilter[GFXFilter["POINT"] = 1] = "POINT";
              GFXFilter[GFXFilter["LINEAR"] = 2] = "LINEAR";
              GFXFilter[GFXFilter["ANISOTROPIC"] = 3] = "ANISOTROPIC";
            })(GFXFilter || (GFXFilter = exports('bH', {})));

            var GFXAddress;

            (function (GFXAddress) {
              GFXAddress[GFXAddress["WRAP"] = 0] = "WRAP";
              GFXAddress[GFXAddress["MIRROR"] = 1] = "MIRROR";
              GFXAddress[GFXAddress["CLAMP"] = 2] = "CLAMP";
              GFXAddress[GFXAddress["BORDER"] = 3] = "BORDER";
            })(GFXAddress || (GFXAddress = exports('bI', {})));

            var GFXTextureType;

            (function (GFXTextureType) {
              GFXTextureType[GFXTextureType["TEX1D"] = 0] = "TEX1D";
              GFXTextureType[GFXTextureType["TEX2D"] = 1] = "TEX2D";
              GFXTextureType[GFXTextureType["TEX3D"] = 2] = "TEX3D";
              GFXTextureType[GFXTextureType["CUBE"] = 3] = "CUBE";
              GFXTextureType[GFXTextureType["TEX1D_ARRAY"] = 4] = "TEX1D_ARRAY";
              GFXTextureType[GFXTextureType["TEX2D_ARRAY"] = 5] = "TEX2D_ARRAY";
            })(GFXTextureType || (GFXTextureType = exports('bJ', {})));

            var GFXTextureUsageBit;

            (function (GFXTextureUsageBit) {
              GFXTextureUsageBit[GFXTextureUsageBit["NONE"] = 0] = "NONE";
              GFXTextureUsageBit[GFXTextureUsageBit["TRANSFER_SRC"] = 1] = "TRANSFER_SRC";
              GFXTextureUsageBit[GFXTextureUsageBit["TRANSFER_DST"] = 2] = "TRANSFER_DST";
              GFXTextureUsageBit[GFXTextureUsageBit["SAMPLED"] = 4] = "SAMPLED";
              GFXTextureUsageBit[GFXTextureUsageBit["STORAGE"] = 8] = "STORAGE";
              GFXTextureUsageBit[GFXTextureUsageBit["COLOR_ATTACHMENT"] = 16] = "COLOR_ATTACHMENT";
              GFXTextureUsageBit[GFXTextureUsageBit["DEPTH_STENCIL_ATTACHMENT"] = 32] = "DEPTH_STENCIL_ATTACHMENT";
              GFXTextureUsageBit[GFXTextureUsageBit["TRANSIENT_ATTACHMENT"] = 64] = "TRANSIENT_ATTACHMENT";
              GFXTextureUsageBit[GFXTextureUsageBit["INPUT_ATTACHMENT"] = 128] = "INPUT_ATTACHMENT";
            })(GFXTextureUsageBit || (GFXTextureUsageBit = exports('bK', {})));

            var GFXSampleCount;

            (function (GFXSampleCount) {
              GFXSampleCount[GFXSampleCount["X1"] = 0] = "X1";
              GFXSampleCount[GFXSampleCount["X2"] = 1] = "X2";
              GFXSampleCount[GFXSampleCount["X4"] = 2] = "X4";
              GFXSampleCount[GFXSampleCount["X8"] = 3] = "X8";
              GFXSampleCount[GFXSampleCount["X16"] = 4] = "X16";
              GFXSampleCount[GFXSampleCount["X32"] = 5] = "X32";
              GFXSampleCount[GFXSampleCount["X64"] = 6] = "X64";
            })(GFXSampleCount || (GFXSampleCount = exports('bL', {})));

            var GFXTextureFlagBit;

            (function (GFXTextureFlagBit) {
              GFXTextureFlagBit[GFXTextureFlagBit["NONE"] = 0] = "NONE";
              GFXTextureFlagBit[GFXTextureFlagBit["GEN_MIPMAP"] = 1] = "GEN_MIPMAP";
              GFXTextureFlagBit[GFXTextureFlagBit["CUBEMAP"] = 2] = "CUBEMAP";
              GFXTextureFlagBit[GFXTextureFlagBit["BAKUP_BUFFER"] = 4] = "BAKUP_BUFFER";
            })(GFXTextureFlagBit || (GFXTextureFlagBit = exports('bM', {})));

            var GFXShaderStageFlagBit;

            (function (GFXShaderStageFlagBit) {
              GFXShaderStageFlagBit[GFXShaderStageFlagBit["NONE"] = 0] = "NONE";
              GFXShaderStageFlagBit[GFXShaderStageFlagBit["VERTEX"] = 1] = "VERTEX";
              GFXShaderStageFlagBit[GFXShaderStageFlagBit["CONTROL"] = 2] = "CONTROL";
              GFXShaderStageFlagBit[GFXShaderStageFlagBit["EVALUATION"] = 4] = "EVALUATION";
              GFXShaderStageFlagBit[GFXShaderStageFlagBit["GEOMETRY"] = 8] = "GEOMETRY";
              GFXShaderStageFlagBit[GFXShaderStageFlagBit["FRAGMENT"] = 16] = "FRAGMENT";
              GFXShaderStageFlagBit[GFXShaderStageFlagBit["COMPUTE"] = 32] = "COMPUTE";
              GFXShaderStageFlagBit[GFXShaderStageFlagBit["ALL"] = 63] = "ALL";
            })(GFXShaderStageFlagBit || (GFXShaderStageFlagBit = exports('bN', {})));

            var GFXDescriptorType;

            (function (GFXDescriptorType) {
              GFXDescriptorType[GFXDescriptorType["UNKNOWN"] = 0] = "UNKNOWN";
              GFXDescriptorType[GFXDescriptorType["UNIFORM_BUFFER"] = 1] = "UNIFORM_BUFFER";
              GFXDescriptorType[GFXDescriptorType["DYNAMIC_UNIFORM_BUFFER"] = 2] = "DYNAMIC_UNIFORM_BUFFER";
              GFXDescriptorType[GFXDescriptorType["STORAGE_BUFFER"] = 4] = "STORAGE_BUFFER";
              GFXDescriptorType[GFXDescriptorType["DYNAMIC_STORAGE_BUFFER"] = 8] = "DYNAMIC_STORAGE_BUFFER";
              GFXDescriptorType[GFXDescriptorType["SAMPLER"] = 16] = "SAMPLER";
            })(GFXDescriptorType || (GFXDescriptorType = exports('bO', {})));

            var GFXCommandBufferType;

            (function (GFXCommandBufferType) {
              GFXCommandBufferType[GFXCommandBufferType["PRIMARY"] = 0] = "PRIMARY";
              GFXCommandBufferType[GFXCommandBufferType["SECONDARY"] = 1] = "SECONDARY";
            })(GFXCommandBufferType || (GFXCommandBufferType = exports('bP', {})));

            var GFXLoadOp;

            (function (GFXLoadOp) {
              GFXLoadOp[GFXLoadOp["LOAD"] = 0] = "LOAD";
              GFXLoadOp[GFXLoadOp["CLEAR"] = 1] = "CLEAR";
              GFXLoadOp[GFXLoadOp["DISCARD"] = 2] = "DISCARD";
            })(GFXLoadOp || (GFXLoadOp = exports('bQ', {})));

            var GFXStoreOp;

            (function (GFXStoreOp) {
              GFXStoreOp[GFXStoreOp["STORE"] = 0] = "STORE";
              GFXStoreOp[GFXStoreOp["DISCARD"] = 1] = "DISCARD";
            })(GFXStoreOp || (GFXStoreOp = exports('bR', {})));

            var GFXTextureLayout;

            (function (GFXTextureLayout) {
              GFXTextureLayout[GFXTextureLayout["UNDEFINED"] = 0] = "UNDEFINED";
              GFXTextureLayout[GFXTextureLayout["GENERAL"] = 1] = "GENERAL";
              GFXTextureLayout[GFXTextureLayout["COLOR_ATTACHMENT_OPTIMAL"] = 2] = "COLOR_ATTACHMENT_OPTIMAL";
              GFXTextureLayout[GFXTextureLayout["DEPTH_STENCIL_ATTACHMENT_OPTIMAL"] = 3] = "DEPTH_STENCIL_ATTACHMENT_OPTIMAL";
              GFXTextureLayout[GFXTextureLayout["DEPTH_STENCIL_READONLY_OPTIMAL"] = 4] = "DEPTH_STENCIL_READONLY_OPTIMAL";
              GFXTextureLayout[GFXTextureLayout["SHADER_READONLY_OPTIMAL"] = 5] = "SHADER_READONLY_OPTIMAL";
              GFXTextureLayout[GFXTextureLayout["TRANSFER_SRC_OPTIMAL"] = 6] = "TRANSFER_SRC_OPTIMAL";
              GFXTextureLayout[GFXTextureLayout["TRANSFER_DST_OPTIMAL"] = 7] = "TRANSFER_DST_OPTIMAL";
              GFXTextureLayout[GFXTextureLayout["PREINITIALIZED"] = 8] = "PREINITIALIZED";
              GFXTextureLayout[GFXTextureLayout["PRESENT_SRC"] = 9] = "PRESENT_SRC";
            })(GFXTextureLayout || (GFXTextureLayout = exports('bS', {})));

            var GFXPipelineBindPoint;

            (function (GFXPipelineBindPoint) {
              GFXPipelineBindPoint[GFXPipelineBindPoint["GRAPHICS"] = 0] = "GRAPHICS";
              GFXPipelineBindPoint[GFXPipelineBindPoint["COMPUTE"] = 1] = "COMPUTE";
              GFXPipelineBindPoint[GFXPipelineBindPoint["RAY_TRACING"] = 2] = "RAY_TRACING";
            })(GFXPipelineBindPoint || (GFXPipelineBindPoint = exports('bT', {})));

            var GFXDynamicStateFlagBit;

            (function (GFXDynamicStateFlagBit) {
              GFXDynamicStateFlagBit[GFXDynamicStateFlagBit["NONE"] = 0] = "NONE";
              GFXDynamicStateFlagBit[GFXDynamicStateFlagBit["VIEWPORT"] = 1] = "VIEWPORT";
              GFXDynamicStateFlagBit[GFXDynamicStateFlagBit["SCISSOR"] = 2] = "SCISSOR";
              GFXDynamicStateFlagBit[GFXDynamicStateFlagBit["LINE_WIDTH"] = 4] = "LINE_WIDTH";
              GFXDynamicStateFlagBit[GFXDynamicStateFlagBit["DEPTH_BIAS"] = 8] = "DEPTH_BIAS";
              GFXDynamicStateFlagBit[GFXDynamicStateFlagBit["BLEND_CONSTANTS"] = 16] = "BLEND_CONSTANTS";
              GFXDynamicStateFlagBit[GFXDynamicStateFlagBit["DEPTH_BOUNDS"] = 32] = "DEPTH_BOUNDS";
              GFXDynamicStateFlagBit[GFXDynamicStateFlagBit["STENCIL_WRITE_MASK"] = 64] = "STENCIL_WRITE_MASK";
              GFXDynamicStateFlagBit[GFXDynamicStateFlagBit["STENCIL_COMPARE_MASK"] = 128] = "STENCIL_COMPARE_MASK";
            })(GFXDynamicStateFlagBit || (GFXDynamicStateFlagBit = exports('bU', {})));

            var GFXStencilFace;

            (function (GFXStencilFace) {
              GFXStencilFace[GFXStencilFace["FRONT"] = 0] = "FRONT";
              GFXStencilFace[GFXStencilFace["BACK"] = 1] = "BACK";
              GFXStencilFace[GFXStencilFace["ALL"] = 2] = "ALL";
            })(GFXStencilFace || (GFXStencilFace = exports('bV', {})));

            var GFXQueueType;

            (function (GFXQueueType) {
              GFXQueueType[GFXQueueType["GRAPHICS"] = 0] = "GRAPHICS";
              GFXQueueType[GFXQueueType["COMPUTE"] = 1] = "COMPUTE";
              GFXQueueType[GFXQueueType["TRANSFER"] = 2] = "TRANSFER";
            })(GFXQueueType || (GFXQueueType = exports('bW', {})));

            var GFXRect = exports('bX', function GFXRect() {
              var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
              var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
              var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

              _classCallCheck(this, GFXRect);

              this.x = void 0;
              this.y = void 0;
              this.width = void 0;
              this.height = void 0;
              this.x = x;
              this.y = y;
              this.width = width;
              this.height = height;
            });
            var GFXViewport = exports('bY', function GFXViewport() {
              var left = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
              var top = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
              var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
              var minDepth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
              var maxDepth = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;

              _classCallCheck(this, GFXViewport);

              this.left = void 0;
              this.top = void 0;
              this.width = void 0;
              this.height = void 0;
              this.minDepth = void 0;
              this.maxDepth = void 0;
              this.left = left;
              this.top = top;
              this.width = width;
              this.height = height;
              this.minDepth = minDepth;
              this.maxDepth = maxDepth;
            });
            var GFXColor = exports('bZ', function GFXColor() {
              var r = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
              var g = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              var b = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
              var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

              _classCallCheck(this, GFXColor);

              this.r = void 0;
              this.g = void 0;
              this.b = void 0;
              this.a = void 0;
              this.r = r;
              this.g = g;
              this.b = b;
              this.a = a;
            });
            var GFXClearFlag;

            (function (GFXClearFlag) {
              GFXClearFlag[GFXClearFlag["NONE"] = 0] = "NONE";
              GFXClearFlag[GFXClearFlag["COLOR"] = 1] = "COLOR";
              GFXClearFlag[GFXClearFlag["DEPTH"] = 2] = "DEPTH";
              GFXClearFlag[GFXClearFlag["STENCIL"] = 4] = "STENCIL";
              GFXClearFlag[GFXClearFlag["DEPTH_STENCIL"] = 6] = "DEPTH_STENCIL";
              GFXClearFlag[GFXClearFlag["ALL"] = 7] = "ALL";
            })(GFXClearFlag || (GFXClearFlag = exports('b_', {})));

            var GFXOffset = exports('b$', function GFXOffset() {
              var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
              var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

              _classCallCheck(this, GFXOffset);

              this.x = void 0;
              this.y = void 0;
              this.z = void 0;
              this.x = x;
              this.y = y;
              this.z = z;
            });
            var GFXExtent = exports('c0', function GFXExtent() {
              var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
              var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

              _classCallCheck(this, GFXExtent);

              this.width = void 0;
              this.height = void 0;
              this.depth = void 0;
              this.width = width;
              this.height = height;
              this.depth = depth;
            });
            var GFXTextureSubres = exports('c1', function GFXTextureSubres() {
              var mipLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
              var baseArrayLayer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              var layerCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

              _classCallCheck(this, GFXTextureSubres);

              this.mipLevel = void 0;
              this.baseArrayLayer = void 0;
              this.layerCount = void 0;
              this.mipLevel = mipLevel;
              this.baseArrayLayer = baseArrayLayer;
              this.layerCount = layerCount;
            });
            var GFXTextureCopy = exports('c2', function GFXTextureCopy() {
              var srcSubres = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new GFXTextureSubres();
              var srcOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new GFXOffset();
              var dstSubres = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new GFXTextureSubres();
              var dstOffset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new GFXOffset();
              var extent = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new GFXExtent();

              _classCallCheck(this, GFXTextureCopy);

              this.srcSubres = void 0;
              this.srcOffset = void 0;
              this.dstSubres = void 0;
              this.dstOffset = void 0;
              this.extent = void 0;
              this.srcSubres = srcSubres;
              this.srcOffset = srcOffset;
              this.dstSubres = dstSubres;
              this.dstOffset = dstOffset;
              this.extent = extent;
            });
            var GFXBufferTextureCopy = exports('c3', function GFXBufferTextureCopy() {
              var buffStride = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
              var buffTexHeight = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              var texOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new GFXOffset();
              var texExtent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new GFXExtent();
              var texSubres = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new GFXTextureSubres();

              _classCallCheck(this, GFXBufferTextureCopy);

              this.buffStride = void 0;
              this.buffTexHeight = void 0;
              this.texOffset = void 0;
              this.texExtent = void 0;
              this.texSubres = void 0;
              this.buffStride = buffStride;
              this.buffTexHeight = buffTexHeight;
              this.texOffset = texOffset;
              this.texExtent = texExtent;
              this.texSubres = texSubres;
            });
            var GFXFormatType;

            (function (GFXFormatType) {
              GFXFormatType[GFXFormatType["NONE"] = 0] = "NONE";
              GFXFormatType[GFXFormatType["UNORM"] = 1] = "UNORM";
              GFXFormatType[GFXFormatType["SNORM"] = 2] = "SNORM";
              GFXFormatType[GFXFormatType["UINT"] = 3] = "UINT";
              GFXFormatType[GFXFormatType["INT"] = 4] = "INT";
              GFXFormatType[GFXFormatType["UFLOAT"] = 5] = "UFLOAT";
              GFXFormatType[GFXFormatType["FLOAT"] = 6] = "FLOAT";
            })(GFXFormatType || (GFXFormatType = exports('c4', {})));

            var GFXFormatInfo = exports('c5', function GFXFormatInfo(name, size, count, type, hasAlpha, hasDepth, hasStencil, isCompressed) {
              _classCallCheck(this, GFXFormatInfo);

              this.name = void 0;
              this.size = void 0;
              this.count = void 0;
              this.type = void 0;
              this.hasAlpha = void 0;
              this.hasDepth = void 0;
              this.hasStencil = void 0;
              this.isCompressed = void 0;
              this.name = name;
              this.size = size;
              this.count = count;
              this.type = type;
              this.hasAlpha = hasAlpha;
              this.hasDepth = hasDepth;
              this.hasStencil = hasStencil;
              this.isCompressed = isCompressed;
            });
            var GFXMemoryStatus = exports('c6', function GFXMemoryStatus() {
              _classCallCheck(this, GFXMemoryStatus);

              this.bufferSize = 0;
              this.textureSize = 0;
            });
            var GFXFormatInfos = exports('c7', Object.freeze([new GFXFormatInfo('UNKNOWN', 0, 0, GFXFormatType.NONE, false, false, false, false), new GFXFormatInfo('A8', 1, 1, GFXFormatType.UNORM, true, false, false, false), new GFXFormatInfo('L8', 1, 1, GFXFormatType.UNORM, false, false, false, false), new GFXFormatInfo('LA8', 1, 2, GFXFormatType.UNORM, true, false, false, false), new GFXFormatInfo('R8', 1, 1, GFXFormatType.UNORM, false, false, false, false), new GFXFormatInfo('R8SN', 1, 1, GFXFormatType.SNORM, false, false, false, false), new GFXFormatInfo('R8UI', 1, 1, GFXFormatType.UINT, false, false, false, false), new GFXFormatInfo('R8I', 1, 1, GFXFormatType.INT, false, false, false, false), new GFXFormatInfo('R16F', 2, 1, GFXFormatType.FLOAT, false, false, false, false), new GFXFormatInfo('R16UI', 2, 1, GFXFormatType.UINT, false, false, false, false), new GFXFormatInfo('R16I', 2, 1, GFXFormatType.INT, false, false, false, false), new GFXFormatInfo('R32F', 4, 1, GFXFormatType.FLOAT, false, false, false, false), new GFXFormatInfo('R32UI', 4, 1, GFXFormatType.UINT, false, false, false, false), new GFXFormatInfo('R32I', 4, 1, GFXFormatType.INT, false, false, false, false), new GFXFormatInfo('RG8', 2, 2, GFXFormatType.UNORM, false, false, false, false), new GFXFormatInfo('RG8SN', 2, 2, GFXFormatType.SNORM, false, false, false, false), new GFXFormatInfo('RG8UI', 2, 2, GFXFormatType.UINT, false, false, false, false), new GFXFormatInfo('RG8I', 2, 2, GFXFormatType.INT, false, false, false, false), new GFXFormatInfo('RG16F', 4, 2, GFXFormatType.FLOAT, false, false, false, false), new GFXFormatInfo('RG16UI', 4, 2, GFXFormatType.UINT, false, false, false, false), new GFXFormatInfo('RG16I', 4, 2, GFXFormatType.INT, false, false, false, false), new GFXFormatInfo('RG32F', 8, 2, GFXFormatType.FLOAT, false, false, false, false), new GFXFormatInfo('RG32UI', 8, 2, GFXFormatType.UINT, false, false, false, false), new GFXFormatInfo('RG32I', 8, 2, GFXFormatType.INT, false, false, false, false), new GFXFormatInfo('RGB8', 3, 3, GFXFormatType.UNORM, false, false, false, false), new GFXFormatInfo('SRGB8', 3, 3, GFXFormatType.UNORM, false, false, false, false), new GFXFormatInfo('RGB8SN', 3, 3, GFXFormatType.SNORM, false, false, false, false), new GFXFormatInfo('RGB8UI', 3, 3, GFXFormatType.UINT, false, false, false, false), new GFXFormatInfo('RGB8I', 3, 3, GFXFormatType.INT, false, false, false, false), new GFXFormatInfo('RGB16F', 6, 3, GFXFormatType.FLOAT, false, false, false, false), new GFXFormatInfo('RGB16UI', 6, 3, GFXFormatType.UINT, false, false, false, false), new GFXFormatInfo('RGB16I', 6, 3, GFXFormatType.INT, false, false, false, false), new GFXFormatInfo('RGB32F', 12, 3, GFXFormatType.FLOAT, false, false, false, false), new GFXFormatInfo('RGB32UI', 12, 3, GFXFormatType.UINT, false, false, false, false), new GFXFormatInfo('RGB32I', 12, 3, GFXFormatType.INT, false, false, false, false), new GFXFormatInfo('RGBA8', 4, 4, GFXFormatType.UNORM, true, false, false, false), new GFXFormatInfo('BGRA8', 4, 4, GFXFormatType.UNORM, true, false, false, false), new GFXFormatInfo('SRGB8_A8', 4, 4, GFXFormatType.UNORM, true, false, false, false), new GFXFormatInfo('RGBA8SN', 4, 4, GFXFormatType.SNORM, true, false, false, false), new GFXFormatInfo('RGBA8UI', 4, 4, GFXFormatType.UINT, true, false, false, false), new GFXFormatInfo('RGBA8I', 4, 4, GFXFormatType.INT, true, false, false, false), new GFXFormatInfo('RGBA16F', 8, 4, GFXFormatType.FLOAT, true, false, false, false), new GFXFormatInfo('RGBA16UI', 8, 4, GFXFormatType.UINT, true, false, false, false), new GFXFormatInfo('RGBA16I', 8, 4, GFXFormatType.INT, true, false, false, false), new GFXFormatInfo('RGBA32F', 16, 4, GFXFormatType.FLOAT, true, false, false, false), new GFXFormatInfo('RGBA32UI', 16, 4, GFXFormatType.UINT, true, false, false, false), new GFXFormatInfo('RGBA32I', 16, 4, GFXFormatType.INT, true, false, false, false), new GFXFormatInfo('R5G6B5', 2, 3, GFXFormatType.UNORM, false, false, false, false), new GFXFormatInfo('R11G11B10F', 4, 3, GFXFormatType.FLOAT, false, false, false, false), new GFXFormatInfo('RGB5A1', 2, 4, GFXFormatType.UNORM, true, false, false, false), new GFXFormatInfo('RGBA4', 2, 4, GFXFormatType.UNORM, true, false, false, false), new GFXFormatInfo('RGB10A2', 2, 4, GFXFormatType.UNORM, true, false, false, false), new GFXFormatInfo('RGB10A2UI', 2, 4, GFXFormatType.UINT, true, false, false, false), new GFXFormatInfo('RGB9E5', 2, 4, GFXFormatType.FLOAT, true, false, false, false), new GFXFormatInfo('D16', 2, 1, GFXFormatType.UINT, false, true, false, false), new GFXFormatInfo('D16S8', 3, 2, GFXFormatType.UINT, false, true, true, false), new GFXFormatInfo('D24', 3, 1, GFXFormatType.UINT, false, true, false, false), new GFXFormatInfo('D24S8', 4, 2, GFXFormatType.UINT, false, true, true, false), new GFXFormatInfo('D32F', 4, 1, GFXFormatType.FLOAT, false, true, false, false), new GFXFormatInfo('D32FS8', 5, 2, GFXFormatType.FLOAT, false, true, true, false), new GFXFormatInfo('BC1', 1, 3, GFXFormatType.UNORM, false, false, false, true), new GFXFormatInfo('BC1_ALPHA', 1, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('BC1_SRGB', 1, 3, GFXFormatType.UNORM, false, false, false, true), new GFXFormatInfo('BC1_SRGB_ALPHA', 1, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('BC2', 1, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('BC2_SRGB', 1, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('BC3', 1, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('BC3_SRGB', 1, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('BC4', 1, 1, GFXFormatType.UNORM, false, false, false, true), new GFXFormatInfo('BC4_SNORM', 1, 1, GFXFormatType.SNORM, false, false, false, true), new GFXFormatInfo('BC5', 1, 2, GFXFormatType.UNORM, false, false, false, true), new GFXFormatInfo('BC5_SNORM', 1, 2, GFXFormatType.SNORM, false, false, false, true), new GFXFormatInfo('BC6H_UF16', 1, 3, GFXFormatType.UFLOAT, false, false, false, true), new GFXFormatInfo('BC6H_SF16', 1, 3, GFXFormatType.FLOAT, false, false, false, true), new GFXFormatInfo('BC7', 1, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('BC7_SRGB', 1, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('ETC_RGB8', 1, 3, GFXFormatType.UNORM, false, false, false, true), new GFXFormatInfo('ETC2_RGB8', 1, 3, GFXFormatType.UNORM, false, false, false, true), new GFXFormatInfo('ETC2_SRGB8', 1, 3, GFXFormatType.UNORM, false, false, false, true), new GFXFormatInfo('ETC2_RGB8_A1', 1, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('ETC2_SRGB8_A1', 1, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('ETC2_RGBA8', 2, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('ETC2_SRGB8_A8', 2, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('EAC_R11', 1, 1, GFXFormatType.UNORM, false, false, false, true), new GFXFormatInfo('EAC_R11SN', 1, 1, GFXFormatType.SNORM, false, false, false, true), new GFXFormatInfo('EAC_RG11', 2, 2, GFXFormatType.UNORM, false, false, false, true), new GFXFormatInfo('EAC_RG11SN', 2, 2, GFXFormatType.SNORM, false, false, false, true), new GFXFormatInfo('PVRTC_RGB2', 2, 3, GFXFormatType.UNORM, false, false, false, true), new GFXFormatInfo('PVRTC_RGBA2', 2, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('PVRTC_RGB4', 2, 3, GFXFormatType.UNORM, false, false, false, true), new GFXFormatInfo('PVRTC_RGBA4', 2, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('PVRTC2_2BPP', 2, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('PVRTC2_4BPP', 2, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('ASTC_RGBA_4x4', 1, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('ASTC_RGBA_5x4', 1, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('ASTC_RGBA_5x5', 1, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('ASTC_RGBA_6x5', 1, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('ASTC_RGBA_6x6', 1, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('ASTC_RGBA_8x5', 1, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('ASTC_RGBA_8x6', 1, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('ASTC_RGBA_8x8', 1, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('ASTC_RGBA_10x5', 1, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('ASTC_RGBA_10x6', 1, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('ASTC_RGBA_10x8', 1, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('ASTC_RGBA_10x10', 1, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('ASTC_RGBA_12x10', 1, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('ASTC_RGBA_12x12', 1, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('ASTC_SRGBA_4x4', 1, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('ASTC_SRGBA_5x4', 1, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('ASTC_SRGBA_5x5', 1, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('ASTC_SRGBA_6x5', 1, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('ASTC_SRGBA_6x6', 1, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('ASTC_SRGBA_8x5', 1, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('ASTC_SRGBA_8x6', 1, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('ASTC_SRGBA_8x8', 1, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('ASTC_SRGBA_10x5', 1, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('ASTC_SRGBA_10x6', 1, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('ASTC_SRGBA_10x8', 1, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('ASTC_SRGBA_10x10', 1, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('ASTC_SRGBA_12x10', 1, 4, GFXFormatType.UNORM, true, false, false, true), new GFXFormatInfo('ASTC_SRGBA_12x12', 1, 4, GFXFormatType.UNORM, true, false, false, true)]));
            /**
             * @en Get memory size of the specified fomat.
             * @zh 获取指定格式对应的内存大小。
             * @param format The target format.
             * @param width The target width.
             * @param height The target height.
             * @param depth The target depth.
             */

            function GFXFormatSize(format, width, height, depth) {
              if (!GFXFormatInfos[format].isCompressed) {
                return width * height * depth * GFXFormatInfos[format].size;
              } else {
                switch (format) {
                  case GFXFormat.BC1:
                  case GFXFormat.BC1_ALPHA:
                  case GFXFormat.BC1_SRGB:
                  case GFXFormat.BC1_SRGB_ALPHA:
                    return Math.ceil(width / 4) * Math.ceil(height / 4) * 8 * depth;

                  case GFXFormat.BC2:
                  case GFXFormat.BC2_SRGB:
                  case GFXFormat.BC3:
                  case GFXFormat.BC3_SRGB:
                  case GFXFormat.BC4:
                  case GFXFormat.BC4_SNORM:
                  case GFXFormat.BC6H_SF16:
                  case GFXFormat.BC6H_UF16:
                  case GFXFormat.BC7:
                  case GFXFormat.BC7_SRGB:
                    return Math.ceil(width / 4) * Math.ceil(height / 4) * 16 * depth;

                  case GFXFormat.BC5:
                  case GFXFormat.BC5_SNORM:
                    return Math.ceil(width / 4) * Math.ceil(height / 4) * 32 * depth;

                  case GFXFormat.ETC_RGB8:
                  case GFXFormat.ETC2_RGB8:
                  case GFXFormat.ETC2_SRGB8:
                  case GFXFormat.ETC2_RGB8_A1:
                  case GFXFormat.EAC_R11:
                  case GFXFormat.EAC_R11SN:
                    return Math.ceil(width / 4) * Math.ceil(height / 4) * 8 * depth;

                  case GFXFormat.ETC2_RGBA8:
                  case GFXFormat.ETC2_SRGB8_A1:
                  case GFXFormat.EAC_RG11:
                  case GFXFormat.EAC_RG11SN:
                    return Math.ceil(width / 4) * Math.ceil(height / 4) * 16 * depth;

                  case GFXFormat.PVRTC_RGB2:
                  case GFXFormat.PVRTC_RGBA2:
                  case GFXFormat.PVRTC2_2BPP:
                    return Math.ceil(Math.max(width, 16) * Math.max(height, 8) / 4) * depth;

                  case GFXFormat.PVRTC_RGB4:
                  case GFXFormat.PVRTC_RGBA4:
                  case GFXFormat.PVRTC2_4BPP:
                    return Math.ceil(Math.max(width, 8) * Math.max(height, 8) / 2) * depth;

                  case GFXFormat.ASTC_RGBA_4x4:
                  case GFXFormat.ASTC_SRGBA_4x4:
                    return Math.ceil(width / 4) * Math.ceil(height / 4) * 16 * depth;

                  case GFXFormat.ASTC_RGBA_5x4:
                  case GFXFormat.ASTC_SRGBA_5x4:
                    return Math.ceil(width / 5) * Math.ceil(height / 4) * 16 * depth;

                  case GFXFormat.ASTC_RGBA_5x5:
                  case GFXFormat.ASTC_SRGBA_5x5:
                    return Math.ceil(width / 5) * Math.ceil(height / 5) * 16 * depth;

                  case GFXFormat.ASTC_RGBA_6x5:
                  case GFXFormat.ASTC_SRGBA_6x5:
                    return Math.ceil(width / 6) * Math.ceil(height / 5) * 16 * depth;

                  case GFXFormat.ASTC_RGBA_6x6:
                  case GFXFormat.ASTC_SRGBA_6x6:
                    return Math.ceil(width / 6) * Math.ceil(height / 6) * 16 * depth;

                  case GFXFormat.ASTC_RGBA_8x5:
                  case GFXFormat.ASTC_SRGBA_8x5:
                    return Math.ceil(width / 8) * Math.ceil(height / 5) * 16 * depth;

                  case GFXFormat.ASTC_RGBA_8x6:
                  case GFXFormat.ASTC_SRGBA_8x6:
                    return Math.ceil(width / 8) * Math.ceil(height / 6) * 16 * depth;

                  case GFXFormat.ASTC_RGBA_8x8:
                  case GFXFormat.ASTC_SRGBA_8x8:
                    return Math.ceil(width / 8) * Math.ceil(height / 8) * 16 * depth;

                  case GFXFormat.ASTC_RGBA_10x5:
                  case GFXFormat.ASTC_SRGBA_10x5:
                    return Math.ceil(width / 10) * Math.ceil(height / 5) * 16 * depth;

                  case GFXFormat.ASTC_RGBA_10x6:
                  case GFXFormat.ASTC_SRGBA_10x6:
                    return Math.ceil(width / 10) * Math.ceil(height / 6) * 16 * depth;

                  case GFXFormat.ASTC_RGBA_10x8:
                  case GFXFormat.ASTC_SRGBA_10x8:
                    return Math.ceil(width / 10) * Math.ceil(height / 8) * 16 * depth;

                  case GFXFormat.ASTC_RGBA_10x10:
                  case GFXFormat.ASTC_SRGBA_10x10:
                    return Math.ceil(width / 10) * Math.ceil(height / 10) * 16 * depth;

                  case GFXFormat.ASTC_RGBA_12x10:
                  case GFXFormat.ASTC_SRGBA_12x10:
                    return Math.ceil(width / 12) * Math.ceil(height / 10) * 16 * depth;

                  case GFXFormat.ASTC_RGBA_12x12:
                  case GFXFormat.ASTC_SRGBA_12x12:
                    return Math.ceil(width / 12) * Math.ceil(height / 12) * 16 * depth;

                  default:
                    {
                      return 0;
                    }
                }
              }
            }
            /**
             * @en Get memory size of the specified surface.
             * @zh GFX 格式表面内存大小。
             * @param format The target format.
             * @param width The target width.
             * @param height The target height.
             * @param depth The target depth.
             * @param mips The target mip levels.
             */

            function GFXFormatSurfaceSize(format, width, height, depth, mips) {
              var size = 0;

              for (var i = 0; i < mips; ++i) {
                size += GFXFormatSize(format, width, height, depth);
                width = Math.max(width >> 1, 1);
                height = Math.max(height >> 1, 1);
              }

              return size;
            }
            var _type2size = [0, // UNKNOWN
            4, // BOOL
            8, // BOOL2
            12, // BOOL3
            16, // BOOL4
            4, // INT
            8, // INT2
            12, // INT3
            16, // INT4
            4, // UINT
            8, // UINT2
            12, // UINT3
            16, // UINT4
            4, // FLOAT
            8, // FLOAT2
            12, // FLOAT3
            16, // FLOAT4
            16, // MAT2
            24, // MAT2X3
            32, // MAT2X4
            24, // MAT3X2
            36, // MAT3
            48, // MAT3X4
            32, // MAT4X2
            48, // MAT4X3
            64, // MAT4
            4, // SAMPLER1D
            4, // SAMPLER1D_ARRAY
            4, // SAMPLER2D
            4, // SAMPLER2D_ARRAY
            4, // SAMPLER3D
            4 // SAMPLER_CUBE
            ];
            /**
             * @en Get the memory size of the specified type.
             * @zh 得到 GFX 数据类型的大小。
             * @param type The target type.
             */

            function GFXGetTypeSize(type) {
              return _type2size[type] || 0;
            }
            function getTypedArrayConstructor(info) {
              var stride = info.size / info.count;

              switch (info.type) {
                case GFXFormatType.UNORM:
                case GFXFormatType.UINT:
                  {
                    switch (stride) {
                      case 1:
                        return Uint8Array;

                      case 2:
                        return Uint16Array;

                      case 4:
                        return Uint32Array;
                    }

                    break;
                  }

                case GFXFormatType.SNORM:
                case GFXFormatType.INT:
                  {
                    switch (stride) {
                      case 1:
                        return Int8Array;

                      case 2:
                        return Int16Array;

                      case 4:
                        return Int32Array;
                    }

                    break;
                  }

                case GFXFormatType.FLOAT:
                  {
                    return Float32Array;
                  }
              }

              return Float32Array;
            }

            var GFXDefines = /*#__PURE__*/Object.freeze({
                __proto__: null,
                GFX_MAX_VERTEX_ATTRIBUTES: GFX_MAX_VERTEX_ATTRIBUTES,
                GFX_MAX_TEXTURE_UNITS: GFX_MAX_TEXTURE_UNITS,
                GFX_MAX_ATTACHMENTS: GFX_MAX_ATTACHMENTS,
                GFX_MAX_BUFFER_BINDINGS: GFX_MAX_BUFFER_BINDINGS,
                get GFXObjectType () { return GFXObjectType; },
                GFXObject: GFXObject,
                get GFXAttributeName () { return GFXAttributeName; },
                get GFXType () { return GFXType; },
                get GFXFormat () { return GFXFormat; },
                get GFXBufferUsageBit () { return GFXBufferUsageBit; },
                get GFXMemoryUsageBit () { return GFXMemoryUsageBit; },
                get GFXBufferFlagBit () { return GFXBufferFlagBit; },
                get GFXBufferAccessBit () { return GFXBufferAccessBit; },
                get GFXPrimitiveMode () { return GFXPrimitiveMode; },
                get GFXPolygonMode () { return GFXPolygonMode; },
                get GFXShadeModel () { return GFXShadeModel; },
                get GFXCullMode () { return GFXCullMode; },
                get GFXComparisonFunc () { return GFXComparisonFunc; },
                get GFXStencilOp () { return GFXStencilOp; },
                get GFXBlendOp () { return GFXBlendOp; },
                get GFXBlendFactor () { return GFXBlendFactor; },
                get GFXColorMask () { return GFXColorMask; },
                get GFXFilter () { return GFXFilter; },
                get GFXAddress () { return GFXAddress; },
                get GFXTextureType () { return GFXTextureType; },
                get GFXTextureUsageBit () { return GFXTextureUsageBit; },
                get GFXSampleCount () { return GFXSampleCount; },
                get GFXTextureFlagBit () { return GFXTextureFlagBit; },
                get GFXShaderStageFlagBit () { return GFXShaderStageFlagBit; },
                get GFXDescriptorType () { return GFXDescriptorType; },
                get GFXCommandBufferType () { return GFXCommandBufferType; },
                get GFXLoadOp () { return GFXLoadOp; },
                get GFXStoreOp () { return GFXStoreOp; },
                get GFXTextureLayout () { return GFXTextureLayout; },
                get GFXPipelineBindPoint () { return GFXPipelineBindPoint; },
                get GFXDynamicStateFlagBit () { return GFXDynamicStateFlagBit; },
                get GFXStencilFace () { return GFXStencilFace; },
                get GFXQueueType () { return GFXQueueType; },
                GFXRect: GFXRect,
                GFXViewport: GFXViewport,
                GFXColor: GFXColor,
                get GFXClearFlag () { return GFXClearFlag; },
                GFXOffset: GFXOffset,
                GFXExtent: GFXExtent,
                GFXTextureSubres: GFXTextureSubres,
                GFXTextureCopy: GFXTextureCopy,
                GFXBufferTextureCopy: GFXBufferTextureCopy,
                get GFXFormatType () { return GFXFormatType; },
                GFXFormatInfo: GFXFormatInfo,
                GFXMemoryStatus: GFXMemoryStatus,
                GFXFormatInfos: GFXFormatInfos,
                GFXFormatSize: GFXFormatSize,
                GFXFormatSurfaceSize: GFXFormatSurfaceSize,
                GFXGetTypeSize: GFXGetTypeSize,
                getTypedArrayConstructor: getTypedArrayConstructor
            });

            var GFXDrawInfo = exports('bm', function GFXDrawInfo() {
              var vertexCount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
              var firstVertex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              var indexCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
              var firstIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
              var vertexOffset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
              var instanceCount = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
              var firstInstance = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;

              _classCallCheck(this, GFXDrawInfo);

              this.vertexCount = void 0;
              this.firstVertex = void 0;
              this.indexCount = void 0;
              this.firstIndex = void 0;
              this.vertexOffset = void 0;
              this.instanceCount = void 0;
              this.firstInstance = void 0;
              this.vertexCount = vertexCount;
              this.firstVertex = firstVertex;
              this.indexCount = indexCount;
              this.firstIndex = firstIndex;
              this.vertexOffset = vertexOffset;
              this.instanceCount = instanceCount;
              this.firstInstance = firstInstance;
            });
            var GFX_DRAW_INFO_SIZE = exports('bn', 28);

            /**
             * @en GFX buffer.
             * @zh GFX 缓冲。
             */
            var GFXBuffer = exports('bo', /*#__PURE__*/function (_GFXObject) {
              _inherits(GFXBuffer, _GFXObject);

              _createClass(GFXBuffer, [{
                key: "usage",

                /**
                 * @en Usage type of the buffer.
                 * @zh 缓冲使用方式。
                 */
                get: function get() {
                  return this._usage;
                }
                /**
                 * @en Memory usage of the buffer.
                 * @zh 缓冲的内存使用方式。
                 */

              }, {
                key: "memUsage",
                get: function get() {
                  return this._memUsage;
                }
                /**
                 * @en Size of the buffer.
                 * @zh 缓冲大小。
                 */

              }, {
                key: "size",
                get: function get() {
                  return this._size;
                }
                /**
                 * @en Stride of the buffer.
                 * @zh 缓冲步长。
                 */

              }, {
                key: "stride",
                get: function get() {
                  return this._stride;
                }
                /**
                 * @en Count of the buffer wrt. stride.
                 * @zh 缓冲条目数量。
                 */

              }, {
                key: "count",
                get: function get() {
                  return this._count;
                }
              }, {
                key: "flags",
                get: function get() {
                  return this._flags;
                }
                /**
                 * @en View of the back-up buffer, if specified.
                 * @zh 备份缓冲视图。
                 */

              }, {
                key: "backupBuffer",
                get: function get() {
                  return this._bakcupBuffer;
                }
              }]);

              function GFXBuffer(device) {
                var _this;

                _classCallCheck(this, GFXBuffer);

                _this = _possibleConstructorReturn(this, _getPrototypeOf(GFXBuffer).call(this, GFXObjectType.BUFFER));
                _this._device = void 0;
                _this._usage = GFXBufferUsageBit.NONE;
                _this._memUsage = GFXMemoryUsageBit.NONE;
                _this._size = 0;
                _this._stride = 1;
                _this._count = 0;
                _this._flags = GFXBufferFlagBit.NONE;
                _this._bakcupBuffer = null;
                _this._indirectBuffer = null;
                _this._isBufferView = false;
                _this._device = device;
                return _this;
              }

              return GFXBuffer;
            }(GFXObject));

            /**
             * @en GFX command buffer.
             * @zh GFX 命令缓冲。
             */
            // tslint:disable: max-line-length
            var GFXCommandBuffer = exports('bp', /*#__PURE__*/function (_GFXObject) {
              _inherits(GFXCommandBuffer, _GFXObject);

              _createClass(GFXCommandBuffer, [{
                key: "type",

                /**
                 * @en Type of the command buffer.
                 * @zh 命令缓冲类型。
                 */
                get: function get() {
                  return this._type;
                }
                /**
                 * @en Type of the command buffer.
                 * @zh 命令缓冲类型。
                 */

              }, {
                key: "queue",
                get: function get() {
                  return this._queue;
                }
                /**
                 * @en Number of draw calls currently recorded.
                 * @zh 绘制调用次数。
                 */

              }, {
                key: "numDrawCalls",
                get: function get() {
                  return this._numDrawCalls;
                }
                /**
                 * @en Number of instances currently recorded.
                 * @zh 绘制 Instance 数量。
                 */

              }, {
                key: "numInstances",
                get: function get() {
                  return this._numInstances;
                }
                /**
                 * @en Number of triangles currently recorded.
                 * @zh 绘制三角形数量。
                 */

              }, {
                key: "numTris",
                get: function get() {
                  return this._numTris;
                }
              }]);

              function GFXCommandBuffer(device) {
                var _this;

                _classCallCheck(this, GFXCommandBuffer);

                _this = _possibleConstructorReturn(this, _getPrototypeOf(GFXCommandBuffer).call(this, GFXObjectType.COMMAND_BUFFER));
                _this._device = void 0;
                _this._queue = null;
                _this._type = GFXCommandBufferType.PRIMARY;
                _this._numDrawCalls = 0;
                _this._numInstances = 0;
                _this._numTris = 0;
                _this._device = device;
                return _this;
              }

              return GFXCommandBuffer;
            }(GFXObject));

            ccenum(GFXFormat);
            var GFXAPI;

            (function (GFXAPI) {
              GFXAPI[GFXAPI["UNKNOWN"] = 0] = "UNKNOWN";
              GFXAPI[GFXAPI["GL"] = 1] = "GL";
              GFXAPI[GFXAPI["GLES2"] = 2] = "GLES2";
              GFXAPI[GFXAPI["GLES3"] = 3] = "GLES3";
              GFXAPI[GFXAPI["METAL"] = 4] = "METAL";
              GFXAPI[GFXAPI["VULKAN"] = 5] = "VULKAN";
              GFXAPI[GFXAPI["DX12"] = 6] = "DX12";
              GFXAPI[GFXAPI["WEBGL"] = 7] = "WEBGL";
              GFXAPI[GFXAPI["WEBGL2"] = 8] = "WEBGL2";
            })(GFXAPI || (GFXAPI = exports('cc', {})));

            var GFXFeature;

            (function (GFXFeature) {
              GFXFeature[GFXFeature["COLOR_FLOAT"] = 0] = "COLOR_FLOAT";
              GFXFeature[GFXFeature["COLOR_HALF_FLOAT"] = 1] = "COLOR_HALF_FLOAT";
              GFXFeature[GFXFeature["TEXTURE_FLOAT"] = 2] = "TEXTURE_FLOAT";
              GFXFeature[GFXFeature["TEXTURE_HALF_FLOAT"] = 3] = "TEXTURE_HALF_FLOAT";
              GFXFeature[GFXFeature["TEXTURE_FLOAT_LINEAR"] = 4] = "TEXTURE_FLOAT_LINEAR";
              GFXFeature[GFXFeature["TEXTURE_HALF_FLOAT_LINEAR"] = 5] = "TEXTURE_HALF_FLOAT_LINEAR";
              GFXFeature[GFXFeature["FORMAT_R11G11B10F"] = 6] = "FORMAT_R11G11B10F";
              GFXFeature[GFXFeature["FORMAT_D16"] = 7] = "FORMAT_D16";
              GFXFeature[GFXFeature["FORMAT_D16S8"] = 8] = "FORMAT_D16S8";
              GFXFeature[GFXFeature["FORMAT_D24"] = 9] = "FORMAT_D24";
              GFXFeature[GFXFeature["FORMAT_D24S8"] = 10] = "FORMAT_D24S8";
              GFXFeature[GFXFeature["FORMAT_D32F"] = 11] = "FORMAT_D32F";
              GFXFeature[GFXFeature["FORMAT_D32FS8"] = 12] = "FORMAT_D32FS8";
              GFXFeature[GFXFeature["FORMAT_ETC1"] = 13] = "FORMAT_ETC1";
              GFXFeature[GFXFeature["FORMAT_ETC2"] = 14] = "FORMAT_ETC2";
              GFXFeature[GFXFeature["FORMAT_DXT"] = 15] = "FORMAT_DXT";
              GFXFeature[GFXFeature["FORMAT_PVRTC"] = 16] = "FORMAT_PVRTC";
              GFXFeature[GFXFeature["FORMAT_ASTC"] = 17] = "FORMAT_ASTC";
              GFXFeature[GFXFeature["FORMAT_RGB8"] = 18] = "FORMAT_RGB8";
              GFXFeature[GFXFeature["MSAA"] = 19] = "MSAA";
              GFXFeature[GFXFeature["ELEMENT_INDEX_UINT"] = 20] = "ELEMENT_INDEX_UINT";
              GFXFeature[GFXFeature["INSTANCED_ARRAYS"] = 21] = "INSTANCED_ARRAYS";
              GFXFeature[GFXFeature["COUNT"] = 22] = "COUNT";
            })(GFXFeature || (GFXFeature = exports('cd', {})));

            var GFXBindingMappingInfo = exports('ce', function GFXBindingMappingInfo() {
              _classCallCheck(this, GFXBindingMappingInfo);

              this.bufferOffsets = [];
              this.samplerOffsets = [];
            });

            /**
             * @en GFX Device.
             * @zh GFX 设备。
             */
            var GFXDevice = exports('cf', /*#__PURE__*/function () {
              function GFXDevice() {
                _classCallCheck(this, GFXDevice);

                this._canvas = null;
                this._canvas2D = null;
                this._gfxAPI = GFXAPI.UNKNOWN;
                this._deviceName = '';
                this._renderer = '';
                this._vendor = '';
                this._version = '';
                this._features = new Array(GFXFeature.COUNT);
                this._queue = null;
                this._devicePixelRatio = 1.0;
                this._width = 0;
                this._height = 0;
                this._nativeWidth = 0;
                this._nativeHeight = 0;
                this._maxVertexAttributes = 0;
                this._maxVertexUniformVectors = 0;
                this._maxFragmentUniformVectors = 0;
                this._maxTextureUnits = 0;
                this._maxVertexTextureUnits = 0;
                this._maxUniformBufferBindings = GFX_MAX_BUFFER_BINDINGS;
                this._maxUniformBlockSize = 0;
                this._maxTextureSize = 0;
                this._maxCubeMapTextureSize = 0;
                this._uboOffsetAlignment = 1;
                this._depthBits = 0;
                this._stencilBits = 0;
                this._colorFmt = GFXFormat.UNKNOWN;
                this._depthStencilFmt = GFXFormat.UNKNOWN;
                this._shaderIdGen = 0;
                this._macros = new Map();
                this._numDrawCalls = 0;
                this._numInstances = 0;
                this._numTris = 0;
                this._memoryStatus = {
                  bufferSize: 0,
                  textureSize: 0
                };
                this._clipSpaceMinZ = -1;
                this._screenSpaceSignY = 1;
                this._UVSpaceSignY = -1;
              }

              _createClass(GFXDevice, [{
                key: "hasFeature",

                /**
                 * @en Whether the device has specific feature.
                 * @zh 是否具备特性。
                 * @param feature The GFX feature to be queried.
                 */
                value: function hasFeature(feature) {
                  return this._features[feature];
                }
                /**
                 * @en Generate shader ID.
                 * @zh 生成 Shader ID。
                 */

              }, {
                key: "genShaderId",
                value: function genShaderId() {
                  return this._shaderIdGen++;
                }
                /**
                 * @en Define a macro.
                 * @zh 定义宏。
                 * @param macro The macro name.
                 * @param value The macro value.
                 */

              }, {
                key: "defineMacro",
                value: function defineMacro(macro, value) {
                  var val = value !== undefined ? value : '';

                  this._macros.set(macro, val);
                }
              }, {
                key: "canvas",

                /**
                 * @en The HTML canvas element.
                 * @zh HTML 画布。
                 */
                get: function get() {
                  return this._canvas;
                }
                /**
                 * @en The HTML canvas element for 2D rendering.
                 * @zh 用于 2D 绘制的 HTML 画布。
                 */

              }, {
                key: "canvas2D",
                get: function get() {
                  return this._canvas2D;
                }
                /**
                 * @en Current rendering API.
                 * @zh 当前 GFX 使用的渲染 API。
                 */

              }, {
                key: "gfxAPI",
                get: function get() {
                  return this._gfxAPI;
                }
                /**
                 * @en GFX queue.
                 * @zh GFX 队列。
                 */

              }, {
                key: "queue",
                get: function get() {
                  return this._queue;
                }
                /**
                 * @en Device pixel ratio.
                 * @zh DPR 设备像素比。
                 */

              }, {
                key: "devicePixelRatio",
                get: function get() {
                  return this._devicePixelRatio;
                }
                /**
                 * @en Device pixel width.
                 * @zh 设备像素宽度。
                 */

              }, {
                key: "width",
                get: function get() {
                  return this._width;
                }
                /**
                 * @en Device pixel height.
                 * @zh 设备像素高度。
                 */

              }, {
                key: "height",
                get: function get() {
                  return this._height;
                }
                /**
                 * @en Device native width.
                 * @zh 设备原生的像素宽度。
                 */

              }, {
                key: "nativeWidth",
                get: function get() {
                  return this._nativeWidth;
                }
                /**
                 * @en Device native height.
                 * @zh 设备原生的像素高度。
                 */

              }, {
                key: "nativeHeight",
                get: function get() {
                  return this._nativeHeight;
                }
                /**
                 * @en Renderer description.
                 * @zh 渲染器描述。
                 */

              }, {
                key: "renderer",
                get: function get() {
                  return this._renderer;
                }
                /**
                 * @en Vendor description.
                 * @zh 厂商描述。
                 */

              }, {
                key: "vendor",
                get: function get() {
                  return this._vendor;
                }
                /**
                 * @en Max vertex attributes supported.
                 * @zh 最大顶点属性数量。
                 */

              }, {
                key: "maxVertexAttributes",
                get: function get() {
                  return this._maxVertexAttributes;
                }
                /**
                 * @en Max vertex uniform vectors supported.
                 * @zh 最大顶点Uniform向量数。
                 */

              }, {
                key: "maxVertexUniformVectors",
                get: function get() {
                  return this._maxVertexUniformVectors;
                }
                /**
                 * @en Max fragment uniform vectors supported.
                 * @zh 最大片段Uniform向量数。
                 */

              }, {
                key: "maxFragmentUniformVectors",
                get: function get() {
                  return this._maxFragmentUniformVectors;
                }
                /**
                 * @en Max texture units supported.
                 * @zh 最大纹理单元数量。
                 */

              }, {
                key: "maxTextureUnits",
                get: function get() {
                  return this._maxTextureUnits;
                }
                /**
                 * @en Max vertex texture units supported.
                 * @zh 最大顶点纹理单元数量。
                 */

              }, {
                key: "maxVertexTextureUnits",
                get: function get() {
                  return this._maxVertexTextureUnits;
                }
                /**
                 * @en Max uniform buffer bindings supported.
                 * @zh 最大 uniform 缓冲绑定数量。
                 */

              }, {
                key: "maxUniformBufferBindings",
                get: function get() {
                  return this._maxUniformBufferBindings;
                }
                /**
                 * @en Max uniform block size supported.
                 * @zh 最大 uniform 缓冲大小。
                 */

              }, {
                key: "maxUniformBlockSize",
                get: function get() {
                  return this._maxUniformBlockSize;
                }
                /**
                 * @en Max texture size supported.
                 * @zh 最大贴图尺寸。
                 */

              }, {
                key: "maxTextureSize",
                get: function get() {
                  return this._maxTextureSize;
                }
                /**
                 * @en Max cube map texture size supported.
                 * @zh 最大立方贴图尺寸。
                 */

              }, {
                key: "maxCubeMapTextureSize",
                get: function get() {
                  return this._maxCubeMapTextureSize;
                }
                /**
                 * @en Uniform buffer offset alignment.
                 * @zh Uniform 缓冲偏移量的对齐单位。
                 */

              }, {
                key: "uboOffsetAlignment",
                get: function get() {
                  return this._uboOffsetAlignment;
                }
                /**
                 * @en Device depth bits.
                 * @zh 深度位数。
                 */

              }, {
                key: "depthBits",
                get: function get() {
                  return this._depthBits;
                }
                /**
                 * @en Device stencil bits.
                 * @zh 模板位数。
                 */

              }, {
                key: "stencilBits",
                get: function get() {
                  return this._stencilBits;
                }
                /**
                 * @en Device color format.
                 * @zh 颜色格式。
                 */

              }, {
                key: "colorFormat",
                get: function get() {
                  return this._colorFmt;
                }
                /**
                 * @en Device depth stencil format.
                 * @zh 深度模板格式。
                 */

              }, {
                key: "depthStencilFormat",
                get: function get() {
                  return this._depthStencilFmt;
                }
                /**
                 * @en Device built-in macros.
                 * @zh 系统宏定义。
                 */

              }, {
                key: "macros",
                get: function get() {
                  return this._macros;
                }
                /**
                 * @en Number of draw calls currently recorded.
                 * @zh 绘制调用次数。
                 */

              }, {
                key: "numDrawCalls",
                get: function get() {
                  return this._numDrawCalls;
                }
                /**
                 * @en Number of instances currently recorded.
                 * @zh 绘制 Instance 数量。
                 */

              }, {
                key: "numInstances",
                get: function get() {
                  return this._numInstances;
                }
                /**
                 * @en Number of triangles currently recorded.
                 * @zh 渲染三角形数量。
                 */

              }, {
                key: "numTris",
                get: function get() {
                  return this._numTris;
                }
                /**
                 * @en Total memory size currently allocated.
                 * @zh 内存状态。
                 */

              }, {
                key: "memoryStatus",
                get: function get() {
                  return this._memoryStatus;
                }
                /**
                 * @en The minimum Z value in clip space for the device.
                 * @zh 裁剪空间的最小 z 值。
                 */

              }, {
                key: "clipSpaceMinZ",
                get: function get() {
                  return this._clipSpaceMinZ;
                }
                /**
                 * @en The sign of the screen space Y axis, positive if origin at lower-left.
                 * @zh 屏幕空间的 y 轴符号，原点在左下角时为正。
                 */

              }, {
                key: "screenSpaceSignY",
                get: function get() {
                  return this._screenSpaceSignY;
                }
                /**
                 * @en The sign of the UV space Y axis, positive if origin at upper-left.
                 * @zh UV 空间的 y 轴符号，原点在左上角时为正。
                 */

              }, {
                key: "UVSpaceSignY",
                get: function get() {
                  return this._UVSpaceSignY;
                }
              }]);

              return GFXDevice;
            }());

            /**
             * @en GFX frame buffer.
             * @zh GFX 帧缓冲。
             */
            var GFXFramebuffer = exports('cg', /*#__PURE__*/function (_GFXObject) {
              _inherits(GFXFramebuffer, _GFXObject);

              _createClass(GFXFramebuffer, [{
                key: "renderPass",

                /**
                 * @en Get current render pass.
                 * @zh GFX 渲染过程。
                 */
                get: function get() {
                  return this._renderPass;
                }
                /**
                 * @en Get current color views.
                 * @zh 颜色纹理视图数组。
                 */

              }, {
                key: "colorTextures",
                get: function get() {
                  return this._colorTextures;
                }
                /**
                 * @en Get current depth stencil views.
                 * @zh 深度模板纹理视图。
                 */

              }, {
                key: "depthStencilTexture",
                get: function get() {
                  return this._depthStencilTexture;
                }
              }]);

              function GFXFramebuffer(device) {
                var _this;

                _classCallCheck(this, GFXFramebuffer);

                _this = _possibleConstructorReturn(this, _getPrototypeOf(GFXFramebuffer).call(this, GFXObjectType.FRAMEBUFFER));
                _this._device = void 0;
                _this._renderPass = null;
                _this._colorTextures = [];
                _this._depthStencilTexture = null;
                _this._device = device;
                return _this;
              }

              return GFXFramebuffer;
            }(GFXObject));

            /*
             * JS Implementation of MurmurHash2
             *
             * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
             * @see http://github.com/garycourt/murmurhash-js
             * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
             * @see http://sites.google.com/site/murmurhash/
             *
             * @param {string} str ASCII only
             * @param {number} seed Positive integer only
             * @return {number} 32-bit positive integer hash
             */

            /**
             * @hidden
             */
            var getUint8ForString = String.prototype.charCodeAt;

            function getUint8ForArray(idx) {
              return this[idx];
            }

            function murmurhash2_32_gc(input, seed) {
              var l = input.length;
              var h = seed ^ l;
              var i = 0;
              var getUint8 = typeof input === 'string' ? getUint8ForString : getUint8ForArray;

              while (l >= 4) {
                var k = getUint8.call(input, i) & 0xff | (getUint8.call(input, ++i) & 0xff) << 8 | (getUint8.call(input, ++i) & 0xff) << 16 | (getUint8.call(input, ++i) & 0xff) << 24;
                k = (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0x5bd1e995 & 0xffff) << 16);
                k ^= k >>> 24;
                k = (k & 0xffff) * 0x5bd1e995 + (((k >>> 16) * 0x5bd1e995 & 0xffff) << 16);
                h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16) ^ k;
                l -= 4;
                ++i;
              }

              switch (l) {
                case 3:
                  h ^= (getUint8.call(input, i + 2) & 0xff) << 16;

                case 2:
                  h ^= (getUint8.call(input, i + 1) & 0xff) << 8;

                case 1:
                  h ^= getUint8.call(input, i) & 0xff;
                  h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16);
              }

              h ^= h >>> 13;
              h = (h & 0xffff) * 0x5bd1e995 + (((h >>> 16) * 0x5bd1e995 & 0xffff) << 16);
              h ^= h >>> 15;
              return h >>> 0;
            }

            /**
             * @en GFX input assembler.
             * @zh GFX 输入汇集器。
             */
            var GFXInputAssembler = exports('ch', /*#__PURE__*/function (_GFXObject) {
              _inherits(GFXInputAssembler, _GFXObject);

              _createClass(GFXInputAssembler, [{
                key: "vertexBuffers",

                /**
                 * @en Get current vertex buffers.
                 * @zh 顶点缓冲数组。
                 */
                get: function get() {
                  return this._vertexBuffers;
                }
                /**
                 * @en Get current index buffer.
                 * @zh 索引缓冲。
                 */

              }, {
                key: "indexBuffer",
                get: function get() {
                  return this._indexBuffer;
                }
                /**
                 * @en Get current attributes.
                 * @zh 顶点属性数组。
                 */

              }, {
                key: "attributes",
                get: function get() {
                  return this._attributes;
                }
                /**
                 * @en Get hash of current attributes.
                 * @zh 获取顶点属性数组的哈希值。
                 */

              }, {
                key: "attributesHash",
                get: function get() {
                  return this._attributesHash;
                }
                /**
                 * @en Get current vertex count.
                 * @zh 顶点数量。
                 */

              }, {
                key: "vertexCount",
                get: function get() {
                  return this._vertexCount;
                },
                set: function set(count) {
                  this._vertexCount = count;
                }
                /**
                 * @en Get starting vertex.
                 * @zh 起始顶点。
                 */

              }, {
                key: "firstVertex",
                get: function get() {
                  return this._firstVertex;
                },
                set: function set(first) {
                  this._firstVertex = first;
                }
                /**
                 * @en Get current index count.
                 * @zh 索引数量。
                 */

              }, {
                key: "indexCount",
                get: function get() {
                  return this._indexCount;
                },
                set: function set(count) {
                  this._indexCount = count;
                }
                /**
                 * @en Get starting index.
                 * @zh 起始索引。
                 */

              }, {
                key: "firstIndex",
                get: function get() {
                  return this._firstIndex;
                },
                set: function set(first) {
                  this._firstIndex = first;
                }
                /**
                 * @en Get current vertex offset.
                 * @zh 顶点偏移量。
                 */

              }, {
                key: "vertexOffset",
                get: function get() {
                  return this._vertexOffset;
                },
                set: function set(offset) {
                  this._vertexOffset = offset;
                }
                /**
                 * @en Get current instance count.
                 * @zh 实例数量。
                 */

              }, {
                key: "instanceCount",
                get: function get() {
                  return this._instanceCount;
                },
                set: function set(count) {
                  this._instanceCount = count;
                }
                /**
                 * @en Get starting instance.
                 * @zh 起始实例。
                 */

              }, {
                key: "firstInstance",
                get: function get() {
                  return this._firstInstance;
                },
                set: function set(first) {
                  this._firstInstance = first;
                }
                /**
                 * @en Get the indirect buffer, if present.
                 * @zh 间接绘制缓冲。
                 */

              }, {
                key: "indirectBuffer",
                get: function get() {
                  return this._indirectBuffer;
                }
              }]);

              function GFXInputAssembler(device) {
                var _this;

                _classCallCheck(this, GFXInputAssembler);

                _this = _possibleConstructorReturn(this, _getPrototypeOf(GFXInputAssembler).call(this, GFXObjectType.INPUT_ASSEMBLER));
                _this._device = void 0;
                _this._attributes = [];
                _this._vertexBuffers = [];
                _this._indexBuffer = null;
                _this._vertexCount = 0;
                _this._firstVertex = 0;
                _this._indexCount = 0;
                _this._firstIndex = 0;
                _this._vertexOffset = 0;
                _this._instanceCount = 0;
                _this._firstInstance = 0;
                _this._attributesHash = 0;
                _this._indirectBuffer = null;
                _this._device = device;
                return _this;
              }

              _createClass(GFXInputAssembler, [{
                key: "getVertexBuffer",

                /**
                 * @en Get the specified vertex buffer.
                 * @zh 获取顶点缓冲。
                 * @param stream The stream index of the vertex buffer.
                 */
                value: function getVertexBuffer() {
                  var stream = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

                  if (stream < this._vertexBuffers.length) {
                    return this._vertexBuffers[stream];
                  } else {
                    return null;
                  }
                }
              }, {
                key: "computeAttributesHash",
                value: function computeAttributesHash() {
                  var res = 'attrs';

                  for (var i = 0; i < this.attributes.length; ++i) {
                    var at = this.attributes[i];
                    res += ",".concat(at.name, ",").concat(at.format, ",").concat(at.isNormalized, ",").concat(at.stream, ",").concat(at.isInstanced);
                  }

                  return murmurhash2_32_gc(res, 666);
                }
              }]);

              return GFXInputAssembler;
            }(GFXObject));

            /**
             * @en GFX rasterizer state.
             * @zh GFX 光栅化状态。
             */
            var GFXRasterizerState = exports('ck', /*#__PURE__*/function () {
              function GFXRasterizerState() {
                _classCallCheck(this, GFXRasterizerState);

                this.isDiscard = false;
                this.polygonMode = GFXPolygonMode.FILL;
                this.shadeModel = GFXShadeModel.GOURAND;
                this.cullMode = GFXCullMode.BACK;
                this.isFrontFaceCCW = true;
                this.depthBias = 0;
                this.depthBiasClamp = 0.0;
                this.depthBiasSlop = 0.0;
                this.isDepthClip = true;
                this.isMultisample = false;
                this.lineWidth = 1.0;
              }

              _createClass(GFXRasterizerState, [{
                key: "compare",
                value: function compare(state) {
                  return this.isDiscard === state.isDiscard && this.polygonMode === state.polygonMode && this.shadeModel === state.shadeModel && this.cullMode === state.cullMode && this.isFrontFaceCCW === state.isFrontFaceCCW && this.depthBias === state.depthBias && this.depthBiasClamp === state.depthBiasClamp && this.depthBiasSlop === state.depthBiasSlop && this.isDepthClip === state.isDepthClip && this.lineWidth === state.lineWidth && this.isMultisample === state.isMultisample;
                }
              }]);

              return GFXRasterizerState;
            }());
            /**
             * @en GFX depth stencil state.
             * @zh GFX 深度模板状态。
             */

            var GFXDepthStencilState = exports('cl', /*#__PURE__*/function () {
              function GFXDepthStencilState() {
                _classCallCheck(this, GFXDepthStencilState);

                this.depthTest = true;
                this.depthWrite = true;
                this.depthFunc = GFXComparisonFunc.LESS;
                this.stencilTestFront = false;
                this.stencilFuncFront = GFXComparisonFunc.ALWAYS;
                this.stencilReadMaskFront = 0xffff;
                this.stencilWriteMaskFront = 0xffff;
                this.stencilFailOpFront = GFXStencilOp.KEEP;
                this.stencilZFailOpFront = GFXStencilOp.KEEP;
                this.stencilPassOpFront = GFXStencilOp.KEEP;
                this.stencilRefFront = 1;
                this.stencilTestBack = false;
                this.stencilFuncBack = GFXComparisonFunc.ALWAYS;
                this.stencilReadMaskBack = 0xffff;
                this.stencilWriteMaskBack = 0xffff;
                this.stencilFailOpBack = GFXStencilOp.KEEP;
                this.stencilZFailOpBack = GFXStencilOp.KEEP;
                this.stencilPassOpBack = GFXStencilOp.KEEP;
                this.stencilRefBack = 1;
              }

              _createClass(GFXDepthStencilState, [{
                key: "compare",
                value: function compare(state) {
                  return this.depthTest === state.depthTest && this.depthWrite === state.depthWrite && this.depthFunc === state.depthFunc && this.stencilTestFront === state.stencilTestFront && this.stencilFuncFront === state.stencilFuncFront && this.stencilReadMaskFront === state.stencilReadMaskFront && this.stencilWriteMaskFront === state.stencilWriteMaskFront && this.stencilFailOpFront === state.stencilFailOpFront && this.stencilZFailOpFront === state.stencilZFailOpFront && this.stencilPassOpFront === state.stencilPassOpFront && this.stencilRefFront === state.stencilRefFront && this.stencilTestBack === state.stencilTestBack && this.stencilFuncBack === state.stencilFuncBack && this.stencilReadMaskBack === state.stencilReadMaskBack && this.stencilWriteMaskBack === state.stencilWriteMaskBack && this.stencilFailOpBack === state.stencilFailOpBack && this.stencilZFailOpBack === state.stencilZFailOpBack && this.stencilPassOpBack === state.stencilPassOpBack && this.stencilRefBack === state.stencilRefBack;
                }
              }]);

              return GFXDepthStencilState;
            }());
            /**
             * @en GFX blend target.
             * @zh GFX 混合目标。
             */

            var GFXBlendTarget = exports('cm', /*#__PURE__*/function () {
              function GFXBlendTarget() {
                _classCallCheck(this, GFXBlendTarget);

                this.blend = false;
                this.blendSrc = GFXBlendFactor.ONE;
                this.blendDst = GFXBlendFactor.ZERO;
                this.blendEq = GFXBlendOp.ADD;
                this.blendSrcAlpha = GFXBlendFactor.ONE;
                this.blendDstAlpha = GFXBlendFactor.ZERO;
                this.blendAlphaEq = GFXBlendOp.ADD;
                this.blendColorMask = GFXColorMask.ALL;
              }

              _createClass(GFXBlendTarget, [{
                key: "compare",
                value: function compare(target) {
                  return this.blend === target.blend && this.blendSrc === target.blendSrc && this.blendDst === target.blendDst && this.blendEq === target.blendEq && this.blendSrcAlpha === target.blendSrcAlpha && this.blendDstAlpha === target.blendDstAlpha && this.blendAlphaEq === target.blendAlphaEq && this.blendColorMask === target.blendColorMask;
                }
              }]);

              return GFXBlendTarget;
            }());
            /**
             * @en GFX blend state.
             * @zh GFX混合状态。
             */

            var GFXBlendState = exports('cn', function GFXBlendState() {
              _classCallCheck(this, GFXBlendState);

              this.isA2C = false;
              this.isIndepend = false;
              this.blendColor = {
                r: 0,
                g: 0,
                b: 0,
                a: 0
              };
              this.targets = [new GFXBlendTarget()];
            });
            /**
             * @en GFX input state.
             * @zh GFX 输入状态。
             */

            var GFXInputState = exports('co', function GFXInputState() {
              _classCallCheck(this, GFXInputState);

              this.attributes = [];
            });

            /**
             * @en GFX pipeline state.
             * @zh GFX 管线状态。
             */
            var GFXPipelineState = exports('cp', /*#__PURE__*/function (_GFXObject) {
              _inherits(GFXPipelineState, _GFXObject);

              _createClass(GFXPipelineState, [{
                key: "shader",

                /**
                 * @en Get current shader.
                 * @zh GFX 着色器。
                 */
                get: function get() {
                  return this._shader;
                }
                /**
                 * @en Get current pipeline layout.
                 * @zh GFX 管线布局。
                 */

              }, {
                key: "pipelineLayout",
                get: function get() {
                  return this._pipelineLayout;
                }
                /**
                 * @en Get current primitve mode.
                 * @zh GFX 图元模式。
                 */

              }, {
                key: "primitive",
                get: function get() {
                  return this._primitive;
                }
                /**
                 * @en Get current rasterizer state.
                 * @zh GFX 光栅化状态。
                 */

              }, {
                key: "rasterizerState",
                get: function get() {
                  return this._rs;
                }
                /**
                 * @en Get current depth stencil state.
                 * @zh GFX 深度模板状态。
                 */

              }, {
                key: "depthStencilState",
                get: function get() {
                  return this._dss;
                }
                /**
                 * @en Get current blend state.
                 * @zh GFX 混合状态。
                 */

              }, {
                key: "blendState",
                get: function get() {
                  return this._bs;
                }
                /**
                 * @en Get current input state.
                 * @zh GFX 输入状态。
                 */

              }, {
                key: "inputState",
                get: function get() {
                  return this._is;
                }
                /**
                 * @en Get current dynamic states.
                 * @zh GFX 动态状态数组。
                 */

              }, {
                key: "dynamicStates",
                get: function get() {
                  return this._dynamicStates;
                }
                /**
                 * @en Get current render pass.
                 * @zh GFX 渲染过程。
                 */

              }, {
                key: "renderPass",
                get: function get() {
                  return this._renderPass;
                }
              }]);

              function GFXPipelineState(device) {
                var _this;

                _classCallCheck(this, GFXPipelineState);

                _this = _possibleConstructorReturn(this, _getPrototypeOf(GFXPipelineState).call(this, GFXObjectType.PIPELINE_STATE));
                _this._device = void 0;
                _this._shader = null;
                _this._pipelineLayout = null;
                _this._primitive = GFXPrimitiveMode.TRIANGLE_LIST;
                _this._is = null;
                _this._rs = null;
                _this._dss = null;
                _this._bs = null;
                _this._dynamicStates = GFXDynamicStateFlagBit.NONE;
                _this._renderPass = null;
                _this._device = device;
                return _this;
              }

              return GFXPipelineState;
            }(GFXObject));

            /**
             * @en GFX Queue.
             * @zh GFX 队列。
             */
            var GFXQueue = exports('cq', /*#__PURE__*/function (_GFXObject) {
              _inherits(GFXQueue, _GFXObject);

              _createClass(GFXQueue, [{
                key: "type",

                /**
                 * @en Get current type.
                 * @zh 队列类型。
                 */
                get: function get() {
                  return this._type;
                }
              }]);

              function GFXQueue(device) {
                var _this;

                _classCallCheck(this, GFXQueue);

                _this = _possibleConstructorReturn(this, _getPrototypeOf(GFXQueue).call(this, GFXObjectType.QUEUE));
                _this._device = void 0;
                _this._type = GFXQueueType.GRAPHICS;
                _this._isAsync = false;
                _this._device = device;
                return _this;
              }

              _createClass(GFXQueue, [{
                key: "isAsync",
                value: function isAsync() {
                  return this._isAsync;
                }
                /**
                 * @en Submit command buffers.
                 * @zh 提交命令缓冲数组。
                 * @param cmdBuffs The command buffers to be submitted.
                 * @param fence The syncing fence.
                 */

              }]);

              return GFXQueue;
            }(GFXObject));

            /**
             * @en Color attachment.
             * @zh GFX 颜色附件。
             */

            var GFXColorAttachment = exports('cr', function GFXColorAttachment() {
              _classCallCheck(this, GFXColorAttachment);

              this.format = GFXFormat.UNKNOWN;
              this.sampleCount = 1;
              this.loadOp = GFXLoadOp.CLEAR;
              this.storeOp = GFXStoreOp.STORE;
              this.beginLayout = GFXTextureLayout.UNDEFINED;
              this.endLayout = GFXTextureLayout.PRESENT_SRC;
            });
            /**
             * @en Depth stencil attachment.
             * @zh GFX 深度模板附件。
             */

            var GFXDepthStencilAttachment = exports('cs', function GFXDepthStencilAttachment() {
              _classCallCheck(this, GFXDepthStencilAttachment);

              this.format = GFXFormat.UNKNOWN;
              this.sampleCount = 1;
              this.depthLoadOp = GFXLoadOp.CLEAR;
              this.depthStoreOp = GFXStoreOp.STORE;
              this.stencilLoadOp = GFXLoadOp.CLEAR;
              this.stencilStoreOp = GFXStoreOp.STORE;
              this.beginLayout = GFXTextureLayout.UNDEFINED;
              this.endLayout = GFXTextureLayout.DEPTH_STENCIL_ATTACHMENT_OPTIMAL;
            });

            /**
             * @en GFX render pass.
             * @zh GFX 渲染过程。
             */
            var GFXRenderPass = exports('ct', /*#__PURE__*/function (_GFXObject) {
              _inherits(GFXRenderPass, _GFXObject);

              _createClass(GFXRenderPass, [{
                key: "colorAttachments",
                get: function get() {
                  return this._colorInfos;
                }
              }, {
                key: "depthStencilAttachment",
                get: function get() {
                  return this._depthStencilInfo;
                }
              }, {
                key: "subPasses",
                get: function get() {
                  return this._subPasses;
                }
              }, {
                key: "hash",
                get: function get() {
                  return this._hash;
                }
              }]);

              function GFXRenderPass(device) {
                var _this;

                _classCallCheck(this, GFXRenderPass);

                _this = _possibleConstructorReturn(this, _getPrototypeOf(GFXRenderPass).call(this, GFXObjectType.RENDER_PASS));
                _this._device = void 0;
                _this._colorInfos = [];
                _this._depthStencilInfo = null;
                _this._subPasses = [];
                _this._hash = 0;
                _this._device = device;
                return _this;
              }

              _createClass(GFXRenderPass, [{
                key: "computeHash",
                // Based on render pass compatibility
                value: function computeHash() {
                  var res = '';

                  if (this._subPasses.length) {
                    for (var i = 0; i < this._subPasses.length; ++i) {
                      var subpass = this._subPasses[i];

                      if (subpass.inputs.length) {
                        res += 'ia';

                        for (var j = 0; j < subpass.inputs.length; ++j) {
                          var ia = this._colorInfos[subpass.inputs[j]];
                          res += ",".concat(ia.format, ",").concat(ia.sampleCount);
                        }
                      }

                      if (subpass.colors.length) {
                        res += 'ca';

                        for (var _j = 0; _j < subpass.inputs.length; ++_j) {
                          var ca = this._colorInfos[subpass.inputs[_j]];
                          res += ",".concat(ca.format, ",").concat(ca.sampleCount);
                        }
                      }

                      if (subpass.depthStencil !== undefined) {
                        var ds = this._colorInfos[subpass.depthStencil];
                        res += "ds,".concat(ds.format, ",").concat(ds.sampleCount);
                      }
                    }
                  } else {
                    res += 'ca';

                    for (var _i = 0; _i < this._colorInfos.length; ++_i) {
                      var _ca = this._colorInfos[_i];
                      res += ",".concat(_ca.format, ",").concat(_ca.sampleCount);
                    }

                    var _ds = this._depthStencilInfo;

                    if (_ds) {
                      res += "ds,".concat(_ds.format, ",").concat(_ds.sampleCount);
                    }
                  }

                  return murmurhash2_32_gc(res, 666);
                }
              }]);

              return GFXRenderPass;
            }(GFXObject));

            /**
             * @en GFX sampler state.
             * @zh GFX 采样器状态。
             */
            var GFXSamplerState = exports('cu', /*#__PURE__*/function () {
              function GFXSamplerState() {
                _classCallCheck(this, GFXSamplerState);

                this.name = '';
                this.minFilter = GFXFilter.LINEAR;
                this.magFilter = GFXFilter.LINEAR;
                this.mipFilter = GFXFilter.NONE;
                this.addressU = GFXAddress.WRAP;
                this.addressV = GFXAddress.WRAP;
                this.addressW = GFXAddress.WRAP;
                this.maxAnisotropy = 16;
                this.cmpFunc = GFXComparisonFunc.NEVER;
                this.borderColor = {
                  r: 0,
                  g: 0,
                  b: 0,
                  a: 0
                };
                this.minLOD = 0;
                this.maxLOD = 0;
                this.mipLODBias = 0.0;
              }

              _createClass(GFXSamplerState, [{
                key: "compare",
                value: function compare(state) {
                  return this.minFilter === state.minFilter && this.magFilter === state.magFilter && this.mipFilter === state.mipFilter && this.addressU === state.addressU && this.addressV === state.addressV && this.addressW === state.addressW && this.maxAnisotropy === state.maxAnisotropy && this.cmpFunc === state.cmpFunc && this.borderColor.r === state.borderColor.r && this.borderColor.g === state.borderColor.g && this.borderColor.b === state.borderColor.b && this.borderColor.a === state.borderColor.a && this.minLOD === state.minLOD && this.maxLOD === state.maxLOD && this.mipLODBias === state.mipLODBias;
                }
              }]);

              return GFXSamplerState;
            }());
            /**
             * @en GFX sampler.
             * @zh GFX 采样器。
             */

            var GFXSampler = exports('cv', /*#__PURE__*/function (_GFXObject) {
              _inherits(GFXSampler, _GFXObject);

              _createClass(GFXSampler, [{
                key: "state",

                /**
                 * @en Get current sampler state.
                 * @zh GFX 采样器状态。
                 */
                get: function get() {
                  return this._state;
                }
              }]);

              function GFXSampler(device) {
                var _this;

                _classCallCheck(this, GFXSampler);

                _this = _possibleConstructorReturn(this, _getPrototypeOf(GFXSampler).call(this, GFXObjectType.SAMPLER));
                _this._device = void 0;
                _this._state = new GFXSamplerState();
                _this._device = device;
                _this._state = new GFXSamplerState();
                return _this;
              }

              return GFXSampler;
            }(GFXObject));

            var GFXShaderStage = exports('cw', function GFXShaderStage() {
              _classCallCheck(this, GFXShaderStage);

              this.stage = GFXShaderStageFlagBit.NONE;
              this.source = '';
            });
            /**
             * @en GFX uniform.
             * @zh GFX uniform。
             */

            var GFXUniform = exports('cx', function GFXUniform() {
              _classCallCheck(this, GFXUniform);

              this.name = '';
              this.type = GFXType.UNKNOWN;
              this.count = 1;
            });
            /**
             * @en GFX uniform block.
             * @zh GFX uniform 块。
             */

            var GFXUniformBlock = exports('cy', function GFXUniformBlock() {
              _classCallCheck(this, GFXUniformBlock);

              this.set = -1;
              this.binding = -1;
              this.name = '';
              this.members = [];
              this.count = 1;
            });
            /**
             * @en GFX uniform sampler.
             * @zh GFX Uniform 采样器。
             */

            var GFXUniformSampler = exports('cz', function GFXUniformSampler() {
              _classCallCheck(this, GFXUniformSampler);

              this.set = -1;
              this.binding = -1;
              this.name = '';
              this.type = GFXType.UNKNOWN;
              this.count = 1;
            });
            var GFXShaderInfo = exports('cA', function GFXShaderInfo() {
              _classCallCheck(this, GFXShaderInfo);

              this.name = '';
              this.stages = [];
              this.attributes = [];
              this.blocks = [];
              this.samplers = [];
            });
            /**
             * @en GFX shader.
             * @zh GFX 着色器。
             */

            var GFXShader = exports('cB', /*#__PURE__*/function (_GFXObject) {
              _inherits(GFXShader, _GFXObject);

              _createClass(GFXShader, [{
                key: "id",

                /**
                 * @en Get current shader id.
                 * @zh 着色器 id。
                 */
                get: function get() {
                  return this._id;
                }
                /**
                 * @en Get current shader name.
                 * @zh 着色器名称。
                 */

              }, {
                key: "name",
                get: function get() {
                  return this._name;
                }
              }, {
                key: "attributes",
                get: function get() {
                  return this._attributes;
                }
              }, {
                key: "blocks",
                get: function get() {
                  return this._blocks;
                }
              }, {
                key: "samplers",
                get: function get() {
                  return this._samplers;
                }
              }]);

              function GFXShader(device) {
                var _this;

                _classCallCheck(this, GFXShader);

                _this = _possibleConstructorReturn(this, _getPrototypeOf(GFXShader).call(this, GFXObjectType.SHADER));
                _this._device = void 0;
                _this._id = void 0;
                _this._name = '';
                _this._stages = [];
                _this._attributes = [];
                _this._blocks = [];
                _this._samplers = [];
                _this._device = device;
                _this._id = device.genShaderId();
                return _this;
              }

              return GFXShader;
            }(GFXObject));

            function IsPowerOf2(x) {
              return x > 0 && (x & x - 1) === 0;
            }
            /**
             * @en GFX texture.
             * @zh GFX 纹理。
             */

            var GFXTexture = exports('cD', /*#__PURE__*/function (_GFXObject) {
              _inherits(GFXTexture, _GFXObject);

              _createClass(GFXTexture, [{
                key: "type",

                /**
                 * @en Get texture type.
                 * @zh 纹理类型。
                 */
                get: function get() {
                  return this._type;
                }
                /**
                 * @en Get texture usage.
                 * @zh 纹理使用方式。
                 */

              }, {
                key: "usage",
                get: function get() {
                  return this._usage;
                }
                /**
                 * @en Get texture format.
                 * @zh 纹理格式。
                 */

              }, {
                key: "format",
                get: function get() {
                  return this._format;
                }
                /**
                 * @en Get texture width.
                 * @zh 纹理宽度。
                 */

              }, {
                key: "width",
                get: function get() {
                  return this._width;
                }
                /**
                 * @en Get texture height.
                 * @zh 纹理高度。
                 */

              }, {
                key: "height",
                get: function get() {
                  return this._height;
                }
                /**
                 * @en Get texture depth.
                 * @zh 纹理深度。
                 */

              }, {
                key: "depth",
                get: function get() {
                  return this._depth;
                }
                /**
                 * @en Get texture array layer.
                 * @zh 纹理数组层数。
                 */

              }, {
                key: "layerCount",
                get: function get() {
                  return this._layerCount;
                }
                /**
                 * @en Get texture mip level.
                 * @zh 纹理 mip 层级数。
                 */

              }, {
                key: "levelCount",
                get: function get() {
                  return this._levelCount;
                }
                /**
                 * @en Get texture samples.
                 * @zh 纹理采样数。
                 */

              }, {
                key: "samples",
                get: function get() {
                  return this._samples;
                }
                /**
                 * @en Get texture flags.
                 * @zh 纹理标识位。
                 */

              }, {
                key: "flags",
                get: function get() {
                  return this._flags;
                }
                /**
                 * @en Get texture size.
                 * @zh 纹理大小。
                 */

              }, {
                key: "size",
                get: function get() {
                  return this._size;
                }
                /**
                 * @en Get texture buffer.
                 * @zh 纹理缓冲。
                 */

              }, {
                key: "buffer",
                get: function get() {
                  return this._buffer;
                }
              }]);

              function GFXTexture(device) {
                var _this;

                _classCallCheck(this, GFXTexture);

                _this = _possibleConstructorReturn(this, _getPrototypeOf(GFXTexture).call(this, GFXObjectType.TEXTURE));
                _this._device = void 0;
                _this._type = GFXTextureType.TEX2D;
                _this._usage = GFXTextureUsageBit.NONE;
                _this._format = GFXFormat.UNKNOWN;
                _this._width = 0;
                _this._height = 0;
                _this._depth = 1;
                _this._layerCount = 1;
                _this._levelCount = 1;
                _this._samples = GFXSampleCount.X1;
                _this._flags = GFXTextureFlagBit.NONE;
                _this._isPowerOf2 = false;
                _this._size = 0;
                _this._buffer = null;
                _this._device = device;
                return _this;
              }

              return GFXTexture;
            }(GFXObject));

            var DESCRIPTOR_BUFFER_TYPE = exports('bj', GFXDescriptorType.UNIFORM_BUFFER | GFXDescriptorType.DYNAMIC_UNIFORM_BUFFER | GFXDescriptorType.STORAGE_BUFFER | GFXDescriptorType.DYNAMIC_STORAGE_BUFFER);
            var DESCRIPTOR_SAMPLER_TYPE = exports('bk', GFXDescriptorType.SAMPLER);

            /**
             * @en GFX descriptor sets.
             * @zh GFX 描述符集组。
             */
            var GFXDescriptorSet = exports('bl', /*#__PURE__*/function (_GFXObject) {
              _inherits(GFXDescriptorSet, _GFXObject);

              _createClass(GFXDescriptorSet, [{
                key: "layout",
                get: function get() {
                  return this._layout;
                }
              }]);

              function GFXDescriptorSet(device) {
                var _this;

                _classCallCheck(this, GFXDescriptorSet);

                _this = _possibleConstructorReturn(this, _getPrototypeOf(GFXDescriptorSet).call(this, GFXObjectType.DESCRIPTOR_SET));
                _this._device = void 0;
                _this._layout = null;
                _this._buffers = [];
                _this._textures = [];
                _this._samplers = [];
                _this._isDirty = false;
                _this._device = device;
                return _this;
              }

              _createClass(GFXDescriptorSet, [{
                key: "bindBuffer",

                /**
                 * @en Bind buffer to the specified descriptor.
                 * @zh 在指定的描述符位置上绑定缓冲。
                 * @param binding The target binding.
                 * @param buffer The buffer to be bound.
                 */
                value: function bindBuffer(binding, buffer) {
                  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
                  var info = this._layout.bindings[binding];
                  var descriptorIndex = this._layout.descriptorIndices[binding];

                  if (info && info.descriptorType & DESCRIPTOR_BUFFER_TYPE) {
                    if (this._buffers[descriptorIndex + index] !== buffer) {
                      this._buffers[descriptorIndex + index] = buffer;
                      this._isDirty = true;
                    }
                  } else {
                    console.error('Setting binding is not GFXDescriptorType.UNIFORM_BUFFER.');
                  }
                }
                /**
                 * @en Bind sampler to the specified descriptor.
                 * @zh 在指定的描述符位置上绑定采样器。
                 * @param binding The target binding.
                 * @param sampler The sampler to be bound.
                 */

              }, {
                key: "bindSampler",
                value: function bindSampler(binding, sampler) {
                  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
                  var info = this._layout.bindings[binding];
                  var descriptorIndex = this._layout.descriptorIndices[binding];

                  if (info && info.descriptorType & DESCRIPTOR_SAMPLER_TYPE) {
                    if (this._samplers[descriptorIndex + index] !== sampler) {
                      this._samplers[descriptorIndex + index] = sampler;
                      this._isDirty = true;
                    }
                  } else {
                    console.error('Setting binding is not GFXDescriptorType.SAMPLER.');
                  }
                }
                /**
                 * @en Bind texture to the specified descriptor.
                 * @zh 在指定的描述符位置上绑定纹理。
                 * @param binding The target binding.
                 * @param texture The texture to be bound.
                 */

              }, {
                key: "bindTexture",
                value: function bindTexture(binding, texture) {
                  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
                  var info = this._layout.bindings[binding];
                  var descriptorIndex = this._layout.descriptorIndices[binding];

                  if (info && info.descriptorType & DESCRIPTOR_SAMPLER_TYPE) {
                    if (this._textures[descriptorIndex + index] !== texture) {
                      this._textures[descriptorIndex + index] = texture;
                      this._isDirty = true;
                    }
                  } else {
                    console.error('Setting binding is not GFXDescriptorType.SAMPLER.');
                  }
                }
                /**
                 * @en Get buffer from the specified binding location.
                 * @zh 获取当前指定绑定位置上的缓冲。
                 * @param binding The target binding.
                 */

              }, {
                key: "getBuffer",
                value: function getBuffer(binding) {
                  var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                  var descriptorIndex = this._layout.descriptorIndices[binding];
                  return this._buffers[descriptorIndex + index];
                }
                /**
                 * @en Get sampler from the specified binding location.
                 * @zh 获取当前指定绑定位置上的采样器。
                 * @param binding The target binding.
                 */

              }, {
                key: "getSampler",
                value: function getSampler(binding) {
                  var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                  var descriptorIndex = this._layout.descriptorIndices[binding];
                  return this._samplers[descriptorIndex + index];
                }
                /**
                 * @en Get texture from the specified binding location.
                 * @zh 获取当前指定绑定位置上的贴图。
                 * @param binding The target binding.
                 */

              }, {
                key: "getTexture",
                value: function getTexture(binding) {
                  var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                  var descriptorIndex = this._layout.descriptorIndices[binding];
                  return this._textures[descriptorIndex + index];
                }
              }]);

              return GFXDescriptorSet;
            }(GFXObject));

            var DESCRIPTOR_DYNAMIC_TYPE = exports('ci', GFXDescriptorType.DYNAMIC_STORAGE_BUFFER | GFXDescriptorType.DYNAMIC_UNIFORM_BUFFER);
            /**
             * @en GFX descriptor sets layout.
             * @zh GFX 描述符集布局。
             */

            var GFXDescriptorSetLayout = exports('cj', /*#__PURE__*/function (_GFXObject) {
              _inherits(GFXDescriptorSetLayout, _GFXObject);

              _createClass(GFXDescriptorSetLayout, [{
                key: "bindings",
                get: function get() {
                  return this._bindings;
                }
              }, {
                key: "descriptorIndices",
                get: function get() {
                  return this._descriptorIndices;
                }
              }]);

              function GFXDescriptorSetLayout(device) {
                var _this;

                _classCallCheck(this, GFXDescriptorSetLayout);

                _this = _possibleConstructorReturn(this, _getPrototypeOf(GFXDescriptorSetLayout).call(this, GFXObjectType.DESCRIPTOR_SET_LAYOUT));
                _this._device = void 0;
                _this._bindings = [];
                _this._descriptorIndices = [];
                _this._device = device;
                return _this;
              }

              return GFXDescriptorSetLayout;
            }(GFXObject));

            /**
             * @category gfx
             */
            legacyCC.GFXDevice = GFXDevice;
            legacyCC.GFXBuffer = GFXBuffer;
            legacyCC.GFXTexture = GFXTexture;
            legacyCC.GFXSampler = GFXSampler;
            legacyCC.GFXShader = GFXShader;
            legacyCC.GFXInputAssembler = GFXInputAssembler;
            legacyCC.GFXRenderPass = GFXRenderPass;
            legacyCC.GFXFramebuffer = GFXFramebuffer;
            legacyCC.GFXPipelineState = GFXPipelineState;
            legacyCC.GFXCommandBuffer = GFXCommandBuffer;
            legacyCC.GFXQueue = GFXQueue;
            Object.assign(legacyCC, GFXDefines);

            /**
             * @category geometry
             */

            /**
             * @en
             * The raycast mode.
             * @zh 
             * 射线检测模式。
             */
            var ERaycastMode;
            /**
             * @en
             * The storage structure of the raycast results.
             * @zh
             * 射线检测结果的存储结构。
             */

            (function (ERaycastMode) {
              ERaycastMode[ERaycastMode["ALL"] = 0] = "ALL";
              ERaycastMode[ERaycastMode["CLOSEST"] = 1] = "CLOSEST";
              ERaycastMode[ERaycastMode["ANY"] = 2] = "ANY";
            })(ERaycastMode || (ERaycastMode = exports('dG', {})));

            /**
             * 几何工具模块
             * @category geometry
             */

            // tslint:disable:only-arrow-functions
            // tslint:disable:one-variable-per-declaration
            // tslint:disable:prefer-for-of
            // tslint:disable:no-shadowed-variable

            /**
             * @en
             * ray-plane intersect detect.
             * @zh
             * 射线与平面的相交性检测。
             * @param {ray} ray 射线
             * @param {plane} plane 平面
             * @return {number} 0 或 非0
             */
            var ray_plane = function () {
              var pt = new Vec3(0, 0, 0);
              return function (ray, plane) {
                var denom = Vec3.dot(ray.d, plane.n);

                if (Math.abs(denom) < Number.EPSILON) {
                  return 0;
                }

                Vec3.multiplyScalar(pt, plane.n, plane.d);
                var t = Vec3.dot(Vec3.subtract(pt, pt, ray.o), plane.n) / denom;

                if (t < 0) {
                  return 0;
                }

                return t;
              };
            }(); // based on http://fileadmin.cs.lth.se/cs/Personal/Tomas_Akenine-Moller/raytri/

            /**
             * @en
             * ray-triangle intersect detect.
             * @zh
             * 射线与三角形的相交性检测。
             * @param {ray} ray 射线
             * @param {triangle} triangle 三角形
             * @param {boolean} doubleSided 三角形是否为双面
             * @return {number} 0 或 非0
             */


            var ray_triangle = function () {
              var ab = new Vec3(0, 0, 0);
              var ac = new Vec3(0, 0, 0);
              var pvec = new Vec3(0, 0, 0);
              var tvec = new Vec3(0, 0, 0);
              var qvec = new Vec3(0, 0, 0);
              return function (ray, triangle, doubleSided) {
                Vec3.subtract(ab, triangle.b, triangle.a);
                Vec3.subtract(ac, triangle.c, triangle.a);
                Vec3.cross(pvec, ray.d, ac);
                var det = Vec3.dot(ab, pvec);

                if (det < Number.EPSILON && (!doubleSided || det > -Number.EPSILON)) {
                  return 0;
                }

                var inv_det = 1 / det;
                Vec3.subtract(tvec, ray.o, triangle.a);
                var u = Vec3.dot(tvec, pvec) * inv_det;

                if (u < 0 || u > 1) {
                  return 0;
                }

                Vec3.cross(qvec, tvec, ab);
                var v = Vec3.dot(ray.d, qvec) * inv_det;

                if (v < 0 || u + v > 1) {
                  return 0;
                }

                var t = Vec3.dot(ac, qvec) * inv_det;
                return t < 0 ? 0 : t;
              };
            }();
            /**
             * @en
             * ray-sphere intersect detect.
             * @zh
             * 射线和球的相交性检测。
             * @param {ray} ray 射线
             * @param {sphere} sphere 球
             * @return {number} 0 或 非0
             */


            var ray_sphere = function () {
              var e = new Vec3(0, 0, 0);
              return function (ray, sphere) {
                var r = sphere.radius;
                var c = sphere.center;
                var o = ray.o;
                var d = ray.d;
                var rSq = r * r;
                Vec3.subtract(e, c, o);
                var eSq = e.lengthSqr();
                var aLength = Vec3.dot(e, d); // assume ray direction already normalized

                var fSq = rSq - (eSq - aLength * aLength);

                if (fSq < 0) {
                  return 0;
                }

                var f = Math.sqrt(fSq);
                var t = eSq < rSq ? aLength + f : aLength - f;

                if (t < 0) {
                  return 0;
                }

                return t;
              };
            }();
            /**
             * @en
             * ray-aabb intersect detect.
             * @zh
             * 射线和轴对齐包围盒的相交性检测。
             * @param {ray} ray 射线
             * @param {aabb} aabb 轴对齐包围盒
             * @return {number} 0 或 非0
             */


            var ray_aabb = function () {
              var min = new Vec3();
              var max = new Vec3();
              return function (ray, aabb) {
                Vec3.subtract(min, aabb.center, aabb.halfExtents);
                Vec3.add(max, aabb.center, aabb.halfExtents);
                return ray_aabb2(ray, min, max);
              };
            }();

            function ray_aabb2(ray, min, max) {
              var o = ray.o,
                  d = ray.d;
              var ix = 1 / d.x,
                  iy = 1 / d.y,
                  iz = 1 / d.z;
              var t1 = (min.x - o.x) * ix;
              var t2 = (max.x - o.x) * ix;
              var t3 = (min.y - o.y) * iy;
              var t4 = (max.y - o.y) * iy;
              var t5 = (min.z - o.z) * iz;
              var t6 = (max.z - o.z) * iz;
              var tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));
              var tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6));

              if (tmax < 0 || tmin > tmax) {
                return 0;
              }

              return tmin > 0 ? tmin : tmax; // ray origin inside aabb
            }
            /**
             * @en
             * ray-obb intersect detect.
             * @zh
             * 射线和方向包围盒的相交性检测。
             * @param {ray} ray 射线
             * @param {obb} obb 方向包围盒
             * @return {number} 0 或 非0
             */


            var ray_obb = function () {
              var center = new Vec3();
              var o = new Vec3();
              var d = new Vec3();
              var X = new Vec3();
              var Y = new Vec3();
              var Z = new Vec3();
              var p = new Vec3();
              var size = new Array(3);
              var f = new Array(3);
              var e = new Array(3);
              var t = new Array(6);
              return function (ray, obb) {
                size[0] = obb.halfExtents.x;
                size[1] = obb.halfExtents.y;
                size[2] = obb.halfExtents.z;
                center = obb.center;
                o = ray.o;
                d = ray.d;
                Vec3.set(X, obb.orientation.m00, obb.orientation.m01, obb.orientation.m02);
                Vec3.set(Y, obb.orientation.m03, obb.orientation.m04, obb.orientation.m05);
                Vec3.set(Z, obb.orientation.m06, obb.orientation.m07, obb.orientation.m08);
                Vec3.subtract(p, center, o); // The cos values of the ray on the X, Y, Z

                f[0] = Vec3.dot(X, d);
                f[1] = Vec3.dot(Y, d);
                f[2] = Vec3.dot(Z, d); // The projection length of P on X, Y, Z

                e[0] = Vec3.dot(X, p);
                e[1] = Vec3.dot(Y, p);
                e[2] = Vec3.dot(Z, p);

                for (var i = 0; i < 3; ++i) {
                  if (f[i] === 0) {
                    if (-e[i] - size[i] > 0 || -e[i] + size[i] < 0) {
                      return 0;
                    } // Avoid div by 0!


                    f[i] = 0.0000001;
                  } // min


                  t[i * 2 + 0] = (e[i] + size[i]) / f[i]; // max

                  t[i * 2 + 1] = (e[i] - size[i]) / f[i];
                }

                var tmin = Math.max(Math.max(Math.min(t[0], t[1]), Math.min(t[2], t[3])), Math.min(t[4], t[5]));
                var tmax = Math.min(Math.min(Math.max(t[0], t[1]), Math.max(t[2], t[3])), Math.max(t[4], t[5]));

                if (tmax < 0 || tmin > tmax) {
                  return 0;
                }

                return tmin > 0 ? tmin : tmax; // ray origin inside aabb
              };
            }();
            /**
             * @en
             * ray-capsule intersect detect.
             * @zh
             * 射线和胶囊体的相交性检测。
             * @param {ray} ray 射线
             * @param {capsule} capsule 胶囊体
             * @return {number} 0 或 非0
             */


            var ray_capsule = function () {
              var v3_0 = new Vec3();
              var v3_1 = new Vec3();
              var v3_2 = new Vec3();
              var v3_3 = new Vec3();
              var v3_4 = new Vec3();
              var v3_5 = new Vec3();
              var v3_6 = new Vec3();
              var sphere_0 = new sphere();
              return function (ray, capsule) {
                var radiusSqr = capsule.radius * capsule.radius;
                var vRayNorm = Vec3.normalize(v3_0, ray.d);
                var A = capsule.ellipseCenter0;
                var B = capsule.ellipseCenter1;
                var BA = Vec3.subtract(v3_1, B, A);

                if (BA.equals(Vec3.ZERO)) {
                  sphere_0.radius = capsule.radius;
                  sphere_0.center.set(capsule.ellipseCenter0);
                  return intersect.ray_sphere(ray, sphere_0);
                }

                var O = ray.o;
                var OA = Vec3.subtract(v3_2, O, A);
                var VxBA = Vec3.cross(v3_3, vRayNorm, BA);
                var a = VxBA.lengthSqr();

                if (a === 0) {
                  sphere_0.radius = capsule.radius;
                  var BO = Vec3.subtract(v3_4, B, O);

                  if (OA.lengthSqr() < BO.lengthSqr()) {
                    sphere_0.center.set(capsule.ellipseCenter0);
                  } else {
                    sphere_0.center.set(capsule.ellipseCenter1);
                  }

                  return intersect.ray_sphere(ray, sphere_0);
                }

                var OAxBA = Vec3.cross(v3_4, OA, BA);
                var ab2 = BA.lengthSqr();
                var b = 2 * Vec3.dot(VxBA, OAxBA);
                var c = OAxBA.lengthSqr() - radiusSqr * ab2;
                var d = b * b - 4 * a * c;

                if (d < 0) {
                  return 0;
                }

                var t = (-b - Math.sqrt(d)) / (2 * a);

                if (t < 0) {
                  sphere_0.radius = capsule.radius;

                  var _BO = Vec3.subtract(v3_5, B, O);

                  if (OA.lengthSqr() < _BO.lengthSqr()) {
                    sphere_0.center.set(capsule.ellipseCenter0);
                  } else {
                    sphere_0.center.set(capsule.ellipseCenter1);
                  }

                  return intersect.ray_sphere(ray, sphere_0);
                } else {
                  // Limit intersection between the bounds of the cylinder's end caps.
                  var iPos = Vec3.scaleAndAdd(v3_5, ray.o, vRayNorm, t);
                  var iPosLen = Vec3.subtract(v3_6, iPos, A);
                  var tLimit = Vec3.dot(iPosLen, BA) / ab2;

                  if (tLimit >= 0 && tLimit <= 1) {
                    return t;
                  } else if (tLimit < 0) {
                    sphere_0.radius = capsule.radius;
                    sphere_0.center.set(capsule.ellipseCenter0);
                    return intersect.ray_sphere(ray, sphere_0);
                  } else if (tLimit > 1) {
                    sphere_0.radius = capsule.radius;
                    sphere_0.center.set(capsule.ellipseCenter1);
                    return intersect.ray_sphere(ray, sphere_0);
                  } else {
                    return 0;
                  }
                }
              };
            }();
            /**
             * @en
             * ray-subMesh intersect detect, in model space.
             * @zh
             * 在模型空间中，射线和子三角网格的相交性检测。
             * @param {ray} ray
             * @param {RenderingSubMesh} subMesh
             * @param {IRaySubMeshOptions} options
             * @return {number} 0 or !0
             */


            var ray_subMesh = function () {
              var tri = triangle.create();
              var deOpt = {
                distance: Infinity,
                doubleSided: false,
                mode: ERaycastMode.ANY
              };
              var minDis = 0;

              var fillResult = function fillResult(m, d, i0, i1, i2, r) {
                if (m === ERaycastMode.CLOSEST) {
                  if (minDis > d || minDis === 0) {
                    minDis = d;

                    if (r) {
                      if (r.length === 0) {
                        r.push({
                          distance: d,
                          vertexIndex0: i0 / 3,
                          vertexIndex1: i1 / 3,
                          vertexIndex2: i2 / 3
                        });
                      } else {
                        r[0].distance = d;
                        r[0].vertexIndex0 = i0 / 3;
                        r[0].vertexIndex1 = i1 / 3;
                        r[0].vertexIndex2 = i2 / 3;
                      }
                    }
                  }
                } else {
                  minDis = d;
                  if (r) r.push({
                    distance: d,
                    vertexIndex0: i0 / 3,
                    vertexIndex1: i1 / 3,
                    vertexIndex2: i2 / 3
                  });
                }
              };

              var narrowphase = function narrowphase(vb, ib, pm, ray, opt) {
                if (pm === GFXPrimitiveMode.TRIANGLE_LIST) {
                  var cnt = ib.length;

                  for (var j = 0; j < cnt; j += 3) {
                    var i0 = ib[j] * 3;
                    var i1 = ib[j + 1] * 3;
                    var i2 = ib[j + 2] * 3;
                    Vec3.set(tri.a, vb[i0], vb[i0 + 1], vb[i0 + 2]);
                    Vec3.set(tri.b, vb[i1], vb[i1 + 1], vb[i1 + 2]);
                    Vec3.set(tri.c, vb[i2], vb[i2 + 1], vb[i2 + 2]);
                    var dist = intersect.ray_triangle(ray, tri, opt.doubleSided);
                    if (dist === 0 || dist > opt.distance) continue;
                    fillResult(opt.mode, dist, i0, i1, i2, opt.result);
                    if (opt.mode === ERaycastMode.ANY) return dist;
                  }
                } else if (pm === GFXPrimitiveMode.TRIANGLE_STRIP) {
                  var _cnt = ib.length - 2;

                  var rev = 0;

                  for (var _j = 0; _j < _cnt; _j += 1) {
                    var _i = ib[_j - rev] * 3;

                    var _i2 = ib[_j + rev + 1] * 3;

                    var _i3 = ib[_j + 2] * 3;

                    Vec3.set(tri.a, vb[_i], vb[_i + 1], vb[_i + 2]);
                    Vec3.set(tri.b, vb[_i2], vb[_i2 + 1], vb[_i2 + 2]);
                    Vec3.set(tri.c, vb[_i3], vb[_i3 + 1], vb[_i3 + 2]);
                    rev = ~rev;

                    var _dist = intersect.ray_triangle(ray, tri, opt.doubleSided);

                    if (_dist === 0 || _dist > opt.distance) continue;
                    fillResult(opt.mode, _dist, _i, _i2, _i3, opt.result);
                    if (opt.mode === ERaycastMode.ANY) return _dist;
                  }
                } else if (pm === GFXPrimitiveMode.TRIANGLE_FAN) {
                  var _cnt2 = ib.length - 1;

                  var _i4 = ib[0] * 3;

                  Vec3.set(tri.a, vb[_i4], vb[_i4 + 1], vb[_i4 + 2]);

                  for (var _j2 = 1; _j2 < _cnt2; _j2 += 1) {
                    var _i5 = ib[_j2] * 3;

                    var _i6 = ib[_j2 + 1] * 3;

                    Vec3.set(tri.b, vb[_i5], vb[_i5 + 1], vb[_i5 + 2]);
                    Vec3.set(tri.c, vb[_i6], vb[_i6 + 1], vb[_i6 + 2]);

                    var _dist2 = intersect.ray_triangle(ray, tri, opt.doubleSided);

                    if (_dist2 === 0 || _dist2 > opt.distance) continue;
                    fillResult(opt.mode, _dist2, _i4, _i5, _i6, opt.result);
                    if (opt.mode === ERaycastMode.ANY) return _dist2;
                  }
                }

                return minDis;
              };

              return function (ray, submesh, options) {
                minDis = 0;
                if (submesh.geometricInfo.positions.length === 0) return minDis;
                var opt = options === undefined ? deOpt : options;
                var min = submesh.geometricInfo.boundingBox.min;
                var max = submesh.geometricInfo.boundingBox.max;

                if (ray_aabb2(ray, min, max)) {
                  var pm = submesh.primitiveMode;
                  var _ref = submesh.geometricInfo,
                      vb = _ref.positions,
                      ib = _ref.indices;
                  narrowphase(vb, ib, pm, ray, opt);
                }

                return minDis;
              };
            }();
            /**
             * @en
             * ray-mesh intersect detect, in model space.
             * @zh
             * 在模型空间中，射线和三角网格资源的相交性检测。
             * @param {ray} ray
             * @param {Mesh} mesh
             * @param {IRayMeshOptions} options
             * @return {number} 0 or !0
             */


            var ray_mesh = function () {
              var minDis = 0;
              var deOpt = {
                distance: Infinity,
                doubleSided: false,
                mode: ERaycastMode.ANY
              };
              return function (ray, mesh, options) {
                minDis = 0;
                var opt = options === undefined ? deOpt : options;
                var length = mesh.renderingSubMeshes.length;
                var min = mesh.struct.minPosition;
                var max = mesh.struct.maxPosition;
                if (min && max && !ray_aabb2(ray, min, max)) return minDis;

                for (var i = 0; i < length; i++) {
                  var sm = mesh.renderingSubMeshes[i];
                  var dis = ray_subMesh(ray, sm, opt);

                  if (dis) {
                    if (opt.mode === ERaycastMode.CLOSEST) {
                      if (minDis === 0 || minDis > dis) {
                        minDis = dis;
                        if (opt.subIndices) opt.subIndices[0] = i;
                      }
                    } else {
                      minDis = dis;
                      if (opt.subIndices) opt.subIndices.push(i);

                      if (opt.mode === ERaycastMode.ANY) {
                        return dis;
                      }
                    }
                  }
                }

                if (minDis && opt.mode === ERaycastMode.CLOSEST) {
                  if (opt.result) {
                    opt.result[0].distance = minDis;
                    opt.result.length = 1;
                  }

                  if (opt.subIndices) opt.subIndices.length = 1;
                }

                return minDis;
              };
            }();
            /**
             * @en
             * ray-model intersect detect, in world space.
             * @zh
             * 在世界空间中，射线和渲染模型的相交性检测。
             * @param ray
             * @param model
             * @param options
             * @return 0 or !0
             */


            var ray_model = function () {
              var minDis = 0;
              var deOpt = {
                distance: Infinity,
                doubleSided: false,
                mode: ERaycastMode.ANY
              };
              var modelRay = new ray();
              var m4 = new Mat4();
              return function (r, model, options) {
                minDis = 0;
                var opt = options === undefined ? deOpt : options;
                var wb = model.worldBounds;
                if (wb && !ray_aabb(r, wb)) return minDis;
                ray.copy(modelRay, r);

                if (model.node) {
                  Mat4.invert(m4, model.node.getWorldMatrix(m4));
                  Vec3.transformMat4(modelRay.o, r.o, m4);
                  Vec3.transformMat4Normal(modelRay.d, r.d, m4);
                }

                var subModels = model.subModels;

                for (var i = 0; i < subModels.length; i++) {
                  var subMesh = subModels[i].subMesh;
                  var dis = ray_subMesh(modelRay, subMesh, opt);

                  if (dis) {
                    if (opt.mode === ERaycastMode.CLOSEST) {
                      if (minDis === 0 || minDis > dis) {
                        minDis = dis;
                        if (opt.subIndices) opt.subIndices[0] = i;
                      }
                    } else {
                      minDis = dis;
                      if (opt.subIndices) opt.subIndices.push(i);

                      if (opt.mode === ERaycastMode.ANY) {
                        return dis;
                      }
                    }
                  }
                }

                if (minDis && opt.mode === ERaycastMode.CLOSEST) {
                  if (opt.result) {
                    opt.result[0].distance = minDis;
                    opt.result.length = 1;
                  }

                  if (opt.subIndices) opt.subIndices.length = 1;
                }

                return minDis;
              };
            }();
            /**
             * @en
             * line-plane intersect detect.
             * @zh
             * 线段与平面的相交性检测。
             * @param {line} line 线段
             * @param {plane} plane 平面
             * @return {number} 0 或 非0
             */


            var line_plane = function () {
              var ab = new Vec3(0, 0, 0);
              return function (line, plane) {
                Vec3.subtract(ab, line.e, line.s);
                var t = (plane.d - Vec3.dot(line.s, plane.n)) / Vec3.dot(ab, plane.n);

                if (t < 0 || t > 1) {
                  return 0;
                }

                return t;
              };
            }();
            /**
             * @en
             * line-triangle intersect detect.
             * @zh
             * 线段与三角形的相交性检测。
             * @param {line} line 线段
             * @param {triangle} triangle 三角形
             * @param {Vec3} outPt 可选，相交点
             * @return {number} 0 或 非0
             */


            var line_triangle = function () {
              var ab = new Vec3(0, 0, 0);
              var ac = new Vec3(0, 0, 0);
              var qp = new Vec3(0, 0, 0);
              var ap = new Vec3(0, 0, 0);
              var n = new Vec3(0, 0, 0);
              var e = new Vec3(0, 0, 0);
              return function (line, triangle, outPt) {
                Vec3.subtract(ab, triangle.b, triangle.a);
                Vec3.subtract(ac, triangle.c, triangle.a);
                Vec3.subtract(qp, line.s, line.e);
                Vec3.cross(n, ab, ac);
                var det = Vec3.dot(qp, n);

                if (det <= 0.0) {
                  return 0;
                }

                Vec3.subtract(ap, line.s, triangle.a);
                var t = Vec3.dot(ap, n);

                if (t < 0 || t > det) {
                  return 0;
                }

                Vec3.cross(e, qp, ap);
                var v = Vec3.dot(ac, e);

                if (v < 0 || v > det) {
                  return 0;
                }

                var w = -Vec3.dot(ab, e);

                if (w < 0.0 || v + w > det) {
                  return 0;
                }

                if (outPt) {
                  var invDet = 1.0 / det;
                  v *= invDet;
                  w *= invDet;
                  var u = 1.0 - v - w; // outPt = u*a + v*d + w*c;

                  Vec3.set(outPt, triangle.a.x * u + triangle.b.x * v + triangle.c.x * w, triangle.a.y * u + triangle.b.y * v + triangle.c.y * w, triangle.a.z * u + triangle.b.z * v + triangle.c.z * w);
                }

                return 1;
              };
            }();

            var r_t = new ray();
            /**
             * @en
             * line-aabb intersect detect.
             * @zh
             * 线段与轴对齐包围盒的相交性检测
             * @param line 线段
             * @param aabb 轴对齐包围盒
             * @return {number} 0 或 非0
             */

            function line_aabb(line, aabb) {
              r_t.o.set(line.s);
              Vec3.subtract(r_t.d, line.e, line.s);
              r_t.d.normalize();
              var min = ray_aabb(r_t, aabb);
              var len = line.length();

              if (min <= len) {
                return min;
              } else {
                return 0;
              }
            }
            /**
             * @en
             * line-obb intersect detect.
             * @zh
             * 线段与方向包围盒的相交性检测
             * @param line 线段
             * @param obb 方向包围盒
             * @return {number} 0 或 非0
             */


            function line_obb(line, obb) {
              r_t.o.set(line.s);
              Vec3.subtract(r_t.d, line.e, line.s);
              r_t.d.normalize();
              var min = ray_obb(r_t, obb);
              var len = line.length();

              if (min <= len) {
                return min;
              } else {
                return 0;
              }
            }
            /**
             * @en
             * line-sphere intersect detect.
             * @zh
             * 线段与球的相交性检测
             * @param line 线段
             * @param sphere 球
             * @return {number} 0 或 非0
             */


            function line_sphere(line, sphere) {
              r_t.o.set(line.s);
              Vec3.subtract(r_t.d, line.e, line.s);
              r_t.d.normalize();
              var min = ray_sphere(r_t, sphere);
              var len = line.length();

              if (min <= len) {
                return min;
              } else {
                return 0;
              }
            }
            /**
             * @en
             * aabb-aabb intersect detect.
             * @zh
             * 轴对齐包围盒和轴对齐包围盒的相交性检测。
             * @param {aabb} aabb1 轴对齐包围盒1
             * @param {aabb} aabb2 轴对齐包围盒2
             * @return {number} 0 或 非0
             */


            var aabb_aabb = function () {
              var aMin = new Vec3();
              var aMax = new Vec3();
              var bMin = new Vec3();
              var bMax = new Vec3();
              return function (aabb1, aabb2) {
                Vec3.subtract(aMin, aabb1.center, aabb1.halfExtents);
                Vec3.add(aMax, aabb1.center, aabb1.halfExtents);
                Vec3.subtract(bMin, aabb2.center, aabb2.halfExtents);
                Vec3.add(bMax, aabb2.center, aabb2.halfExtents);
                return aMin.x <= bMax.x && aMax.x >= bMin.x && aMin.y <= bMax.y && aMax.y >= bMin.y && aMin.z <= bMax.z && aMax.z >= bMin.z;
              };
            }();

            function getAABBVertices(min, max, out) {
              Vec3.set(out[0], min.x, max.y, max.z);
              Vec3.set(out[1], min.x, max.y, min.z);
              Vec3.set(out[2], min.x, min.y, max.z);
              Vec3.set(out[3], min.x, min.y, min.z);
              Vec3.set(out[4], max.x, max.y, max.z);
              Vec3.set(out[5], max.x, max.y, min.z);
              Vec3.set(out[6], max.x, min.y, max.z);
              Vec3.set(out[7], max.x, min.y, min.z);
            }

            function getOBBVertices(c, e, a1, a2, a3, out) {
              Vec3.set(out[0], c.x + a1.x * e.x + a2.x * e.y + a3.x * e.z, c.y + a1.y * e.x + a2.y * e.y + a3.y * e.z, c.z + a1.z * e.x + a2.z * e.y + a3.z * e.z);
              Vec3.set(out[1], c.x - a1.x * e.x + a2.x * e.y + a3.x * e.z, c.y - a1.y * e.x + a2.y * e.y + a3.y * e.z, c.z - a1.z * e.x + a2.z * e.y + a3.z * e.z);
              Vec3.set(out[2], c.x + a1.x * e.x - a2.x * e.y + a3.x * e.z, c.y + a1.y * e.x - a2.y * e.y + a3.y * e.z, c.z + a1.z * e.x - a2.z * e.y + a3.z * e.z);
              Vec3.set(out[3], c.x + a1.x * e.x + a2.x * e.y - a3.x * e.z, c.y + a1.y * e.x + a2.y * e.y - a3.y * e.z, c.z + a1.z * e.x + a2.z * e.y - a3.z * e.z);
              Vec3.set(out[4], c.x - a1.x * e.x - a2.x * e.y - a3.x * e.z, c.y - a1.y * e.x - a2.y * e.y - a3.y * e.z, c.z - a1.z * e.x - a2.z * e.y - a3.z * e.z);
              Vec3.set(out[5], c.x + a1.x * e.x - a2.x * e.y - a3.x * e.z, c.y + a1.y * e.x - a2.y * e.y - a3.y * e.z, c.z + a1.z * e.x - a2.z * e.y - a3.z * e.z);
              Vec3.set(out[6], c.x - a1.x * e.x + a2.x * e.y - a3.x * e.z, c.y - a1.y * e.x + a2.y * e.y - a3.y * e.z, c.z - a1.z * e.x + a2.z * e.y - a3.z * e.z);
              Vec3.set(out[7], c.x - a1.x * e.x - a2.x * e.y + a3.x * e.z, c.y - a1.y * e.x - a2.y * e.y + a3.y * e.z, c.z - a1.z * e.x - a2.z * e.y + a3.z * e.z);
            }

            function getInterval(vertices, axis) {
              var min = Vec3.dot(axis, vertices[0]),
                  max = min;

              for (var i = 1; i < 8; ++i) {
                var projection = Vec3.dot(axis, vertices[i]);
                min = projection < min ? projection : min;
                max = projection > max ? projection : max;
              }

              return [min, max];
            }
            /**
             * @en
             * aabb-obb intersect detect.
             * @zh
             * 轴对齐包围盒和方向包围盒的相交性检测。
             * @param {aabb} aabb 轴对齐包围盒
             * @param {obb} obb 方向包围盒
             * @return {number} 0 或 非0
             */


            var aabb_obb = function () {
              var test = new Array(15);

              for (var i = 0; i < 15; i++) {
                test[i] = new Vec3(0, 0, 0);
              }

              var vertices = new Array(8);
              var vertices2 = new Array(8);

              for (var _i7 = 0; _i7 < 8; _i7++) {
                vertices[_i7] = new Vec3(0, 0, 0);
                vertices2[_i7] = new Vec3(0, 0, 0);
              }

              var min = new Vec3();
              var max = new Vec3();
              return function (aabb, obb) {
                Vec3.set(test[0], 1, 0, 0);
                Vec3.set(test[1], 0, 1, 0);
                Vec3.set(test[2], 0, 0, 1);
                Vec3.set(test[3], obb.orientation.m00, obb.orientation.m01, obb.orientation.m02);
                Vec3.set(test[4], obb.orientation.m03, obb.orientation.m04, obb.orientation.m05);
                Vec3.set(test[5], obb.orientation.m06, obb.orientation.m07, obb.orientation.m08);

                for (var _i8 = 0; _i8 < 3; ++_i8) {
                  // Fill out rest of axis
                  Vec3.cross(test[6 + _i8 * 3 + 0], test[_i8], test[0]);
                  Vec3.cross(test[6 + _i8 * 3 + 1], test[_i8], test[1]);
                  Vec3.cross(test[6 + _i8 * 3 + 1], test[_i8], test[2]);
                }

                Vec3.subtract(min, aabb.center, aabb.halfExtents);
                Vec3.add(max, aabb.center, aabb.halfExtents);
                getAABBVertices(min, max, vertices);
                getOBBVertices(obb.center, obb.halfExtents, test[3], test[4], test[5], vertices2);

                for (var j = 0; j < 15; ++j) {
                  var a = getInterval(vertices, test[j]);
                  var b = getInterval(vertices2, test[j]);

                  if (b[0] > a[1] || a[0] > b[1]) {
                    return 0; // Seperating axis found
                  }
                }

                return 1;
              };
            }();
            /**
             * @en
             * aabb-plane intersect detect.
             * @zh
             * 轴对齐包围盒和平面的相交性检测。
             * @param {aabb} aabb 轴对齐包围盒
             * @param {plane} plane 平面
             * @return {number} inside(back) = -1, outside(front) = 0, intersect = 1
             */


            var aabb_plane = function aabb_plane(aabb, plane) {
              var r = aabb.halfExtents.x * Math.abs(plane.n.x) + aabb.halfExtents.y * Math.abs(plane.n.y) + aabb.halfExtents.z * Math.abs(plane.n.z);
              var dot = Vec3.dot(plane.n, aabb.center);

              if (dot + r < plane.d) {
                return -1;
              } else if (dot - r > plane.d) {
                return 0;
              }

              return 1;
            };
            /**
             * @en
             * aabb-frustum intersect detect, faster but has false positive corner cases.
             * @zh
             * 轴对齐包围盒和锥台相交性检测，速度快，但有错误情况。
             * @param {aabb} aabb 轴对齐包围盒
             * @param {frustum} frustum 锥台
             * @return {number} 0 或 非0
             */


            var aabb_frustum = function aabb_frustum(aabb, frustum) {
              for (var i = 0; i < frustum.planes.length; i++) {
                // frustum plane normal points to the inside
                if (aabb_plane(aabb, frustum.planes[i]) === -1) {
                  return 0;
                }
              } // completely outside


              return 1;
            }; // https://cesium.com/blog/2017/02/02/tighter-frustum-culling-and-why-you-may-want-to-disregard-it/

            /**
             * @en
             * aabb-frustum intersect, handles most of the false positives correctly.
             * @zh
             * 轴对齐包围盒和锥台相交性检测，正确处理大多数错误情况。
             * @param {aabb} aabb 轴对齐包围盒
             * @param {frustum} frustum 锥台
             * @return {number}
             */


            var aabb_frustum_accurate = function () {
              var tmp = new Array(8);
              var out1 = 0,
                  out2 = 0;

              for (var i = 0; i < tmp.length; i++) {
                tmp[i] = new Vec3(0, 0, 0);
              }

              return function (aabb, frustum) {
                var result = 0,
                    intersects = false; // 1. aabb inside/outside frustum test

                for (var _i9 = 0; _i9 < frustum.planes.length; _i9++) {
                  result = aabb_plane(aabb, frustum.planes[_i9]); // frustum plane normal points to the inside

                  if (result === -1) {
                    return 0;
                  } // completely outside
                  else if (result === 1) {
                      intersects = true;
                    }
                }

                if (!intersects) {
                  return 1;
                } // completely inside
                // in case of false positives
                // 2. frustum inside/outside aabb test


                for (var _i10 = 0; _i10 < frustum.vertices.length; _i10++) {
                  Vec3.subtract(tmp[_i10], frustum.vertices[_i10], aabb.center);
                }

                out1 = 0, out2 = 0;

                for (var _i11 = 0; _i11 < frustum.vertices.length; _i11++) {
                  if (tmp[_i11].x > aabb.halfExtents.x) {
                    out1++;
                  } else if (tmp[_i11].x < -aabb.halfExtents.x) {
                    out2++;
                  }
                }

                if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
                  return 0;
                }

                out1 = 0;
                out2 = 0;

                for (var _i12 = 0; _i12 < frustum.vertices.length; _i12++) {
                  if (tmp[_i12].y > aabb.halfExtents.y) {
                    out1++;
                  } else if (tmp[_i12].y < -aabb.halfExtents.y) {
                    out2++;
                  }
                }

                if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
                  return 0;
                }

                out1 = 0;
                out2 = 0;

                for (var _i13 = 0; _i13 < frustum.vertices.length; _i13++) {
                  if (tmp[_i13].z > aabb.halfExtents.z) {
                    out1++;
                  } else if (tmp[_i13].z < -aabb.halfExtents.z) {
                    out2++;
                  }
                }

                if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
                  return 0;
                }

                return 1;
              };
            }();
            /**
             * @en
             * obb contains the point.
             * @zh
             * 方向包围盒和点的相交性检测。
             * @param {obb} obb 方向包围盒
             * @param {Vec3} point 点
             * @return {boolean} true or false
             */


            var obb_point = function () {
              var tmp = new Vec3(0, 0, 0),
                  m3 = new Mat3();

              var lessThan = function lessThan(a, b) {
                return Math.abs(a.x) < b.x && Math.abs(a.y) < b.y && Math.abs(a.z) < b.z;
              };

              return function (obb, point) {
                Vec3.subtract(tmp, point, obb.center);
                Vec3.transformMat3(tmp, tmp, Mat3.transpose(m3, obb.orientation));
                return lessThan(tmp, obb.halfExtents);
              };
            }();
            /**
             * @en
             * obb-plane intersect detect.
             * @zh
             * 方向包围盒和平面的相交性检测。
             * @param {obb} obb 方向包围盒
             * @param {plane} plane 平面
             * @return {number} inside(back) = -1, outside(front) = 0, intersect = 1
             */


            var obb_plane = function () {
              var absDot = function absDot(n, x, y, z) {
                return Math.abs(n.x * x + n.y * y + n.z * z);
              };

              return function (obb, plane) {
                // Real-Time Collision Detection, Christer Ericson, p. 163.
                var r = obb.halfExtents.x * absDot(plane.n, obb.orientation.m00, obb.orientation.m01, obb.orientation.m02) + obb.halfExtents.y * absDot(plane.n, obb.orientation.m03, obb.orientation.m04, obb.orientation.m05) + obb.halfExtents.z * absDot(plane.n, obb.orientation.m06, obb.orientation.m07, obb.orientation.m08);
                var dot = Vec3.dot(plane.n, obb.center);

                if (dot + r < plane.d) {
                  return -1;
                } else if (dot - r > plane.d) {
                  return 0;
                }

                return 1;
              };
            }();
            /**
             * @en
             * obb-frustum intersect, faster but has false positive corner cases.
             * @zh
             * 方向包围盒和锥台相交性检测，速度快，但有错误情况。
             * @param {obb} obb 方向包围盒
             * @param {frustum} frustum 锥台
             * @return {number} 0 或 非0
             */


            var obb_frustum = function obb_frustum(obb, frustum) {
              for (var i = 0; i < frustum.planes.length; i++) {
                // frustum plane normal points to the inside
                if (obb_plane(obb, frustum.planes[i]) === -1) {
                  return 0;
                }
              } // completely outside


              return 1;
            }; // https://cesium.com/blog/2017/02/02/tighter-frustum-culling-and-why-you-may-want-to-disregard-it/

            /**
             * @en
             * obb-frustum intersect, handles most of the false positives correctly.
             * @zh
             * 方向包围盒和锥台相交性检测，正确处理大多数错误情况。
             * @param {obb} obb 方向包围盒
             * @param {frustum} frustum 锥台
             * @return {number} 0 或 非0
             */


            var obb_frustum_accurate = function () {
              var tmp = new Array(8);
              var dist = 0,
                  out1 = 0,
                  out2 = 0;

              for (var i = 0; i < tmp.length; i++) {
                tmp[i] = new Vec3(0, 0, 0);
              }

              var dot = function dot(n, x, y, z) {
                return n.x * x + n.y * y + n.z * z;
              };

              return function (obb, frustum) {
                var result = 0,
                    intersects = false; // 1. obb inside/outside frustum test

                for (var _i14 = 0; _i14 < frustum.planes.length; _i14++) {
                  result = obb_plane(obb, frustum.planes[_i14]); // frustum plane normal points to the inside

                  if (result === -1) {
                    return 0;
                  } // completely outside
                  else if (result === 1) {
                      intersects = true;
                    }
                }

                if (!intersects) {
                  return 1;
                } // completely inside
                // in case of false positives
                // 2. frustum inside/outside obb test


                for (var _i15 = 0; _i15 < frustum.vertices.length; _i15++) {
                  Vec3.subtract(tmp[_i15], frustum.vertices[_i15], obb.center);
                }

                out1 = 0, out2 = 0;

                for (var _i16 = 0; _i16 < frustum.vertices.length; _i16++) {
                  dist = dot(tmp[_i16], obb.orientation.m00, obb.orientation.m01, obb.orientation.m02);

                  if (dist > obb.halfExtents.x) {
                    out1++;
                  } else if (dist < -obb.halfExtents.x) {
                    out2++;
                  }
                }

                if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
                  return 0;
                }

                out1 = 0;
                out2 = 0;

                for (var _i17 = 0; _i17 < frustum.vertices.length; _i17++) {
                  dist = dot(tmp[_i17], obb.orientation.m03, obb.orientation.m04, obb.orientation.m05);

                  if (dist > obb.halfExtents.y) {
                    out1++;
                  } else if (dist < -obb.halfExtents.y) {
                    out2++;
                  }
                }

                if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
                  return 0;
                }

                out1 = 0;
                out2 = 0;

                for (var _i18 = 0; _i18 < frustum.vertices.length; _i18++) {
                  dist = dot(tmp[_i18], obb.orientation.m06, obb.orientation.m07, obb.orientation.m08);

                  if (dist > obb.halfExtents.z) {
                    out1++;
                  } else if (dist < -obb.halfExtents.z) {
                    out2++;
                  }
                }

                if (out1 === frustum.vertices.length || out2 === frustum.vertices.length) {
                  return 0;
                }

                return 1;
              };
            }();
            /**
             * @en
             * obb-obb intersect detect.
             * @zh
             * 方向包围盒和方向包围盒的相交性检测。
             * @param {obb} obb1 方向包围盒1
             * @param {obb} obb2 方向包围盒2
             * @return {number} 0 或 非0
             */


            var obb_obb = function () {
              var test = new Array(15);

              for (var i = 0; i < 15; i++) {
                test[i] = new Vec3(0, 0, 0);
              }

              var vertices = new Array(8);
              var vertices2 = new Array(8);

              for (var _i19 = 0; _i19 < 8; _i19++) {
                vertices[_i19] = new Vec3(0, 0, 0);
                vertices2[_i19] = new Vec3(0, 0, 0);
              }

              return function (obb1, obb2) {
                Vec3.set(test[0], obb1.orientation.m00, obb1.orientation.m01, obb1.orientation.m02);
                Vec3.set(test[1], obb1.orientation.m03, obb1.orientation.m04, obb1.orientation.m05);
                Vec3.set(test[2], obb1.orientation.m06, obb1.orientation.m07, obb1.orientation.m08);
                Vec3.set(test[3], obb2.orientation.m00, obb2.orientation.m01, obb2.orientation.m02);
                Vec3.set(test[4], obb2.orientation.m03, obb2.orientation.m04, obb2.orientation.m05);
                Vec3.set(test[5], obb2.orientation.m06, obb2.orientation.m07, obb2.orientation.m08);

                for (var _i20 = 0; _i20 < 3; ++_i20) {
                  // Fill out rest of axis
                  Vec3.cross(test[6 + _i20 * 3 + 0], test[_i20], test[0]);
                  Vec3.cross(test[6 + _i20 * 3 + 1], test[_i20], test[1]);
                  Vec3.cross(test[6 + _i20 * 3 + 1], test[_i20], test[2]);
                }

                getOBBVertices(obb1.center, obb1.halfExtents, test[0], test[1], test[2], vertices);
                getOBBVertices(obb2.center, obb2.halfExtents, test[3], test[4], test[5], vertices2);

                for (var _i21 = 0; _i21 < 15; ++_i21) {
                  var a = getInterval(vertices, test[_i21]);
                  var b = getInterval(vertices2, test[_i21]);

                  if (b[0] > a[1] || a[0] > b[1]) {
                    return 0; // Seperating axis found
                  }
                }

                return 1;
              };
            }(); // tslint:disable-next-line: max-line-length
            // https://github.com/diku-dk/bvh-tvcg18/blob/1fd3348c17bc8cf3da0b4ae60fdb8f2aa90a6ff0/FOUNDATION/GEOMETRY/GEOMETRY/include/overlap/geometry_overlap_obb_capsule.h

            /**
             * @en
             * obb-capsule intersect detect.
             * @zh
             * 方向包围盒和胶囊体的相交性检测。
             * @param obb 方向包围盒
             * @param capsule 胶囊体
             */


            var obb_capsule = function () {
              var sphere_0 = new sphere();
              var v3_0 = new Vec3();
              var v3_1 = new Vec3();
              var v3_2 = new Vec3();
              var v3_verts8 = new Array(8);

              for (var i = 0; i < 8; i++) {
                v3_verts8[i] = new Vec3();
              }

              var v3_axis8 = new Array(8);

              for (var _i22 = 0; _i22 < 8; _i22++) {
                v3_axis8[_i22] = new Vec3();
              }

              return function (obb, capsule) {
                var h = Vec3.squaredDistance(capsule.ellipseCenter0, capsule.ellipseCenter1);

                if (h === 0) {
                  sphere_0.radius = capsule.radius;
                  sphere_0.center.set(capsule.ellipseCenter0);
                  return intersect.sphere_obb(sphere_0, obb);
                } else {
                  v3_0.x = obb.orientation.m00;
                  v3_0.y = obb.orientation.m01;
                  v3_0.z = obb.orientation.m02;
                  v3_1.x = obb.orientation.m03;
                  v3_1.y = obb.orientation.m04;
                  v3_1.z = obb.orientation.m05;
                  v3_2.x = obb.orientation.m06;
                  v3_2.y = obb.orientation.m07;
                  v3_2.z = obb.orientation.m08;
                  getOBBVertices(obb.center, obb.halfExtents, v3_0, v3_1, v3_2, v3_verts8);
                  var axes = v3_axis8;
                  var a0 = Vec3.copy(axes[0], v3_0);
                  var a1 = Vec3.copy(axes[1], v3_1);
                  var a2 = Vec3.copy(axes[2], v3_2);
                  var C = Vec3.subtract(axes[3], capsule.center, obb.center);
                  C.normalize();
                  var B = Vec3.subtract(axes[4], capsule.ellipseCenter0, capsule.ellipseCenter1);
                  B.normalize();
                  Vec3.cross(axes[5], a0, B);
                  Vec3.cross(axes[6], a1, B);
                  Vec3.cross(axes[7], a2, B);

                  for (var _i23 = 0; _i23 < 8; ++_i23) {
                    var a = getInterval(v3_verts8, axes[_i23]);
                    var d0 = Vec3.dot(axes[_i23], capsule.ellipseCenter0);
                    var d1 = Vec3.dot(axes[_i23], capsule.ellipseCenter1);
                    var max_d = Math.max(d0, d1);
                    var min_d = Math.min(d0, d1);
                    var d_min = min_d - capsule.radius;
                    var d_max = max_d + capsule.radius;

                    if (d_min > a[1] || a[0] > d_max) {
                      return 0; // Seperating axis found
                    }
                  }

                  return 1;
                }
              };
            }();
            /**
             * @en
             * sphere-plane intersect, not necessarily faster than obb-plane,due to the length calculation of the
             * plane normal to factor out the unnomalized plane distance.
             * @zh
             * 球与平面的相交性检测。
             * @param {sphere} sphere 球
             * @param {plane} plane 平面
             * @return {number} inside(back) = -1, outside(front) = 0, intersect = 1
             */


            var sphere_plane = function sphere_plane(sphere, plane) {
              var dot = Vec3.dot(plane.n, sphere.center);
              var r = sphere.radius * plane.n.length();

              if (dot + r < plane.d) {
                return -1;
              } else if (dot - r > plane.d) {
                return 0;
              }

              return 1;
            };
            /**
             * @en
             * sphere-frustum intersect, faster but has false positive corner cases.
             * @zh
             * 球和锥台的相交性检测，速度快，但有错误情况。
             * @param {sphere} sphere 球
             * @param {frustum} frustum 锥台
             * @return {number} 0 或 非0
             */


            var sphere_frustum = function sphere_frustum(sphere, frustum) {
              for (var i = 0; i < frustum.planes.length; i++) {
                // frustum plane normal points to the inside
                if (sphere_plane(sphere, frustum.planes[i]) === -1) {
                  return 0;
                }
              } // completely outside


              return 1;
            }; // https://stackoverflow.com/questions/20912692/view-frustum-culling-corner-cases

            /**
             * @en
             * sphere-frustum intersect, handles the false positives correctly.
             * @zh
             * 球和锥台的相交性检测，正确处理大多数错误情况。
             * @param {sphere} sphere 球
             * @param {frustum} frustum 锥台
             * @return {number} 0 或 非0
             */


            var sphere_frustum_accurate = function () {
              var pt = new Vec3(0, 0, 0),
                  map = [1, -1, 1, -1, 1, -1];
              return function (sphere, frustum) {
                for (var i = 0; i < 6; i++) {
                  var plane = frustum.planes[i];
                  var r = sphere.radius,
                      c = sphere.center;
                  var n = plane.n,
                      d = plane.d;
                  var dot = Vec3.dot(n, c); // frustum plane normal points to the inside

                  if (dot + r < d) {
                    return 0;
                  } // completely outside
                  else if (dot - r > d) {
                      continue;
                    } // in case of false positives
                  // has false negatives, still working on it


                  Vec3.add(pt, c, Vec3.multiplyScalar(pt, n, r));

                  for (var j = 0; j < 6; j++) {
                    if (j === i || j === i + map[i]) {
                      continue;
                    }

                    var test = frustum.planes[j];

                    if (Vec3.dot(test.n, pt) < test.d) {
                      return 0;
                    }
                  }
                }

                return 1;
              };
            }();
            /**
             * @en
             * sphere-sphere intersect detect.
             * @zh
             * 球和球的相交性检测。
             * @param {sphere} sphere0 球0
             * @param {sphere} sphere1 球1
             * @return {boolean} true or false
             */


            var sphere_sphere = function sphere_sphere(sphere0, sphere1) {
              var r = sphere0.radius + sphere1.radius;
              return Vec3.squaredDistance(sphere0.center, sphere1.center) < r * r;
            };
            /**
             * @en
             * sphere-aabb intersect detect.
             * @zh
             * 球和轴对齐包围盒的相交性检测。
             * @param {sphere} sphere 球
             * @param {aabb} aabb 轴对齐包围盒
             * @return {boolean} true or false
             */


            var sphere_aabb = function () {
              var pt = new Vec3();
              return function (sphere, aabb) {
                pt_point_aabb(pt, sphere.center, aabb);
                return Vec3.squaredDistance(sphere.center, pt) < sphere.radius * sphere.radius;
              };
            }();
            /**
             * @en
             * sphere-obb intersect detect.
             * @zh
             * 球和方向包围盒的相交性检测。
             * @param {sphere} sphere 球
             * @param {obb} obb 方向包围盒
             * @return {boolean} true or false
             */


            var sphere_obb = function () {
              var pt = new Vec3();
              return function (sphere, obb) {
                pt_point_obb(pt, sphere.center, obb);
                return Vec3.squaredDistance(sphere.center, pt) < sphere.radius * sphere.radius;
              };
            }();
            /**
             * @en
             * sphere-capsule intersect detect.
             * @zh
             * 球和胶囊体的相交性检测。
             */


            var sphere_capsule = function () {
              var v3_0 = new Vec3();
              var v3_1 = new Vec3();
              return function (sphere, capsule) {
                var r = sphere.radius + capsule.radius;
                var squaredR = r * r;
                var h = Vec3.squaredDistance(capsule.ellipseCenter0, capsule.ellipseCenter1);

                if (h === 0) {
                  return Vec3.squaredDistance(sphere.center, capsule.center) < squaredR;
                } else {
                  Vec3.subtract(v3_0, sphere.center, capsule.ellipseCenter0);
                  Vec3.subtract(v3_1, capsule.ellipseCenter1, capsule.ellipseCenter0);
                  var t = Vec3.dot(v3_0, v3_1) / h;

                  if (t < 0) {
                    return Vec3.squaredDistance(sphere.center, capsule.ellipseCenter0) < squaredR;
                  } else if (t > 1) {
                    return Vec3.squaredDistance(sphere.center, capsule.ellipseCenter1) < squaredR;
                  } else {
                    Vec3.scaleAndAdd(v3_0, capsule.ellipseCenter0, v3_1, t);
                    return Vec3.squaredDistance(sphere.center, v3_0) < squaredR;
                  }
                }
              };
            }(); // http://www.geomalgorithms.com/a07-_distance.html

            /**
             * @en
             * capsule-capsule intersect detect.
             * @zh
             * 胶囊体和胶囊体的相交性检测。
             */


            var capsule_capsule = function () {
              var v3_0 = new Vec3();
              var v3_1 = new Vec3();
              var v3_2 = new Vec3();
              var v3_3 = new Vec3();
              var v3_4 = new Vec3();
              var v3_5 = new Vec3();
              return function capsule_capsule(capsuleA, capsuleB) {
                var u = Vec3.subtract(v3_0, capsuleA.ellipseCenter1, capsuleA.ellipseCenter0);
                var v = Vec3.subtract(v3_1, capsuleB.ellipseCenter1, capsuleB.ellipseCenter0);
                var w = Vec3.subtract(v3_2, capsuleA.ellipseCenter0, capsuleB.ellipseCenter0);
                var a = Vec3.dot(u, u); // always >= 0

                var b = Vec3.dot(u, v);
                var c = Vec3.dot(v, v); // always >= 0

                var d = Vec3.dot(u, w);
                var e = Vec3.dot(v, w);
                var D = a * c - b * b; // always >= 0

                var sc;
                var sN;
                var sD = D; // sc = sN / sD, default sD = D >= 0

                var tc;
                var tN;
                var tD = D; // tc = tN / tD, default tD = D >= 0
                // compute the line parameters of the two closest points

                if (D < EPSILON) {
                  // the lines are almost parallel
                  sN = 0.0; // force using point P0 on segment S1

                  sD = 1.0; // to prevent possible division by 0.0 later

                  tN = e;
                  tD = c;
                } else {
                  // get the closest points on the infinite lines
                  sN = b * e - c * d;
                  tN = a * e - b * d;

                  if (sN < 0.0) {
                    // sc < 0 => the s=0 edge is visible
                    sN = 0.0;
                    tN = e;
                    tD = c;
                  } else if (sN > sD) {
                    // sc > 1  => the s=1 edge is visible
                    sN = sD;
                    tN = e + b;
                    tD = c;
                  }
                }

                if (tN < 0.0) {
                  // tc < 0 => the t=0 edge is visible
                  tN = 0.0; // recompute sc for this edge

                  if (-d < 0.0) {
                    sN = 0.0;
                  } else if (-d > a) {
                    sN = sD;
                  } else {
                    sN = -d;
                    sD = a;
                  }
                } else if (tN > tD) {
                  // tc > 1  => the t=1 edge is visible
                  tN = tD; // recompute sc for this edge

                  if (-d + b < 0.0) {
                    sN = 0;
                  } else if (-d + b > a) {
                    sN = sD;
                  } else {
                    sN = -d + b;
                    sD = a;
                  }
                } // finally do the division to get sc and tc


                sc = Math.abs(sN) < EPSILON ? 0.0 : sN / sD;
                tc = Math.abs(tN) < EPSILON ? 0.0 : tN / tD; // get the difference of the two closest points

                var dP = v3_3;
                dP.set(w);
                dP.add(Vec3.multiplyScalar(v3_4, u, sc));
                dP.subtract(Vec3.multiplyScalar(v3_5, v, tc));
                var radius = capsuleA.radius + capsuleB.radius;
                return dP.lengthSqr() < radius * radius;
              };
            }();
            /**
             * @en
             * Algorithm of intersect detect for basic geometry.
             * @zh
             * 基础几何的相交性检测算法。
             */


            var intersect = exports('dv', {
              ray_sphere: ray_sphere,
              ray_aabb: ray_aabb,
              ray_obb: ray_obb,
              ray_plane: ray_plane,
              ray_triangle: ray_triangle,
              ray_capsule: ray_capsule,
              ray_subMesh: ray_subMesh,
              ray_mesh: ray_mesh,
              ray_model: ray_model,
              line_sphere: line_sphere,
              line_aabb: line_aabb,
              line_obb: line_obb,
              line_plane: line_plane,
              line_triangle: line_triangle,
              sphere_sphere: sphere_sphere,
              sphere_aabb: sphere_aabb,
              sphere_obb: sphere_obb,
              sphere_plane: sphere_plane,
              sphere_frustum: sphere_frustum,
              sphere_frustum_accurate: sphere_frustum_accurate,
              sphere_capsule: sphere_capsule,
              aabb_aabb: aabb_aabb,
              aabb_obb: aabb_obb,
              aabb_plane: aabb_plane,
              aabb_frustum: aabb_frustum,
              aabb_frustum_accurate: aabb_frustum_accurate,
              obb_obb: obb_obb,
              obb_plane: obb_plane,
              obb_frustum: obb_frustum,
              obb_frustum_accurate: obb_frustum_accurate,
              obb_point: obb_point,
              obb_capsule: obb_capsule,
              capsule_capsule: capsule_capsule,

              /**
               * @zh
               * g1 和 g2 的相交性检测，可填入基础几何中的形状。
               * @param g1 几何1
               * @param g2 几何2
               * @param outPt 可选，相交点。（注：仅部分形状的检测带有这个返回值）
               */
              resolve: function resolve(g1, g2) {
                var outPt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
                var type1 = g1._type,
                    type2 = g2._type;
                var resolver = this[type1 | type2];

                if (type1 < type2) {
                  return resolver(g1, g2, outPt);
                } else {
                  return resolver(g2, g1, outPt);
                }
              }
            });
            intersect[enums.SHAPE_RAY | enums.SHAPE_SPHERE] = ray_sphere;
            intersect[enums.SHAPE_RAY | enums.SHAPE_AABB] = ray_aabb;
            intersect[enums.SHAPE_RAY | enums.SHAPE_OBB] = ray_obb;
            intersect[enums.SHAPE_RAY | enums.SHAPE_PLANE] = ray_plane;
            intersect[enums.SHAPE_RAY | enums.SHAPE_TRIANGLE] = ray_triangle;
            intersect[enums.SHAPE_RAY | enums.SHAPE_CAPSULE] = ray_capsule;
            intersect[enums.SHAPE_LINE | enums.SHAPE_SPHERE] = line_sphere;
            intersect[enums.SHAPE_LINE | enums.SHAPE_AABB] = line_aabb;
            intersect[enums.SHAPE_LINE | enums.SHAPE_OBB] = line_obb;
            intersect[enums.SHAPE_LINE | enums.SHAPE_PLANE] = line_plane;
            intersect[enums.SHAPE_LINE | enums.SHAPE_TRIANGLE] = line_triangle;
            intersect[enums.SHAPE_SPHERE] = sphere_sphere;
            intersect[enums.SHAPE_SPHERE | enums.SHAPE_AABB] = sphere_aabb;
            intersect[enums.SHAPE_SPHERE | enums.SHAPE_OBB] = sphere_obb;
            intersect[enums.SHAPE_SPHERE | enums.SHAPE_PLANE] = sphere_plane;
            intersect[enums.SHAPE_SPHERE | enums.SHAPE_FRUSTUM] = sphere_frustum;
            intersect[enums.SHAPE_SPHERE | enums.SHAPE_FRUSTUM_ACCURATE] = sphere_frustum_accurate;
            intersect[enums.SHAPE_SPHERE | enums.SHAPE_CAPSULE] = sphere_capsule;
            intersect[enums.SHAPE_AABB] = aabb_aabb;
            intersect[enums.SHAPE_AABB | enums.SHAPE_OBB] = aabb_obb;
            intersect[enums.SHAPE_AABB | enums.SHAPE_PLANE] = aabb_plane;
            intersect[enums.SHAPE_AABB | enums.SHAPE_FRUSTUM] = aabb_frustum;
            intersect[enums.SHAPE_AABB | enums.SHAPE_FRUSTUM_ACCURATE] = aabb_frustum_accurate;
            intersect[enums.SHAPE_OBB] = obb_obb;
            intersect[enums.SHAPE_OBB | enums.SHAPE_PLANE] = obb_plane;
            intersect[enums.SHAPE_OBB | enums.SHAPE_FRUSTUM] = obb_frustum;
            intersect[enums.SHAPE_OBB | enums.SHAPE_FRUSTUM_ACCURATE] = obb_frustum_accurate;
            intersect[enums.SHAPE_OBB | enums.SHAPE_CAPSULE] = obb_capsule;
            intersect[enums.SHAPE_CAPSULE] = capsule_capsule;

            /**
             * @en
             * Basic Geometry: line.
             * @zh
             * 基础几何 line。
             */
            // tslint:disable-next-line:class-name

            var line = exports('dw', /*#__PURE__*/function () {
              _createClass(line, [{
                key: "type",

                /**
                 * @en
                 * Gets the type of the shape.
                 * @zh
                 * 获取形状的类型。
                 */
                get: function get() {
                  return this._type;
                }
              }], [{
                key: "create",

                /**
                 * @en
                 * create a new line
                 * @zh
                 * 创建一个新的 line。
                 * @param sx 起点的 x 部分。
                 * @param sy 起点的 y 部分。
                 * @param sz 起点的 z 部分。
                 * @param ex 终点的 x 部分。
                 * @param ey 终点的 y 部分。
                 * @param ez 终点的 z 部分。
                 * @return
                 */
                value: function create(sx, sy, sz, ex, ey, ez) {
                  return new line(sx, sy, sz, ex, ey, ez);
                }
                /**
                 * @en
                 * Creates a new line initialized with values from an existing line
                 * @zh
                 * 克隆一个新的 line。
                 * @param a 克隆的来源。
                 * @return 克隆出的对象。
                 */

              }, {
                key: "clone",
                value: function clone(a) {
                  return new line(a.s.x, a.s.y, a.s.z, a.e.x, a.e.y, a.e.z);
                }
                /**
                 * @en
                 * Copy the values from one line to another
                 * @zh
                 * 复制一个线的值到另一个。
                 * @param out 接受操作的对象。
                 * @param a 复制的来源。
                 * @return 接受操作的对象。
                 */

              }, {
                key: "copy",
                value: function copy(out, a) {
                  Vec3.copy(out.s, a.s);
                  Vec3.copy(out.e, a.e);
                  return out;
                }
                /**
                 * @en
                 * create a line from two points
                 * @zh
                 * 用两个点创建一个线。
                 * @param out 接受操作的对象。
                 * @param start 起点。
                 * @param end 终点。
                 * @return out 接受操作的对象。
                 */

              }, {
                key: "fromPoints",
                value: function fromPoints(out, start, end) {
                  Vec3.copy(out.s, start);
                  Vec3.copy(out.e, end);
                  return out;
                }
                /**
                 * @en
                 * Set the components of a Vec3 to the given values
                 * @zh
                 * 将给定线的属性设置为给定值。
                 * @param out 接受操作的对象。
                 * @param sx 起点的 x 部分。
                 * @param sy 起点的 y 部分。
                 * @param sz 起点的 z 部分。
                 * @param ex 终点的 x 部分。
                 * @param ey 终点的 y 部分。
                 * @param ez 终点的 z 部分。
                 * @return out 接受操作的对象。
                 */

              }, {
                key: "set",
                value: function set(out, sx, sy, sz, ex, ey, ez) {
                  out.s.x = sx;
                  out.s.y = sy;
                  out.s.z = sz;
                  out.e.x = ex;
                  out.e.y = ey;
                  out.e.z = ez;
                  return out;
                }
                /**
                 * @zh
                 * 计算线的长度。
                 * @param a 要计算的线。
                 * @return 长度。
                 */

              }, {
                key: "len",
                value: function len(a) {
                  return Vec3.distance(a.s, a.e);
                }
                /**
                 * @zh
                 * 起点。
                 */

              }]);

              /**
               * 构造一条线。
               * @param sx 起点的 x 部分。
               * @param sy 起点的 y 部分。
               * @param sz 起点的 z 部分。
               * @param ex 终点的 x 部分。
               * @param ey 终点的 y 部分。
               * @param ez 终点的 z 部分。
               */
              function line() {
                var sx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                var sy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                var sz = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
                var ex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
                var ey = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
                var ez = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : -1;

                _classCallCheck(this, line);

                this.s = void 0;
                this.e = void 0;
                this._type = void 0;
                this._type = enums.SHAPE_LINE;
                this.s = new Vec3(sx, sy, sz);
                this.e = new Vec3(ex, ey, ez);
              }
              /**
               * @zh
               * 计算线的长度。
               * @param a 要计算的线。
               * @return 长度。
               */


              _createClass(line, [{
                key: "length",
                value: function length() {
                  return Vec3.distance(this.s, this.e);
                }
              }]);

              return line;
            }());

            var v1 = new Vec3(0, 0, 0);
            var v2 = new Vec3(0, 0, 0);
            var temp_mat = legacyCC.mat4();
            var temp_vec4 = legacyCC.v4();
            /**
             * @en
             * Basic Geometry: plane.
             * @zh
             * 基础几何 plane。
             */
            // tslint:disable-next-line:class-name

            var plane = exports('dx', /*#__PURE__*/function () {
              _createClass(plane, [{
                key: "type",

                /**
                 * @en
                 * Gets the type of the shape.
                 * @zh
                 * 获取形状的类型。
                 */
                get: function get() {
                  return this._type;
                }
              }], [{
                key: "create",

                /**
                 * @en
                 * create a new plane
                 * @zh
                 * 创建一个新的 plane。
                 * @param nx 法向分量的 x 部分。
                 * @param ny 法向分量的 y 部分。
                 * @param nz 法向分量的 z 部分。
                 * @param d 与原点的距离。
                 * @return
                 */
                value: function create(nx, ny, nz, d) {
                  return new plane(nx, ny, nz, d);
                }
                /**
                 * @en
                 * clone a new plane
                 * @zh
                 * 克隆一个新的 plane。
                 * @param p 克隆的来源。
                 * @return 克隆出的对象。
                 */

              }, {
                key: "clone",
                value: function clone(p) {
                  return new plane(p.n.x, p.n.y, p.n.z, p.d);
                }
                /**
                 * @en
                 * copy the values from one plane to another
                 * @zh
                 * 复制一个平面的值到另一个。
                 * @param out 接受操作的对象。
                 * @param p 复制的来源。
                 * @return 接受操作的对象。
                 */

              }, {
                key: "copy",
                value: function copy(out, p) {
                  Vec3.copy(out.n, p.n);
                  out.d = p.d;
                  return out;
                }
                /**
                 * @en
                 * create a plane from three points
                 * @zh
                 * 用三个点创建一个平面。
                 * @param out 接受操作的对象。
                 * @param a 点 a。
                 * @param b 点 b。
                 * @param c 点 c。
                 * @return out 接受操作的对象。
                 */

              }, {
                key: "fromPoints",
                value: function fromPoints(out, a, b, c) {
                  Vec3.subtract(v1, b, a);
                  Vec3.subtract(v2, c, a);
                  Vec3.normalize(out.n, Vec3.cross(out.n, v1, v2));
                  out.d = Vec3.dot(out.n, a);
                  return out;
                }
                /**
                 * @en
                 * Set the components of a plane to the given values
                 * @zh
                 * 将给定平面的属性设置为给定值。
                 * @param out 接受操作的对象。
                 * @param nx 法向分量的 x 部分。
                 * @param ny 法向分量的 y 部分。
                 * @param nz 法向分量的 z 部分。
                 * @param d 与原点的距离。
                 * @return out 接受操作的对象。
                 */

              }, {
                key: "set",
                value: function set(out, nx, ny, nz, d) {
                  out.n.x = nx;
                  out.n.y = ny;
                  out.n.z = nz;
                  out.d = d;
                  return out;
                }
                /**
                 * @en
                 * create plane from normal and point
                 * @zh
                 * 用一条法线和一个点创建平面。
                 * @param out 接受操作的对象。
                 * @param normal 平面的法线。
                 * @param point 平面上的一点。
                 * @return out 接受操作的对象。
                 */

              }, {
                key: "fromNormalAndPoint",
                value: function fromNormalAndPoint(out, normal, point) {
                  Vec3.copy(out.n, normal);
                  out.d = Vec3.dot(normal, point);
                  return out;
                }
                /**
                 * @en
                 * normalize a plane
                 * @zh
                 * 归一化一个平面。
                 * @param out 接受操作的对象。
                 * @param a 操作的源数据。
                 * @return out 接受操作的对象。
                 */

              }, {
                key: "normalize",
                value: function normalize(out, a) {
                  var len = a.n.length();
                  Vec3.normalize(out.n, a.n);

                  if (len > 0) {
                    out.d = a.d / len;
                  }

                  return out;
                }
                /**
                 * @en
                 * The normal of the plane.
                 * @zh
                 * 法线向量。
                 */

              }]);

              /**
               * @en
               * Construct a plane.
               * @zh
               * 构造一个平面。
               * @param nx 法向分量的 x 部分。
               * @param ny 法向分量的 y 部分。
               * @param nz 法向分量的 z 部分。
               * @param d 与原点的距离。
               */
              function plane() {
                var nx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                var ny = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
                var nz = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
                var d = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

                _classCallCheck(this, plane);

                this.n = void 0;
                this.d = void 0;
                this._type = void 0;
                this._type = enums.SHAPE_PLANE;
                this.n = new Vec3(nx, ny, nz);
                this.d = d;
              }
              /**
               * @en
               * transform this plane.
               * @zh
               * 变换一个平面。
               * @param mat
               */


              _createClass(plane, [{
                key: "transform",
                value: function transform(mat) {
                  Mat4.invert(temp_mat, mat);
                  Mat4.transpose(temp_mat, temp_mat);
                  Vec4.set(temp_vec4, this.n.x, this.n.y, this.n.z, this.d);
                  Vec4.transformMat4(temp_vec4, temp_vec4, temp_mat);
                  Vec3.set(this.n, temp_vec4.x, temp_vec4.y, temp_vec4.z);
                  this.d = temp_vec4.w;
                }
              }]);

              return plane;
            }());

            var _v3_tmp$1 = new Vec3();

            var _v3_tmp2 = new Vec3();

            var _v3_tmp3 = new Vec3();

            var _v3_tmp4 = new Vec3();

            var _m3_tmp = new Mat3(); // https://zeuxcg.org/2010/10/17/aabb-from-obb-with-component-wise-abs/


            var transform_extent_m4 = function transform_extent_m4(out, extent, m4) {
              _m3_tmp.m00 = Math.abs(m4.m00);
              _m3_tmp.m01 = Math.abs(m4.m01);
              _m3_tmp.m02 = Math.abs(m4.m02);
              _m3_tmp.m03 = Math.abs(m4.m04);
              _m3_tmp.m04 = Math.abs(m4.m05);
              _m3_tmp.m05 = Math.abs(m4.m06);
              _m3_tmp.m06 = Math.abs(m4.m08);
              _m3_tmp.m07 = Math.abs(m4.m09);
              _m3_tmp.m08 = Math.abs(m4.m10);
              Vec3.transformMat3(out, extent, _m3_tmp);
            };
            /**
             * @en
             * Basic Geometry: Axis-aligned bounding box, using center and half extents structure.
             * @zh
             * 基础几何  轴对齐包围盒，使用中心点和半长宽高的结构。
             */
            // tslint:disable-next-line: class-name


            var aabb = exports('dB', /*#__PURE__*/function () {
              _createClass(aabb, [{
                key: "type",

                /**
                 * @en
                 * Gets the type of the shape.
                 * @zh
                 * 获取形状的类型。
                 */
                get: function get() {
                  return this._type;
                }
              }], [{
                key: "create",

                /**
                 * @en
                 * create a new aabb
                 * @zh
                 * 创建一个新的 aabb 实例。
                 * @param px - aabb 的原点的 X 坐标。
                 * @param py - aabb 的原点的 Y 坐标。
                 * @param pz - aabb 的原点的 Z 坐标。
                 * @param hw - aabb 宽度的一半。
                 * @param hh - aabb 高度的一半。
                 * @param hl - aabb 长度的一半。
                 * @returns 返回新创建的 aabb 实例。
                 */
                value: function create(px, py, pz, hw, hh, hl) {
                  return new aabb(px, py, pz, hw, hh, hl);
                }
                /**
                 * @en
                 * clone a new aabb
                 * @zh
                 * 克隆一个 aabb。
                 * @param a - 克隆的目标。
                 * @returns 克隆出的 aabb。
                 */

              }, {
                key: "clone",
                value: function clone(a) {
                  return new aabb(a.center.x, a.center.y, a.center.z, a.halfExtents.x, a.halfExtents.y, a.halfExtents.z);
                }
                /**
                 * @en
                 * copy the values from one aabb to another
                 * @zh
                 * 将从一个 aabb 的值复制到另一个 aabb。
                 * @param {aabb} out 接受操作的 aabb。
                 * @param {aabb} a 被复制的 aabb。
                 * @return {aabb} out 接受操作的 aabb。
                 */

              }, {
                key: "copy",
                value: function copy(out, a) {
                  Vec3.copy(out.center, a.center);
                  Vec3.copy(out.halfExtents, a.halfExtents);
                  return out;
                }
                /**
                 * @en
                 * create a new aabb from two corner points
                 * @zh
                 * 从两个点创建一个新的 aabb。
                 * @param out - 接受操作的 aabb。
                 * @param minPos - aabb 的最小点。
                 * @param maxPos - aabb 的最大点。
                 * @returns {aabb} out 接受操作的 aabb。
                 */

              }, {
                key: "fromPoints",
                value: function fromPoints(out, minPos, maxPos) {
                  Vec3.add(_v3_tmp$1, maxPos, minPos);
                  Vec3.subtract(_v3_tmp2, maxPos, minPos);
                  Vec3.multiplyScalar(out.center, _v3_tmp$1, 0.5);
                  Vec3.multiplyScalar(out.halfExtents, _v3_tmp2, 0.5);
                  return out;
                }
                /**
                 * @en
                 * Set the components of a aabb to the given values
                 * @zh
                 * 将 aabb 的属性设置为给定的值。
                 * @param {aabb} out 接受操作的 aabb。
                 * @param px - aabb 的原点的 X 坐标。
                 * @param py - aabb 的原点的 Y 坐标。
                 * @param pz - aabb 的原点的 Z 坐标。
                 * @param hw - aabb 宽度的一半。
                 * @param hh - aabb 高度的一半。
                 * @param hl - aabb 长度度的一半。
                 * @return {aabb} out 接受操作的 aabb。
                 */

              }, {
                key: "set",
                value: function set(out, px, py, pz, hw, hh, hl) {
                  Vec3.set(out.center, px, py, pz);
                  Vec3.set(out.halfExtents, hw, hh, hl);
                  return out;
                }
                /**
                 * @en
                 * Merge tow aabb.
                 * @zh
                 * 合并两个 aabb 到 out。
                 * @param out 接受操作的 aabb。
                 * @param a 输入的 aabb。
                 * @param b 输入的 aabb。
                 * @returns {aabb} out 接受操作的 aabb。
                 */

              }, {
                key: "merge",
                value: function merge(out, a, b) {
                  Vec3.subtract(_v3_tmp$1, a.center, a.halfExtents);
                  Vec3.subtract(_v3_tmp2, b.center, b.halfExtents);
                  Vec3.add(_v3_tmp3, a.center, a.halfExtents);
                  Vec3.add(_v3_tmp4, b.center, b.halfExtents);
                  Vec3.max(_v3_tmp4, _v3_tmp3, _v3_tmp4);
                  Vec3.min(_v3_tmp3, _v3_tmp$1, _v3_tmp2);
                  return aabb.fromPoints(out, _v3_tmp3, _v3_tmp4);
                }
                /**
                 * @en
                 * Transform this aabb.
                 * @zh
                 * 变换一个 aabb 到 out 中。
                 * @param out 接受操作的 aabb。
                 * @param a 输入的源 aabb。
                 * @param matrix 矩阵。
                 * @returns {aabb} out 接受操作的 aabb。
                 */

              }, {
                key: "transform",
                value: function transform(out, a, matrix) {
                  Vec3.transformMat4(out.center, a.center, matrix);
                  transform_extent_m4(out.halfExtents, a.halfExtents, matrix);
                  return out;
                }
                /**
                 * @zh
                 * 本地坐标的中心点。
                 */

              }]);

              function aabb() {
                var px = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                var py = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                var pz = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
                var hw = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
                var hh = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
                var hl = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;

                _classCallCheck(this, aabb);

                this.center = void 0;
                this.halfExtents = void 0;
                this._type = void 0;
                this._type = enums.SHAPE_AABB;
                this.center = new Vec3(px, py, pz);
                this.halfExtents = new Vec3(hw, hh, hl);
              }
              /**
               * @en
               * Get the bounding points of this shape
               * @zh
               * 获取 aabb 的最小点和最大点。
               * @param {Vec3} minPos 最小点。
               * @param {Vec3} maxPos 最大点。
               */


              _createClass(aabb, [{
                key: "getBoundary",
                value: function getBoundary(minPos, maxPos) {
                  Vec3.subtract(minPos, this.center, this.halfExtents);
                  Vec3.add(maxPos, this.center, this.halfExtents);
                }
                /**
                 * @en
                 * Transform this shape
                 * @zh
                 * 将 out 根据这个 aabb 的数据进行变换。
                 * @param m 变换的矩阵。
                 * @param pos 变换的位置部分。
                 * @param rot 变换的旋转部分。
                 * @param scale 变换的缩放部分。
                 * @param out 变换的目标。
                 */

              }, {
                key: "transform",
                value: function transform(m, pos, rot, scale, out) {
                  Vec3.transformMat4(out.center, this.center, m);
                  transform_extent_m4(out.halfExtents, this.halfExtents, m);
                }
                /**
                 * @zh
                 * 获得克隆。
                 * @returns {aabb}
                 */

              }, {
                key: "clone",
                value: function clone() {
                  return aabb.clone(this);
                }
                /**
                 * @zh
                 * 拷贝对象。
                 * @param a 拷贝的目标。
                 * @returns {aabb}
                 */

              }, {
                key: "copy",
                value: function copy(a) {
                  return aabb.copy(this, a);
                }
              }]);

              return aabb;
            }());

            var _v3_tmp$2 = new Vec3();

            var _v3_tmp2$1 = new Vec3();

            var _m3_tmp$1 = new Mat3(); // https://zeuxcg.org/2010/10/17/aabb-from-obb-with-component-wise-abs/


            var transform_extent_m3 = function transform_extent_m3(out, extent, m3) {
              _m3_tmp$1.m00 = Math.abs(m3.m00);
              _m3_tmp$1.m01 = Math.abs(m3.m01);
              _m3_tmp$1.m02 = Math.abs(m3.m02);
              _m3_tmp$1.m03 = Math.abs(m3.m03);
              _m3_tmp$1.m04 = Math.abs(m3.m04);
              _m3_tmp$1.m05 = Math.abs(m3.m05);
              _m3_tmp$1.m06 = Math.abs(m3.m06);
              _m3_tmp$1.m07 = Math.abs(m3.m07);
              _m3_tmp$1.m08 = Math.abs(m3.m08);
              Vec3.transformMat3(out, extent, _m3_tmp$1);
            };
            /**
             * @en
             * Basic Geometry: directional bounding box.
             * @zh
             * 基础几何  方向包围盒。
             */
            // tslint:disable-next-line:class-name


            var obb = exports('dC', /*#__PURE__*/function () {
              _createClass(obb, [{
                key: "type",

                /**
                 * @en
                 * Gets the type of the shape.
                 * @zh
                 * 获取形状的类型。
                 */
                get: function get() {
                  return this._type;
                }
              }], [{
                key: "create",

                /**
                 * @en
                 * create a new obb
                 * @zh
                 * 创建一个新的 obb 实例。
                 * @param cx 形状的相对于原点的 X 坐标。
                 * @param cy 形状的相对于原点的 Y 坐标。
                 * @param cz 形状的相对于原点的 Z 坐标。
                 * @param hw - obb 宽度的一半。
                 * @param hh - obb 高度的一半。
                 * @param hl - obb 长度的一半。
                 * @param ox_1 方向矩阵参数。
                 * @param ox_2 方向矩阵参数。
                 * @param ox_3 方向矩阵参数。
                 * @param oy_1 方向矩阵参数。
                 * @param oy_2 方向矩阵参数。
                 * @param oy_3 方向矩阵参数。
                 * @param oz_1 方向矩阵参数。
                 * @param oz_2 方向矩阵参数。
                 * @param oz_3 方向矩阵参数。
                 * @return 返回一个 obb。
                 */
                value: function create(cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3) {
                  return new obb(cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3);
                }
                /**
                 * @en
                 * clone a new obb
                 * @zh
                 * 克隆一个 obb。
                 * @param a 克隆的目标。
                 * @returns 克隆出的新对象。
                 */

              }, {
                key: "clone",
                value: function clone(a) {
                  return new obb(a.center.x, a.center.y, a.center.z, a.halfExtents.x, a.halfExtents.y, a.halfExtents.z, a.orientation.m00, a.orientation.m01, a.orientation.m02, a.orientation.m03, a.orientation.m04, a.orientation.m05, a.orientation.m06, a.orientation.m07, a.orientation.m08);
                }
                /**
                 * @en
                 * copy the values from one obb to another
                 * @zh
                 * 将从一个 obb 的值复制到另一个 obb。
                 * @param {obb} out 接受操作的 obb。
                 * @param {obb} a 被复制的 obb。
                 * @return {obb} out 接受操作的 obb。
                 */

              }, {
                key: "copy",
                value: function copy(out, a) {
                  Vec3.copy(out.center, a.center);
                  Vec3.copy(out.halfExtents, a.halfExtents);
                  Mat3.copy(out.orientation, a.orientation);
                  return out;
                }
                /**
                 * @en
                 * create a new obb from two corner points
                 * @zh
                 * 用两个点创建一个新的 obb。
                 * @param out - 接受操作的 obb。
                 * @param minPos - obb 的最小点。
                 * @param maxPos - obb 的最大点。
                 * @returns {obb} out 接受操作的 obb。
                 */

              }, {
                key: "fromPoints",
                value: function fromPoints(out, minPos, maxPos) {
                  Vec3.multiplyScalar(out.center, Vec3.add(_v3_tmp$2, minPos, maxPos), 0.5);
                  Vec3.multiplyScalar(out.halfExtents, Vec3.subtract(_v3_tmp2$1, maxPos, minPos), 0.5);
                  Mat3.identity(out.orientation);
                  return out;
                }
                /**
                 * @en
                 * Set the components of a obb to the given values
                 * @zh
                 * 将给定 obb 的属性设置为给定的值。
                 * @param cx - obb 的原点的 X 坐标。
                 * @param cy - obb 的原点的 Y 坐标。
                 * @param cz - obb 的原点的 Z 坐标。
                 * @param hw - obb 宽度的一半。
                 * @param hh - obb 高度的一半。
                 * @param hl - obb 长度的一半。
                 * @param ox_1 方向矩阵参数。
                 * @param ox_2 方向矩阵参数。
                 * @param ox_3 方向矩阵参数。
                 * @param oy_1 方向矩阵参数。
                 * @param oy_2 方向矩阵参数。
                 * @param oy_3 方向矩阵参数。
                 * @param oz_1 方向矩阵参数。
                 * @param oz_2 方向矩阵参数。
                 * @param oz_3 方向矩阵参数。
                 * @return {obb} out
                 */

              }, {
                key: "set",
                value: function set(out, cx, cy, cz, hw, hh, hl, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3) {
                  Vec3.set(out.center, cx, cy, cz);
                  Vec3.set(out.halfExtents, hw, hh, hl);
                  Mat3.set(out.orientation, ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3);
                  return out;
                }
                /**
                 * @zh
                 * 本地坐标的中心点。
                 */

              }]);

              function obb() {
                var cx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                var cy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                var cz = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
                var hw = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
                var hh = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
                var hl = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
                var ox_1 = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 1;
                var ox_2 = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
                var ox_3 = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 0;
                var oy_1 = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 0;
                var oy_2 = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 1;
                var oy_3 = arguments.length > 11 && arguments[11] !== undefined ? arguments[11] : 0;
                var oz_1 = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : 0;
                var oz_2 = arguments.length > 13 && arguments[13] !== undefined ? arguments[13] : 0;
                var oz_3 = arguments.length > 14 && arguments[14] !== undefined ? arguments[14] : 1;

                _classCallCheck(this, obb);

                this.center = void 0;
                this.halfExtents = void 0;
                this.orientation = void 0;
                this._type = void 0;
                this._type = enums.SHAPE_OBB;
                this.center = new Vec3(cx, cy, cz);
                this.halfExtents = new Vec3(hw, hh, hl);
                this.orientation = new Mat3(ox_1, ox_2, ox_3, oy_1, oy_2, oy_3, oz_1, oz_2, oz_3);
              }
              /**
               * @en
               * Get the bounding points of this shape
               * @zh
               * 获取 obb 的最小点和最大点。
               * @param {Vec3} minPos 最小点。
               * @param {Vec3} maxPos 最大点。
               */


              _createClass(obb, [{
                key: "getBoundary",
                value: function getBoundary(minPos, maxPos) {
                  transform_extent_m3(_v3_tmp$2, this.halfExtents, this.orientation);
                  Vec3.subtract(minPos, this.center, _v3_tmp$2);
                  Vec3.add(maxPos, this.center, _v3_tmp$2);
                }
                /**
                 * Transform this shape
                 * @zh
                 * 将 out 根据这个 obb 的数据进行变换。
                 * @param m 变换的矩阵。
                 * @param pos 变换的位置部分。
                 * @param rot 变换的旋转部分。
                 * @param scale 变换的缩放部分。
                 * @param out 变换的目标。
                 */

              }, {
                key: "transform",
                value: function transform(m, pos, rot, scale, out) {
                  Vec3.transformMat4(out.center, this.center, m); // parent shape doesn't contain rotations for now

                  Mat3.fromQuat(out.orientation, rot);
                  Vec3.multiply(out.halfExtents, this.halfExtents, scale);
                }
                /**
                 * @zh
                 * 将 out 根据这个 obb 的数据进行变换。
                 * @param m 变换的矩阵。
                 * @param rot 变换的旋转部分。
                 * @param out 变换的目标。
                 */

              }, {
                key: "translateAndRotate",
                value: function translateAndRotate(m, rot, out) {
                  Vec3.transformMat4(out.center, this.center, m); // parent shape doesn't contain rotations for now

                  Mat3.fromQuat(out.orientation, rot);
                }
                /**
                 * @zh
                 *  将 out 根据这个 obb 的数据进行缩放。
                 * @param scale 缩放值。
                 * @param out 缩放的目标。
                 */

              }, {
                key: "setScale",
                value: function setScale(scale, out) {
                  Vec3.multiply(out.halfExtents, this.halfExtents, scale);
                }
              }]);

              return obb;
            }());

            var _v = new Array(8);

            _v[0] = new Vec3(1, 1, 1);
            _v[1] = new Vec3(-1, 1, 1);
            _v[2] = new Vec3(-1, -1, 1);
            _v[3] = new Vec3(1, -1, 1);
            _v[4] = new Vec3(1, 1, -1);
            _v[5] = new Vec3(-1, 1, -1);
            _v[6] = new Vec3(-1, -1, -1);
            _v[7] = new Vec3(1, -1, -1);
            /**
             * @en
             * Basic Geometry: frustum.
             * @zh
             * 基础几何 截头锥体。
             */
            // tslint:disable-next-line: class-name

            var frustum = exports('dD', /*#__PURE__*/function () {
              _createClass(frustum, [{
                key: "accurate",

                /**
                 * @en
                 * Set whether to use accurate intersection testing function on this frustum.
                 * @zh
                 * 设置是否在此截锥体上使用精确的相交测试函数。
                 */
                set: function set(b) {
                  this._type = b ? enums.SHAPE_FRUSTUM_ACCURATE : enums.SHAPE_FRUSTUM;
                }
                /**
                 * @en
                 * Create a ortho frustum.
                 * @zh
                 * 创建一个正交视锥体。
                 * @param out 正交视锥体。
                 * @param width 正交视锥体的宽度。
                 * @param height 正交视锥体的高度。
                 * @param near 正交视锥体的近平面值。
                 * @param far 正交视锥体的远平面值。
                 * @param transform 正交视锥体的变换矩阵。
                 * @return {frustum} frustum.
                 */

              }, {
                key: "type",

                /**
                 * @en
                 * Gets the type of the shape.
                 * @zh
                 * 获取形状的类型。
                 */
                get: function get() {
                  return this._type;
                }
              }], [{
                key: "create",

                /**
                 * @en
                 * create a new frustum.
                 * @zh
                 * 创建一个新的截锥体。
                 * @return {frustum} frustum.
                 */
                value: function create() {
                  return new frustum();
                }
                /**
                 * @en
                 * Clone a frustum.
                 * @zh
                 * 克隆一个截锥体。
                 */

              }, {
                key: "clone",
                value: function clone(f) {
                  return frustum.copy(new frustum(), f);
                }
                /**
                 * @en
                 * Copy the values from one frustum to another.
                 * @zh
                 * 从一个截锥体拷贝到另一个截锥体。
                 */

              }, {
                key: "copy",
                value: function copy(out, f) {
                  out._type = f._type;

                  for (var i = 0; i < 6; ++i) {
                    plane.copy(out.planes[i], f.planes[i]);
                  }

                  for (var _i = 0; _i < 8; ++_i) {
                    Vec3.copy(out.vertices[_i], f.vertices[_i]);
                  }

                  return out;
                }
              }]);

              function frustum() {
                _classCallCheck(this, frustum);

                this._type = void 0;
                this.planes = void 0;
                this.vertices = void 0;
                this._type = enums.SHAPE_FRUSTUM;
                this.planes = new Array(6);

                for (var i = 0; i < 6; ++i) {
                  this.planes[i] = plane.create(0, 0, 0, 0);
                }

                this.vertices = new Array(8);

                for (var _i2 = 0; _i2 < 8; ++_i2) {
                  this.vertices[_i2] = new Vec3();
                }
              }
              /**
               * @en
               * Update the frustum information according to the given transform matrix.
               * Note that the resulting planes are not normalized under normal mode.
               * @zh
               * 根据给定的变换矩阵更新截锥体信息，注意得到的平面不是在标准模式下归一化的。
               * @param {Mat4} m the view-projection matrix
               * @param {Mat4} inv the inverse view-projection matrix
               */


              _createClass(frustum, [{
                key: "update",
                value: function update(m, inv) {
                  // RTR4, ch. 22.14.1, p. 983
                  // extract frustum planes from view-proj matrix.
                  // left plane
                  Vec3.set(this.planes[0].n, m.m03 + m.m00, m.m07 + m.m04, m.m11 + m.m08);
                  this.planes[0].d = -(m.m15 + m.m12); // right plane

                  Vec3.set(this.planes[1].n, m.m03 - m.m00, m.m07 - m.m04, m.m11 - m.m08);
                  this.planes[1].d = -(m.m15 - m.m12); // bottom plane

                  Vec3.set(this.planes[2].n, m.m03 + m.m01, m.m07 + m.m05, m.m11 + m.m09);
                  this.planes[2].d = -(m.m15 + m.m13); // top plane

                  Vec3.set(this.planes[3].n, m.m03 - m.m01, m.m07 - m.m05, m.m11 - m.m09);
                  this.planes[3].d = -(m.m15 - m.m13); // near plane

                  Vec3.set(this.planes[4].n, m.m03 + m.m02, m.m07 + m.m06, m.m11 + m.m10);
                  this.planes[4].d = -(m.m15 + m.m14); // far plane

                  Vec3.set(this.planes[5].n, m.m03 - m.m02, m.m07 - m.m06, m.m11 - m.m10);
                  this.planes[5].d = -(m.m15 - m.m14);

                  if (this._type !== enums.SHAPE_FRUSTUM_ACCURATE) {
                    return;
                  } // normalize planes


                  for (var i = 0; i < 6; i++) {
                    var pl = this.planes[i];
                    var invDist = 1 / pl.n.length();
                    Vec3.multiplyScalar(pl.n, pl.n, invDist);
                    pl.d *= invDist;
                  } // update frustum vertices


                  for (var _i3 = 0; _i3 < 8; _i3++) {
                    Vec3.transformMat4(this.vertices[_i3], _v[_i3], inv);
                  }
                }
                /**
                 * @en
                 * Transform this frustum.
                 * @zh
                 * 变换此截锥体。
                 * @param mat 变换矩阵。
                 */

              }, {
                key: "transform",
                value: function transform(mat) {
                  if (this._type !== enums.SHAPE_FRUSTUM_ACCURATE) {
                    return;
                  }

                  for (var i = 0; i < 8; i++) {
                    Vec3.transformMat4(this.vertices[i], this.vertices[i], mat);
                  }

                  plane.fromPoints(this.planes[0], this.vertices[1], this.vertices[5], this.vertices[6]);
                  plane.fromPoints(this.planes[1], this.vertices[3], this.vertices[7], this.vertices[4]);
                  plane.fromPoints(this.planes[2], this.vertices[6], this.vertices[7], this.vertices[3]);
                  plane.fromPoints(this.planes[3], this.vertices[0], this.vertices[4], this.vertices[5]);
                  plane.fromPoints(this.planes[4], this.vertices[2], this.vertices[3], this.vertices[0]);
                  plane.fromPoints(this.planes[0], this.vertices[7], this.vertices[6], this.vertices[5]);
                }
              }]);

              return frustum;
            }());

            frustum.createOrtho = function () {
              var _temp_v3 = new Vec3();

              return function (out, width, height, near, far, transform) {
                var halfWidth = width / 2;
                var halfHeight = height / 2;
                Vec3.set(_temp_v3, halfWidth, halfHeight, near);
                Vec3.transformMat4(out.vertices[0], _temp_v3, transform);
                Vec3.set(_temp_v3, -halfWidth, halfHeight, near);
                Vec3.transformMat4(out.vertices[1], _temp_v3, transform);
                Vec3.set(_temp_v3, -halfWidth, -halfHeight, near);
                Vec3.transformMat4(out.vertices[2], _temp_v3, transform);
                Vec3.set(_temp_v3, halfWidth, -halfHeight, near);
                Vec3.transformMat4(out.vertices[3], _temp_v3, transform);
                Vec3.set(_temp_v3, halfWidth, halfHeight, far);
                Vec3.transformMat4(out.vertices[4], _temp_v3, transform);
                Vec3.set(_temp_v3, -halfWidth, halfHeight, far);
                Vec3.transformMat4(out.vertices[5], _temp_v3, transform);
                Vec3.set(_temp_v3, -halfWidth, -halfHeight, far);
                Vec3.transformMat4(out.vertices[6], _temp_v3, transform);
                Vec3.set(_temp_v3, halfWidth, -halfHeight, far);
                Vec3.transformMat4(out.vertices[7], _temp_v3, transform);
                plane.fromPoints(out.planes[0], out.vertices[1], out.vertices[6], out.vertices[5]);
                plane.fromPoints(out.planes[1], out.vertices[3], out.vertices[4], out.vertices[7]);
                plane.fromPoints(out.planes[2], out.vertices[6], out.vertices[3], out.vertices[7]);
                plane.fromPoints(out.planes[3], out.vertices[0], out.vertices[5], out.vertices[4]);
                plane.fromPoints(out.planes[4], out.vertices[2], out.vertices[0], out.vertices[3]);
                plane.fromPoints(out.planes[0], out.vertices[7], out.vertices[5], out.vertices[6]);
              };
            }();

            var WrapModeMask;

            (function (WrapModeMask) {
              WrapModeMask[WrapModeMask["Default"] = 0] = "Default";
              WrapModeMask[WrapModeMask["Normal"] = 1] = "Normal";
              WrapModeMask[WrapModeMask["Loop"] = 2] = "Loop";
              WrapModeMask[WrapModeMask["ShouldWrap"] = 4] = "ShouldWrap";
              WrapModeMask[WrapModeMask["Clamp"] = 8] = "Clamp";
              WrapModeMask[WrapModeMask["PingPong"] = 22] = "PingPong";
              WrapModeMask[WrapModeMask["Reverse"] = 36] = "Reverse";
            })(WrapModeMask || (WrapModeMask = exports('dW', {})));

            /**
             * 动画使用的循环模式。
             */
            var WrapMode;

            (function (WrapMode) {
              WrapMode[WrapMode["Default"] = WrapModeMask.Default] = "Default";
              WrapMode[WrapMode["Normal"] = WrapModeMask.Normal] = "Normal";
              WrapMode[WrapMode["Reverse"] = WrapModeMask.Reverse] = "Reverse";
              WrapMode[WrapMode["Loop"] = WrapModeMask.Loop] = "Loop";
              WrapMode[WrapMode["LoopReverse"] = WrapModeMask.Loop | WrapModeMask.Reverse] = "LoopReverse";
              WrapMode[WrapMode["PingPong"] = WrapModeMask.PingPong] = "PingPong";
              WrapMode[WrapMode["PingPongReverse"] = WrapModeMask.PingPong | WrapModeMask.Reverse] = "PingPongReverse";
            })(WrapMode || (WrapMode = exports('dU', {})));

            ccenum(WrapMode);
            /**
             * For internal
             */

            var WrappedInfo = exports('dV', /*#__PURE__*/function () {
              function WrappedInfo(info) {
                _classCallCheck(this, WrappedInfo);

                this.ratio = 0;
                this.time = 0;
                this.direction = 1;
                this.stopped = true;
                this.iterations = 0;
                this.frameIndex = undefined;

                if (info) {
                  this.set(info);
                }
              }

              _createClass(WrappedInfo, [{
                key: "set",
                value: function set(info) {
                  this.ratio = info.ratio;
                  this.time = info.time;
                  this.direction = info.direction;
                  this.stopped = info.stopped;
                  this.iterations = info.iterations;
                  this.frameIndex = info.frameIndex;
                }
              }]);

              return WrappedInfo;
            }());
            function isLerpable(object) {
              return typeof object.lerp === 'function';
            }

            var LOOK_FORWARD = 3;
            var WrapMode$1 = Enum({
              Default: WrapModeMask.Default,
              Normal: WrapModeMask.Normal,
              Clamp: WrapModeMask.Clamp,
              Loop: WrapModeMask.Loop,
              PingPong: WrapModeMask.PingPong
            });
            /**
             * @en
             * A key frame in the curve.
             * @zh 
             * 曲线中的一个关键帧。
             */

            var Keyframe = exports('dE', function Keyframe() {
              _classCallCheck(this, Keyframe);

              this.time = 0;
              this.value = 0;
              this.inTangent = 0;
              this.outTangent = 0;
            });
            CCClass.fastDefine('cc.Keyframe', Keyframe, {
              time: 0,
              value: 0,
              inTangent: 0,
              outTangent: 0
            });
            var OptimizedKey = /*#__PURE__*/function () {
              function OptimizedKey() {
                _classCallCheck(this, OptimizedKey);

                this.index = void 0;
                this.time = void 0;
                this.endTime = void 0;
                this.coefficient = void 0;
                this.index = -1;
                this.time = 0;
                this.endTime = 0;
                this.coefficient = new Float32Array(4);
              }

              _createClass(OptimizedKey, [{
                key: "evaluate",
                value: function evaluate(T) {
                  var t = T - this.time;
                  return evalOptCurve(t, this.coefficient);
                }
              }]);

              return OptimizedKey;
            }();
            function evalOptCurve(t, coefs) {
              return t * (t * (t * coefs[0] + coefs[1]) + coefs[2]) + coefs[3];
            }
            /**
             * @en
             * Describe a curve in which three times Hermite interpolation is used for each adjacent key frame.
             * @zh
             * 描述一条曲线，其中每个相邻关键帧采用三次hermite插值计算。
             */

            var AnimationCurve = exports('dF', /*#__PURE__*/function () {
              /**
               * @en
               * The key frame of the curve.
               * @zh 
               * 曲线的关键帧。
               */

              /**
               * @en
               * Loop mode [[WrapMode]] when the sampling time exceeds the left end.
               * @zh 
               * 当采样时间超出左端时采用的循环模式[[WrapMode]]。
               */

              /**
               * @en
               * Cycle mode [[WrapMode]] when the sampling time exceeds the right end.
               * @zh 
               * 当采样时间超出右端时采用的循环模式[[WrapMode]]。
               */

              /**
               * 构造函数。
               * @param keyFrames 关键帧。
               */
              function AnimationCurve() {
                var keyFrames = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

                _classCallCheck(this, AnimationCurve);

                this.keyFrames = void 0;
                this.preWrapMode = WrapMode$1.Loop;
                this.postWrapMode = WrapMode$1.Clamp;
                this.cachedKey = void 0;
                this.keyFrames = keyFrames || [].concat(AnimationCurve.defaultKF);
                this.cachedKey = new OptimizedKey();
              }
              /**
               * @en
               * Add a keyframe.
               * @zh 
               * 添加一个关键帧。
               * @param keyFrame 关键帧。
               */


              _createClass(AnimationCurve, [{
                key: "addKey",
                value: function addKey(keyFrame) {
                  if (this.keyFrames == null) {
                    this.keyFrames = [];
                  }

                  this.keyFrames.push(keyFrame);
                }
                /**
                 * @ignore
                 * @param time
                 */

              }, {
                key: "evaluate_slow",
                value: function evaluate_slow(time) {
                  var wrappedTime = time;
                  var wrapMode = time < 0 ? this.preWrapMode : this.postWrapMode;
                  var startTime = this.keyFrames[0].time;
                  var endTime = this.keyFrames[this.keyFrames.length - 1].time;

                  switch (wrapMode) {
                    case WrapMode$1.Loop:
                      wrappedTime = repeat(time - startTime, endTime - startTime) + startTime;
                      break;

                    case WrapMode$1.PingPong:
                      wrappedTime = pingPong(time - startTime, endTime - startTime) + startTime;
                      break;

                    case WrapMode$1.Clamp:
                      wrappedTime = clamp(time, startTime, endTime);
                      break;
                  }

                  var preKFIndex = 0;

                  if (wrappedTime > this.keyFrames[0].time) {
                    if (wrappedTime >= this.keyFrames[this.keyFrames.length - 1].time) {
                      preKFIndex = this.keyFrames.length - 2;
                    } else {
                      for (var i = 0; i < this.keyFrames.length - 1; i++) {
                        if (wrappedTime >= this.keyFrames[0].time && wrappedTime <= this.keyFrames[i + 1].time) {
                          preKFIndex = i;
                          break;
                        }
                      }
                    }
                  }

                  var keyframe0 = this.keyFrames[preKFIndex];
                  var keyframe1 = this.keyFrames[preKFIndex + 1];
                  var t = inverseLerp(keyframe0.time, keyframe1.time, wrappedTime);
                  var dt = keyframe1.time - keyframe0.time;
                  var m0 = keyframe0.outTangent * dt;
                  var m1 = keyframe1.inTangent * dt;
                  var t2 = t * t;
                  var t3 = t2 * t;
                  var a = 2 * t3 - 3 * t2 + 1;
                  var b = t3 - 2 * t2 + t;
                  var c = t3 - t2;
                  var d = -2 * t3 + 3 * t2;
                  return a * keyframe0.value + b * m0 + c * m1 + d * keyframe1.value;
                }
                /**
                 * @en
                 * Calculate the curve interpolation at a given point in time.
                 * @zh 
                 * 计算给定时间点的曲线插值。
                 * @param time 时间。
                 */

              }, {
                key: "evaluate",
                value: function evaluate(time) {
                  var wrappedTime = time;
                  var wrapMode = time < 0 ? this.preWrapMode : this.postWrapMode;
                  var startTime = this.keyFrames[0].time;
                  var endTime = this.keyFrames[this.keyFrames.length - 1].time;

                  switch (wrapMode) {
                    case WrapMode$1.Loop:
                      wrappedTime = repeat(time - startTime, endTime - startTime) + startTime;
                      break;

                    case WrapMode$1.PingPong:
                      wrappedTime = pingPong(time - startTime, endTime - startTime) + startTime;
                      break;

                    case WrapMode$1.Clamp:
                      wrappedTime = clamp(time, startTime, endTime);
                      break;
                  }

                  if (wrappedTime >= this.cachedKey.time && wrappedTime < this.cachedKey.endTime) {
                    return this.cachedKey.evaluate(wrappedTime);
                  } else {
                    var leftIndex = this.findIndex(this.cachedKey, wrappedTime);
                    var rightIndex = leftIndex + 1;

                    if (rightIndex === this.keyFrames.length) {
                      rightIndex -= 1;
                    }

                    this.calcOptimizedKey(this.cachedKey, leftIndex, rightIndex);
                    return this.cachedKey.evaluate(wrappedTime);
                  }
                }
                /**
                 * @ignore
                 * @param optKey
                 * @param leftIndex
                 * @param rightIndex
                 */

              }, {
                key: "calcOptimizedKey",
                value: function calcOptimizedKey(optKey, leftIndex, rightIndex) {
                  var lhs = this.keyFrames[leftIndex];
                  var rhs = this.keyFrames[rightIndex];
                  optKey.index = leftIndex;
                  optKey.time = lhs.time;
                  optKey.endTime = rhs.time;
                  var dx = rhs.time - lhs.time;
                  var dy = rhs.value - lhs.value;
                  var length = 1 / (dx * dx);
                  var d1 = lhs.outTangent * dx;
                  var d2 = rhs.inTangent * dx;
                  optKey.coefficient[0] = (d1 + d2 - dy - dy) * length / dx;
                  optKey.coefficient[1] = (dy + dy + dy - d1 - d1 - d2) * length;
                  optKey.coefficient[2] = lhs.outTangent;
                  optKey.coefficient[3] = lhs.value;
                }
                /**
                 * @ignore
                 * @param optKey
                 * @param t
                 */

              }, {
                key: "findIndex",
                value: function findIndex(optKey, t) {
                  var cachedIndex = optKey.index;

                  if (cachedIndex !== -1) {
                    var cachedTime = this.keyFrames[cachedIndex].time;

                    if (t > cachedTime) {
                      for (var i = 0; i < LOOK_FORWARD; i++) {
                        var currIndex = cachedIndex + i;

                        if (currIndex + 1 < this.keyFrames.length && this.keyFrames[currIndex + 1].time > t) {
                          return currIndex;
                        }
                      }
                    } else {
                      for (var _i = 0; _i < LOOK_FORWARD; _i++) {
                        var _currIndex = cachedIndex - _i;

                        if (_currIndex >= 0 && this.keyFrames[_currIndex - 1].time <= t) {
                          return _currIndex - 1;
                        }
                      }
                    }
                  }

                  var left = 0;
                  var right = this.keyFrames.length;
                  var mid = Math.floor((left + right) / 2);

                  while (right - left > 1) {
                    if (this.keyFrames[mid].time >= t) {
                      right = mid;
                    } else {
                      left = mid + 1;
                    }

                    mid = Math.floor((left + right) / 2);
                  }

                  return left;
                }
              }]);

              return AnimationCurve;
            }());
            AnimationCurve.defaultKF = [{
              time: 0,
              value: 1,
              inTangent: 0,
              outTangent: 0
            }, {
              time: 1,
              value: 1,
              inTangent: 0,
              outTangent: 0
            }];
            CCClass.fastDefine('cc.AnimationCurve', AnimationCurve, {
              preWrapMode: WrapMode$1.Default,
              postWrapMode: WrapMode$1.Default,
              keyFrames: []
            });

            /**
             * @hidden
             */
            replaceProperty(line.prototype, 'line', [{
              name: 'mag',
              newName: 'len'
            }, {
              name: 'magnitude',
              newName: 'len'
            }]);
            removeProperty(intersect, 'intersect', [{
              name: 'line_quad'
            }]);

            /*
             Copyright (c) 2013-2016 Chukong Technologies Inc.
             Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

             http://www.cocos.com

             Permission is hereby granted, free of charge, to any person obtaining a copy
             of this software and associated engine source code (the "Software"), a limited,
             worldwide, royalty-free, non-assignable, revocable and non-exclusive license
             to use Cocos Creator solely to develop games on your target platforms. You shall
             not use Cocos Creator software for developing other software or tools that's
             used for developing games. You are not granted to publish, distribute,
             sublicense, and/or sell copies of Cocos Creator.

             The software or tools in this License Agreement are licensed, not sold.
             Xiamen Yaji Software Co., Ltd. reserves all rights not expressly granted to you.

             THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
             THE SOFTWARE.
            */

            /**
             * @hidden
             */
            var BASELINE_RATIO = exports('aC', 0.26);
            var WORD_REG = /([a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôûа-яА-ЯЁё]+|\S)/;
            var SYMBOL_REG = /^[!,.:;'}\]%\?>、‘“》？。，！]/;
            var LAST_WORD_REG = /([a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôûаíìÍÌïÁÀáàÉÈÒÓòóŐőÙÚŰúűñÑæÆœŒÃÂãÔõěščřžýáíéóúůťďňĚŠČŘŽÁÍÉÓÚŤżźśóńłęćąŻŹŚÓŃŁĘĆĄ-яА-ЯЁё]+|\S)$/;
            var LAST_ENGLISH_REG = /[a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôûаíìÍÌïÁÀáàÉÈÒÓòóŐőÙÚŰúűñÑæÆœŒÃÂãÔõěščřžýáíéóúůťďňĚŠČŘŽÁÍÉÓÚŤżźśóńłęćąŻŹŚÓŃŁĘĆĄ-яА-ЯЁё]+$/;
            var FIRST_ENGLISH_REG = /^[a-zA-Z0-9ÄÖÜäöüßéèçàùêâîôûаíìÍÌïÁÀáàÉÈÒÓòóŐőÙÚŰúűñÑæÆœŒÃÂãÔõěščřžýáíéóúůťďňĚŠČŘŽÁÍÉÓÚŤżźśóńłęćąŻŹŚÓŃŁĘĆĄ-яА-ЯЁё]/;
            function isUnicodeCJK(ch) {
              var __CHINESE_REG = /^[\u4E00-\u9FFF\u3400-\u4DFF]+$/;
              var __JAPANESE_REG = /[\u3000-\u303F]|[\u3040-\u309F]|[\u30A0-\u30FF]|[\uFF00-\uFFEF]|[\u4E00-\u9FAF]|[\u2605-\u2606]|[\u2190-\u2195]|\u203B/g;
              var __KOREAN_REG = /^[\u1100-\u11FF]|[\u3130-\u318F]|[\uA960-\uA97F]|[\uAC00-\uD7AF]|[\uD7B0-\uD7FF]+$/;
              return __CHINESE_REG.test(ch) || __JAPANESE_REG.test(ch) || __KOREAN_REG.test(ch);
            } // Checking whether the character is a whitespace

            function isUnicodeSpace(ch) {
              var chCode = ch.charCodeAt(0);
              return chCode >= 9 && chCode <= 13 || chCode === 32 || chCode === 133 || chCode === 160 || chCode === 5760 || chCode >= 8192 && chCode <= 8202 || chCode === 8232 || chCode === 8233 || chCode === 8239 || chCode === 8287 || chCode === 12288;
            }
            function safeMeasureText(ctx, string) {
              var metric = ctx.measureText(string);
              return metric && metric.width || 0;
            } // in case truncate a character on the Supplementary Multilingual Plane
            // test case: a = '😉🚗'
            // _safeSubstring(a, 1) === '😉🚗'
            // _safeSubstring(a, 0, 1) === '😉'
            // _safeSubstring(a, 0, 2) === '😉'
            // _safeSubstring(a, 0, 3) === '😉'
            // _safeSubstring(a, 0, 4) === '😉🚗'
            // _safeSubstring(a, 1, 2) === _safeSubstring(a, 1, 3) === '😉'
            // _safeSubstring(a, 2, 3) === _safeSubstring(a, 2, 4) === '🚗'

            function _safeSubstring(targetString, startIndex, endIndex) {
              var newStartIndex = startIndex;
              var newEndIndex = endIndex;
              var startChar = targetString[startIndex]; // lowSurrogateRex

              if (startChar >= "\uDC00" && startChar <= "\uDFFF") {
                newStartIndex--;
              }

              if (endIndex !== undefined) {
                if (endIndex - 1 !== startIndex) {
                  var endChar = targetString[endIndex - 1]; // highSurrogateRex

                  if (endChar >= "\uD800" && endChar <= "\uDBFF") {
                    newEndIndex--;
                  }
                } // highSurrogateRex
                else if (startChar >= "\uD800" && startChar <= "\uDBFF") {
                    newEndIndex++;
                  }
              }

              return targetString.substring(newStartIndex, newEndIndex);
            }

            function fragmentText(stringToken, allWidth, maxWidth, measureText) {
              // check the first character
              var wrappedWords = []; // fast return if strArr is empty

              if (stringToken.length === 0 || maxWidth < 0) {
                wrappedWords.push('');
                return wrappedWords;
              }

              var text = stringToken;

              while (allWidth > maxWidth && text.length > 1) {
                var fuzzyLen = text.length * (maxWidth / allWidth) | 0;

                var tmpText = _safeSubstring(text, fuzzyLen);

                var width = allWidth - measureText(tmpText);
                var sLine = tmpText;
                var pushNum = 0;
                var checkWhile = 0;
                var checkCount = 10; // Exceeded the size

                while (width > maxWidth && checkWhile++ < checkCount) {
                  fuzzyLen *= maxWidth / width;
                  fuzzyLen = fuzzyLen | 0;
                  tmpText = _safeSubstring(text, fuzzyLen);
                  width = allWidth - measureText(tmpText);
                }

                checkWhile = 0; // Find the truncation point

                while (width <= maxWidth && checkWhile++ < checkCount) {
                  if (tmpText) {
                    var exec = WORD_REG.exec(tmpText);
                    pushNum = exec ? exec[0].length : 1;
                    sLine = tmpText;
                  }

                  fuzzyLen = fuzzyLen + pushNum;
                  tmpText = _safeSubstring(text, fuzzyLen);
                  width = allWidth - measureText(tmpText);
                }

                fuzzyLen -= pushNum; // in case maxWidth cannot contain any characters, need at least one character per line

                if (fuzzyLen === 0) {
                  fuzzyLen = 1;
                  sLine = _safeSubstring(text, 1);
                } // highSurrogateRex
                else if (fuzzyLen === 1 && text[0] >= "\uD800" && text[0] <= "\uDBFF") {
                    fuzzyLen = 2;
                    sLine = _safeSubstring(text, 2);
                  }

                var sText = _safeSubstring(text, 0, fuzzyLen);

                var result = void 0; // symbol in the first

                {
                  if (SYMBOL_REG.test(sLine || tmpText)) {
                    result = LAST_WORD_REG.exec(sText);
                    fuzzyLen -= result ? result[0].length : 0;

                    if (fuzzyLen === 0) {
                      fuzzyLen = 1;
                    }

                    sLine = _safeSubstring(text, fuzzyLen);
                    sText = _safeSubstring(text, 0, fuzzyLen);
                  }
                } // To judge whether a English words are truncated


                if (FIRST_ENGLISH_REG.test(sLine)) {
                  result = LAST_ENGLISH_REG.exec(sText);

                  if (result && sText !== result[0]) {
                    fuzzyLen -= result[0].length;
                    sLine = _safeSubstring(text, fuzzyLen);
                    sText = _safeSubstring(text, 0, fuzzyLen);
                  }
                } // The first line And do not wrap should not remove the space


                if (wrappedWords.length === 0) {
                  wrappedWords.push(sText);
                } else {
                  sText = sText.trim();

                  if (sText.length > 0) {
                    wrappedWords.push(sText);
                  }
                }

                text = sLine || tmpText;
                allWidth = measureText(text);
              }

              if (wrappedWords.length === 0) {
                wrappedWords.push(text);
              } else {
                text = text.trim();

                if (text.length > 0) {
                  wrappedWords.push(text);
                }
              }

              return wrappedWords;
            }

            var _dec, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _temp;
            var PrefabInfo = exports('aH', (_dec = ccclass('cc.PrefabInfo'), _dec(_class = (_class2 = (_temp = function PrefabInfo() {
              _classCallCheck(this, PrefabInfo);

              _initializerDefineProperty(this, "root", _descriptor, this);

              _initializerDefineProperty(this, "asset", _descriptor2, this);

              _initializerDefineProperty(this, "fileId", _descriptor3, this);

              _initializerDefineProperty(this, "sync", _descriptor4, this);

              _initializerDefineProperty(this, "_synced", _descriptor5, this);
            } // _instantiate (cloned) {
            //     if (!cloned) {
            //         cloned = new cc._PrefabInfo();
            //     }
            //     cloned.root = this.root;
            //     cloned.asset = this.asset;
            //     cloned.fileId = this.fileId;
            //     cloned.sync = this.sync;
            //     cloned._synced = this._synced;
            //     return cloned;
            // }
            , _temp), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "root", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "asset", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "fileId", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return '';
              }
            }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "sync", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return false;
              }
            }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "_synced", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return {
                  "default": false,
                  serializable: false
                };
              }
            })), _class2)) || _class));
            legacyCC._PrefabInfo = PrefabInfo; // update node to make it sync with prefab

            var _typeMap2;

            var _typeMap = (_typeMap2 = {}, _defineProperty(_typeMap2, GFXFormatType.UNORM, 'Uint'), _defineProperty(_typeMap2, GFXFormatType.SNORM, 'Int'), _defineProperty(_typeMap2, GFXFormatType.UINT, 'Uint'), _defineProperty(_typeMap2, GFXFormatType.INT, 'Int'), _defineProperty(_typeMap2, GFXFormatType.UFLOAT, 'Float'), _defineProperty(_typeMap2, GFXFormatType.FLOAT, 'Float'), _defineProperty(_typeMap2, "default", 'Uint'), _typeMap2);

            function _getDataViewType(info) {
              var type = _typeMap[info.type] || _typeMap["default"];
              var bytes = info.size / info.count * 8;
              return type + bytes;
            } // default params bahaves just like on an plain, compact Float32Array


            function writeBuffer(target, data) {
              var format = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : GFXFormat.R32F;
              var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
              var stride = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
              var info = GFXFormatInfos[format];

              if (!stride) {
                stride = info.size;
              }

              var writer = 'set' + _getDataViewType(info);

              var componentBytesLength = info.size / info.count;
              var nSeg = Math.floor(data.length / info.count);
              var isLittleEndian = sys.isLittleEndian;

              for (var iSeg = 0; iSeg < nSeg; ++iSeg) {
                var x = offset + stride * iSeg;

                for (var iComponent = 0; iComponent < info.count; ++iComponent) {
                  var y = x + componentBytesLength * iComponent;
                  target[writer](y, data[info.count * iSeg + iComponent], isLittleEndian);
                }
              }
            }
            function readBuffer(target) {
              var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : GFXFormat.R32F;
              var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
              var length = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : target.byteLength - offset;
              var stride = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
              var out = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];
              var info = GFXFormatInfos[format];

              if (!stride) {
                stride = info.size;
              }

              var reader = 'get' + _getDataViewType(info);

              var componentBytesLength = info.size / info.count;
              var nSeg = Math.floor(length / stride);
              var isLittleEndian = sys.isLittleEndian;

              for (var iSeg = 0; iSeg < nSeg; ++iSeg) {
                var x = offset + stride * iSeg;

                for (var iComponent = 0; iComponent < info.count; ++iComponent) {
                  var y = x + componentBytesLength * iComponent;
                  out[info.count * iSeg + iComponent] = target[reader](y, isLittleEndian);
                }
              }

              return out;
            }
            function mapBuffer(target, callback) {
              var format = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : GFXFormat.R32F;
              var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
              var length = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : target.byteLength - offset;
              var stride = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
              var out = arguments.length > 6 ? arguments[6] : undefined;

              if (!out) {
                out = new DataView(target.buffer.slice(target.byteOffset, target.byteOffset + target.byteLength));
              }

              var info = GFXFormatInfos[format];

              if (!stride) {
                stride = info.size;
              }

              var writer = 'set' + _getDataViewType(info);

              var reader = 'get' + _getDataViewType(info);

              var componentBytesLength = info.size / info.count;
              var nSeg = Math.floor(length / stride);
              var isLittleEndian = sys.isLittleEndian;

              for (var iSeg = 0; iSeg < nSeg; ++iSeg) {
                var x = offset + stride * iSeg;

                for (var iComponent = 0; iComponent < info.count; ++iComponent) {
                  var y = x + componentBytesLength * iComponent;

                  var _cur = target[reader](y, isLittleEndian); // iComponent is usually more useful than y


                  out[writer](y, callback(_cur, iComponent, target), isLittleEndian);
                }
              }

              return out;
            }

            var BufferBlob = /*#__PURE__*/function () {
              function BufferBlob() {
                _classCallCheck(this, BufferBlob);

                this._arrayBufferOrPaddings = [];
                this._length = 0;
              }

              _createClass(BufferBlob, [{
                key: "setNextAlignment",
                value: function setNextAlignment(align) {
                  if (align !== 0) {
                    var remainder = this._length % align;

                    if (remainder !== 0) {
                      var padding = align - remainder;

                      this._arrayBufferOrPaddings.push(padding);

                      this._length += padding;
                    }
                  }
                }
              }, {
                key: "addBuffer",
                value: function addBuffer(arrayBuffer) {
                  var result = this._length;

                  this._arrayBufferOrPaddings.push(arrayBuffer);

                  this._length += arrayBuffer.byteLength;
                  return result;
                }
              }, {
                key: "getLength",
                value: function getLength() {
                  return this._length;
                }
              }, {
                key: "getCombined",
                value: function getCombined() {
                  var result = new Uint8Array(this._length);
                  var counter = 0;

                  this._arrayBufferOrPaddings.forEach(function (arrayBufferOrPadding) {
                    if (typeof arrayBufferOrPadding === 'number') {
                      counter += arrayBufferOrPadding;
                    } else {
                      result.set(new Uint8Array(arrayBufferOrPadding), counter);
                      counter += arrayBufferOrPadding.byteLength;
                    }
                  });

                  return result.buffer;
                }
              }]);

              return BufferBlob;
            }();

            /*
             Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

             http://www.cocos.com

             Permission is hereby granted, free of charge, to any person obtaining a copy
             of this software and associated engine source code (the "Software"), a limited,
              worldwide, royalty-free, non-assignable, revocable and non-exclusive license
             to use Cocos Creator solely to develop games on your target platforms. You shall
              not use Cocos Creator software for developing other software or tools that's
              used for developing games. You are not granted to publish, distribute,
              sublicense, and/or sell copies of Cocos Creator.

             The software or tools in this License Agreement are licensed, not sold.
             Xiamen Yaji Software Co., Ltd. reserves all rights not expressly granted to you.

             THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
             THE SOFTWARE.
            */
            function postLoadMesh(mesh, callback) {
              if (mesh.loaded) {
                if (callback) {
                  callback();
                }

                return;
              }

              if (!mesh.nativeUrl) {
                if (callback) {
                  callback();
                }

                return;
              } // load image


              legacyCC.loader.load({
                url: mesh.nativeUrl
              }, function (err, arrayBuffer) {
                if (arrayBuffer) {
                  if (!mesh.loaded) {
                    mesh._nativeAsset = arrayBuffer;
                  }
                }

                if (callback) {
                  callback(err);
                }
              });
            }

            /**
             * @category asset
             */

            var CUSTOM_PIXEL_FORMAT = 1024;
            /**
             * @en
             * The texture pixel format, default value is RGBA8888,<br>
             * you should note that textures loaded by normal image files (png, jpg) can only support RGBA8888 format,<br>
             * other formats are supported by compressed file types or raw data.
             * @zh
             * 纹理像素格式，默认值为RGBA8888，<br>
             * 你应该注意到普通图像文件（png，jpg）加载的纹理只能支持RGBA8888格式，<br>
             * 压缩文件类型或原始数据支持其他格式。
             */

            var PixelFormat;
            /**
             * @en
             * The texture wrap mode.
             * @zh
             * 纹理环绕方式。
             */

            (function (PixelFormat) {
              PixelFormat[PixelFormat["RGB565"] = GFXFormat.R5G6B5] = "RGB565";
              PixelFormat[PixelFormat["RGB5A1"] = GFXFormat.RGB5A1] = "RGB5A1";
              PixelFormat[PixelFormat["RGBA4444"] = GFXFormat.RGBA4] = "RGBA4444";
              PixelFormat[PixelFormat["RGB888"] = GFXFormat.RGB8] = "RGB888";
              PixelFormat[PixelFormat["RGB32F"] = GFXFormat.RGB32F] = "RGB32F";
              PixelFormat[PixelFormat["RGBA8888"] = GFXFormat.RGBA8] = "RGBA8888";
              PixelFormat[PixelFormat["RGBA32F"] = GFXFormat.RGBA32F] = "RGBA32F";
              PixelFormat[PixelFormat["A8"] = GFXFormat.A8] = "A8";
              PixelFormat[PixelFormat["I8"] = GFXFormat.L8] = "I8";
              PixelFormat[PixelFormat["AI8"] = GFXFormat.LA8] = "AI8";
              PixelFormat[PixelFormat["RGB_PVRTC_2BPPV1"] = GFXFormat.PVRTC_RGB2] = "RGB_PVRTC_2BPPV1";
              PixelFormat[PixelFormat["RGBA_PVRTC_2BPPV1"] = GFXFormat.PVRTC_RGBA2] = "RGBA_PVRTC_2BPPV1";
              PixelFormat[PixelFormat["RGB_A_PVRTC_2BPPV1"] = CUSTOM_PIXEL_FORMAT++] = "RGB_A_PVRTC_2BPPV1";
              PixelFormat[PixelFormat["RGB_PVRTC_4BPPV1"] = GFXFormat.PVRTC_RGB4] = "RGB_PVRTC_4BPPV1";
              PixelFormat[PixelFormat["RGBA_PVRTC_4BPPV1"] = GFXFormat.PVRTC_RGBA4] = "RGBA_PVRTC_4BPPV1";
              PixelFormat[PixelFormat["RGB_A_PVRTC_4BPPV1"] = CUSTOM_PIXEL_FORMAT++] = "RGB_A_PVRTC_4BPPV1";
              PixelFormat[PixelFormat["RGB_ETC1"] = GFXFormat.ETC_RGB8] = "RGB_ETC1";
              PixelFormat[PixelFormat["RGBA_ETC1"] = CUSTOM_PIXEL_FORMAT++] = "RGBA_ETC1";
              PixelFormat[PixelFormat["RGB_ETC2"] = GFXFormat.ETC2_RGB8] = "RGB_ETC2";
              PixelFormat[PixelFormat["RGBA_ETC2"] = GFXFormat.ETC2_RGBA8] = "RGBA_ETC2";
              PixelFormat[PixelFormat["RGBA_ASTC_4x4"] = GFXFormat.ASTC_RGBA_4x4] = "RGBA_ASTC_4x4";
              PixelFormat[PixelFormat["RGBA_ASTC_5x4"] = GFXFormat.ASTC_RGBA_5x4] = "RGBA_ASTC_5x4";
              PixelFormat[PixelFormat["RGBA_ASTC_5x5"] = GFXFormat.ASTC_RGBA_5x5] = "RGBA_ASTC_5x5";
              PixelFormat[PixelFormat["RGBA_ASTC_6x5"] = GFXFormat.ASTC_RGBA_6x5] = "RGBA_ASTC_6x5";
              PixelFormat[PixelFormat["RGBA_ASTC_6x6"] = GFXFormat.ASTC_RGBA_6x6] = "RGBA_ASTC_6x6";
              PixelFormat[PixelFormat["RGBA_ASTC_8x5"] = GFXFormat.ASTC_RGBA_8x5] = "RGBA_ASTC_8x5";
              PixelFormat[PixelFormat["RGBA_ASTC_8x6"] = GFXFormat.ASTC_RGBA_8x6] = "RGBA_ASTC_8x6";
              PixelFormat[PixelFormat["RGBA_ASTC_8x8"] = GFXFormat.ASTC_RGBA_8x8] = "RGBA_ASTC_8x8";
              PixelFormat[PixelFormat["RGBA_ASTC_10x5"] = GFXFormat.ASTC_RGBA_10x5] = "RGBA_ASTC_10x5";
              PixelFormat[PixelFormat["RGBA_ASTC_10x6"] = GFXFormat.ASTC_RGBA_10x6] = "RGBA_ASTC_10x6";
              PixelFormat[PixelFormat["RGBA_ASTC_10x8"] = GFXFormat.ASTC_RGBA_10x8] = "RGBA_ASTC_10x8";
              PixelFormat[PixelFormat["RGBA_ASTC_10x10"] = GFXFormat.ASTC_RGBA_10x10] = "RGBA_ASTC_10x10";
              PixelFormat[PixelFormat["RGBA_ASTC_12x10"] = GFXFormat.ASTC_RGBA_12x10] = "RGBA_ASTC_12x10";
              PixelFormat[PixelFormat["RGBA_ASTC_12x12"] = GFXFormat.ASTC_RGBA_12x12] = "RGBA_ASTC_12x12";
            })(PixelFormat || (PixelFormat = exports('df', {})));

            var WrapMode$2;
            /**
             * @en
             * The texture filter mode
             * @zh
             * 纹理过滤模式。
             */

            (function (WrapMode) {
              WrapMode[WrapMode["REPEAT"] = GFXAddress.WRAP] = "REPEAT";
              WrapMode[WrapMode["CLAMP_TO_EDGE"] = GFXAddress.CLAMP] = "CLAMP_TO_EDGE";
              WrapMode[WrapMode["MIRRORED_REPEAT"] = GFXAddress.MIRROR] = "MIRRORED_REPEAT";
              WrapMode[WrapMode["CLAMP_TO_BORDER"] = GFXAddress.BORDER] = "CLAMP_TO_BORDER";
            })(WrapMode$2 || (WrapMode$2 = exports('dZ', {})));

            var Filter;

            (function (Filter) {
              Filter[Filter["NONE"] = GFXFilter.NONE] = "NONE";
              Filter[Filter["LINEAR"] = GFXFilter.LINEAR] = "LINEAR";
              Filter[Filter["NEAREST"] = GFXFilter.POINT] = "NEAREST";
            })(Filter || (Filter = exports('dQ', {})));

            var _dec$1, _class$1, _class2$1, _class3, _temp$1;


            function isNativeImage(imageSource) {
              {
                return imageSource instanceof HTMLImageElement || imageSource instanceof HTMLCanvasElement;
              }
            }
            /**
             * @en Image Asset.
             * @zh 图像资源。
             */


            var ImageAsset = exports('aX', (_dec$1 = ccclass('cc.ImageAsset'), _dec$1(_class$1 = (_class2$1 = (_temp$1 = _class3 = /*#__PURE__*/function (_Asset) {
              _inherits(ImageAsset, _Asset);

              _createClass(ImageAsset, [{
                key: "_nativeAsset",
                get: function get() {
                  // Maybe returned to pool in webgl.
                  return this._nativeData;
                },
                set: function set(value) {
                  if (!(value instanceof HTMLElement)) {
                    value.format = value.format || this._format;
                  }

                  this.reset(value);
                }
                /**
                 * @en Image data.
                 * @zh 此图像资源的图像数据。
                 */

              }, {
                key: "data",
                get: function get() {
                  if (isNativeImage(this._nativeData)) {
                    return this._nativeData;
                  } else {
                    return this._nativeData._data;
                  }
                }
                /**
                 * @en The pixel width of the image.
                 * @zh 此图像资源的像素宽度。
                 */

              }, {
                key: "width",
                get: function get() {
                  return this._nativeData.width || this._width;
                }
                /**
                 * @en The pixel height of the image.
                 * @zh 此图像资源的像素高度。
                 */

              }, {
                key: "height",
                get: function get() {
                  return this._nativeData.height || this._height;
                }
                /**
                 * @en The pixel format of the image.
                 * @zh 此图像资源的像素格式。
                 */

              }, {
                key: "format",
                get: function get() {
                  return this._format;
                }
                /**
                 * @en Whether the image is in compressed texture format.
                 * @zh 此图像资源是否为压缩像素格式。
                 */

              }, {
                key: "isCompressed",
                get: function get() {
                  return this._format >= PixelFormat.RGB_ETC1 && this._format <= PixelFormat.RGBA_ASTC_12x12 || this._format >= PixelFormat.RGB_A_PVRTC_2BPPV1 && this._format <= PixelFormat.RGBA_ETC1;
                }
                /**
                 * @en The original source image URL, it could be empty.
                 * @zh 此图像资源的原始图像源的 URL。当原始图像元不是 HTML 文件时可能为空。
                 * @deprecated Please use [[nativeUrl]]
                 */

              }, {
                key: "url",
                get: function get() {
                  return this._url;
                }
                /**
                 * @private
                 */

              }, {
                key: "_texture",
                set: function set(tex) {
                  this._tex = tex;
                },
                get: function get() {
                  if (!this._tex) {
                    var tex = new legacyCC.Texture2D();
                    tex.name = this._url;
                    tex.image = this;
                    this._tex = tex;
                  }

                  return this._tex;
                }
              }]);

              function ImageAsset(nativeAsset) {
                var _this;

                _classCallCheck(this, ImageAsset);

                _this = _possibleConstructorReturn(this, _getPrototypeOf(ImageAsset).call(this));
                _this._nativeData = void 0;
                _this._tex = void 0;
                _this._url = void 0;
                _this._exportedExts = undefined;
                _this._format = PixelFormat.RGBA8888;
                _this._width = 0;
                _this._height = 0;
                _this._url = '';
                _this.loaded = false;
                _this._nativeData = {
                  _data: null,
                  width: 0,
                  height: 0,
                  format: 0,
                  _compressed: false
                };

                if (nativeAsset !== undefined) {
                  _this.reset(nativeAsset);
                }

                return _this;
              }
              /**
               * @en Reset the source of the image asset.
               * @zh 重置此图像资源使用的原始图像源。
               * @param data The new source
               */


              _createClass(ImageAsset, [{
                key: "reset",
                value: function reset(data) {
                  var _this2 = this;

                  if (!(data instanceof HTMLElement)) {
                    // this._nativeData = Object.create(data);
                    this._nativeData = data;
                    this._format = data.format;

                    this._onDataComplete();
                  } else {
                    this._nativeData = data;

                    if ( data.complete || data instanceof HTMLCanvasElement) {
                      // todo need adatper
                      this._onDataComplete();
                    } else {
                      this.loaded = false;
                      data.addEventListener('load', function () {
                        _this2._onDataComplete();
                      });
                      data.addEventListener('error', function (err) {
                        warnID(3119, err.message);
                      });
                    }
                  }
                }
              }, {
                key: "destroy",
                value: function destroy() {
                  if (this.data && this.data instanceof HTMLImageElement) {
                    this.data.src = "";

                    this._setRawAsset("");

                    legacyCC.loader.removeItem(this.data.id);
                  }

                  return _get(_getPrototypeOf(ImageAsset.prototype), "destroy", this).call(this);
                } // SERIALIZATION

              }, {
                key: "_serialize",
                value: function _serialize() {
                  var targetExtensions = this._exportedExts;

                  if (!targetExtensions && this._native) {
                    targetExtensions = [this._native];
                  }

                  if (!targetExtensions) {
                    return '';
                  }

                  var extensionIndices = [];

                  for (var _iterator = _createForOfIteratorHelperLoose(targetExtensions), _step; !(_step = _iterator()).done;) {
                    var targetExtension = _step.value;
                    var extensionFormat = targetExtension.split('@');
                    var i = ImageAsset.extnames.indexOf(extensionFormat[0]);
                    var exportedExtensionID = i < 0 ? targetExtension : "".concat(i);

                    if (extensionFormat[1]) {
                      exportedExtensionID += '@' + extensionFormat[1];
                    }

                    extensionIndices.push(exportedExtensionID);
                  }

                  return {
                    fmt: extensionIndices.join('_'),
                    w: this.width,
                    h: this.height
                  };
                }
              }, {
                key: "_deserialize",
                value: function _deserialize(data, handle) {
                  var fmtStr = '';

                  if (typeof data === 'string') {
                    fmtStr = data;
                  } else {
                    this._width = data.w;
                    this._height = data.h;
                    fmtStr = data.fmt;
                  }

                  var device = _getGlobalDevice();

                  var extensionIDs = fmtStr.split('_');
                  var preferedExtensionIndex = Number.MAX_VALUE;
                  var format = this._format;
                  var ext = '';
                  var SupportTextureFormats = legacyCC.macro.SUPPORT_TEXTURE_FORMATS;

                  for (var _iterator2 = _createForOfIteratorHelperLoose(extensionIDs), _step2; !(_step2 = _iterator2()).done;) {
                    var extensionID = _step2.value;
                    var extFormat = extensionID.split('@');
                    var i = parseInt(extFormat[0], undefined);
                    var tmpExt = ImageAsset.extnames[i] || extFormat.join();
                    var index = SupportTextureFormats.indexOf(tmpExt);

                    if (index !== -1 && index < preferedExtensionIndex) {
                      var fmt = extFormat[1] ? parseInt(extFormat[1]) : this._format; // check whether or not support compressed texture

                      if (tmpExt === '.astc' && (!device || !device.hasFeature(GFXFeature.FORMAT_ASTC))) {
                        continue;
                      } else if (tmpExt === '.pvr' && (!device || !device.hasFeature(GFXFeature.FORMAT_PVRTC))) {
                        continue;
                      } else if ((fmt === PixelFormat.RGB_ETC1 || fmt === PixelFormat.RGBA_ETC1) && (!device || !device.hasFeature(GFXFeature.FORMAT_ETC1))) {
                        continue;
                      } else if ((fmt === PixelFormat.RGB_ETC2 || fmt === PixelFormat.RGBA_ETC2) && (!device || !device.hasFeature(GFXFeature.FORMAT_ETC2))) {
                        continue;
                      } else if (tmpExt === '.webp' && !legacyCC.sys.capabilities.webp) {
                        continue;
                      }

                      preferedExtensionIndex = index;
                      ext = tmpExt;
                      format = fmt;
                    }
                  }

                  if (ext) {
                    this._setRawAsset(ext);

                    this._format = format;
                  } // preset uuid to get correct nativeUrl


                  var loadingItem = handle.customEnv;
                  var uuid = loadingItem && loadingItem.uuid;

                  if (uuid) {
                    this._uuid = uuid;
                    this._url = this.nativeUrl;
                  }
                }
              }, {
                key: "_onDataComplete",
                value: function _onDataComplete() {
                  this.loaded = true;
                  this.emit('load');
                }
              }]);

              return ImageAsset;
            }(Asset), _class3.extnames = ['.png', '.jpg', '.jpeg', '.bmp', '.webp', '.pvr', '.pkm', '.astc'], _temp$1), (_applyDecoratedDescriptor(_class2$1.prototype, "_nativeAsset", [override], Object.getOwnPropertyDescriptor(_class2$1.prototype, "_nativeAsset"), _class2$1.prototype)), _class2$1)) || _class$1));

            function _getGlobalDevice() {
              if (legacyCC.director.root) {
                return legacyCC.director.root.device;
              } else {
                return null;
              }
            }
            /**
             * @zh
             * 当该资源加载成功后触发该事件。
             * @en
             * This event is emitted when the asset is loaded
             *
             * @event load
             */


            legacyCC.ImageAsset = ImageAsset;

            var SamplerInfoIndex;

            (function (SamplerInfoIndex) {
              SamplerInfoIndex[SamplerInfoIndex["minFilter"] = 0] = "minFilter";
              SamplerInfoIndex[SamplerInfoIndex["magFilter"] = 1] = "magFilter";
              SamplerInfoIndex[SamplerInfoIndex["mipFilter"] = 2] = "mipFilter";
              SamplerInfoIndex[SamplerInfoIndex["addressU"] = 3] = "addressU";
              SamplerInfoIndex[SamplerInfoIndex["addressV"] = 4] = "addressV";
              SamplerInfoIndex[SamplerInfoIndex["addressW"] = 5] = "addressW";
              SamplerInfoIndex[SamplerInfoIndex["maxAnisotropy"] = 6] = "maxAnisotropy";
              SamplerInfoIndex[SamplerInfoIndex["cmpFunc"] = 7] = "cmpFunc";
              SamplerInfoIndex[SamplerInfoIndex["minLOD"] = 8] = "minLOD";
              SamplerInfoIndex[SamplerInfoIndex["maxLOD"] = 9] = "maxLOD";
              SamplerInfoIndex[SamplerInfoIndex["mipLODBias"] = 10] = "mipLODBias";
              SamplerInfoIndex[SamplerInfoIndex["total"] = 11] = "total";
            })(SamplerInfoIndex || (SamplerInfoIndex = exports('ak', {})));

            var defaultInfo = [GFXFilter.LINEAR, GFXFilter.LINEAR, GFXFilter.NONE, GFXAddress.WRAP, GFXAddress.WRAP, GFXAddress.WRAP, 8, GFXComparisonFunc.NEVER, 0, 0, 0];
            var defaultSamplerHash = exports('al', genSamplerHash(defaultInfo));
            var borderColor = {
              r: 0,
              g: 0,
              b: 0,
              a: 0
            };
            var gfxInfo = {};
            function genSamplerHash(info) {
              var value = 0;
              var hash = 0;

              for (var i = 0; i < defaultInfo.length; i++) {
                value = info[i] || defaultInfo[i];

                switch (i) {
                  case SamplerInfoIndex.minFilter:
                    hash |= value;
                    break;

                  case SamplerInfoIndex.magFilter:
                    hash |= value << 2;
                    break;

                  case SamplerInfoIndex.mipFilter:
                    hash |= value << 4;
                    break;

                  case SamplerInfoIndex.addressU:
                    hash |= value << 6;
                    break;

                  case SamplerInfoIndex.addressV:
                    hash |= value << 8;
                    break;

                  case SamplerInfoIndex.addressW:
                    hash |= value << 10;
                    break;

                  case SamplerInfoIndex.maxAnisotropy:
                    hash |= value << 12;
                    break;

                  case SamplerInfoIndex.cmpFunc:
                    hash |= value << 16;
                    break;

                  case SamplerInfoIndex.minLOD:
                    hash |= value << 20;
                    break;

                  case SamplerInfoIndex.maxLOD:
                    hash |= value << 24;
                    break;

                  case SamplerInfoIndex.mipLODBias:
                    hash |= value << 28;
                    break;
                }
              }

              return hash;
            }
            /**
             * @zh
             * 维护 sampler 资源实例的全局管理器。
             */

            var SamplerLib = /*#__PURE__*/function () {
              function SamplerLib() {
                _classCallCheck(this, SamplerLib);

                this._cache = {};
              }

              _createClass(SamplerLib, [{
                key: "getSampler",

                /**
                 * @zh
                 * 获取指定属性的 sampler 资源。
                 * @param device 渲染设备 [GFXDevice]
                 * @param info 目标 sampler 属性
                 */
                value: function getSampler(device, hash) {
                  if (!hash) {
                    hash = defaultSamplerHash;
                  }

                  var cache = this._cache[hash];

                  if (cache) {
                    return cache;
                  }

                  gfxInfo.minFilter = hash & 3;
                  gfxInfo.magFilter = hash >> 2 & 3;
                  gfxInfo.mipFilter = hash >> 4 & 3;
                  gfxInfo.addressU = hash >> 6 & 3;
                  gfxInfo.addressV = hash >> 8 & 3;
                  gfxInfo.addressW = hash >> 10 & 3;
                  gfxInfo.maxAnisotropy = hash >> 12 & 15;
                  gfxInfo.cmpFunc = hash >> 16 & 15;
                  gfxInfo.minLOD = hash >> 20 & 15;
                  gfxInfo.maxLOD = hash >> 24 & 15;
                  gfxInfo.mipLODBias = hash >> 28 & 15;
                  gfxInfo.borderColor = borderColor;
                  var sampler = this._cache[hash] = device.createSampler(gfxInfo);
                  return sampler;
                }
              }]);

              return SamplerLib;
            }();

            var samplerLib = exports('an', new SamplerLib());
            legacyCC.samplerLib = samplerLib;

            var _dec$2, _class$2, _class2$2, _descriptor$1, _descriptor2$1, _descriptor3$1, _descriptor4$1, _descriptor5$1, _descriptor6, _descriptor7, _descriptor8, _class3$1, _temp$2;
            var idGenerator = new IDGenerator('Tex');
            /**
             * @en The base texture class, it defines features shared by all textures.
             * @zh 贴图资源基类。它定义了所有贴图共用的概念。
             */

            var TextureBase = exports('de', (_dec$2 = ccclass('cc.TextureBase'), _dec$2(_class$2 = (_class2$2 = (_temp$2 = _class3$1 = /*#__PURE__*/function (_Asset) {
              _inherits(TextureBase, _Asset);

              _createClass(TextureBase, [{
                key: "isCompressed",

                /**
                 * @en Whether the pixel data is compressed.
                 * @zh 此贴图是否为压缩的像素格式。
                 */
                get: function get() {
                  return this._format >= PixelFormat.RGB_ETC1 && this._format <= PixelFormat.RGBA_PVRTC_4BPPV1;
                }
                /**
                 * @en Pixel width of the texture
                 * @zh 此贴图的像素宽度。
                 */

              }, {
                key: "width",
                get: function get() {
                  return this._width;
                }
                /**
                 * @en Pixel height of the texture
                 * @zh 此贴图的像素高度。
                 */

              }, {
                key: "height",
                get: function get() {
                  return this._height;
                }
                /**
                 * @en The pixel format enum.
                 * @zh 像素格式枚举类型
                 */

              }]);

              function TextureBase() {
                var _this;

                _classCallCheck(this, TextureBase);

                _this = _possibleConstructorReturn(this, _getPrototypeOf(TextureBase).call(this)); // Id for generate hash in material

                _initializerDefineProperty(_this, "_format", _descriptor$1, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_minFilter", _descriptor2$1, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_magFilter", _descriptor3$1, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_mipFilter", _descriptor4$1, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_wrapS", _descriptor5$1, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_wrapT", _descriptor6, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_wrapR", _descriptor7, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_anisotropy", _descriptor8, _assertThisInitialized(_this));

                _this._width = 1;
                _this._height = 1;
                _this._id = void 0;
                _this._samplerInfo = [];
                _this._samplerHash = 0;
                _this._gfxSampler = null;
                _this._gfxDevice = null;
                _this._id = idGenerator.getNewId();
                _this.loaded = false;
                _this._gfxDevice = _this._getGFXDevice();
                return _this;
              }
              /**
               * @en Gets the id of the texture
               * @zh 获取标识符。
               * @returns The id
               */


              _createClass(TextureBase, [{
                key: "getId",
                value: function getId() {
                  return this._id;
                }
                /**
                 * @en Gets the pixel format
                 * @zh 获取像素格式。
                 * @returns The pixel format
                 */

              }, {
                key: "getPixelFormat",
                value: function getPixelFormat() {
                  return this._format;
                }
                /**
                 * @en Gets the anisotropy
                 * @zh 获取各向异性。
                 * @returns The anisotropy
                 */

              }, {
                key: "getAnisotropy",
                value: function getAnisotropy() {
                  return this._anisotropy;
                }
                /**
                 * @en Sets the wrap mode of the texture.
                 * Be noted, if the size of the texture is not power of two, only [[WrapMode.CLAMP_TO_EDGE]] is allowed.
                 * @zh 设置此贴图的缠绕模式。
                 * 注意，若贴图尺寸不是 2 的整数幂，缠绕模式仅允许 [[WrapMode.CLAMP_TO_EDGE]]。
                 * @param wrapS S(U) coordinate wrap mode
                 * @param wrapT T(V) coordinate wrap mode
                 * @param wrapR R(W) coordinate wrap mode
                 */

              }, {
                key: "setWrapMode",
                value: function setWrapMode(wrapS, wrapT, wrapR) {
                  this._wrapS = wrapS;
                  this._samplerInfo[SamplerInfoIndex.addressU] = wrapS;
                  this._wrapT = wrapT;
                  this._samplerInfo[SamplerInfoIndex.addressV] = wrapT;

                  if (wrapR !== undefined) {
                    this._wrapR = wrapR;
                    this._samplerInfo[SamplerInfoIndex.addressW] = wrapR;
                  }

                  this._samplerHash = genSamplerHash(this._samplerInfo); // for editor assetDB

                  if (this._gfxDevice) {
                    this._gfxSampler = samplerLib.getSampler(this._gfxDevice, this._samplerHash);
                  }
                }
                /**
                 * @en Sets the texture's filter mode
                 * @zh 设置此贴图的过滤算法。
                 * @param minFilter Filter mode for scale down
                 * @param magFilter Filter mode for scale up
                 */

              }, {
                key: "setFilters",
                value: function setFilters(minFilter, magFilter) {
                  this._minFilter = minFilter;
                  this._samplerInfo[SamplerInfoIndex.minFilter] = minFilter;
                  this._magFilter = magFilter;
                  this._samplerInfo[SamplerInfoIndex.magFilter] = magFilter;
                  this._samplerHash = genSamplerHash(this._samplerInfo);

                  if (this._gfxDevice) {
                    this._gfxSampler = samplerLib.getSampler(this._gfxDevice, this._samplerHash);
                  }
                }
                /**
                 * @en Sets the texture's mip filter
                 * @zh 设置此贴图的缩小过滤算法。
                 * @param mipFilter Filter mode for scale down
                 */

              }, {
                key: "setMipFilter",
                value: function setMipFilter(mipFilter) {
                  this._mipFilter = mipFilter;
                  this._samplerInfo[SamplerInfoIndex.mipFilter] = mipFilter;
                  this._samplerInfo[SamplerInfoIndex.maxLOD] = mipFilter === Filter.NONE ? 0 : 15; // WebGL2 on some platform need this

                  this._samplerHash = genSamplerHash(this._samplerInfo);

                  if (this._gfxDevice) {
                    this._gfxSampler = samplerLib.getSampler(this._gfxDevice, this._samplerHash);
                  }
                }
                /**
                 * @en Sets the texture's anisotropy
                 * @zh 设置此贴图的各向异性。
                 * @param anisotropy
                 */

              }, {
                key: "setAnisotropy",
                value: function setAnisotropy(anisotropy) {
                  this._anisotropy = anisotropy;
                  this._samplerInfo[SamplerInfoIndex.maxAnisotropy] = anisotropy;
                  this._samplerHash = genSamplerHash(this._samplerInfo);

                  if (this._gfxDevice) {
                    this._gfxSampler = samplerLib.getSampler(this._gfxDevice, this._samplerHash);
                  }
                }
                /**
                 * @en Destroy the current texture, clear up the related GPU resources.
                 * @zh 销毁此贴图，并释放占用的 GPU 资源。
                 */

              }, {
                key: "destroy",
                value: function destroy() {
                  return _get(_getPrototypeOf(TextureBase.prototype), "destroy", this).call(this);
                }
                /**
                 * @en Gets the GFXTexture resource
                 * @zh 获取此贴图底层的 GFX 贴图对象。
                 */

              }, {
                key: "getGFXTexture",
                value: function getGFXTexture() {
                  return null;
                }
                /**
                 * @en Gets the internal GFX sampler hash.
                 * @zh 获取此贴图内部使用的 GFX 采样器信息。
                 * @private
                 */

              }, {
                key: "getSamplerHash",
                value: function getSamplerHash() {
                  return this._samplerHash;
                }
                /**
                 * @en Gets the sampler resource for the texture
                 * @zh 获取此贴图底层的 GFX 采样信息。
                 */

              }, {
                key: "getGFXSampler",
                value: function getGFXSampler() {
                  if (!this._gfxSampler) {
                    if (this._gfxDevice) {
                      this._gfxSampler = samplerLib.getSampler(this._gfxDevice, this._samplerHash);
                    } else {
                      errorID(9302);
                    }
                  }

                  return this._gfxSampler;
                } // SERIALIZATION

                /**
                 * @return
                 */

              }, {
                key: "_serialize",
                value: function _serialize(exporting) {
                  return this._minFilter + ',' + this._magFilter + ',' + this._wrapS + ',' + this._wrapT + ',' + this._mipFilter + ',' + this._anisotropy;
                }
                /**
                 *
                 * @param data
                 */

              }, {
                key: "_deserialize",
                value: function _deserialize(serializedData, handle) {
                  var data = serializedData;
                  var fields = data.split(',');
                  fields.unshift('');

                  if (fields.length >= 5) {
                    // decode filters
                    this.setFilters(parseInt(fields[1]), parseInt(fields[2])); // decode wraps

                    this.setWrapMode(parseInt(fields[3]), parseInt(fields[4]));
                  }

                  if (fields.length >= 7) {
                    this.setMipFilter(parseInt(fields[5]));
                    this.setAnisotropy(parseInt(fields[6]));
                  }
                }
              }, {
                key: "_getGFXDevice",
                value: function _getGFXDevice() {
                  return legacyCC.director.root && legacyCC.director.root.device;
                }
              }, {
                key: "_getGFXFormat",
                value: function _getGFXFormat() {
                  return this._getGFXPixelFormat(this._format);
                }
              }, {
                key: "_setGFXFormat",
                value: function _setGFXFormat(format) {
                  this._format = format === undefined ? PixelFormat.RGBA8888 : format;
                }
              }, {
                key: "_getGFXPixelFormat",
                value: function _getGFXPixelFormat(format) {
                  if (format === PixelFormat.RGBA_ETC1) {
                    format = PixelFormat.RGB_ETC1;
                  } else if (format === PixelFormat.RGB_A_PVRTC_4BPPV1) {
                    format = PixelFormat.RGB_PVRTC_4BPPV1;
                  } else if (format === PixelFormat.RGB_A_PVRTC_2BPPV1) {
                    format = PixelFormat.RGB_PVRTC_2BPPV1;
                  }

                  return format;
                }
              }]);

              return TextureBase;
            }(Asset), _class3$1.PixelFormat = PixelFormat, _class3$1.WrapMode = WrapMode$2, _class3$1.Filter = Filter, _temp$2), (_descriptor$1 = _applyDecoratedDescriptor(_class2$2.prototype, "_format", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return PixelFormat.RGBA8888;
              }
            }), _descriptor2$1 = _applyDecoratedDescriptor(_class2$2.prototype, "_minFilter", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return Filter.LINEAR;
              }
            }), _descriptor3$1 = _applyDecoratedDescriptor(_class2$2.prototype, "_magFilter", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return Filter.LINEAR;
              }
            }), _descriptor4$1 = _applyDecoratedDescriptor(_class2$2.prototype, "_mipFilter", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return Filter.NONE;
              }
            }), _descriptor5$1 = _applyDecoratedDescriptor(_class2$2.prototype, "_wrapS", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return WrapMode$2.REPEAT;
              }
            }), _descriptor6 = _applyDecoratedDescriptor(_class2$2.prototype, "_wrapT", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return WrapMode$2.REPEAT;
              }
            }), _descriptor7 = _applyDecoratedDescriptor(_class2$2.prototype, "_wrapR", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return WrapMode$2.REPEAT;
              }
            }), _descriptor8 = _applyDecoratedDescriptor(_class2$2.prototype, "_anisotropy", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 8;
              }
            })), _class2$2)) || _class$2));
            legacyCC.TextureBase = TextureBase;

            /*
             Copyright (c) 2008-2010 Ricardo Quesada
             Copyright (c) 2011-2012 cocos2d-x.org
             Copyright (c) 2013-2016 Chukong Technologies Inc.
             Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

             http://www.cocos2d-x.org

             Permission is hereby granted, free of charge, to any person obtaining a copy
             of this software and associated documentation files (the "Software"), to deal
             in the Software without restriction, including without limitation the rights
             to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
             copies of the Software, and to permit persons to whom the Software is
             furnished to do so, subject to the following conditions:

             The above copyright notice and this permission notice shall be included in
             all copies or substantial portions of the Software.

             THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
             THE SOFTWARE.
            */
            var SUPPORT_TEXTURE_FORMATS = ['.astc', '.pkm', '.pvr', '.webp', '.jpg', '.jpeg', '.bmp', '.png'];
            var KEY = {
              /**
               * @en None
               * @zh 没有分配
               * @readonly
               */
              'none': 0,
              // android

              /**
               * @en The back key
               * @zh 返回键
               * @readonly
               */
              'back': 6,

              /**
               * @en The menu key
               * @zh 菜单键
               * @readonly
               */
              'menu': 18,

              /**
               * @en The backspace key
               * @zh 退格键
               * @readonly
               */
              'backspace': 8,

              /**
               * @en The tab key
               * @zh Tab 键
               * @readonly
               */
              'tab': 9,

              /**
               * @en The enter key
               * @zh 回车键
               * @readonly
               */
              'enter': 13,

              /**
               * @en The shift key
               * @zh Shift 键
               * @readonly
               */
              'shift': 16,
              // should use shiftkey instead

              /**
               * @en The ctrl key
               * @zh Ctrl 键
               * @readonly
               */
              'ctrl': 17,
              // should use ctrlkey

              /**
               * @en The alt key
               * @zh Alt 键
               * @readonly
               */
              'alt': 18,
              // should use altkey

              /**
               * @en The pause key
               * @zh 暂停键
               * @readonly
               */
              'pause': 19,

              /**
               * @en The caps lock key
               * @zh 大写锁定键
               * @readonly
               */
              'capslock': 20,

              /**
               * @en The esc key
               * @zh ESC 键
               * @readonly
               */
              'escape': 27,

              /**
               * @en The space key
               * @zh 空格键
               * @readonly
               */
              'space': 32,

              /**
               * @en The page up key
               * @zh 向上翻页键
               * @readonly
               */
              'pageup': 33,

              /**
               * @en The page down key
               * @zh 向下翻页键
               * @readonly
               */
              'pagedown': 34,

              /**
               * @en The end key
               * @zh 结束键
               * @readonly
               */
              'end': 35,

              /**
               * @en The home key
               * @zh 主菜单键
               * @readonly
               */
              'home': 36,

              /**
               * @en The left key
               * @zh 向左箭头键
               * @readonly
               */
              'left': 37,

              /**
               * @en The up key
               * @zh 向上箭头键
               * @readonly
               */
              'up': 38,

              /**
               * @en The right key
               * @zh 向右箭头键
               * @readonly
               */
              'right': 39,

              /**
               * @en The down key
               * @zh 向下箭头键
               * @readonly
               */
              'down': 40,

              /**
               * @en The select key
               * @zh Select 键
               * @readonly
               */
              'select': 41,

              /**
               * @en The insert key
               * @zh 插入键
               * @readonly
               */
              'insert': 45,

              /**
               * @en The Delete key
               * @zh 删除键
               * @readonly
               */
              'Delete': 46,

              /**
               * @en The '0' key on the top of the alphanumeric keyboard.
               * @zh 字母键盘上的 0 键
               * @readonly
               */
              '0': 48,

              /**
               * @en The '1' key on the top of the alphanumeric keyboard.
               * @zh 字母键盘上的 1 键
               * @readonly
               */
              '1': 49,

              /**
               * @en The '2' key on the top of the alphanumeric keyboard.
               * @zh 字母键盘上的 2 键
               * @readonly
               */
              '2': 50,

              /**
               * @en The '3' key on the top of the alphanumeric keyboard.
               * @zh 字母键盘上的 3 键
               * @readonly
               */
              '3': 51,

              /**
               * @en The '4' key on the top of the alphanumeric keyboard.
               * @zh 字母键盘上的 4 键
               * @readonly
               */
              '4': 52,

              /**
               * @en The '5' key on the top of the alphanumeric keyboard.
               * @zh 字母键盘上的 5 键
               * @readonly
               */
              '5': 53,

              /**
               * @en The '6' key on the top of the alphanumeric keyboard.
               * @zh 字母键盘上的 6 键
               * @readonly
               */
              '6': 54,

              /**
               * @en The '7' key on the top of the alphanumeric keyboard.
               * @zh 字母键盘上的 7 键
               * @readonly
               */
              '7': 55,

              /**
               * @en The '8' key on the top of the alphanumeric keyboard.
               * @zh 字母键盘上的 8 键
               * @readonly
               */
              '8': 56,

              /**
               * @en The '9' key on the top of the alphanumeric keyboard.
               * @zh 字母键盘上的 9 键
               * @readonly
               */
              '9': 57,

              /**
               * @en The a key
               * @zh A 键
               * @readonly
               */
              'a': 65,

              /**
               * @en The b key
               * @zh B 键
               * @readonly
               */
              'b': 66,

              /**
               * @en The c key
               * @zh C 键
               * @readonly
               */
              'c': 67,

              /**
               * @en The d key
               * @zh D 键
               * @readonly
               */
              'd': 68,

              /**
               * @en The e key
               * @zh E 键
               * @readonly
               */
              'e': 69,

              /**
               * @en The f key
               * @zh F 键
               * @readonly
               */
              'f': 70,

              /**
               * @en The g key
               * @zh G 键
               * @readonly
               */
              'g': 71,

              /**
               * @en The h key
               * @zh H 键
               * @readonly
               */
              'h': 72,

              /**
               * @en The i key
               * @zh I 键
               * @readonly
               */
              'i': 73,

              /**
               * @en The j key
               * @zh J 键
               * @readonly
               */
              'j': 74,

              /**
               * @en The k key
               * @zh K 键
               * @readonly
               */
              'k': 75,

              /**
               * @en The l key
               * @zh L 键
               * @readonly
               */
              'l': 76,

              /**
               * @en The m key
               * @zh M 键
               * @readonly
               */
              'm': 77,

              /**
               * @en The n key
               * @zh N 键
               * @readonly
               */
              'n': 78,

              /**
               * @en The o key
               * @zh O 键
               * @readonly
               */
              'o': 79,

              /**
               * @en The p key
               * @zh P 键
               * @readonly
               */
              'p': 80,

              /**
               * @en The q key
               * @zh Q 键
               * @readonly
               */
              'q': 81,

              /**
               * @en The r key
               * @zh R 键
               * @readonly
               */
              'r': 82,

              /**
               * @en The s key
               * @zh S 键
               * @readonly
               */
              's': 83,

              /**
               * @en The t key
               * @zh T 键
               * @readonly
               */
              't': 84,

              /**
               * @en The u key
               * @zh U 键
               * @readonly
               */
              'u': 85,

              /**
               * @en The v key
               * @zh V 键
               * @readonly
               */
              'v': 86,

              /**
               * @en The w key
               * @zh W 键
               * @readonly
               */
              'w': 87,

              /**
               * @en The x key
               * @zh X 键
               * @readonly
               */
              'x': 88,

              /**
               * @en The y key
               * @zh Y 键
               * @readonly
               */
              'y': 89,

              /**
               * @en The z key
               * @zh Z 键
               * @readonly
               */
              'z': 90,

              /**
               * @en The numeric keypad 0
               * @zh 数字键盘 0
               * @readonly
               */
              'num0': 96,

              /**
               * @en The numeric keypad 1
               * @zh 数字键盘 1
               * @readonly
               */
              'num1': 97,

              /**
               * @en The numeric keypad 2
               * @zh 数字键盘 2
               * @readonly
               */
              'num2': 98,

              /**
               * @en The numeric keypad 3
               * @zh 数字键盘 3
               * @readonly
               */
              'num3': 99,

              /**
               * @en The numeric keypad 4
               * @zh 数字键盘 4
               * @readonly
               */
              'num4': 100,

              /**
               * @en The numeric keypad 5
               * @zh 数字键盘 5
               * @readonly
               */
              'num5': 101,

              /**
               * @en The numeric keypad 6
               * @zh 数字键盘 6
               * @readonly
               */
              'num6': 102,

              /**
               * @en The numeric keypad 7
               * @zh 数字键盘 7
               * @readonly
               */
              'num7': 103,

              /**
               * @en The numeric keypad 8
               * @zh 数字键盘 8
               * @readonly
               */
              'num8': 104,

              /**
               * @en The numeric keypad 9
               * @zh 数字键盘 9
               * @readonly
               */
              'num9': 105,

              /**
               * @en The numeric keypad '*'
               * @zh 数字键盘 *
               * @readonly
               */
              '*': 106,

              /**
               * @en The numeric keypad '+'
               * @zh 数字键盘 +
               * @readonly
               */
              '+': 107,

              /**
               * @en The numeric keypad '-'
               * @zh 数字键盘 -
               * @readonly
               */
              '-': 109,

              /**
               * @en The numeric keypad 'delete'
               * @zh 数字键盘删除键
               * @readonly
               */
              'numdel': 110,

              /**
               * @en The numeric keypad '/'
               * @zh 数字键盘 /
               * @readonly
               */
              '/': 111,

              /**
               * @en The F1 function key
               * @zh F1 功能键
               * @readonly
               */
              'f1': 112,
              // f1-f12 dont work on ie

              /**
               * @en The F2 function key
               * @zh F2 功能键
               * @readonly
               */
              'f2': 113,

              /**
               * @en The F3 function key
               * @zh F3 功能键
               * @readonly
               */
              'f3': 114,

              /**
               * @en The F4 function key
               * @zh F4 功能键
               * @readonly
               */
              'f4': 115,

              /**
               * @en The F5 function key
               * @zh F5 功能键
               * @readonly
               */
              'f5': 116,

              /**
               * @en The F6 function key
               * @zh F6 功能键
               * @readonly
               */
              'f6': 117,

              /**
               * @en The F7 function key
               * @zh F7 功能键
               * @readonly
               */
              'f7': 118,

              /**
               * @en The F8 function key
               * @zh F8 功能键
               * @readonly
               */
              'f8': 119,

              /**
               * @en The F9 function key
               * @zh F9 功能键
               * @readonly
               */
              'f9': 120,

              /**
               * @en The F10 function key
               * @zh F10 功能键
               * @readonly
               */
              'f10': 121,

              /**
               * @en The F11 function key
               * @zh F11 功能键
               * @readonly
               */
              'f11': 122,

              /**
               * @en The F12 function key
               * @zh F12 功能键
               * @readonly
               */
              'f12': 123,

              /**
               * @en The numlock key
               * @zh 数字锁定键
               * @readonly
               */
              'numlock': 144,

              /**
               * @en The scroll lock key
               * @zh 滚动锁定键
               * @readonly
               */
              'scrolllock': 145,

              /**
               * @en The ';' key.
               * @zh 分号键
               * @readonly
               */
              ';': 186,

              /**
               * @en The ';' key.
               * @zh 分号键
               * @readonly
               */
              'semicolon': 186,

              /**
               * @en The '=' key.
               * @zh 等于号键
               * @readonly
               */
              'equal': 187,

              /**
               * @en The '=' key.
               * @zh 等于号键
               * @readonly
               */
              '=': 187,

              /**
               * @en The ',' key.
               * @zh 逗号键
               * @readonly
               */
              ',': 188,

              /**
               * @en The ',' key.
               * @zh 逗号键
               * @readonly
               */
              'comma': 188,

              /**
               * @en The dash '-' key.
               * @zh 中划线键
               * @readonly
               */
              'dash': 189,

              /**
               * @en The '.' key.
               * @zh 句号键
               * @readonly
               */
              '.': 190,

              /**
               * @en The '.' key
               * @zh 句号键
               * @readonly
               */
              'period': 190,

              /**
               * @en The forward slash key
               * @zh 正斜杠键
               * @readonly
               */
              'forwardslash': 191,

              /**
               * @en The grave key
               * @zh 按键 `
               * @readonly
               */
              'grave': 192,

              /**
               * @en The '[' key
               * @zh 按键 [
               * @readonly
               */
              '[': 219,

              /**
               * @en The '[' key
               * @zh 按键 [
               * @readonly
               */
              'openbracket': 219,

              /**
               * @en The '\' key
               * @zh 反斜杠键
               * @readonly
               */
              'backslash': 220,

              /**
               * @en The ']' key
               * @zh 按键 ]
               * @readonly
               */
              ']': 221,

              /**
               * @en The ']' key
               * @zh 按键 ]
               * @readonly
               */
              'closebracket': 221,

              /**
               * @en The quote key
               * @zh 单引号键
               * @readonly
               */
              'quote': 222,
              // gamepad controll

              /**
               * @en The dpad left key
               * @zh 导航键 向左
               * @readonly
               */
              'dpadLeft': 1000,

              /**
               * @en The dpad right key
               * @zh 导航键 向右
               * @readonly
               */
              'dpadRight': 1001,

              /**
               * @en The dpad up key
               * @zh 导航键 向上
               * @readonly
               */
              'dpadUp': 1003,

              /**
               * @en The dpad down key
               * @zh 导航键 向下
               * @readonly
               */
              'dpadDown': 1004,

              /**
               * @en The dpad center key
               * @zh 导航键 确定键
               * @readonly
               */
              'dpadCenter': 1005
            };
            /**
             * @en
             * Predefined constants
             * @zh
             * 预定义常量。
             */

            var macro = exports('b8', {
              /**
               * @en
               * The image format supported by the engine defaults, and the supported formats may differ in different build platforms and device types.
               * Currently all platform and device support ['.webp', '.jpg', '.jpeg', '.bmp', '.png'], ios mobile platform
               * @zh
               * 引擎默认支持的图片格式，支持的格式可能在不同的构建平台和设备类型上有所差别。
               * 目前所有平台和设备支持的格式有 ['.webp', '.jpg', '.jpeg', '.bmp', '.png']. The iOS mobile platform also supports the PVR format。
               */
              SUPPORT_TEXTURE_FORMATS: SUPPORT_TEXTURE_FORMATS,

              /**
               * @en Key map for keyboard event
               * @zh 键盘事件的按键值。
               * @example {@link cocos/core/platform/CCCommon/KEY.js}
               */
              KEY: KEY,

              /**
               * PI / 180
               */
              RAD: Math.PI / 180,

              /**
               * One degree
               */
              DEG: 180 / Math.PI,

              /**
               * A maximum value of number
               */
              REPEAT_FOREVER: Number.MAX_VALUE - 1,

              /**
               * A minimal float value
               */
              FLT_EPSILON: 0.0000001192092896,
              // Possible device orientations

              /**
               * @en Oriented vertically
               * @zh 竖屏朝向
               */
              ORIENTATION_PORTRAIT: 1,

              /**
               * @en Oriented horizontally
               * @zh 横屏朝向
               */
              ORIENTATION_LANDSCAPE: 2,

              /**
               * @en Oriented automatically
               * @zh 自动适配朝向
               */
              ORIENTATION_AUTO: 3,

              /**
               * <p>
               *   If enabled, the texture coordinates will be calculated by using this formula: <br/>
               *      - texCoord.left = (rect.x*2+1) / (texture.wide*2);                  <br/>
               *      - texCoord.right = texCoord.left + (rect.width*2-2)/(texture.wide*2); <br/>
               *                                                                                 <br/>
               *  The same for bottom and top.                                                   <br/>
               *                                                                                 <br/>
               *  This formula prevents artifacts by using 99% of the texture.                   <br/>
               *  The "correct" way to prevent artifacts is by expand the texture's border with the same color by 1 pixel<br/>
               *                                                                                  <br/>
               *  Affected component:                                                                 <br/>
               *      - TMXLayer                                                       <br/>
               *                                                                                  <br/>
               *  Enabled by default. To disabled set it to 0. <br/>
               *  To modify it, in Web engine please refer to CCMacro.js, in JSB please refer to CCConfig.h
               * </p>
               * Currently not useful in 3D engine
               */
              // FIX_ARTIFACTS_BY_STRECHING_TEXEL_TMX: true,

              /**
               * @en
               * Whether or not enabled tiled map auto culling. If you set the TiledMap skew or rotation,
               * then need to manually disable this, otherwise, the rendering will be wrong.
               * Currently not useful in 3D engine
               * @zh
               * 是否开启瓦片地图的自动裁减功能。瓦片地图如果设置了 skew, rotation 的话，需要手动关闭，否则渲染会出错。
               * 在 3D 引擎中暂时无效。
               * @default true
               */
              ENABLE_TILEDMAP_CULLING: true,

              /**
               * @en
               * The timeout to determine whether a touch is no longer active and should be removed.
               * The reason to add this timeout is due to an issue in X5 browser core,
               * when X5 is presented in wechat on Android, if a touch is glissed from the bottom up, and leave the page area,
               * no touch cancel event is triggered, and the touch will be considered active forever.
               * After multiple times of this action, our maximum touches number will be reached and all new touches will be ignored.
               * So this new mechanism can remove the touch that should be inactive if it's not updated during the last 5000 milliseconds.
               * Though it might remove a real touch if it's just not moving for the last 5 seconds which is not easy with the sensibility of mobile touch screen.
               * You can modify this value to have a better behavior if you find it's not enough.
               * @zh
               * 用于甄别一个触点对象是否已经失效并且可以被移除的延时时长
               * 添加这个时长的原因是 X5 内核在微信浏览器中出现的一个 bug。
               * 在这个环境下，如果用户将一个触点从底向上移出页面区域，将不会触发任何 touch cancel 或 touch end 事件，而这个触点会被永远当作停留在页面上的有效触点。
               * 重复这样操作几次之后，屏幕上的触点数量将达到我们的事件系统所支持的最高触点数量，之后所有的触摸事件都将被忽略。
               * 所以这个新的机制可以在触点在一定时间内没有任何更新的情况下视为失效触点并从事件系统中移除。
               * 当然，这也可能移除一个真实的触点，如果用户的触点真的在一定时间段内完全没有移动（这在当前手机屏幕的灵敏度下会很难）。
               * 你可以修改这个值来获得你需要的效果，默认值是 5000 毫秒。
               * @default 5000
               */
              TOUCH_TIMEOUT: 5000,

              /**
               * @en
               * The max concurrent task number for the downloader
               * @zh
               * 下载任务的最大并发数限制，在安卓平台部分机型或版本上可能需要限制在较低的水平
               * @default 64
               */
              DOWNLOAD_MAX_CONCURRENT: 64,

              /**
               * @en
               * Boolean that indicates if the canvas contains an alpha channel, default sets to false for better performance.
               * Though if you want to make your canvas background transparent and show other dom elements at the background,
               * you can set it to true before {{game.init}}.
               * Web only.
               * @zh
               * 用于设置 Canvas 背景是否支持 alpha 通道，默认为 false，这样可以有更高的性能表现。
               * 如果你希望 Canvas 背景是透明的，并显示背后的其他 DOM 元素，你可以在 {{game.init}} 之前将这个值设为 true。
               * 仅支持 Web
               * @default false
               */
              ENABLE_TRANSPARENT_CANVAS: false,

              /**
               * @en
               * Boolean that indicates if the WebGL context is created with `antialias` option turned on, default value is false.
               * Set it to true could make your game graphics slightly smoother, like texture hard edges when rotated.
               * Whether to use this really depend on your game design and targeted platform,
               * device with retina display usually have good detail on graphics with or without this option,
               * you probably don't want antialias if your game style is pixel art based.
               * Also, it could have great performance impact with some browser / device using software MSAA.
               * You can set it to true before {{game.init}}.
               * Web only.
               * @zh
               * 用于设置在创建 WebGL Context 时是否开启抗锯齿选项，默认值是 false。
               * 将这个选项设置为 true 会让你的游戏画面稍稍平滑一些，比如旋转硬边贴图时的锯齿。是否开启这个选项很大程度上取决于你的游戏和面向的平台。
               * 在大多数拥有 retina 级别屏幕的设备上用户往往无法区分这个选项带来的变化；如果你的游戏选择像素艺术风格，你也多半不会想开启这个选项。
               * 同时，在少部分使用软件级别抗锯齿算法的设备或浏览器上，这个选项会对性能产生比较大的影响。
               * 你可以在 {{game.init}} 之前设置这个值，否则它不会生效。
               * 仅支持 Web
               * @default false
               */
              ENABLE_WEBGL_ANTIALIAS: false,

              /**
               * @en
               * Whether or not clear dom Image object cache after uploading to gl texture.
               * Concretely, we are setting image.src to empty string to release the cache.
               * Normally you don't need to enable this option, because on web the Image object doesn't consume too much memory.
               * But on Wechat Game platform, the current version cache decoded data in Image object, which has high memory usage.
               * So we enabled this option by default on Wechat, so that we can release Image cache immediately after uploaded to GPU.
               * Currently not useful in 3D engine
               * @zh
               * 是否在将贴图上传至 GPU 之后删除 DOM Image 缓存。
               * 具体来说，我们通过设置 image.src 为空字符串来释放这部分内存。
               * 正常情况下，你不需要开启这个选项，因为在 web 平台，Image 对象所占用的内存很小。
               * 但是在微信小游戏平台的当前版本，Image 对象会缓存解码后的图片数据，它所占用的内存空间很大。
               * 所以我们在微信平台默认开启了这个选项，这样我们就可以在上传 GL 贴图之后立即释放 Image 对象的内存，避免过高的内存占用。
               * 在 3D 引擎中暂时无效。
               * @default false
               */
              CLEANUP_IMAGE_CACHE: false,

              /**
               * @en
               * Whether to enable multi-touch.
               * @zh
               * 是否开启多点触摸
               * @default true
               */
              ENABLE_MULTI_TOUCH: true
            });
            legacyCC.macro = macro;

            var _dec$3, _class$3, _temp$3;
            var _regions = [{
              buffStride: 0,
              buffTexHeight: 0,
              texOffset: {
                x: 0,
                y: 0,
                z: 0
              },
              texExtent: {
                width: 1,
                height: 1,
                depth: 1
              },
              texSubres: {
                mipLevel: 0,
                baseArrayLayer: 0,
                layerCount: 1
              }
            }];

            function getMipLevel(width, height) {
              var size = Math.max(width, height);
              var level = 0;

              while (size) {
                size >>= 1;
                level++;
              }

              return level;
            }

            function isPOT(n) {
              return n && (n & n - 1) === 0;
            }

            function canGenerateMipmap(device, w, h) {
              var needCheckPOT = device.gfxAPI === GFXAPI.WEBGL;

              if (needCheckPOT) {
                return isPOT(w) && isPOT(h);
              }

              return true;
            }
            /**
             * @en The simple texture base class.
             * It create the GFXTexture and can set mipmap levels.
             * @zh 简单贴图基类。
             * 简单贴图内部创建了 GFX 贴图和该贴图上的 GFX 贴图视图。
             * 简单贴图允许指定不同的 Mipmap 层级。
             */


            var SimpleTexture = (_dec$3 = ccclass('cc.SimpleTexture'), _dec$3(_class$3 = (_temp$3 = /*#__PURE__*/function (_TextureBase) {
              _inherits(SimpleTexture, _TextureBase);

              function SimpleTexture() {
                var _getPrototypeOf2;

                var _this;

                _classCallCheck(this, SimpleTexture);

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SimpleTexture)).call.apply(_getPrototypeOf2, [this].concat(args)));
                _this._gfxTexture = null;
                _this._mipmapLevel = 1;
                return _this;
              }

              _createClass(SimpleTexture, [{
                key: "getGFXTexture",

                /**
                 * @en The GFXTexture resource
                 * @zh 获取此贴图底层的 GFX 贴图对象。
                 */
                value: function getGFXTexture() {
                  return this._gfxTexture;
                }
              }, {
                key: "destroy",
                value: function destroy() {
                  this._tryDestroyTexture();

                  return _get(_getPrototypeOf(SimpleTexture.prototype), "destroy", this).call(this);
                }
                /**
                 * @en Update the level 0 mipmap image.
                 * @zh 更新 0 级 Mipmap。
                 */

              }, {
                key: "updateImage",
                value: function updateImage() {
                  this.updateMipmaps(0);
                }
                /**
                 * @en Update the given level mipmap image.
                 * @zh 更新指定层级范围内的 Mipmap。当 Mipmap 数据发生了改变时应调用此方法提交更改。
                 * 若指定的层级范围超出了实际已有的层级范围，只有覆盖的那些层级范围会被更新。
                 * @param firstLevel First level to be updated
                 * @param count Mipmap level count to be updated
                 */

              }, {
                key: "updateMipmaps",
                value: function updateMipmaps() {
                }
                /**
                 * @en Upload data to the given mipmap level.
                 * The size of the image will affect how the mipmap is updated.
                 * - When the image is an ArrayBuffer, the size of the image must match the mipmap size.
                 * - If the image size matches the mipmap size, the mipmap data will be updated entirely.
                 * - If the image size is smaller than the mipmap size, the mipmap will be updated from top left corner.
                 * - If the image size is larger, an error will be raised
                 * @zh 上传图像数据到指定层级的 Mipmap 中。
                 * 图像的尺寸影响 Mipmap 的更新范围：
                 * - 当图像是 `ArrayBuffer` 时，图像的尺寸必须和 Mipmap 的尺寸一致；否则，
                 * - 若图像的尺寸与 Mipmap 的尺寸相同，上传后整个 Mipmap 的数据将与图像数据一致；
                 * - 若图像的尺寸小于指定层级 Mipmap 的尺寸（不管是长或宽），则从贴图左上角开始，图像尺寸范围内的 Mipmap 会被更新；
                 * - 若图像的尺寸超出了指定层级 Mipmap 的尺寸（不管是长或宽），都将引起错误。
                 * @param source The source image or image data
                 * @param level Mipmap level to upload the image to
                 * @param arrayIndex The array index
                 */

              }, {
                key: "uploadData",
                value: function uploadData(source) {
                  var level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                  var arrayIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

                  if (!this._gfxTexture || this._gfxTexture.levelCount <= level) {
                    return;
                  }

                  var gfxDevice = this._getGFXDevice();

                  if (!gfxDevice) {
                    return;
                  }

                  var region = _regions[0];
                  region.texExtent.width = this._gfxTexture.width >> level;
                  region.texExtent.height = this._gfxTexture.height >> level;
                  region.texSubres.mipLevel = level;
                  region.texSubres.baseArrayLayer = arrayIndex;

                  if (ArrayBuffer.isView(source)) {
                    gfxDevice.copyBuffersToTexture([source], this._gfxTexture, _regions);
                  } else {
                    gfxDevice.copyTexImagesToTexture([source], this._gfxTexture, _regions);
                  }
                }
              }, {
                key: "_assignImage",
                value: function _assignImage(image, level, arrayIndex) {
                  var _this2 = this;

                  var upload = function upload() {
                    var data = image.data;

                    if (!data) {
                      return;
                    }

                    _this2.uploadData(data, level, arrayIndex);

                    _this2._checkTextureLoaded();

                    if (macro.CLEANUP_IMAGE_CACHE) {
                      legacyCC.loader.release(image);
                    }
                  };

                  if (image.loaded) {
                    upload();
                  } else {
                    image.once('load', function () {
                      upload();
                    });

                    if (!this.isCompressed) {
                      var defaultImg = legacyCC.builtinResMgr.get('black-texture').image;
                      this.uploadData(defaultImg.data, level, arrayIndex);
                    }

                    legacyCC.textureUtil.postLoadImage(image);
                  }
                }
              }, {
                key: "_checkTextureLoaded",
                value: function _checkTextureLoaded() {
                  this._textureReady();
                }
              }, {
                key: "_textureReady",
                value: function _textureReady() {
                  this.loaded = true;
                  this.emit('load');
                }
                /**
                 * Set mipmap level of this texture.
                 * The value is passes as presumed info to `this._getGfxTextureCreateInfo()`.
                 * @param value The mipmap level.
                 */

              }, {
                key: "_setMipmapLevel",
                value: function _setMipmapLevel(value) {
                  this._mipmapLevel = value < 1 ? 1 : value;
                }
                /**
                 * @en This method is overrided by derived classes to provide GFX texture info.
                 * @zh 这个方法被派生类重写以提供GFX纹理信息。
                 * @param presumed The presumed GFX texture info.
                 */

              }, {
                key: "_getGfxTextureCreateInfo",
                value: function _getGfxTextureCreateInfo(presumed) {
                  return null;
                }
              }, {
                key: "_tryReset",
                value: function _tryReset() {
                  this._tryDestroyTexture();

                  if (this._mipmapLevel === 0) {
                    return;
                  }

                  var device = this._getGFXDevice();

                  if (!device) {
                    return;
                  }

                  this._createTexture(device);
                }
              }, {
                key: "_createTexture",
                value: function _createTexture(device) {
                  var flags = GFXTextureFlagBit.NONE;

                  if (this._mipFilter !== Filter.NONE && canGenerateMipmap(device, this._width, this._height)) {
                    this._mipmapLevel = getMipLevel(this._width, this._height);
                    flags = GFXTextureFlagBit.GEN_MIPMAP;
                  }

                  var textureCreateInfo = this._getGfxTextureCreateInfo({
                    usage: GFXTextureUsageBit.SAMPLED | GFXTextureUsageBit.TRANSFER_DST,
                    format: this._getGFXFormat(),
                    levelCount: this._mipmapLevel,
                    flags: flags
                  });

                  if (!textureCreateInfo) {
                    return;
                  }

                  var texture = device.createTexture(textureCreateInfo);
                  this._gfxTexture = texture;
                }
              }, {
                key: "_tryDestroyTexture",
                value: function _tryDestroyTexture() {
                  if (this._gfxTexture) {
                    this._gfxTexture.destroy();

                    this._gfxTexture = null;
                  }
                }
              }, {
                key: "mipmapLevel",

                /**
                 * @en The mipmap level of the texture
                 * @zh 贴图中的 Mipmap 层级数量
                 */
                get: function get() {
                  return this._mipmapLevel;
                }
              }]);

              return SimpleTexture;
            }(TextureBase), _temp$3)) || _class$3);
            legacyCC.SimpleTexture = SimpleTexture;

            var _dec$4, _dec2, _class$4, _class2$3, _descriptor$2, _temp$4;
            /**
             * @en The create information for [[Texture2D]]
             * @zh 用来创建贴图的信息。
             */

            var Texture2D = exports('aY', (_dec$4 = ccclass('cc.Texture2D'), _dec2 = type([ImageAsset]), _dec$4(_class$4 = (_class2$3 = (_temp$4 = /*#__PURE__*/function (_SimpleTexture) {
              _inherits(Texture2D, _SimpleTexture);

              function Texture2D() {
                var _getPrototypeOf2;

                var _this;

                _classCallCheck(this, Texture2D);

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Texture2D)).call.apply(_getPrototypeOf2, [this].concat(args)));

                _initializerDefineProperty(_this, "_mipmaps", _descriptor$2, _assertThisInitialized(_this));

                return _this;
              }

              _createClass(Texture2D, [{
                key: "initialize",
                value: function initialize() {
                  this.mipmaps = this._mipmaps;
                }
              }, {
                key: "onLoaded",
                value: function onLoaded() {
                  this.initialize();
                }
                /**
                 * @en Reset the current texture with given size, pixel format and mipmap images.
                 * After reset, the gfx resource will become invalid, you must use [[uploadData]] explicitly to upload the new mipmaps to GPU resources.
                 * @zh 将当前贴图重置为指定尺寸、像素格式以及指定 mipmap 层级。重置后，贴图的像素数据将变为未定义。
                 * mipmap 图像的数据不会自动更新到贴图中，你必须显式调用 [[uploadData]] 来上传贴图数据。
                 * @param info The create information
                 */

              }, {
                key: "reset",
                value: function reset(info) {
                  this._width = info.width;
                  this._height = info.height;

                  this._setGFXFormat(info.format);

                  this._setMipmapLevel(info.mipmapLevel || 1);

                  this._tryReset();
                }
                /**
                 * @en Reset the current texture with given size, pixel format and mipmap images.
                 * After reset, the gfx resource will become invalid, you must use [[uploadData]] explicitly to upload the new mipmaps to GPU resources.
                 * @zh 将当前贴图重置为指定尺寸、像素格式以及指定 mipmap 层级。重置后，贴图的像素数据将变为未定义。
                 * mipmap 图像的数据不会自动更新到贴图中，你必须显式调用 [[uploadData]] 来上传贴图数据。
                 * @param width Pixel width
                 * @param height Pixel height
                 * @param format Pixel format
                 * @param mipmapLevel Mipmap level count
                 * @deprecated since v1.0 please use [[reset]] instead
                 */

              }, {
                key: "create",
                value: function create(width, height) {
                  var format = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : PixelFormat.RGBA8888;
                  var mipmapLevel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
                  this.reset({
                    width: width,
                    height: height,
                    format: format,
                    mipmapLevel: mipmapLevel
                  });
                }
              }, {
                key: "toString",
                value: function toString() {
                  return this._mipmaps.length !== 0 ? this._mipmaps[0].url : '';
                }
              }, {
                key: "updateMipmaps",
                value: function updateMipmaps() {
                  var firstLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                  var count = arguments.length > 1 ? arguments[1] : undefined;

                  if (firstLevel >= this._mipmaps.length) {
                    return;
                  }

                  var nUpdate = Math.min(count === undefined ? this._mipmaps.length : count, this._mipmaps.length - firstLevel);

                  for (var i = 0; i < nUpdate; ++i) {
                    var level = firstLevel + i;

                    this._assignImage(this._mipmaps[level], level);
                  }
                }
                /**
                 * @en If the level 0 mipmap image is a HTML element, then return it, otherwise return null.
                 * @zh 若此贴图 0 级 Mipmap 的图像资源的实际源存在并为 HTML 元素则返回它，否则返回 `null`。
                 * @returns HTML element or `null`
                 * @deprecated Please use [[image.data]] instead
                 */

              }, {
                key: "getHtmlElementObj",
                value: function getHtmlElementObj() {
                  return this._mipmaps[0] && this._mipmaps[0].data instanceof HTMLElement ? this._mipmaps[0].data : null;
                }
                /**
                 * @en Destroy the current 2d texture, clear up all mipmap levels and the related GPU resources.
                 * @zh 销毁此贴图，清空所有 Mipmap 并释放占用的 GPU 资源。
                 */

              }, {
                key: "destroy",
                value: function destroy() {
                  this._mipmaps = [];
                  return _get(_getPrototypeOf(Texture2D.prototype), "destroy", this).call(this);
                }
                /**
                 * @en Gets the description of the 2d texture
                 * @zh 返回此贴图的描述。
                 * @returns The description
                 */

              }, {
                key: "description",
                value: function description() {
                  var url = this._mipmaps[0] ? this._mipmaps[0].url : '';
                  return "<cc.Texture2D | Name = ".concat(url, " | Dimension = ").concat(this.width, " x ").concat(this.height, ">");
                }
                /**
                 * @en Release used GPU resources.
                 * @zh 释放占用的 GPU 资源。
                 * @deprecated please use [[destroy]] instead
                 */

              }, {
                key: "releaseTexture",
                value: function releaseTexture() {
                  this.destroy();
                }
              }, {
                key: "_serialize",
                value: function _serialize(exporting) {
                  return {
                    base: _get(_getPrototypeOf(Texture2D.prototype), "_serialize", this).call(this, exporting),
                    mipmaps: this._mipmaps.map(function (mipmap) {
                      if (!mipmap || !mipmap._uuid) {
                        return null;
                      }

                      if (exporting) {
                        return EditorExtends.UuidUtils.compressUuid(mipmap._uuid, true);
                      }

                      return mipmap._uuid;
                    })
                  };
                }
              }, {
                key: "_deserialize",
                value: function _deserialize(serializedData, handle) {
                  var data = serializedData;

                  _get(_getPrototypeOf(Texture2D.prototype), "_deserialize", this).call(this, data.base, handle);

                  this._mipmaps = new Array(data.mipmaps.length);

                  for (var i = 0; i < data.mipmaps.length; ++i) {
                    // Prevent resource load failed
                    this._mipmaps[i] = new ImageAsset();

                    if (!data.mipmaps[i]) {
                      continue;
                    }

                    var mipmapUUID = data.mipmaps[i];
                    handle.result.push(this._mipmaps, "".concat(i), mipmapUUID);
                    this._mipmaps[i]._texture = this;
                  }
                }
              }, {
                key: "_getGfxTextureCreateInfo",
                value: function _getGfxTextureCreateInfo(presumed) {
                  return Object.assign({
                    type: GFXTextureType.TEX2D,
                    width: this._width,
                    height: this._height
                  }, presumed);
                }
              }, {
                key: "_checkTextureLoaded",
                value: function _checkTextureLoaded() {
                  var ready = true;

                  for (var i = 0; i < this._mipmaps.length; ++i) {
                    var image = this._mipmaps[i];

                    if (!image.loaded) {
                      ready = false;
                      break;
                    }
                  }

                  if (ready) {
                    _get(_getPrototypeOf(Texture2D.prototype), "_textureReady", this).call(this);
                  }
                }
              }, {
                key: "mipmaps",

                /**
                 * @en All levels of mipmap images, be noted, automatically generated mipmaps are not included.
                 * When setup mipmap, the size of the texture and pixel format could be modified.
                 * @zh 所有层级 Mipmap，注意，这里不包含自动生成的 Mipmap。
                 * 当设置 Mipmap 时，贴图的尺寸以及像素格式可能会改变。
                 */
                get: function get() {
                  return this._mipmaps;
                },
                set: function set(value) {
                  var _this2 = this;

                  this._mipmaps = value;

                  this._setMipmapLevel(this._mipmaps.length);

                  if (this._mipmaps.length > 0) {
                    var imageAsset = this._mipmaps[0];
                    this.reset({
                      width: imageAsset.width,
                      height: imageAsset.height,
                      format: imageAsset.format,
                      mipmapLevel: this._mipmaps.length
                    });

                    this._mipmaps.forEach(function (mipmap, level) {
                      _this2._assignImage(mipmap, level);
                    });
                  } else {
                    this.reset({
                      width: 0,
                      height: 0,
                      mipmapLevel: this._mipmaps.length
                    });
                  }
                }
                /**
                 * @en Level 0 mipmap image.
                 * Be noted, `this.image = img` equals `this.mipmaps = [img]`, 
                 * sets image will clear all previous mipmaps.
                 * @zh 0 级 Mipmap。
                 * 注意，`this.image = img` 等价于 `this.mipmaps = [img]`，
                 * 也就是说，通过 `this.image` 设置 0 级 Mipmap 时将隐式地清除之前的所有 Mipmap。
                 */

              }, {
                key: "image",
                get: function get() {
                  return this._mipmaps.length === 0 ? null : this._mipmaps[0];
                },
                set: function set(value) {
                  this.mipmaps = value ? [value] : [];
                }
              }]);

              return Texture2D;
            }(SimpleTexture), _temp$4), (_descriptor$2 = _applyDecoratedDescriptor(_class2$3.prototype, "_mipmaps", [_dec2], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [];
              }
            })), _class2$3)) || _class$4));
            legacyCC.Texture2D = Texture2D;

            var layerList = {
              NONE: 0,
              IGNORE_RAYCAST: 1 << 20,
              GIZMOS: 1 << 21,
              EDITOR: 1 << 22,
              UI_3D: 1 << 23,
              SCENE_GIZMO: 1 << 24,
              UI_2D: 1 << 25,
              PROFILER: 1 << 28,
              DEFAULT: 1 << 30,
              ALL: 0xffffffff
            };
            /**
             * @zh 节点层管理器，层数据是以掩码数据方式存储在 [[Node.layer]] 中，用于射线检测、物理碰撞和用户自定义脚本逻辑。
             * 每个节点可属于一个或多个层，可通过 “包含式” 或 “排除式” 两种检测器进行层检测。
             * @en Node's layer manager, it's stored as bit mask data in [[Node.layer]].
             * Layer information is widely used in raycast, physics and user logic.
             * Every node can be assigned to multiple layers with different bit masks, you can setup layer with inclusive or exclusive operation.
             */

            var Layers = exports('cY', /*#__PURE__*/function () {
              function Layers() {
                _classCallCheck(this, Layers);
              }

              _createClass(Layers, null, [{
                key: "makeMaskInclude",

                /**
                 * @en All layers in an Enum
                 * @zh 以 Enum 形式存在的所有层列表
                 */

                /**
                 * @en All layers in [[BitMask]] type
                 * @zh 包含所有层的 [[BitMask]]
                 */

                /**
                 * @en
                 * Make a layer mask accepting nothing but the listed layers
                 * @zh
                 * 创建一个包含式层检测器，只接受列表中的层
                 * @param includes All accepted layers
                 * @return A filter which can detect all accepted layers
                 */
                value: function makeMaskInclude(includes) {
                  var mask = 0;

                  for (var _iterator = _createForOfIteratorHelperLoose(includes), _step; !(_step = _iterator()).done;) {
                    var inc = _step.value;
                    mask |= inc;
                  }

                  return mask;
                }
                /**
                 * @en
                 * Make a layer mask accepting everything but the listed layers
                 * @zh
                 * 创建一个排除式层检测器，只拒绝列表中的层
                 * @param excludes All excluded layers
                 * @return A filter which can detect for excluded layers
                 */

              }, {
                key: "makeMaskExclude",
                value: function makeMaskExclude(excludes) {
                  return ~Layers.makeMaskInclude(excludes);
                }
                /**
                 * @zh 添加一个新层，用户可编辑 0 - 19 位为用户自定义层
                 * @en Add a new layer, user can use layers from bit position 0 to 19, other bits are reserved.
                 * @param name Layer's name
                 * @param bitNum Layer's bit position
                 */

              }, {
                key: "addLayer",
                value: function addLayer(name, bitNum) {
                  if (bitNum === undefined) {
                    console.warn('bitNum can\'t be undefined');
                    return;
                  }

                  if (bitNum > 19 || bitNum < 0) {
                    console.warn('maximum layers reached.');
                    return;
                  }

                  Layers.Enum[name] = 1 << bitNum;
                  Layers.Enum[bitNum] = name;
                  Layers.BitMask[name] = 1 << bitNum;
                  Layers.BitMask[bitNum] = name;
                }
                /**
                 * @en Remove a layer, user can remove layers from bit position 0 to 19, other bits are reserved.
                 * @zh 移除一个层，用户可编辑 0 - 19 位为用户自定义层
                 * @param bitNum Layer's bit position
                 */

              }, {
                key: "deleteLayer",
                value: function deleteLayer(bitNum) {
                  if (bitNum > 19 || bitNum < 0) {
                    console.warn('do not change buildin layers.');
                    return;
                  }

                  delete Layers.Enum[Layers.Enum[bitNum]];
                  delete Layers.Enum[bitNum];
                  delete Layers.BitMask[Layers.BitMask[bitNum]];
                  delete Layers.BitMask[bitNum];
                }
              }]);

              return Layers;
            }());
            Layers.Enum = Enum(layerList);
            Layers.BitMask = BitMask(Object.assign({}, layerList));
            legacyCC.Layers = Layers;

            var PIPELINE_FLOW_FORWARD = 'ForwardFlow';
            var PIPELINE_FLOW_SHADOW = 'ShadowFlow';
            var PIPELINE_FLOW_SMAA = 'SMAAFlow';
            var PIPELINE_FLOW_TONEMAP = 'ToneMapFlow';
            /**
             * @en The predefined render pass stage ids
             * @zh 预设的渲染阶段。
             */

            var RenderPassStage;

            (function (RenderPassStage) {
              RenderPassStage[RenderPassStage["DEFAULT"] = 100] = "DEFAULT";
              RenderPassStage[RenderPassStage["UI"] = 200] = "UI";
            })(RenderPassStage || (RenderPassStage = {}));

            legacyCC.RenderPassStage = RenderPassStage;
            /**
             * @en The predefined render priorities
             * @zh 预设的渲染优先级。
             */

            var RenderPriority;
            /**
             * @en Render object interface
             * @zh 渲染对象接口。
             */

            (function (RenderPriority) {
              RenderPriority[RenderPriority["MIN"] = 0] = "MIN";
              RenderPriority[RenderPriority["MAX"] = 255] = "MAX";
              RenderPriority[RenderPriority["DEFAULT"] = 128] = "DEFAULT";
            })(RenderPriority || (RenderPriority = exports('dk', {})));

            var globalDescriptorSetLayout = {
              bindings: [],
              record: {}
            };
            var localDescriptorSetLayout = {
              bindings: [],
              record: {}
            };
            /**
             * @en The uniform bindings
             * @zh Uniform 参数绑定。
             */

            var PipelineGlobalBindings;

            (function (PipelineGlobalBindings) {
              PipelineGlobalBindings[PipelineGlobalBindings["UBO_GLOBAL"] = 0] = "UBO_GLOBAL";
              PipelineGlobalBindings[PipelineGlobalBindings["UBO_SHADOW"] = 1] = "UBO_SHADOW";
              PipelineGlobalBindings[PipelineGlobalBindings["SAMPLER_ENVIRONMENT"] = 2] = "SAMPLER_ENVIRONMENT";
              PipelineGlobalBindings[PipelineGlobalBindings["SAMPLER_SHADOWMAP"] = 3] = "SAMPLER_SHADOWMAP";
              PipelineGlobalBindings[PipelineGlobalBindings["COUNT"] = 4] = "COUNT";
            })(PipelineGlobalBindings || (PipelineGlobalBindings = {}));

            var GLOBAL_UBO_COUNT = PipelineGlobalBindings.SAMPLER_ENVIRONMENT;
            var GLOBAL_SAMPLER_COUNT = PipelineGlobalBindings.COUNT - GLOBAL_UBO_COUNT;
            var ModelLocalBindings;

            (function (ModelLocalBindings) {
              ModelLocalBindings[ModelLocalBindings["UBO_LOCAL"] = 0] = "UBO_LOCAL";
              ModelLocalBindings[ModelLocalBindings["UBO_FORWARD_LIGHTS"] = 1] = "UBO_FORWARD_LIGHTS";
              ModelLocalBindings[ModelLocalBindings["UBO_SKINNING_ANIMATION"] = 2] = "UBO_SKINNING_ANIMATION";
              ModelLocalBindings[ModelLocalBindings["UBO_SKINNING_TEXTURE"] = 3] = "UBO_SKINNING_TEXTURE";
              ModelLocalBindings[ModelLocalBindings["UBO_MORPH"] = 4] = "UBO_MORPH";
              ModelLocalBindings[ModelLocalBindings["SAMPLER_JOINTS"] = 5] = "SAMPLER_JOINTS";
              ModelLocalBindings[ModelLocalBindings["SAMPLER_MORPH_POSITION"] = 6] = "SAMPLER_MORPH_POSITION";
              ModelLocalBindings[ModelLocalBindings["SAMPLER_MORPH_NORMAL"] = 7] = "SAMPLER_MORPH_NORMAL";
              ModelLocalBindings[ModelLocalBindings["SAMPLER_MORPH_TANGENT"] = 8] = "SAMPLER_MORPH_TANGENT";
              ModelLocalBindings[ModelLocalBindings["SAMPLER_LIGHTING_MAP"] = 9] = "SAMPLER_LIGHTING_MAP";
              ModelLocalBindings[ModelLocalBindings["SAMPLER_SPRITE"] = 10] = "SAMPLER_SPRITE";
              ModelLocalBindings[ModelLocalBindings["COUNT"] = 11] = "COUNT";
            })(ModelLocalBindings || (ModelLocalBindings = exports('dq', {})));

            var LOCAL_UBO_COUNT = ModelLocalBindings.SAMPLER_JOINTS;
            var LOCAL_SAMPLER_COUNT = ModelLocalBindings.COUNT - LOCAL_UBO_COUNT;
            /**
             * @en Check whether the given uniform binding is a builtin binding
             * @zh 检查指定的 UniformBinding 是否是引擎内置的
             * @param binding
             */

            var isBuiltinBinding = function isBuiltinBinding(set) {
              return set !== SetIndex.MATERIAL;
            };
            var SetIndex; // parameters passed to GFXDevice

            (function (SetIndex) {
              SetIndex[SetIndex["GLOBAL"] = 0] = "GLOBAL";
              SetIndex[SetIndex["MATERIAL"] = 1] = "MATERIAL";
              SetIndex[SetIndex["LOCAL"] = 2] = "LOCAL";
            })(SetIndex || (SetIndex = exports('dm', {})));

            var bindingMappingInfo = new GFXBindingMappingInfo();
            bindingMappingInfo.bufferOffsets = [0, GLOBAL_UBO_COUNT + LOCAL_UBO_COUNT, GLOBAL_UBO_COUNT];
            bindingMappingInfo.samplerOffsets = [0, GLOBAL_SAMPLER_COUNT + LOCAL_SAMPLER_COUNT, GLOBAL_SAMPLER_COUNT];
            /**
             * @en The global uniform buffer object
             * @zh 全局 UBO。
             */

            var UBOGlobal = function UBOGlobal() {
              _classCallCheck(this, UBOGlobal);
            };
            UBOGlobal.TIME_OFFSET = 0;
            UBOGlobal.SCREEN_SIZE_OFFSET = UBOGlobal.TIME_OFFSET + 4;
            UBOGlobal.SCREEN_SCALE_OFFSET = UBOGlobal.SCREEN_SIZE_OFFSET + 4;
            UBOGlobal.NATIVE_SIZE_OFFSET = UBOGlobal.SCREEN_SCALE_OFFSET + 4;
            UBOGlobal.MAT_VIEW_OFFSET = UBOGlobal.NATIVE_SIZE_OFFSET + 4;
            UBOGlobal.MAT_VIEW_INV_OFFSET = UBOGlobal.MAT_VIEW_OFFSET + 16;
            UBOGlobal.MAT_PROJ_OFFSET = UBOGlobal.MAT_VIEW_INV_OFFSET + 16;
            UBOGlobal.MAT_PROJ_INV_OFFSET = UBOGlobal.MAT_PROJ_OFFSET + 16;
            UBOGlobal.MAT_VIEW_PROJ_OFFSET = UBOGlobal.MAT_PROJ_INV_OFFSET + 16;
            UBOGlobal.MAT_VIEW_PROJ_INV_OFFSET = UBOGlobal.MAT_VIEW_PROJ_OFFSET + 16;
            UBOGlobal.CAMERA_POS_OFFSET = UBOGlobal.MAT_VIEW_PROJ_INV_OFFSET + 16;
            UBOGlobal.EXPOSURE_OFFSET = UBOGlobal.CAMERA_POS_OFFSET + 4;
            UBOGlobal.MAIN_LIT_DIR_OFFSET = UBOGlobal.EXPOSURE_OFFSET + 4;
            UBOGlobal.MAIN_LIT_COLOR_OFFSET = UBOGlobal.MAIN_LIT_DIR_OFFSET + 4;
            UBOGlobal.AMBIENT_SKY_OFFSET = UBOGlobal.MAIN_LIT_COLOR_OFFSET + 4;
            UBOGlobal.AMBIENT_GROUND_OFFSET = UBOGlobal.AMBIENT_SKY_OFFSET + 4;
            UBOGlobal.GLOBAL_FOG_COLOR_OFFSET = UBOGlobal.AMBIENT_GROUND_OFFSET + 4;
            UBOGlobal.GLOBAL_FOG_BASE_OFFSET = UBOGlobal.GLOBAL_FOG_COLOR_OFFSET + 4;
            UBOGlobal.GLOBAL_FOG_ADD_OFFSET = UBOGlobal.GLOBAL_FOG_BASE_OFFSET + 4;
            UBOGlobal.COUNT = UBOGlobal.GLOBAL_FOG_ADD_OFFSET + 4;
            UBOGlobal.SIZE = UBOGlobal.COUNT * 4;
            UBOGlobal.BLOCK = {
              stageFlags: GFXShaderStageFlagBit.ALL,
              descriptorType: GFXDescriptorType.UNIFORM_BUFFER,
              count: 1,
              set: SetIndex.GLOBAL,
              binding: PipelineGlobalBindings.UBO_GLOBAL,
              name: 'CCGlobal',
              members: [{
                name: 'cc_time',
                type: GFXType.FLOAT4,
                count: 1
              }, {
                name: 'cc_screenSize',
                type: GFXType.FLOAT4,
                count: 1
              }, {
                name: 'cc_screenScale',
                type: GFXType.FLOAT4,
                count: 1
              }, {
                name: 'cc_nativeSize',
                type: GFXType.FLOAT4,
                count: 1
              }, {
                name: 'cc_matView',
                type: GFXType.MAT4,
                count: 1
              }, {
                name: 'cc_matViewInv',
                type: GFXType.MAT4,
                count: 1
              }, {
                name: 'cc_matProj',
                type: GFXType.MAT4,
                count: 1
              }, {
                name: 'cc_matProjInv',
                type: GFXType.MAT4,
                count: 1
              }, {
                name: 'cc_matViewProj',
                type: GFXType.MAT4,
                count: 1
              }, {
                name: 'cc_matViewProjInv',
                type: GFXType.MAT4,
                count: 1
              }, {
                name: 'cc_cameraPos',
                type: GFXType.FLOAT4,
                count: 1
              }, {
                name: 'cc_exposure',
                type: GFXType.FLOAT4,
                count: 1
              }, {
                name: 'cc_mainLitDir',
                type: GFXType.FLOAT4,
                count: 1
              }, {
                name: 'cc_mainLitColor',
                type: GFXType.FLOAT4,
                count: 1
              }, {
                name: 'cc_ambientSky',
                type: GFXType.FLOAT4,
                count: 1
              }, {
                name: 'cc_ambientGround',
                type: GFXType.FLOAT4,
                count: 1
              }, {
                name: 'cc_fogColor',
                type: GFXType.FLOAT4,
                count: 1
              }, {
                name: 'cc_fogBase',
                type: GFXType.FLOAT4,
                count: 1
              }, {
                name: 'cc_fogAdd',
                type: GFXType.FLOAT4,
                count: 1
              }]
            };
            globalDescriptorSetLayout.record[UBOGlobal.BLOCK.name] = UBOGlobal.BLOCK;
            globalDescriptorSetLayout.bindings[UBOGlobal.BLOCK.binding] = UBOGlobal.BLOCK;
            /**
             * @en The uniform buffer object for shadow
             * @zh 阴影 UBO。
             */

            var UBOShadow = function UBOShadow() {
              _classCallCheck(this, UBOShadow);
            };
            UBOShadow.MAT_LIGHT_PLANE_PROJ_OFFSET = 0;
            UBOShadow.MAT_LIGHT_VIEW_PROJ_OFFSET = UBOShadow.MAT_LIGHT_PLANE_PROJ_OFFSET + 16;
            UBOShadow.SHADOW_COLOR_OFFSET = UBOShadow.MAT_LIGHT_VIEW_PROJ_OFFSET + 16;
            UBOShadow.SHADOW_PCF_OFFSET = UBOShadow.SHADOW_COLOR_OFFSET + 4;
            UBOShadow.SHADOW_SIZE_OFFSET = UBOShadow.SHADOW_PCF_OFFSET + 4;
            UBOShadow.COUNT = UBOShadow.SHADOW_SIZE_OFFSET + 4;
            UBOShadow.SIZE = UBOShadow.COUNT * 4;
            UBOShadow.BLOCK = {
              stageFlags: GFXShaderStageFlagBit.ALL,
              descriptorType: GFXDescriptorType.UNIFORM_BUFFER,
              count: 1,
              set: SetIndex.GLOBAL,
              binding: PipelineGlobalBindings.UBO_SHADOW,
              name: 'CCShadow',
              members: [{
                name: 'cc_matLightPlaneProj',
                type: GFXType.MAT4,
                count: 1
              }, {
                name: 'cc_matLightViewProj',
                type: GFXType.MAT4,
                count: 1
              }, {
                name: 'cc_shadowColor',
                type: GFXType.FLOAT4,
                count: 1
              }, {
                name: 'cc_shadowPCF',
                type: GFXType.FLOAT4,
                count: 1
              }, {
                name: 'cc_shadowSize',
                type: GFXType.FLOAT4,
                count: 1
              }]
            };
            globalDescriptorSetLayout.record[UBOShadow.BLOCK.name] = UBOShadow.BLOCK;
            globalDescriptorSetLayout.bindings[UBOShadow.BLOCK.binding] = UBOShadow.BLOCK;
            var UNIFORM_SHADOWMAP = {
              stageFlags: GFXShaderStageFlagBit.FRAGMENT,
              descriptorType: GFXDescriptorType.SAMPLER,
              count: 1,
              set: SetIndex.GLOBAL,
              binding: PipelineGlobalBindings.SAMPLER_SHADOWMAP,
              name: 'cc_shadowMap',
              type: GFXType.SAMPLER2D
            };
            globalDescriptorSetLayout.record[UNIFORM_SHADOWMAP.name] = UNIFORM_SHADOWMAP;
            globalDescriptorSetLayout.bindings[UNIFORM_SHADOWMAP.binding] = UNIFORM_SHADOWMAP;
            var UNIFORM_ENVIRONMENT = {
              stageFlags: GFXShaderStageFlagBit.FRAGMENT,
              descriptorType: GFXDescriptorType.SAMPLER,
              count: 1,
              set: SetIndex.GLOBAL,
              binding: PipelineGlobalBindings.SAMPLER_ENVIRONMENT,
              name: 'cc_environment',
              type: GFXType.SAMPLER_CUBE
            };
            globalDescriptorSetLayout.record[UNIFORM_ENVIRONMENT.name] = UNIFORM_ENVIRONMENT;
            globalDescriptorSetLayout.bindings[UNIFORM_ENVIRONMENT.binding] = UNIFORM_ENVIRONMENT;
            /**
             * @en The local uniform buffer object
             * @zh 本地 UBO。
             */

            var UBOLocal = function UBOLocal() {
              _classCallCheck(this, UBOLocal);
            };
            UBOLocal.MAT_WORLD_OFFSET = 0;
            UBOLocal.MAT_WORLD_IT_OFFSET = UBOLocal.MAT_WORLD_OFFSET + 16;
            UBOLocal.LIGHTINGMAP_UVPARAM = UBOLocal.MAT_WORLD_IT_OFFSET + 16;
            UBOLocal.COUNT = UBOLocal.LIGHTINGMAP_UVPARAM + 4;
            UBOLocal.SIZE = UBOLocal.COUNT * 4;
            UBOLocal.BLOCK = {
              stageFlags: GFXShaderStageFlagBit.VERTEX,
              descriptorType: GFXDescriptorType.UNIFORM_BUFFER,
              count: 1,
              set: SetIndex.LOCAL,
              binding: ModelLocalBindings.UBO_LOCAL,
              name: 'CCLocal',
              members: [{
                name: 'cc_matWorld',
                type: GFXType.MAT4,
                count: 1
              }, {
                name: 'cc_matWorldIT',
                type: GFXType.MAT4,
                count: 1
              }, {
                name: 'cc_lightingMapUVParam',
                type: GFXType.FLOAT4,
                count: 1
              }]
            };
            localDescriptorSetLayout.record[UBOLocal.BLOCK.name] = UBOLocal.BLOCK;
            localDescriptorSetLayout.bindings[UBOLocal.BLOCK.binding] = UBOLocal.BLOCK;
            var INST_MAT_WORLD = 'a_matWorld0';
            var UBOLocalBatched = function UBOLocalBatched() {
              _classCallCheck(this, UBOLocalBatched);
            };
            UBOLocalBatched.BATCHING_COUNT = 10;
            UBOLocalBatched.MAT_WORLDS_OFFSET = 0;
            UBOLocalBatched.COUNT = 16 * UBOLocalBatched.BATCHING_COUNT;
            UBOLocalBatched.SIZE = UBOLocalBatched.COUNT * 4;
            UBOLocalBatched.BLOCK = {
              stageFlags: GFXShaderStageFlagBit.VERTEX,
              descriptorType: GFXDescriptorType.UNIFORM_BUFFER,
              count: 1,
              set: SetIndex.LOCAL,
              binding: ModelLocalBindings.UBO_LOCAL,
              name: 'CCLocalBatched',
              members: [{
                name: 'cc_matWorlds',
                type: GFXType.MAT4,
                count: UBOLocalBatched.BATCHING_COUNT
              }]
            };
            localDescriptorSetLayout.record[UBOLocalBatched.BLOCK.name] = UBOLocalBatched.BLOCK;
            localDescriptorSetLayout.bindings[UBOLocalBatched.BLOCK.binding] = UBOLocalBatched.BLOCK;
            /**
             * @en The uniform buffer object for forward lighting
             * @zh 前向灯光 UBO。
             */

            var UBOForwardLight = function UBOForwardLight() {
              _classCallCheck(this, UBOForwardLight);
            };
            UBOForwardLight.LIGHTS_PER_PASS = 1;
            UBOForwardLight.LIGHT_POS_OFFSET = 0;
            UBOForwardLight.LIGHT_COLOR_OFFSET = UBOForwardLight.LIGHT_POS_OFFSET + UBOForwardLight.LIGHTS_PER_PASS * 4;
            UBOForwardLight.LIGHT_SIZE_RANGE_ANGLE_OFFSET = UBOForwardLight.LIGHT_COLOR_OFFSET + UBOForwardLight.LIGHTS_PER_PASS * 4;
            UBOForwardLight.LIGHT_DIR_OFFSET = UBOForwardLight.LIGHT_SIZE_RANGE_ANGLE_OFFSET + UBOForwardLight.LIGHTS_PER_PASS * 4;
            UBOForwardLight.COUNT = UBOForwardLight.LIGHT_DIR_OFFSET + UBOForwardLight.LIGHTS_PER_PASS * 4;
            UBOForwardLight.SIZE = UBOForwardLight.COUNT * 4;
            UBOForwardLight.BLOCK = {
              stageFlags: GFXShaderStageFlagBit.FRAGMENT,
              descriptorType: GFXDescriptorType.DYNAMIC_UNIFORM_BUFFER,
              count: 1,
              set: SetIndex.LOCAL,
              binding: ModelLocalBindings.UBO_FORWARD_LIGHTS,
              name: 'CCForwardLight',
              members: [{
                name: 'cc_lightPos',
                type: GFXType.FLOAT4,
                count: UBOForwardLight.LIGHTS_PER_PASS
              }, {
                name: 'cc_lightColor',
                type: GFXType.FLOAT4,
                count: UBOForwardLight.LIGHTS_PER_PASS
              }, {
                name: 'cc_lightSizeRangeAngle',
                type: GFXType.FLOAT4,
                count: UBOForwardLight.LIGHTS_PER_PASS
              }, {
                name: 'cc_lightDir',
                type: GFXType.FLOAT4,
                count: UBOForwardLight.LIGHTS_PER_PASS
              }]
            };
            localDescriptorSetLayout.record[UBOForwardLight.BLOCK.name] = UBOForwardLight.BLOCK;
            localDescriptorSetLayout.bindings[UBOForwardLight.BLOCK.binding] = UBOForwardLight.BLOCK; // The actual uniform vectors used is JointUniformCapacity * 3.
            // We think this is a reasonable default capacity considering MAX_VERTEX_UNIFORM_VECTORS in WebGL spec is just 128.
            // Skinning models with number of bones more than this capacity will be automatically switched to texture skinning.
            // But still, you can tweak this for your own need by changing the number below
            // and the JOINT_UNIFORM_CAPACITY macro in cc-skinning shader header.

            var JOINT_UNIFORM_CAPACITY = 30;
            /**
             * @en The uniform buffer object for skinning texture
             * @zh 骨骼贴图 UBO。
             */

            var UBOSkinningTexture = exports('dH', function UBOSkinningTexture() {
              _classCallCheck(this, UBOSkinningTexture);
            });
            UBOSkinningTexture.JOINTS_TEXTURE_INFO_OFFSET = 0;
            UBOSkinningTexture.COUNT = UBOSkinningTexture.JOINTS_TEXTURE_INFO_OFFSET + 4;
            UBOSkinningTexture.SIZE = UBOSkinningTexture.COUNT * 4;
            UBOSkinningTexture.BLOCK = {
              stageFlags: GFXShaderStageFlagBit.VERTEX,
              descriptorType: GFXDescriptorType.UNIFORM_BUFFER,
              count: 1,
              set: SetIndex.LOCAL,
              binding: ModelLocalBindings.UBO_SKINNING_TEXTURE,
              name: 'CCSkinningTexture',
              members: [{
                name: 'cc_jointTextureInfo',
                type: GFXType.FLOAT4,
                count: 1
              }]
            };
            localDescriptorSetLayout.record[UBOSkinningTexture.BLOCK.name] = UBOSkinningTexture.BLOCK;
            localDescriptorSetLayout.bindings[UBOSkinningTexture.BLOCK.binding] = UBOSkinningTexture.BLOCK;
            var UBOSkinningAnimation = exports('dJ', function UBOSkinningAnimation() {
              _classCallCheck(this, UBOSkinningAnimation);
            });
            UBOSkinningAnimation.JOINTS_ANIM_INFO_OFFSET = 0;
            UBOSkinningAnimation.COUNT = UBOSkinningAnimation.JOINTS_ANIM_INFO_OFFSET + 4;
            UBOSkinningAnimation.SIZE = UBOSkinningAnimation.COUNT * 4;
            UBOSkinningAnimation.BLOCK = {
              stageFlags: GFXShaderStageFlagBit.VERTEX,
              descriptorType: GFXDescriptorType.UNIFORM_BUFFER,
              count: 1,
              set: SetIndex.LOCAL,
              binding: ModelLocalBindings.UBO_SKINNING_ANIMATION,
              name: 'CCSkinningAnimation',
              members: [{
                name: 'cc_jointAnimInfo',
                type: GFXType.FLOAT4,
                count: 1
              }]
            };
            localDescriptorSetLayout.record[UBOSkinningAnimation.BLOCK.name] = UBOSkinningAnimation.BLOCK;
            localDescriptorSetLayout.bindings[UBOSkinningAnimation.BLOCK.binding] = UBOSkinningAnimation.BLOCK;
            var INST_JOINT_ANIM_INFO = exports('dK', 'a_jointAnimInfo');
            var UBOSkinning = function UBOSkinning() {
              _classCallCheck(this, UBOSkinning);
            };
            UBOSkinning.JOINTS_OFFSET = 0;
            UBOSkinning.COUNT = UBOSkinning.JOINTS_OFFSET + JOINT_UNIFORM_CAPACITY * 12;
            UBOSkinning.SIZE = UBOSkinning.COUNT * 4;
            UBOSkinning.BLOCK = {
              stageFlags: GFXShaderStageFlagBit.VERTEX,
              descriptorType: GFXDescriptorType.UNIFORM_BUFFER,
              count: 1,
              set: SetIndex.LOCAL,
              binding: ModelLocalBindings.UBO_SKINNING_TEXTURE,
              name: 'CCSkinning',
              members: [{
                name: 'cc_joints',
                type: GFXType.FLOAT4,
                count: JOINT_UNIFORM_CAPACITY * 3
              }]
            };
            localDescriptorSetLayout.record[UBOSkinning.BLOCK.name] = UBOSkinning.BLOCK;
            localDescriptorSetLayout.bindings[UBOSkinning.BLOCK.binding] = UBOSkinning.BLOCK;
            /**
             * @en The uniform buffer object for morph setting
             * @zh 形变配置的 UBO
             */

            var UBOMorph = function UBOMorph() {
              _classCallCheck(this, UBOMorph);
            };
            UBOMorph.MAX_MORPH_TARGET_COUNT = 60;
            UBOMorph.OFFSET_OF_WEIGHTS = 0;
            UBOMorph.OFFSET_OF_DISPLACEMENT_TEXTURE_WIDTH = 4 * UBOMorph.MAX_MORPH_TARGET_COUNT;
            UBOMorph.OFFSET_OF_DISPLACEMENT_TEXTURE_HEIGHT = UBOMorph.OFFSET_OF_DISPLACEMENT_TEXTURE_WIDTH + 4;
            UBOMorph.COUNT_BASE_4_BYTES = 4 * Math.ceil(UBOMorph.MAX_MORPH_TARGET_COUNT / 4) + 4;
            UBOMorph.SIZE = UBOMorph.COUNT_BASE_4_BYTES * 4;
            UBOMorph.BLOCK = {
              stageFlags: GFXShaderStageFlagBit.VERTEX,
              descriptorType: GFXDescriptorType.UNIFORM_BUFFER,
              count: 1,
              set: SetIndex.LOCAL,
              binding: ModelLocalBindings.UBO_MORPH,
              name: 'CCMorph',
              members: [{
                name: 'cc_displacementWeights',
                type: GFXType.FLOAT4,
                count: UBOMorph.MAX_MORPH_TARGET_COUNT / 4
              }, {
                name: 'cc_displacementTextureInfo',
                type: GFXType.FLOAT4,
                count: 1
              }]
            };
            localDescriptorSetLayout.record[UBOMorph.BLOCK.name] = UBOMorph.BLOCK;
            localDescriptorSetLayout.bindings[UBOMorph.BLOCK.binding] = UBOMorph.BLOCK;
            /**
             * @en The sampler for joint texture
             * @zh 骨骼纹理采样器。
             */

            var UniformJointTexture = exports('dI', {
              stageFlags: GFXShaderStageFlagBit.VERTEX,
              descriptorType: GFXDescriptorType.SAMPLER,
              count: 1,
              set: SetIndex.LOCAL,
              binding: ModelLocalBindings.SAMPLER_JOINTS,
              name: 'cc_jointTexture',
              type: GFXType.SAMPLER2D
            });
            localDescriptorSetLayout.record[UniformJointTexture.name] = UniformJointTexture;
            localDescriptorSetLayout.bindings[UniformJointTexture.binding] = UniformJointTexture;
            /**
             * @en The sampler for morph texture of position
             * @zh 位置形变纹理采样器。
             */

            var UniformPositionMorphTexture = {
              stageFlags: GFXShaderStageFlagBit.VERTEX,
              descriptorType: GFXDescriptorType.SAMPLER,
              count: 1,
              set: SetIndex.LOCAL,
              binding: ModelLocalBindings.SAMPLER_MORPH_POSITION,
              name: 'cc_PositionDisplacements',
              type: GFXType.SAMPLER2D
            };
            localDescriptorSetLayout.record[UniformPositionMorphTexture.name] = UniformPositionMorphTexture;
            localDescriptorSetLayout.bindings[UniformPositionMorphTexture.binding] = UniformPositionMorphTexture;
            /**
             * @en The sampler for morph texture of normal
             * @zh 法线形变纹理采样器。
             */

            var UniformNormalMorphTexture = {
              stageFlags: GFXShaderStageFlagBit.VERTEX,
              descriptorType: GFXDescriptorType.SAMPLER,
              count: 1,
              set: SetIndex.LOCAL,
              binding: ModelLocalBindings.SAMPLER_MORPH_NORMAL,
              name: 'cc_NormalDisplacements',
              type: GFXType.SAMPLER2D
            };
            localDescriptorSetLayout.record[UniformNormalMorphTexture.name] = UniformNormalMorphTexture;
            localDescriptorSetLayout.bindings[UniformNormalMorphTexture.binding] = UniformNormalMorphTexture;
            /**
             * @en The sampler for morph texture of tangent
             * @zh 切线形变纹理采样器。
             */

            var UniformTangentMorphTexture = {
              stageFlags: GFXShaderStageFlagBit.VERTEX,
              descriptorType: GFXDescriptorType.SAMPLER,
              count: 1,
              set: SetIndex.LOCAL,
              binding: ModelLocalBindings.SAMPLER_MORPH_TANGENT,
              name: 'cc_TangentDisplacements',
              type: GFXType.SAMPLER2D
            };
            localDescriptorSetLayout.record[UniformTangentMorphTexture.name] = UniformTangentMorphTexture;
            localDescriptorSetLayout.bindings[UniformTangentMorphTexture.binding] = UniformTangentMorphTexture;
            /**
             * @en The sampler for light map texture
             * @zh 光照图纹理采样器。
             */

            var UniformLightingMapSampler = {
              stageFlags: GFXShaderStageFlagBit.FRAGMENT,
              descriptorType: GFXDescriptorType.SAMPLER,
              count: 1,
              set: SetIndex.LOCAL,
              binding: ModelLocalBindings.SAMPLER_LIGHTING_MAP,
              name: 'cc_lightingMap',
              type: GFXType.SAMPLER2D
            };
            localDescriptorSetLayout.record[UniformLightingMapSampler.name] = UniformLightingMapSampler;
            localDescriptorSetLayout.bindings[UniformLightingMapSampler.binding] = UniformLightingMapSampler;
            /**
             * @en The sampler for UI sprites.
             * @zh UI 精灵纹理采样器。
             */

            var UniformSpriteSampler = {
              stageFlags: GFXShaderStageFlagBit.FRAGMENT,
              descriptorType: GFXDescriptorType.SAMPLER,
              count: 1,
              set: SetIndex.LOCAL,
              binding: ModelLocalBindings.SAMPLER_SPRITE,
              name: 'cc_spriteTexture',
              type: GFXType.SAMPLER2D
            };
            localDescriptorSetLayout.record[UniformSpriteSampler.name] = UniformSpriteSampler;
            localDescriptorSetLayout.bindings[UniformSpriteSampler.binding] = UniformSpriteSampler;
            var CAMERA_DEFAULT_MASK = exports('dS', Layers.makeMaskExclude([Layers.BitMask.UI_2D, Layers.BitMask.GIZMOS, Layers.BitMask.EDITOR, Layers.BitMask.SCENE_GIZMO, Layers.BitMask.PROFILER]));
            var CAMERA_EDITOR_MASK = Layers.makeMaskExclude([Layers.BitMask.UI_2D, Layers.BitMask.PROFILER]);
            var MODEL_ALWAYS_MASK = Layers.Enum.ALL;

            var pipelineDefine = /*#__PURE__*/Object.freeze({
                __proto__: null,
                PIPELINE_FLOW_FORWARD: PIPELINE_FLOW_FORWARD,
                PIPELINE_FLOW_SHADOW: PIPELINE_FLOW_SHADOW,
                PIPELINE_FLOW_SMAA: PIPELINE_FLOW_SMAA,
                PIPELINE_FLOW_TONEMAP: PIPELINE_FLOW_TONEMAP,
                get RenderPassStage () { return RenderPassStage; },
                get RenderPriority () { return RenderPriority; },
                globalDescriptorSetLayout: globalDescriptorSetLayout,
                localDescriptorSetLayout: localDescriptorSetLayout,
                get PipelineGlobalBindings () { return PipelineGlobalBindings; },
                get ModelLocalBindings () { return ModelLocalBindings; },
                isBuiltinBinding: isBuiltinBinding,
                get SetIndex () { return SetIndex; },
                bindingMappingInfo: bindingMappingInfo,
                UBOGlobal: UBOGlobal,
                UBOShadow: UBOShadow,
                UNIFORM_SHADOWMAP: UNIFORM_SHADOWMAP,
                UNIFORM_ENVIRONMENT: UNIFORM_ENVIRONMENT,
                UBOLocal: UBOLocal,
                INST_MAT_WORLD: INST_MAT_WORLD,
                UBOLocalBatched: UBOLocalBatched,
                UBOForwardLight: UBOForwardLight,
                JOINT_UNIFORM_CAPACITY: JOINT_UNIFORM_CAPACITY,
                UBOSkinningTexture: UBOSkinningTexture,
                UBOSkinningAnimation: UBOSkinningAnimation,
                INST_JOINT_ANIM_INFO: INST_JOINT_ANIM_INFO,
                UBOSkinning: UBOSkinning,
                UBOMorph: UBOMorph,
                UniformJointTexture: UniformJointTexture,
                UniformPositionMorphTexture: UniformPositionMorphTexture,
                UniformNormalMorphTexture: UniformNormalMorphTexture,
                UniformTangentMorphTexture: UniformTangentMorphTexture,
                UniformLightingMapSampler: UniformLightingMapSampler,
                UniformSpriteSampler: UniformSpriteSampler,
                CAMERA_DEFAULT_MASK: CAMERA_DEFAULT_MASK,
                CAMERA_EDITOR_MASK: CAMERA_EDITOR_MASK,
                MODEL_ALWAYS_MASK: MODEL_ALWAYS_MASK
            });
            exports('au', pipelineDefine);

            /**
             * Standard morph rendering.
             * The standard morph rendering renders each of sub-mesh morph separately.
             * Sub-mesh morph rendering may select different technique according sub-mesh morph itself.
             */

            var StdMorphRendering = /*#__PURE__*/function () {
              function StdMorphRendering(mesh, gfxDevice) {
                _classCallCheck(this, StdMorphRendering);

                this._mesh = void 0;
                this._subMeshRenderings = [];
                this._mesh = mesh;

                if (!this._mesh.struct.morph) {
                  return;
                }

                var nSubMeshes = this._mesh.struct.primitives.length;
                this._subMeshRenderings = new Array(nSubMeshes).fill(null);

                for (var iSubMesh = 0; iSubMesh < nSubMeshes; ++iSubMesh) {
                  var subMeshMorph = this._mesh.struct.morph.subMeshMorphs[iSubMesh];

                  if (!subMeshMorph) {
                    continue;
                  }

                  if (subMeshMorph.targets.length > UBOMorph.MAX_MORPH_TARGET_COUNT) {
                    warnID(10002, UBOMorph.MAX_MORPH_TARGET_COUNT, subMeshMorph.targets.length);
                    continue;
                  }

                  {
                    this._subMeshRenderings[iSubMesh] = new GpuComputing(this._mesh, iSubMesh, this._mesh.struct.morph, gfxDevice);
                  }
                }
              }

              _createClass(StdMorphRendering, [{
                key: "createInstance",
                value: function createInstance() {
                  var _this = this;

                  var nSubMeshes = this._mesh.struct.primitives.length;
                  var subMeshInstances = new Array(nSubMeshes);

                  for (var iSubMesh = 0; iSubMesh < nSubMeshes; ++iSubMesh) {
                    var _this$_subMeshRenderi, _this$_subMeshRenderi2;

                    subMeshInstances[iSubMesh] = (_this$_subMeshRenderi = (_this$_subMeshRenderi2 = this._subMeshRenderings[iSubMesh]) === null || _this$_subMeshRenderi2 === void 0 ? void 0 : _this$_subMeshRenderi2.createInstance()) !== null && _this$_subMeshRenderi !== void 0 ? _this$_subMeshRenderi : null;
                  }

                  return {
                    setWeights: function setWeights(subMeshIndex, weights) {
                      var _subMeshInstances$sub;

                      (_subMeshInstances$sub = subMeshInstances[subMeshIndex]) === null || _subMeshInstances$sub === void 0 ? void 0 : _subMeshInstances$sub.setWeights(weights);
                    },
                    requiredPatches: function requiredPatches(subMeshIndex) {
                      assertIsNonNullable(_this._mesh.struct.morph);
                      var subMeshMorph = _this._mesh.struct.morph.subMeshMorphs[subMeshIndex];
                      var subMeshRenderingInstance = subMeshInstances[subMeshIndex];

                      if (subMeshRenderingInstance === null) {
                        return;
                      }

                      assertIsNonNullable(subMeshMorph);
                      var patches = [{
                        name: 'CC_USE_MORPH',
                        value: true
                      }, {
                        name: 'CC_MORPH_TARGET_COUNT',
                        value: subMeshMorph.targets.length
                      }];

                      if (subMeshMorph.attributes.includes(GFXAttributeName.ATTR_POSITION)) {
                        patches.push({
                          name: 'CC_MORPH_TARGET_HAS_POSITION',
                          value: true
                        });
                      }

                      if (subMeshMorph.attributes.includes(GFXAttributeName.ATTR_NORMAL)) {
                        patches.push({
                          name: 'CC_MORPH_TARGET_HAS_NORMAL',
                          value: true
                        });
                      }

                      if (subMeshMorph.attributes.includes(GFXAttributeName.ATTR_TANGENT)) {
                        patches.push({
                          name: 'CC_MORPH_TARGET_HAS_TANGENT',
                          value: true
                        });
                      }

                      patches.push.apply(patches, _toConsumableArray(subMeshRenderingInstance.requiredPatches()));
                      return patches;
                    },
                    adaptPipelineState: function adaptPipelineState(subMeshIndex, descriptorSet) {
                      var _subMeshInstances$sub2;

                      (_subMeshInstances$sub2 = subMeshInstances[subMeshIndex]) === null || _subMeshInstances$sub2 === void 0 ? void 0 : _subMeshInstances$sub2.adaptPipelineState(descriptorSet);
                    },
                    destroy: function destroy() {
                      for (var _iterator = _createForOfIteratorHelperLoose(subMeshInstances), _step; !(_step = _iterator()).done;) {
                        var subMeshInstance = _step.value;
                        subMeshInstance === null || subMeshInstance === void 0 ? void 0 : subMeshInstance.destroy();
                      }
                    }
                  };
                }
              }]);

              return StdMorphRendering;
            }();
            /**
             * Describes how to render a sub-mesh morph.
             */

            /**
             * (General purpose) Gpu computing based sub-mesh morph rendering.
             * This technique computes final attribute displacements on GPU.
             * Target displacements of each attribute are transferred through vertex texture, say, morph texture.
             */
            var GpuComputing = /*#__PURE__*/function () {
              function GpuComputing(mesh, subMeshIndex, morph, gfxDevice) {
                _classCallCheck(this, GpuComputing);

                this._gfxDevice = void 0;
                this._subMeshMorph = void 0;
                this._textureInfo = void 0;
                this._attributes = void 0;
                this._gfxDevice = gfxDevice;
                var subMeshMorph = morph.subMeshMorphs[subMeshIndex];
                assertIsNonNullable(subMeshMorph);
                this._subMeshMorph = subMeshMorph;
                enableVertexId(mesh, subMeshIndex, gfxDevice);
                var nVertices = mesh.struct.vertexBundles[mesh.struct.primitives[subMeshIndex].vertexBundelIndices[0]].view.count;
                var nTargets = subMeshMorph.targets.length; // Head includes N vector 4, where N is number of targets.
                // Every r channel of the pixel denotes the index of the data pixel of corresponding target.
                // [ (target1_data_offset), (target2_data_offset), .... ] target_data

                var vec4Required = nTargets + nVertices * nTargets;
                var vec4TextureFactory = createVec4TextureFactory(gfxDevice, vec4Required);
                this._textureInfo = {
                  width: vec4TextureFactory.width,
                  height: vec4TextureFactory.height
                }; // Creates texture for each attribute.

                this._attributes = subMeshMorph.attributes.map(function (attributeName, attributeIndex) {
                  var vec4Tex = vec4TextureFactory.create();
                  var valueView = vec4Tex.valueView; // if (DEV) { // Make it easy to view texture in profilers...
                  //     for (let i = 0; i < valueView.length / 4; ++i) {
                  //         valueView[i * 4 + 3] = 1.0;
                  //     }
                  // }

                  {
                    var pHead = 0;
                    var nVec4s = subMeshMorph.targets.length;
                    subMeshMorph.targets.forEach(function (morphTarget) {
                      var displacementsView = morphTarget.displacements[attributeIndex];
                      var displacements = new Float32Array(mesh.data.buffer, mesh.data.byteOffset + displacementsView.offset, displacementsView.count);
                      var nVec3s = displacements.length / 3; // See `Mesh.prototype.enableVertexIdChannel` for the magic `0.5`.

                      valueView[pHead] = nVec4s + 0.5;
                      var displacementsOffset = nVec4s * 4;

                      for (var iVec3 = 0; iVec3 < nVec3s; ++iVec3) {
                        valueView[displacementsOffset + 4 * iVec3 + 0] = displacements[3 * iVec3 + 0];
                        valueView[displacementsOffset + 4 * iVec3 + 1] = displacements[3 * iVec3 + 1];
                        valueView[displacementsOffset + 4 * iVec3 + 2] = displacements[3 * iVec3 + 2];
                      }

                      pHead += 4;
                      nVec4s += nVec3s;
                    });
                  }
                  vec4Tex.updatePixels();
                  return {
                    name: attributeName,
                    morphTexture: vec4Tex
                  };
                });
              }

              _createClass(GpuComputing, [{
                key: "destroy",
                value: function destroy() {
                  for (var _iterator2 = _createForOfIteratorHelperLoose(this._attributes), _step2; !(_step2 = _iterator2()).done;) {
                    var attribute = _step2.value;
                    attribute.morphTexture.destroy();
                  }
                }
              }, {
                key: "createInstance",
                value: function createInstance() {
                  var _this2 = this;

                  var morphUniforms = new MorphUniforms(this._gfxDevice, this._subMeshMorph.targets.length);
                  morphUniforms.setMorphTextureInfo(this._textureInfo.width, this._textureInfo.height);
                  morphUniforms.commit();
                  return {
                    setWeights: function setWeights(weights) {
                      morphUniforms.setWeights(weights);
                      morphUniforms.commit();
                    },
                    requiredPatches: function requiredPatches() {
                      return [{
                        name: 'CC_MORPH_TARGET_USE_TEXTURE',
                        value: true
                      }];
                    },
                    adaptPipelineState: function adaptPipelineState(descriptorSet) {
                      for (var _iterator3 = _createForOfIteratorHelperLoose(_this2._attributes), _step3; !(_step3 = _iterator3()).done;) {
                        var attribute = _step3.value;
                        var binding = void 0;

                        switch (attribute.name) {
                          case GFXAttributeName.ATTR_POSITION:
                            binding = UniformPositionMorphTexture.binding;
                            break;

                          case GFXAttributeName.ATTR_NORMAL:
                            binding = UniformNormalMorphTexture.binding;
                            break;

                          case GFXAttributeName.ATTR_TANGENT:
                            binding = UniformTangentMorphTexture.binding;
                            break;

                          default:
                            warn("Unexpected attribute!");
                            break;
                        }

                        if (binding !== undefined) {
                          descriptorSet.bindSampler(binding, attribute.morphTexture.sampler);
                          descriptorSet.bindTexture(binding, attribute.morphTexture.texture);
                        }
                      }

                      descriptorSet.bindBuffer(UBOMorph.BLOCK.binding, morphUniforms.buffer);
                      descriptorSet.update();
                    },
                    destroy: function destroy() {}
                  };
                }
              }]);

              return GpuComputing;
            }();
            /**
             * Provides the access to morph related uniforms.
             */


            var MorphUniforms = /*#__PURE__*/function () {
              function MorphUniforms(gfxDevice, targetCount) {
                _classCallCheck(this, MorphUniforms);

                this._targetCount = void 0;
                this._localBuffer = void 0;
                this._remoteBuffer = void 0;
                this._targetCount = targetCount;
                this._localBuffer = new DataView(new ArrayBuffer(UBOMorph.SIZE));
                this._remoteBuffer = gfxDevice.createBuffer({
                  usage: GFXBufferUsageBit.UNIFORM | GFXBufferUsageBit.TRANSFER_DST,
                  memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                  size: UBOMorph.SIZE,
                  stride: UBOMorph.SIZE
                });
              }

              _createClass(MorphUniforms, [{
                key: "destroy",
                value: function destroy() {
                  this._remoteBuffer.destroy();
                }
              }, {
                key: "setWeights",
                value: function setWeights(weights) {
                  assertIsTrue(weights.length === this._targetCount);

                  for (var iWeight = 0; iWeight < weights.length; ++iWeight) {
                    this._localBuffer.setFloat32(UBOMorph.OFFSET_OF_WEIGHTS + 4 * iWeight, weights[iWeight], legacyCC.sys.isLittleEndian);
                  }
                }
              }, {
                key: "setMorphTextureInfo",
                value: function setMorphTextureInfo(width, height) {
                  this._localBuffer.setFloat32(UBOMorph.OFFSET_OF_DISPLACEMENT_TEXTURE_WIDTH, width, legacyCC.sys.isLittleEndian);

                  this._localBuffer.setFloat32(UBOMorph.OFFSET_OF_DISPLACEMENT_TEXTURE_HEIGHT, height, legacyCC.sys.isLittleEndian);
                }
              }, {
                key: "commit",
                value: function commit() {
                  this._remoteBuffer.update(this._localBuffer.buffer, this._localBuffer.byteOffset, this._localBuffer.byteLength);
                }
              }, {
                key: "buffer",
                get: function get() {
                  return this._remoteBuffer;
                }
              }]);

              return MorphUniforms;
            }();
            /**
             *
             * @param gfxDevice
             * @param vec4Capacity Capacity of vec4.
             */


            function createVec4TextureFactory(gfxDevice, vec4Capacity) {
              var hasFeatureFloatTexture = gfxDevice.hasFeature(GFXFeature.TEXTURE_FLOAT);
              var pixelRequired;
              var pixelFormat;
              var pixelBytes;
              var updateViewConstructor;

              if (hasFeatureFloatTexture) {
                pixelRequired = vec4Capacity;
                pixelBytes = 16;
                pixelFormat = Texture2D.PixelFormat.RGBA32F;
                updateViewConstructor = Float32Array;
              } else {
                pixelRequired = 4 * vec4Capacity;
                pixelBytes = 4;
                pixelFormat = Texture2D.PixelFormat.RGBA8888;
                updateViewConstructor = Uint8Array;
              }

              var _bestSizeToHavePixels = bestSizeToHavePixels(pixelRequired),
                  width = _bestSizeToHavePixels.width,
                  height = _bestSizeToHavePixels.height;

              assertIsTrue(width * height >= pixelRequired);
              return {
                width: width,
                height: height,
                create: function create() {
                  var arrayBuffer = new ArrayBuffer(width * height * pixelBytes);
                  var valueView = new Float32Array(arrayBuffer);
                  var updateView = updateViewConstructor === Float32Array ? valueView : new updateViewConstructor(arrayBuffer);
                  var image = new ImageAsset({
                    width: width,
                    height: height,
                    _data: updateView,
                    _compressed: false,
                    format: pixelFormat
                  });
                  var textureAsset = new Texture2D();
                  textureAsset.setFilters(Texture2D.Filter.NEAREST, Texture2D.Filter.NEAREST);
                  textureAsset.setMipFilter(Texture2D.Filter.NONE);
                  textureAsset.setWrapMode(Texture2D.WrapMode.CLAMP_TO_EDGE, Texture2D.WrapMode.CLAMP_TO_EDGE, Texture2D.WrapMode.CLAMP_TO_EDGE);
                  textureAsset.image = image;

                  if (!textureAsset.getGFXTexture()) {
                    warn("Unexpected: failed to create morph texture?");
                  }

                  var sampler = samplerLib.getSampler(gfxDevice, textureAsset.getSamplerHash());
                  return {
                    /**
                     * Gets the GFX texture.
                     */
                    get texture() {
                      return textureAsset.getGFXTexture();
                    },

                    /**
                     * Gets the GFX sampler.
                     */
                    get sampler() {
                      return sampler;
                    },

                    /**
                     * Value view.
                     */
                    get valueView() {
                      return valueView;
                    },

                    /**
                     * Destroy the texture. Release its GPU resources.
                     */
                    destroy: function destroy() {
                      textureAsset.destroy(); // Samplers allocated from `samplerLib` are not required and
                      // should not be destroyed.
                      // this._sampler.destroy();
                    },

                    /**
                     * Update the pixels content to `valueView`.
                     */
                    updatePixels: function updatePixels() {
                      textureAsset.uploadData(updateView);
                    }
                  };
                }
              };
            }

            /**
             * When use vertex-texture-fetch technique, we do need
             * `gl_vertexId` when we sample per-vertex data.
             * WebGL 1.0 does not have `gl_vertexId`; WebGL 2.0, however, does.
             * @param mesh
             * @param subMeshIndex
             * @param gfxDevice
             */
            function enableVertexId(mesh, subMeshIndex, gfxDevice) {
              mesh.renderingSubMeshes[subMeshIndex].enableVertexIdChannel(gfxDevice);
            }
            /**
             * Decides a best texture size to have the specified pixel capacity at least.
             * The decided width and height has the following characteristics:
             * - the width and height are both power of 2;
             * - if the width and height are different, the width would be set to the larger once;
             * - the width is ensured to be multiple of 4.
             * @param nPixels Least pixel capacity.
             */


            function bestSizeToHavePixels(nPixels) {
              if (nPixels < 5) {
                nPixels = 5;
              }

              var aligned = nextPow2(nPixels);
              var epxSum = log2(aligned);
              var h = epxSum >> 1;
              var w = epxSum & 1 ? h + 1 : h;
              return {
                width: 1 << w,
                height: 1 << h
              };
            }

            /**
             * @hidden
             */
            function createMorphRendering(mesh, gfxDevice) {
              return new StdMorphRendering(mesh, gfxDevice);
            }
            /**
             * Class which control rendering of a morph resource.
             */

            var _dec$5, _class$5, _class2$4, _descriptor$3, _descriptor2$2, _descriptor3$2, _temp$5;

            function getIndexStrideCtor(stride) {
              switch (stride) {
                case 1:
                  return Uint8Array;

                case 2:
                  return Uint16Array;

                case 4:
                  return Uint32Array;
              }

              return Uint8Array;
            }
            /**
             * @en Array views for index buffer
             * @zh 允许存储索引的数组视图。
             */


            /**
             * @en Sub mesh for rendering which contains all geometry data, it can be used to create [[GFXInputAssembler]].
             * @zh 包含所有顶点数据的渲染子网格，可以用来创建 [[GFXInputAssembler]]。
             */
            var RenderingSubMesh = exports('b4', /*#__PURE__*/function () {
              _createClass(RenderingSubMesh, [{
                key: "geometricInfo",

                /**
                 * @en All vertex buffers used by the sub mesh
                 * @zh 使用的所有顶点缓冲区。
                 */

                /**
                 * @en All vertex attributes used by the sub mesh
                 * @zh 所有顶点属性。
                 */

                /**
                 * @en Primitive mode used by the sub mesh
                 * @zh 图元类型。
                 */

                /**
                 * @en Index buffer used by the sub mesh
                 * @zh 使用的索引缓冲区，若未使用则无需指定。
                 */

                /**
                 * @en Indirect buffer used by the sub mesh
                 * @zh 间接绘制缓冲区。
                 */

                /**
                 * @en The geometric info of the sub mesh, used for raycast.
                 * @zh （用于射线检测的）几何信息。
                 */
                get: function get() {
                  if (this._geometricInfo) {
                    return this._geometricInfo;
                  }

                  if (this.mesh === undefined) {
                    return {
                      positions: new Float32Array(),
                      indices: new Uint8Array(),
                      boundingBox: {
                        min: Vec3.ZERO,
                        max: Vec3.ZERO
                      }
                    };
                  }

                  if (this.subMeshIdx === undefined) {
                    return {
                      positions: new Float32Array(),
                      indices: new Uint8Array(),
                      boundingBox: {
                        min: Vec3.ZERO,
                        max: Vec3.ZERO
                      }
                    };
                  }

                  var mesh = this.mesh;
                  var index = this.subMeshIdx;
                  var positions = mesh.readAttribute(index, GFXAttributeName.ATTR_POSITION);
                  var indices = mesh.readIndices(index);
                  var max = new Vec3();
                  var min = new Vec3();
                  var pAttri = this.attributes.find(function (element) {
                    return element.name === legacyCC.GFXAttributeName.ATTR_POSITION;
                  });

                  if (pAttri) {
                    var conut = GFXFormatInfos[pAttri.format].count;

                    if (conut === 2) {
                      max.set(positions[0], positions[1], 0);
                      min.set(positions[0], positions[1], 0);
                    } else {
                      max.set(positions[0], positions[1], positions[2]);
                      min.set(positions[0], positions[1], positions[2]);
                    }

                    for (var i = 0; i < positions.length; i += conut) {
                      if (conut === 2) {
                        max.x = positions[i] > max.x ? positions[i] : max.x;
                        max.y = positions[i + 1] > max.y ? positions[i + 1] : max.y;
                        min.x = positions[i] < min.x ? positions[i] : min.x;
                        min.y = positions[i + 1] < min.y ? positions[i + 1] : min.y;
                      } else {
                        max.x = positions[i] > max.x ? positions[i] : max.x;
                        max.y = positions[i + 1] > max.y ? positions[i + 1] : max.y;
                        max.z = positions[i + 2] > max.z ? positions[i + 2] : max.z;
                        min.x = positions[i] < min.x ? positions[i] : min.x;
                        min.y = positions[i + 1] < min.y ? positions[i + 1] : min.y;
                        min.z = positions[i + 2] < min.z ? positions[i + 2] : min.z;
                      }
                    }
                  }

                  this._geometricInfo = {
                    positions: positions,
                    indices: indices,
                    boundingBox: {
                      max: max,
                      min: min
                    }
                  };
                  return this._geometricInfo;
                }
                /**
                 * @en Flatted vertex buffers
                 * @zh 扁平化的顶点缓冲区。
                 */

              }, {
                key: "flatBuffers",
                get: function get() {
                  if (this._flatBuffers) {
                    return this._flatBuffers;
                  }

                  var buffers = this._flatBuffers = [];

                  if (!this.mesh || this.subMeshIdx === undefined) {
                    return buffers;
                  }

                  var mesh = this.mesh;
                  var idxCount = 0;
                  var prim = mesh.struct.primitives[this.subMeshIdx];

                  if (prim.indexView) {
                    idxCount = prim.indexView.count;
                  }

                  for (var _iterator = _createForOfIteratorHelperLoose(prim.vertexBundelIndices), _step; !(_step = _iterator()).done;) {
                    var bundleIdx = _step.value;
                    var _vertexBundle = mesh.struct.vertexBundles[bundleIdx];
                    var vbCount = prim.indexView ? prim.indexView.count : _vertexBundle.view.count;
                    var vbStride = _vertexBundle.view.stride;
                    var vbSize = vbStride * vbCount;
                    var view = new Uint8Array(mesh.data.buffer, _vertexBundle.view.offset, _vertexBundle.view.length);

                    if (!prim.indexView) {
                      this._flatBuffers.push({
                        stride: vbStride,
                        count: vbCount,
                        buffer: view
                      });

                      continue;
                    }

                    var vbView = new Uint8Array(vbSize);
                    var ibView = mesh.readIndices(this.subMeshIdx); // transform to flat buffer

                    for (var n = 0; n < idxCount; ++n) {
                      var idx = ibView[n];
                      var offset = n * vbStride;
                      var srcOffset = idx * vbStride;

                      for (var m = 0; m < vbStride; ++m) {
                        vbView[offset + m] = view[srcOffset + m];
                      }
                    }

                    this._flatBuffers.push({
                      stride: vbStride,
                      count: vbCount,
                      buffer: vbView
                    });
                  }

                  return this._flatBuffers;
                }
                /**
                 * @en The vertex buffer for joint after mapping
                 * @zh 骨骼索引按映射表处理后的顶点缓冲。
                 */

              }, {
                key: "jointMappedBuffers",
                get: function get() {
                  var _this = this;

                  if (this._jointMappedBuffers) {
                    return this._jointMappedBuffers;
                  }

                  var buffers = this._jointMappedBuffers = [];
                  var indices = this._jointMappedBufferIndices = [];

                  if (!this.mesh || this.subMeshIdx === undefined) {
                    return this._jointMappedBuffers = this.vertexBuffers;
                  }

                  var struct = this.mesh.struct;
                  var prim = struct.primitives[this.subMeshIdx];

                  if (!struct.jointMaps || prim.jointMapIndex === undefined || !struct.jointMaps[prim.jointMapIndex]) {
                    return this._jointMappedBuffers = this.vertexBuffers;
                  }

                  var jointFormat;
                  var jointOffset;
                  var device = legacyCC.director.root.device;

                  for (var i = 0; i < prim.vertexBundelIndices.length; i++) {
                    var bundle = struct.vertexBundles[prim.vertexBundelIndices[i]];
                    jointOffset = 0;
                    jointFormat = GFXFormat.UNKNOWN;

                    for (var j = 0; j < bundle.attributes.length; j++) {
                      var attr = bundle.attributes[j];

                      if (attr.name === GFXAttributeName.ATTR_JOINTS) {
                        jointFormat = attr.format;
                        break;
                      }

                      jointOffset += GFXFormatInfos[attr.format].size;
                    }

                    if (jointFormat) {
                      (function () {
                        var data = new Uint8Array(_this.mesh.data.buffer, bundle.view.offset, bundle.view.length);
                        var dataView = new DataView(data.slice().buffer);
                        var idxMap = struct.jointMaps[prim.jointMapIndex];
                        mapBuffer(dataView, function (cur) {
                          return idxMap.indexOf(cur);
                        }, jointFormat, jointOffset, bundle.view.length, bundle.view.stride, dataView);
                        var buffer = device.createBuffer({
                          usage: GFXBufferUsageBit.VERTEX | GFXBufferUsageBit.TRANSFER_DST,
                          memUsage: GFXMemoryUsageBit.DEVICE,
                          size: bundle.view.length,
                          stride: bundle.view.stride
                        });
                        buffer.update(dataView.buffer);
                        buffers.push(buffer);
                        indices.push(i);
                      })();
                    } else {
                      buffers.push(this.vertexBuffers[prim.vertexBundelIndices[i]]);
                    }
                  }

                  if (this._vertexIdChannel) {
                    buffers.push(this._allocVertexIdBuffer(device));
                  }

                  return buffers;
                }
              }]);

              function RenderingSubMesh(vertexBuffers, attributes, primitiveMode) {
                _classCallCheck(this, RenderingSubMesh);

                this.vertexBuffers = void 0;
                this.attributes = void 0;
                this.primitiveMode = void 0;
                this.indexBuffer = void 0;
                this.indirectBuffer = void 0;
                this.mesh = void 0;
                this.subMeshIdx = void 0;
                this._flatBuffers = void 0;
                this._jointMappedBuffers = void 0;
                this._jointMappedBufferIndices = void 0;
                this._vertexIdChannel = void 0;
                this._geometricInfo = void 0;
                this.vertexBuffers = vertexBuffers;
                this.attributes = attributes;
                this.primitiveMode = primitiveMode;
              }

              _createClass(RenderingSubMesh, [{
                key: "destroy",
                value: function destroy() {
                  for (var i = 0; i < this.vertexBuffers.length; i++) {
                    this.vertexBuffers[i].destroy();
                  }

                  this.vertexBuffers.length = 0;

                  if (this.indexBuffer) {
                    this.indexBuffer.destroy();
                    this.indexBuffer = undefined;
                  }

                  if (this._jointMappedBuffers && this._jointMappedBufferIndices) {
                    for (var _i = 0; _i < this._jointMappedBufferIndices.length; _i++) {
                      this._jointMappedBuffers[this._jointMappedBufferIndices[_i]].destroy();
                    }

                    this._jointMappedBuffers = undefined;
                    this._jointMappedBufferIndices = undefined;
                  }

                  if (this.indirectBuffer) {
                    this.indirectBuffer.destroy();
                    this.indirectBuffer = undefined;
                  }
                }
                /**
                 * @en Adds a vertex attribute input called 'a_vertexId' into this sub-mesh.
                 * This is useful if you want to simulate `gl_VertexId` in WebGL context prior to 2.0.
                 * Once you call this function, the vertex attribute is permanently added.
                 * Subsequent calls to this function take no effect.
                 * @param device Device used to create related rendering resources.
                 */

              }, {
                key: "enableVertexIdChannel",
                value: function enableVertexIdChannel(device) {
                  if (this._vertexIdChannel) {
                    return;
                  }

                  var streamIndex = this.vertexBuffers.length;
                  var attributeIndex = this.attributes.length;

                  var vertexIdBuffer = this._allocVertexIdBuffer(device);

                  this.vertexBuffers.push(vertexIdBuffer);
                  this.attributes.push({
                    name: 'a_vertexId',
                    format: GFXFormat.R32F,
                    stream: streamIndex,
                    isNormalized: false
                  });
                  this._vertexIdChannel = {
                    stream: streamIndex,
                    index: attributeIndex
                  };
                }
              }, {
                key: "_allocVertexIdBuffer",
                value: function _allocVertexIdBuffer(device) {
                  var vertexCount = this.vertexBuffers.length === 0 || this.vertexBuffers[0].stride === 0 ? 0 : // TODO: This depends on how stride of a vertex buffer is defined; Consider padding problem.
                  this.vertexBuffers[0].size / this.vertexBuffers[0].stride;
                  var vertexIds = new Float32Array(vertexCount);

                  for (var iVertex = 0; iVertex < vertexCount; ++iVertex) {
                    // `+0.5` because on some platforms, the "fetched integer" may have small error.
                    // For example `26` may yield `25.99999`, which is convert to `25` instead of `26` using `int()`.
                    vertexIds[iVertex] = iVertex + 0.5;
                  }

                  var vertexIdBuffer = device.createBuffer({
                    usage: GFXBufferUsageBit.VERTEX | GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: GFXMemoryUsageBit.DEVICE,
                    size: vertexIds.byteLength,
                    stride: vertexIds.BYTES_PER_ELEMENT
                  });
                  vertexIdBuffer.update(vertexIds);
                  return vertexIdBuffer;
                }
              }]);

              return RenderingSubMesh;
            }());
            var v3_1 = new Vec3();
            var v3_2 = new Vec3();
            var globalEmptyMeshBuffer = new Uint8Array();
            /**
             * @en Mesh asset
             * @zh 网格资源。
             */

            var Mesh = exports('at', (_dec$5 = ccclass('cc.Mesh'), _dec$5(_class$5 = (_class2$4 = (_temp$5 = /*#__PURE__*/function (_Asset) {
              _inherits(Mesh, _Asset);

              _createClass(Mesh, [{
                key: "_nativeAsset",
                get: function get() {
                  return this._data.buffer;
                },
                set: function set(value) {
                  if (this._data.byteLength === value.byteLength) {
                    this._data.set(new Uint8Array(value));

                    if (legacyCC.loader._cache[this.nativeUrl]) {
                      legacyCC.loader._cache[this.nativeUrl].content = this._data.buffer;
                    }
                  } else {
                    this._data = new Uint8Array(value);
                  }

                  this.loaded = true;
                  this.emit('load');
                }
                /**
                 * @en The sub meshes count of the mesh.
                 * @zh 此网格的子网格数量。
                 * @deprecated Please use [[renderingSubMeshes.length]] instead
                 */

              }, {
                key: "subMeshCount",
                get: function get() {
                  var renderingMesh = this.renderingSubMeshes;
                  return renderingMesh ? renderingMesh.length : 0;
                }
                /**
                 * @en The minimum position of all vertices in the mesh
                 * @zh （各分量都）小于等于此网格任何顶点位置的最大位置。
                 * @deprecated Please use [[struct.minPosition]] instead
                 */

              }, {
                key: "minPosition",
                get: function get() {
                  return this.struct.minPosition;
                }
                /**
                 * @en The maximum position of all vertices in the mesh
                 * @zh （各分量都）大于等于此网格任何顶点位置的最大位置。
                 * @deprecated Please use [[struct.maxPosition]] instead
                 */

              }, {
                key: "maxPosition",
                get: function get() {
                  return this.struct.maxPosition;
                }
                /**
                 * @en The struct of the mesh
                 * @zh 此网格的结构。
                 */

              }, {
                key: "struct",
                get: function get() {
                  return this._struct;
                }
                /**
                 * @en The actual data of the mesh
                 * @zh 此网格的数据。
                 */

              }, {
                key: "data",
                get: function get() {
                  return this._data;
                }
                /**
                 * @en The hash of the mesh
                 * @zh 此网格的哈希值。
                 */

              }, {
                key: "hash",
                get: function get() {
                  // hashes should already be computed offline, but if not, make one
                  if (!this._hash) {
                    this._hash = murmurhash2_32_gc(this._data, 666);
                  }

                  return this._hash;
                }
                /**
                 * The index of the joint buffer of all sub meshes in the joint map buffers
                 */

              }, {
                key: "jointBufferIndices",
                get: function get() {
                  if (this._jointBufferIndices) {
                    return this._jointBufferIndices;
                  }

                  return this._jointBufferIndices = this._struct.primitives.map(function (p) {
                    return p.jointMapIndex || 0;
                  });
                }
                /**
                 * @en The sub meshes for rendering. Mesh could be split into different sub meshes for rendering.
                 * @zh 此网格创建的渲染网格。
                 */

              }, {
                key: "renderingSubMeshes",
                get: function get() {
                  this.initialize();
                  return this._renderingSubMeshes;
                }
              }]);

              function Mesh() {
                var _this2;

                _classCallCheck(this, Mesh);

                _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Mesh).call(this));

                _initializerDefineProperty(_this2, "_struct", _descriptor$3, _assertThisInitialized(_this2));

                _initializerDefineProperty(_this2, "_dataLength", _descriptor2$2, _assertThisInitialized(_this2));

                _initializerDefineProperty(_this2, "_hash", _descriptor3$2, _assertThisInitialized(_this2));

                _this2._data = globalEmptyMeshBuffer;
                _this2._initialized = false;
                _this2._renderingSubMeshes = null;
                _this2._boneSpaceBounds = new Map();
                _this2._jointBufferIndices = null;
                _this2.morphRendering = null;
                _this2.loaded = false;
                return _this2;
              }

              _createClass(Mesh, [{
                key: "initialize",
                value: function initialize() {
                  var _this3 = this;

                  if (this._initialized) {
                    return;
                  }

                  this._initialized = true;

                  if (this._data.byteLength !== this._dataLength) {
                    // In the case of deferred loading, `this._data` is created before
                    // the actual binary buffer is loaded.
                    this._data = new Uint8Array(this._dataLength);
                    postLoadMesh(this);
                  }

                  var buffer = this._data.buffer;
                  var gfxDevice = legacyCC.director.root.device;

                  var vertexBuffers = this._createVertexBuffers(gfxDevice, buffer);
                  var subMeshes = [];

                  var _loop = function _loop(i) {
                    var prim = _this3._struct.primitives[i];

                    if (prim.vertexBundelIndices.length === 0) {
                      return "continue";
                    }

                    var indexBuffer = void 0;
                    var ib = null;

                    if (prim.indexView) {
                      var idxView = prim.indexView;
                      var dstStride = idxView.stride;
                      var dstSize = idxView.length;

                      if (dstStride === 4 && !gfxDevice.hasFeature(GFXFeature.ELEMENT_INDEX_UINT)) {
                        var vertexCount = _this3._struct.vertexBundles[prim.vertexBundelIndices[0]].view.count;

                        if (vertexCount >= 65536) {
                          warnID(10001, vertexCount, 65536);
                          return "continue"; // Ignore this primitive
                        } else {
                          dstStride >>= 1; // Reduce to short.

                          dstSize >>= 1;
                        }
                      }

                      indexBuffer = gfxDevice.createBuffer({
                        usage: GFXBufferUsageBit.INDEX | GFXBufferUsageBit.TRANSFER_DST,
                        memUsage: GFXMemoryUsageBit.DEVICE,
                        size: dstSize,
                        stride: dstStride
                      });
                      ib = new (getIndexStrideCtor(idxView.stride))(buffer, idxView.offset, idxView.count);

                      if (idxView.stride !== dstStride) {
                        ib = getIndexStrideCtor(dstStride).from(ib);
                      }

                      if (_this3.loaded) {
                        indexBuffer.update(ib);
                      } else {
                        _this3.once('load', function () {
                          indexBuffer.update(ib);
                        });
                      }
                    }

                    var vbReference = prim.vertexBundelIndices.map(function (idx) {
                      return vertexBuffers[idx];
                    });
                    var gfxAttributes = [];

                    if (prim.vertexBundelIndices.length > 0) {
                      var idx = prim.vertexBundelIndices[0];
                      var _vertexBundle2 = _this3._struct.vertexBundles[idx];
                      gfxAttributes = _vertexBundle2.attributes;
                    }

                    var subMesh = new RenderingSubMesh(vbReference, gfxAttributes, prim.primitiveMode);
                    subMesh.mesh = _this3;
                    subMesh.subMeshIdx = i;
                    subMesh.indexBuffer = indexBuffer;
                    subMeshes.push(subMesh);
                  };

                  for (var i = 0; i < this._struct.primitives.length; i++) {
                    var _ret = _loop(i);

                    if (_ret === "continue") continue;
                  }

                  this._renderingSubMeshes = subMeshes;

                  if (this._struct.morph) {
                    this.morphRendering = createMorphRendering(this, gfxDevice);
                  }
                }
                /**
                 * @en Destroy the mesh and release all related GPU resources
                 * @zh 销毁此网格，并释放它占有的所有 GPU 资源。
                 */

              }, {
                key: "destroy",
                value: function destroy() {
                  this.destroyRenderingMesh();
                  return _get(_getPrototypeOf(Mesh.prototype), "destroy", this).call(this);
                }
                /**
                 * @en Release all related GPU resources
                 * @zh 释放此网格占有的所有 GPU 资源。
                 */

              }, {
                key: "destroyRenderingMesh",
                value: function destroyRenderingMesh() {
                  if (this._renderingSubMeshes) {
                    for (var i = 0; i < this._renderingSubMeshes.length; i++) {
                      this._renderingSubMeshes[i].destroy();
                    }

                    this._renderingSubMeshes = null;
                    this._initialized = false;
                  }
                }
                /**
                 * @en Reset the struct and data of the mesh
                 * @zh 重置此网格的结构和数据。
                 * @param struct The new struct
                 * @param data The new data
                 * @deprecated Will be removed in v3.0.0, please use [[reset]] instead
                 */

              }, {
                key: "assign",
                value: function assign(struct, data) {
                  this.reset({
                    struct: struct,
                    data: data
                  });
                }
                /**
                 * @en Reset the mesh with mesh creation information
                 * @zh 重置此网格。
                 * @param info Mesh creation information including struct and data
                 */

              }, {
                key: "reset",
                value: function reset(info) {
                  this.destroyRenderingMesh();
                  this._struct = info.struct;
                  this._data = info.data;
                  this._dataLength = this.data.byteLength;
                  this._hash = 0;
                  this.loaded = true;
                  this.emit('load');
                }
                /**
                 * @en Get [[AABB]] bounds in the skeleton's bone space
                 * @zh 获取骨骼变换空间内下的 [[AABB]] 包围盒
                 * @param skeleton
                 */

              }, {
                key: "getBoneSpaceBounds",
                value: function getBoneSpaceBounds(skeleton) {
                  if (this._boneSpaceBounds.has(skeleton.hash)) {
                    return this._boneSpaceBounds.get(skeleton.hash);
                  }

                  var bounds = [];

                  this._boneSpaceBounds.set(skeleton.hash, bounds);

                  var valid = [];
                  var bindposes = skeleton.bindposes;

                  for (var i = 0; i < bindposes.length; i++) {
                    bounds.push(new aabb(Infinity, Infinity, Infinity, -Infinity, -Infinity, -Infinity));
                    valid.push(false);
                  }

                  var primitives = this._struct.primitives;

                  for (var p = 0; p < primitives.length; p++) {
                    var joints = this.readAttribute(p, GFXAttributeName.ATTR_JOINTS);
                    var weights = this.readAttribute(p, GFXAttributeName.ATTR_WEIGHTS);
                    var positions = this.readAttribute(p, GFXAttributeName.ATTR_POSITION);

                    if (!joints || !weights || !positions) {
                      continue;
                    }

                    var vertCount = Math.min(joints.length / 4, weights.length / 4, positions.length / 3);

                    for (var _i2 = 0; _i2 < vertCount; _i2++) {
                      Vec3.set(v3_1, positions[3 * _i2 + 0], positions[3 * _i2 + 1], positions[3 * _i2 + 2]);

                      for (var j = 0; j < 4; ++j) {
                        var idx = 4 * _i2 + j;
                        var joint = joints[idx];

                        if (weights[idx] === 0 || joint >= bindposes.length) {
                          continue;
                        }

                        Vec3.transformMat4(v3_2, v3_1, bindposes[joint]);
                        valid[joint] = true;
                        var b = bounds[joint];
                        Vec3.min(b.center, b.center, v3_2);
                        Vec3.max(b.halfExtents, b.halfExtents, v3_2);
                      }
                    }
                  }

                  for (var _i3 = 0; _i3 < bindposes.length; _i3++) {
                    var _b = bounds[_i3];

                    if (!valid[_i3]) {
                      bounds[_i3] = null;
                    } else {
                      aabb.fromPoints(_b, _b.center, _b.halfExtents);
                    }
                  }

                  return bounds;
                }
                /**
                 * @en Merge the given mesh into the current mesh
                 * @zh 合并指定的网格到此网格中。
                 * @param mesh The mesh to be merged
                 * @param worldMatrix The world matrix of the given mesh
                 * @param [validate=false] Whether to validate the mesh
                 * @returns Check the mesh state and return the validation result.
                 */

              }, {
                key: "merge",
                value: function merge(mesh, worldMatrix, validate) {
                  if (validate) {
                    if (!this.loaded || !mesh.loaded || !this.validateMergingMesh(mesh)) {
                      return false;
                    }
                  }

                  var vec3_temp = new Vec3();
                  var rotate = worldMatrix && new Quat();
                  var boundingBox = worldMatrix && new aabb();

                  if (rotate) {
                    worldMatrix.getRotation(rotate);
                  }

                  if (!this._initialized) {
                    var struct = JSON.parse(JSON.stringify(mesh._struct));

                    var data = mesh._data.slice();

                    if (worldMatrix) {
                      if (struct.maxPosition && struct.minPosition) {
                        Vec3.add(boundingBox.center, struct.maxPosition, struct.minPosition);
                        Vec3.multiplyScalar(boundingBox.center, boundingBox.center, 0.5);
                        Vec3.subtract(boundingBox.halfExtents, struct.maxPosition, struct.minPosition);
                        Vec3.multiplyScalar(boundingBox.halfExtents, boundingBox.halfExtents, 0.5);
                        aabb.transform(boundingBox, boundingBox, worldMatrix);
                        Vec3.add(struct.maxPosition, boundingBox.center, boundingBox.halfExtents);
                        Vec3.subtract(struct.minPosition, boundingBox.center, boundingBox.halfExtents);
                      }

                      for (var i = 0; i < struct.vertexBundles.length; i++) {
                        var vtxBdl = struct.vertexBundles[i];

                        for (var j = 0; j < vtxBdl.attributes.length; j++) {
                          if (vtxBdl.attributes[j].name === GFXAttributeName.ATTR_POSITION || vtxBdl.attributes[j].name === GFXAttributeName.ATTR_NORMAL) {
                            var format = vtxBdl.attributes[j].format;
                            var inputView = new DataView(data.buffer, vtxBdl.view.offset + getOffset(vtxBdl.attributes, j));
                            var reader = getReader(inputView, format);
                            var writer = getWriter(inputView, format);

                            if (!reader || !writer) {
                              continue;
                            }

                            var vertexCount = vtxBdl.view.count;
                            var vertexStride = vtxBdl.view.stride;
                            var attrComponentByteLength = getComponentByteLength(format);

                            for (var vtxIdx = 0; vtxIdx < vertexCount; vtxIdx++) {
                              var xOffset = vtxIdx * vertexStride;
                              var yOffset = xOffset + attrComponentByteLength;
                              var zOffset = yOffset + attrComponentByteLength;
                              vec3_temp.set(reader(xOffset), reader(yOffset), reader(zOffset));

                              switch (vtxBdl.attributes[j].name) {
                                case GFXAttributeName.ATTR_POSITION:
                                  vec3_temp.transformMat4(worldMatrix);
                                  break;

                                case GFXAttributeName.ATTR_NORMAL:
                                  Vec3.transformQuat(vec3_temp, vec3_temp, rotate);
                                  break;
                              }

                              writer(xOffset, vec3_temp.x);
                              writer(yOffset, vec3_temp.y);
                              writer(zOffset, vec3_temp.z);
                            }
                          }
                        }
                      }
                    }

                    this.reset({
                      struct: struct,
                      data: data
                    });
                    this.initialize();
                    return true;
                  } // merge buffer


                  var bufferBlob = new BufferBlob(); // merge vertex buffer

                  var vertCount = 0;
                  var vertStride = 0;
                  var srcOffset = 0;
                  var dstOffset = 0;
                  var vb;
                  var vbView;
                  var srcVBView;
                  var dstVBView;
                  var srcAttrOffset = 0;
                  var srcVBOffset = 0;
                  var dstVBOffset = 0;
                  var attrSize = 0;
                  var dstAttrView;
                  var hasAttr = false;
                  var vertexBundles = new Array(this._struct.vertexBundles.length);

                  for (var _i4 = 0; _i4 < this._struct.vertexBundles.length; ++_i4) {
                    var bundle = this._struct.vertexBundles[_i4];
                    var dstBundle = mesh._struct.vertexBundles[_i4];
                    srcOffset = bundle.view.offset;
                    dstOffset = dstBundle.view.offset;
                    vertStride = bundle.view.stride;
                    vertCount = bundle.view.count + dstBundle.view.count;
                    vb = new ArrayBuffer(vertCount * vertStride);
                    vbView = new Uint8Array(vb);
                    srcVBView = this._data.subarray(srcOffset, srcOffset + bundle.view.length);
                    srcOffset += srcVBView.length;
                    dstVBView = mesh._data.subarray(dstOffset, dstOffset + dstBundle.view.length);
                    dstOffset += dstVBView.length;
                    vbView.set(srcVBView);
                    srcAttrOffset = 0;

                    for (var _iterator2 = _createForOfIteratorHelperLoose(bundle.attributes), _step2; !(_step2 = _iterator2()).done;) {
                      var attr = _step2.value;
                      dstVBOffset = 0;
                      hasAttr = false;

                      for (var _iterator3 = _createForOfIteratorHelperLoose(dstBundle.attributes), _step3; !(_step3 = _iterator3()).done;) {
                        var dstAttr = _step3.value;

                        if (attr.name === dstAttr.name && attr.format === dstAttr.format) {
                          hasAttr = true;
                          break;
                        }

                        dstVBOffset += GFXFormatInfos[dstAttr.format].size;
                      }

                      if (hasAttr) {
                        attrSize = GFXFormatInfos[attr.format].size;
                        srcVBOffset = bundle.view.length + srcAttrOffset;

                        for (var v = 0; v < dstBundle.view.count; ++v) {
                          dstAttrView = dstVBView.subarray(dstVBOffset, dstVBOffset + attrSize);
                          vbView.set(dstAttrView, srcVBOffset);

                          if ((attr.name === GFXAttributeName.ATTR_POSITION || attr.name === GFXAttributeName.ATTR_NORMAL) && worldMatrix) {
                            var f32_temp = new Float32Array(vbView.buffer, srcVBOffset, 3);
                            vec3_temp.set(f32_temp[0], f32_temp[1], f32_temp[2]);

                            switch (attr.name) {
                              case GFXAttributeName.ATTR_POSITION:
                                vec3_temp.transformMat4(worldMatrix);
                                break;

                              case GFXAttributeName.ATTR_NORMAL:
                                Vec3.transformQuat(vec3_temp, vec3_temp, rotate);
                                break;
                            }

                            f32_temp[0] = vec3_temp.x;
                            f32_temp[1] = vec3_temp.y;
                            f32_temp[2] = vec3_temp.z;
                          }

                          srcVBOffset += bundle.view.stride;
                          dstVBOffset += dstBundle.view.stride;
                        }
                      }

                      srcAttrOffset += GFXFormatInfos[attr.format].size;
                    }

                    vertexBundles[_i4] = {
                      attributes: bundle.attributes,
                      view: {
                        offset: bufferBlob.getLength(),
                        length: vb.byteLength,
                        count: vertCount,
                        stride: vertStride
                      }
                    };
                    bufferBlob.addBuffer(vb);
                  } // merge index buffer


                  var idxCount = 0;
                  var idxStride = 2;
                  var vertBatchCount = 0;
                  var ibView;
                  var srcIBView;
                  var dstIBView;
                  var primitives = new Array(this._struct.primitives.length);

                  for (var _i5 = 0; _i5 < this._struct.primitives.length; ++_i5) {
                    var prim = this._struct.primitives[_i5];
                    var dstPrim = mesh._struct.primitives[_i5];
                    primitives[_i5] = {
                      primitiveMode: prim.primitiveMode,
                      vertexBundelIndices: prim.vertexBundelIndices
                    };

                    for (var _iterator4 = _createForOfIteratorHelperLoose(prim.vertexBundelIndices), _step4; !(_step4 = _iterator4()).done;) {
                      var bundleIdx = _step4.value;
                      vertBatchCount = Math.max(vertBatchCount, this._struct.vertexBundles[bundleIdx].view.count);
                    }

                    if (prim.indexView && dstPrim.indexView) {
                      idxCount = prim.indexView.count;
                      idxCount += dstPrim.indexView.count;
                      srcOffset = prim.indexView.offset;
                      dstOffset = dstPrim.indexView.offset;

                      if (idxCount < 256) {
                        idxStride = 1;
                      } else if (idxCount < 65536) {
                        idxStride = 2;
                      } else {
                        idxStride = 4;
                      }

                      var ib = new ArrayBuffer(idxCount * idxStride);

                      if (idxStride === 2) {
                        ibView = new Uint16Array(ib);
                      } else if (idxStride === 1) {
                        ibView = new Uint8Array(ib);
                      } else {
                        // Uint32
                        ibView = new Uint32Array(ib);
                      } // merge src indices


                      if (prim.indexView.stride === 2) {
                        srcIBView = new Uint16Array(this._data.buffer, srcOffset, prim.indexView.count);
                      } else if (prim.indexView.stride === 1) {
                        srcIBView = new Uint8Array(this._data.buffer, srcOffset, prim.indexView.count);
                      } else {
                        // Uint32
                        srcIBView = new Uint32Array(this._data.buffer, srcOffset, prim.indexView.count);
                      }

                      if (idxStride === prim.indexView.stride) {
                        ibView.set(srcIBView);
                      } else {
                        for (var n = 0; n < prim.indexView.count; ++n) {
                          ibView[n] = srcIBView[n];
                        }
                      }

                      srcOffset += prim.indexView.length; // merge dst indices

                      if (dstPrim.indexView.stride === 2) {
                        dstIBView = new Uint16Array(mesh._data.buffer, dstOffset, dstPrim.indexView.count);
                      } else if (dstPrim.indexView.stride === 1) {
                        dstIBView = new Uint8Array(mesh._data.buffer, dstOffset, dstPrim.indexView.count);
                      } else {
                        // Uint32
                        dstIBView = new Uint32Array(mesh._data.buffer, dstOffset, dstPrim.indexView.count);
                      }

                      for (var _n = 0; _n < dstPrim.indexView.count; ++_n) {
                        ibView[prim.indexView.count + _n] = vertBatchCount + dstIBView[_n];
                      }

                      dstOffset += dstPrim.indexView.length;
                      primitives[_i5].indexView = {
                        offset: bufferBlob.getLength(),
                        length: ib.byteLength,
                        count: idxCount,
                        stride: idxStride
                      };
                      bufferBlob.setNextAlignment(idxStride);
                      bufferBlob.addBuffer(ib);
                    }
                  } // Create mesh struct.


                  var meshStruct = {
                    vertexBundles: vertexBundles,
                    primitives: primitives,
                    minPosition: this._struct.minPosition,
                    maxPosition: this._struct.maxPosition
                  };

                  if (meshStruct.minPosition && mesh._struct.minPosition && meshStruct.maxPosition && mesh._struct.maxPosition) {
                    if (worldMatrix) {
                      Vec3.add(boundingBox.center, mesh._struct.maxPosition, mesh._struct.minPosition);
                      Vec3.multiplyScalar(boundingBox.center, boundingBox.center, 0.5);
                      Vec3.subtract(boundingBox.halfExtents, mesh._struct.maxPosition, mesh._struct.minPosition);
                      Vec3.multiplyScalar(boundingBox.halfExtents, boundingBox.halfExtents, 0.5);
                      aabb.transform(boundingBox, boundingBox, worldMatrix);
                      Vec3.add(vec3_temp, boundingBox.center, boundingBox.halfExtents);
                      Vec3.max(meshStruct.maxPosition, meshStruct.maxPosition, vec3_temp);
                      Vec3.subtract(vec3_temp, boundingBox.center, boundingBox.halfExtents);
                      Vec3.min(meshStruct.minPosition, meshStruct.minPosition, vec3_temp);
                    } else {
                      Vec3.min(meshStruct.minPosition, meshStruct.minPosition, mesh._struct.minPosition);
                      Vec3.max(meshStruct.maxPosition, meshStruct.maxPosition, mesh._struct.maxPosition);
                    }
                  } // Create mesh.


                  this.reset({
                    struct: meshStruct,
                    data: new Uint8Array(bufferBlob.getCombined())
                  });
                  this.initialize();
                  return true;
                }
                /**
                 * @en Validation for whether the given mesh can be merged into the current mesh.
                 * To pass the validation, it must satisfy either of these two requirements:
                 * - When the current mesh have no data
                 * - When the two mesh have the same vertex bundle count, the same sub meshes count, and the same sub mesh layout.
                 * 
                 * Same mesh layout means:
                 * - They have the same primitive type and reference to the same amount vertex bundle with the same indices.
                 * - And they all have or don't have index view
                 * @zh 验证指定网格是否可以合并至当前网格。
                 *
                 * 当满足以下条件之一时，指定网格可以合并至当前网格：
                 *  - 当前网格无数据而待合并网格有数据；
                 *  - 它们的顶点块数目相同且对应顶点块的布局一致，并且它们的子网格数目相同且对应子网格的布局一致。
                 *
                 * 两个顶点块布局一致当且仅当：
                 *  - 它们具有相同数量的顶点属性且对应的顶点属性具有相同的属性格式。
                 *
                 * 两个子网格布局一致，当且仅当：
                 *  - 它们具有相同的图元类型并且引用相同数量、相同索引的顶点块；并且，
                 *  - 要么都需要索引绘制，要么都不需要索引绘制。
                 * @param mesh The other mesh to be validated
                 */

              }, {
                key: "validateMergingMesh",
                value: function validateMergingMesh(mesh) {
                  // validate vertex bundles
                  if (this._struct.vertexBundles.length !== mesh._struct.vertexBundles.length) {
                    return false;
                  }

                  for (var i = 0; i < this._struct.vertexBundles.length; ++i) {
                    var bundle = this._struct.vertexBundles[i];
                    var dstBundle = mesh._struct.vertexBundles[i];

                    if (bundle.attributes.length !== dstBundle.attributes.length) {
                      return false;
                    }

                    for (var j = 0; j < bundle.attributes.length; ++j) {
                      if (bundle.attributes[j].format !== dstBundle.attributes[j].format) {
                        return false;
                      }
                    }
                  } // validate primitives


                  if (this._struct.primitives.length !== mesh._struct.primitives.length) {
                    return false;
                  }

                  for (var _i6 = 0; _i6 < this._struct.primitives.length; ++_i6) {
                    var prim = this._struct.primitives[_i6];
                    var dstPrim = mesh._struct.primitives[_i6];

                    if (prim.vertexBundelIndices.length !== dstPrim.vertexBundelIndices.length) {
                      return false;
                    }

                    for (var _j = 0; _j < prim.vertexBundelIndices.length; ++_j) {
                      if (prim.vertexBundelIndices[_j] !== dstPrim.vertexBundelIndices[_j]) {
                        return false;
                      }
                    }

                    if (prim.primitiveMode !== dstPrim.primitiveMode) {
                      return false;
                    }

                    if (prim.indexView) {
                      if (dstPrim.indexView === undefined) {
                        return false;
                      }
                    } else {
                      if (dstPrim.indexView) {
                        return false;
                      }
                    }
                  }

                  return true;
                }
                /**
                 * @en Read the requested attribute of the given sub mesh
                 * @zh 读取子网格的指定属性。
                 * @param primitiveIndex Sub mesh index
                 * @param attributeName Attribute name
                 * @returns Return null if not found or can't read, otherwise, will create a large enough typed array to contain all data of the attribute, 
                 * the array type will match the data type of the attribute.
                 */

              }, {
                key: "readAttribute",
                value: function readAttribute(primitiveIndex, attributeName) {
                  var _this4 = this;

                  var result = null;

                  this._accessAttribute(primitiveIndex, attributeName, function (vertexBundle, iAttribute) {
                    var vertexCount = vertexBundle.view.count;
                    var format = vertexBundle.attributes[iAttribute].format;
                    var storageConstructor = getTypedArrayConstructor(GFXFormatInfos[format]);

                    if (vertexCount === 0) {
                      return new storageConstructor();
                    }

                    var inputView = new DataView(_this4._data.buffer, vertexBundle.view.offset + getOffset(vertexBundle.attributes, iAttribute));
                    var formatInfo = GFXFormatInfos[format];
                    var reader = getReader(inputView, format);

                    if (!storageConstructor || !reader) {
                      return;
                    }

                    var componentCount = formatInfo.count;
                    var storage = new storageConstructor(vertexCount * componentCount);
                    var inputStride = vertexBundle.view.stride;

                    for (var iVertex = 0; iVertex < vertexCount; ++iVertex) {
                      for (var iComponent = 0; iComponent < componentCount; ++iComponent) {
                        storage[componentCount * iVertex + iComponent] = reader(inputStride * iVertex + storage.BYTES_PER_ELEMENT * iComponent);
                      }
                    }

                    result = storage;
                    return;
                  });

                  return result;
                }
                /**
                 * @en Read the requested attribute of the given sub mesh and fill into the given buffer.
                 * @zh 读取子网格的指定属性到目标缓冲区中。
                 * @param primitiveIndex Sub mesh index
                 * @param attributeName Attribute name
                 * @param buffer The target array buffer
                 * @param stride Byte distance between two attributes in the target buffer
                 * @param offset The offset of the first attribute in the target buffer
                 * @returns Return false if failed to access attribute, return true otherwise.
                 */

              }, {
                key: "copyAttribute",
                value: function copyAttribute(primitiveIndex, attributeName, buffer, stride, offset) {
                  var _this5 = this;

                  var written = false;

                  this._accessAttribute(primitiveIndex, attributeName, function (vertexBundle, iAttribute) {
                    var vertexCount = vertexBundle.view.count;

                    if (vertexCount === 0) {
                      written = true;
                      return;
                    }

                    var format = vertexBundle.attributes[iAttribute].format;
                    var inputView = new DataView(_this5._data.buffer, vertexBundle.view.offset + getOffset(vertexBundle.attributes, iAttribute));
                    var outputView = new DataView(buffer, offset);
                    var formatInfo = GFXFormatInfos[format];
                    var reader = getReader(inputView, format);
                    var writer = getWriter(outputView, format);

                    if (!reader || !writer) {
                      return;
                    }

                    var componentCount = formatInfo.count;
                    var inputStride = vertexBundle.view.stride;
                    var inputComponentByteLength = getComponentByteLength(format);
                    var outputStride = stride;
                    var outputComponentByteLength = inputComponentByteLength;

                    for (var iVertex = 0; iVertex < vertexCount; ++iVertex) {
                      for (var iComponent = 0; iComponent < componentCount; ++iComponent) {
                        var inputOffset = inputStride * iVertex + inputComponentByteLength * iComponent;
                        var outputOffset = outputStride * iVertex + outputComponentByteLength * iComponent;
                        writer(outputOffset, reader(inputOffset));
                      }
                    }

                    written = true;
                    return;
                  });

                  return written;
                }
                /**
                 * @en Read the indices data of the given sub mesh
                 * @zh 读取子网格的索引数据。
                 * @param primitiveIndex Sub mesh index
                 * @returns Return null if not found or can't read, otherwise, will create a large enough typed array to contain all indices data, 
                 * the array type will use the corresponding stride size.
                 */

              }, {
                key: "readIndices",
                value: function readIndices(primitiveIndex) {
                  if (primitiveIndex >= this._struct.primitives.length) {
                    return null;
                  }

                  var primitive = this._struct.primitives[primitiveIndex];

                  if (!primitive.indexView) {
                    return null;
                  }

                  var stride = primitive.indexView.stride;
                  var ctor = stride === 1 ? Uint8Array : stride === 2 ? Uint16Array : Uint32Array;
                  return new ctor(this._data.buffer, primitive.indexView.offset, primitive.indexView.count);
                }
                /**
                 * @en Read the indices data of the given sub mesh and fill into the given array
                 * @zh 读取子网格的索引数据到目标数组中。
                 * @param primitiveIndex Sub mesh index
                 * @param outputArray The target output array
                 * @returns Return false if failed to access the indices data, return true otherwise.
                 */

              }, {
                key: "copyIndices",
                value: function copyIndices(primitiveIndex, outputArray) {
                  if (primitiveIndex >= this._struct.primitives.length) {
                    return false;
                  }

                  var primitive = this._struct.primitives[primitiveIndex];

                  if (!primitive.indexView) {
                    return false;
                  }

                  var indexCount = primitive.indexView.count;
                  var indexFormat = primitive.indexView.stride === 1 ? GFXFormat.R8UI : primitive.indexView.stride === 2 ? GFXFormat.R16UI : GFXFormat.R32UI;
                  var reader = getReader(new DataView(this._data.buffer), indexFormat);

                  for (var i = 0; i < indexCount; ++i) {
                    outputArray[i] = reader(primitive.indexView.offset + GFXFormatInfos[indexFormat].size * i);
                  }

                  return true;
                }
              }, {
                key: "_accessAttribute",
                value: function _accessAttribute(primitiveIndex, attributeName, accessor) {
                  if (primitiveIndex >= this._struct.primitives.length) {
                    return;
                  }

                  var primitive = this._struct.primitives[primitiveIndex];

                  for (var _iterator5 = _createForOfIteratorHelperLoose(primitive.vertexBundelIndices), _step5; !(_step5 = _iterator5()).done;) {
                    var vertexBundleIndex = _step5.value;
                    var _vertexBundle3 = this._struct.vertexBundles[vertexBundleIndex];

                    var _iAttribute = _vertexBundle3.attributes.findIndex(function (a) {
                      return a.name === attributeName;
                    });

                    if (_iAttribute < 0) {
                      continue;
                    }

                    accessor(_vertexBundle3, _iAttribute);
                    break;
                  }

                  return;
                }
              }, {
                key: "_createVertexBuffers",
                value: function _createVertexBuffers(gfxDevice, data) {
                  var _this6 = this;

                  return this._struct.vertexBundles.map(function (vertexBundle) {
                    var vertexBuffer = gfxDevice.createBuffer({
                      usage: GFXBufferUsageBit.VERTEX | GFXBufferUsageBit.TRANSFER_DST,
                      memUsage: GFXMemoryUsageBit.DEVICE,
                      size: vertexBundle.view.length,
                      stride: vertexBundle.view.stride
                    });
                    var view = new Uint8Array(data, vertexBundle.view.offset, vertexBundle.view.length);

                    if (_this6.loaded) {
                      vertexBuffer.update(view);
                    } else {
                      _this6.once('load', function () {
                        vertexBuffer.update(view);
                      });
                    }

                    return vertexBuffer;
                  });
                }
              }]);

              return Mesh;
            }(Asset), _temp$5), (_descriptor$3 = _applyDecoratedDescriptor(_class2$4.prototype, "_struct", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return {
                  vertexBundles: [],
                  primitives: []
                };
              }
            }), _descriptor2$2 = _applyDecoratedDescriptor(_class2$4.prototype, "_dataLength", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            }), _descriptor3$2 = _applyDecoratedDescriptor(_class2$4.prototype, "_hash", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            })), _class2$4)) || _class$5));
            legacyCC.Mesh = Mesh;

            function getOffset(attributes, attributeIndex) {
              var result = 0;

              for (var i = 0; i < attributeIndex; ++i) {
                var attribute = attributes[i];
                result += GFXFormatInfos[attribute.format].size;
              }

              return result;
            }

            var isLittleEndian = sys.isLittleEndian;

            function getComponentByteLength(format) {
              var info = GFXFormatInfos[format];
              return info.size / info.count;
            }

            function getReader(dataView, format) {
              var info = GFXFormatInfos[format];
              var stride = info.size / info.count;

              switch (info.type) {
                case GFXFormatType.UNORM:
                  {
                    switch (stride) {
                      case 1:
                        return function (offset) {
                          return dataView.getUint8(offset);
                        };

                      case 2:
                        return function (offset) {
                          return dataView.getUint16(offset, isLittleEndian);
                        };

                      case 4:
                        return function (offset) {
                          return dataView.getUint32(offset, isLittleEndian);
                        };
                    }

                    break;
                  }

                case GFXFormatType.SNORM:
                  {
                    switch (stride) {
                      case 1:
                        return function (offset) {
                          return dataView.getInt8(offset);
                        };

                      case 2:
                        return function (offset) {
                          return dataView.getInt16(offset, isLittleEndian);
                        };

                      case 4:
                        return function (offset) {
                          return dataView.getInt32(offset, isLittleEndian);
                        };
                    }

                    break;
                  }

                case GFXFormatType.INT:
                  {
                    switch (stride) {
                      case 1:
                        return function (offset) {
                          return dataView.getInt8(offset);
                        };

                      case 2:
                        return function (offset) {
                          return dataView.getInt16(offset, isLittleEndian);
                        };

                      case 4:
                        return function (offset) {
                          return dataView.getInt32(offset, isLittleEndian);
                        };
                    }

                    break;
                  }

                case GFXFormatType.UINT:
                  {
                    switch (stride) {
                      case 1:
                        return function (offset) {
                          return dataView.getUint8(offset);
                        };

                      case 2:
                        return function (offset) {
                          return dataView.getUint16(offset, isLittleEndian);
                        };

                      case 4:
                        return function (offset) {
                          return dataView.getUint32(offset, isLittleEndian);
                        };
                    }

                    break;
                  }

                case GFXFormatType.FLOAT:
                  {
                    return function (offset) {
                      return dataView.getFloat32(offset, isLittleEndian);
                    };
                  }
              }

              return null;
            }

            function getWriter(dataView, format) {
              var info = GFXFormatInfos[format];
              var stride = info.size / info.count;

              switch (info.type) {
                case GFXFormatType.UNORM:
                  {
                    switch (stride) {
                      case 1:
                        return function (offset, value) {
                          return dataView.setUint8(offset, value);
                        };

                      case 2:
                        return function (offset, value) {
                          return dataView.setUint16(offset, value, isLittleEndian);
                        };

                      case 4:
                        return function (offset, value) {
                          return dataView.setUint32(offset, value, isLittleEndian);
                        };
                    }

                    break;
                  }

                case GFXFormatType.SNORM:
                  {
                    switch (stride) {
                      case 1:
                        return function (offset, value) {
                          return dataView.setInt8(offset, value);
                        };

                      case 2:
                        return function (offset, value) {
                          return dataView.setInt16(offset, value, isLittleEndian);
                        };

                      case 4:
                        return function (offset, value) {
                          return dataView.setInt32(offset, value, isLittleEndian);
                        };
                    }

                    break;
                  }

                case GFXFormatType.INT:
                  {
                    switch (stride) {
                      case 1:
                        return function (offset, value) {
                          return dataView.setInt8(offset, value);
                        };

                      case 2:
                        return function (offset, value) {
                          return dataView.setInt16(offset, value, isLittleEndian);
                        };

                      case 4:
                        return function (offset, value) {
                          return dataView.setInt32(offset, value, isLittleEndian);
                        };
                    }

                    break;
                  }

                case GFXFormatType.UINT:
                  {
                    switch (stride) {
                      case 1:
                        return function (offset, value) {
                          return dataView.setUint8(offset, value);
                        };

                      case 2:
                        return function (offset, value) {
                          return dataView.setUint16(offset, value, isLittleEndian);
                        };

                      case 4:
                        return function (offset, value) {
                          return dataView.setUint32(offset, value, isLittleEndian);
                        };
                    }

                    break;
                  }

                case GFXFormatType.FLOAT:
                  {
                    return function (offset, value) {
                      return dataView.setFloat32(offset, value, isLittleEndian);
                    };
                  }
              }

              return null;
            } // function get

            /**
             * @hidden
             */
            var RenderQueue;

            (function (RenderQueue) {
              RenderQueue[RenderQueue["OPAQUE"] = 0] = "OPAQUE";
              RenderQueue[RenderQueue["TRANSPARENT"] = 1] = "TRANSPARENT";
              RenderQueue[RenderQueue["OVERLAY"] = 2] = "OVERLAY";
            })(RenderQueue || (RenderQueue = exports('a3', {})));

            var PassStage;

            (function (PassStage) {
              PassStage[PassStage["DEFAULT"] = 1] = "DEFAULT";
              PassStage[PassStage["FORWARD"] = 2] = "FORWARD";
              PassStage[PassStage["SHADOWCAST"] = 4] = "SHADOWCAST";
            })(PassStage || (PassStage = exports('a4', {})));

            var _type2reader, _type2writer;
            var dtMask = 0xf0000000; //  4 bits => 16 property types

            var typeMask = 0x0fc00000; //  6 bits => 64 types

            var setMask = 0x00300000; //  2 bits => 4 sets

            var bindingMask = 0x000fc000; //  6 bits => 64 bindings

            var offsetMask = 0x00003fff; // 14 bits => 4096 vectors

            /**
             * @en The type enums of the property
             * @zh Uniform 的绑定类型（UBO 或贴图等）
             */

            var PropertyType;

            (function (PropertyType) {
              PropertyType[PropertyType["UBO"] = 0] = "UBO";
              PropertyType[PropertyType["SAMPLER"] = 1] = "SAMPLER";
            })(PropertyType || (PropertyType = exports('a5', {})));

            var genHandle = exports('a6', function genHandle(pt, set, binding, type) {
              var offset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
              return pt << 28 & dtMask | type << 22 & typeMask | set << 20 & setMask | binding << 14 & bindingMask | offset & offsetMask;
            });
            var getPropertyTypeFromHandle = exports('a7', function getPropertyTypeFromHandle(handle) {
              return (handle & dtMask) >>> 28;
            });
            var getTypeFromHandle = exports('a8', function getTypeFromHandle(handle) {
              return (handle & typeMask) >>> 22;
            });
            var getSetIndexFromHandle = exports('a9', function getSetIndexFromHandle(handle) {
              return (handle & setMask) >>> 20;
            });
            var getBindingFromHandle = exports('aa', function getBindingFromHandle(handle) {
              return (handle & bindingMask) >>> 14;
            });
            var getOffsetFromHandle = exports('ab', function getOffsetFromHandle(handle) {
              return handle & offsetMask;
            });
            var customizeType = exports('ac', function customizeType(handle, type) {
              return handle & ~typeMask | type << 22 & typeMask;
            });
            /**
             * @en Vector type uniforms
             * @zh 向量类型 uniform
             */

            var type2reader = exports('ad', (_type2reader = {}, _defineProperty(_type2reader, GFXType.UNKNOWN, function (a, v) {
              return console.warn('illegal uniform handle');
            }), _defineProperty(_type2reader, GFXType.INT, function (a, v) {
              var idx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
              return a[idx];
            }), _defineProperty(_type2reader, GFXType.INT2, function (a, v) {
              var idx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
              return Vec2.fromArray(v, a, idx);
            }), _defineProperty(_type2reader, GFXType.INT3, function (a, v) {
              var idx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
              return Vec3.fromArray(v, a, idx);
            }), _defineProperty(_type2reader, GFXType.INT4, function (a, v) {
              var idx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
              return Vec4.fromArray(v, a, idx);
            }), _defineProperty(_type2reader, GFXType.FLOAT, function (a, v) {
              var idx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
              return a[idx];
            }), _defineProperty(_type2reader, GFXType.FLOAT2, function (a, v) {
              var idx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
              return Vec2.fromArray(v, a, idx);
            }), _defineProperty(_type2reader, GFXType.FLOAT3, function (a, v) {
              var idx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
              return Vec3.fromArray(v, a, idx);
            }), _defineProperty(_type2reader, GFXType.FLOAT4, function (a, v) {
              var idx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
              return Vec4.fromArray(v, a, idx);
            }), _defineProperty(_type2reader, GFXType.MAT3, function (a, v) {
              var idx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
              return Mat3.fromArray(v, a, idx);
            }), _defineProperty(_type2reader, GFXType.MAT4, function (a, v) {
              var idx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
              return Mat4.fromArray(v, a, idx);
            }), _type2reader));
            var type2writer = exports('ae', (_type2writer = {}, _defineProperty(_type2writer, GFXType.UNKNOWN, function (a, v) {
              return console.warn('illegal uniform handle');
            }), _defineProperty(_type2writer, GFXType.INT, function (a, v) {
              var idx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
              return a[idx] = v;
            }), _defineProperty(_type2writer, GFXType.INT2, function (a, v) {
              var idx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
              return Vec2.toArray(a, v, idx);
            }), _defineProperty(_type2writer, GFXType.INT3, function (a, v) {
              var idx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
              return Vec3.toArray(a, v, idx);
            }), _defineProperty(_type2writer, GFXType.INT4, function (a, v) {
              var idx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
              return Vec4.toArray(a, v, idx);
            }), _defineProperty(_type2writer, GFXType.FLOAT, function (a, v) {
              var idx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
              return a[idx] = v;
            }), _defineProperty(_type2writer, GFXType.FLOAT2, function (a, v) {
              var idx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
              return Vec2.toArray(a, v, idx);
            }), _defineProperty(_type2writer, GFXType.FLOAT3, function (a, v) {
              var idx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
              return Vec3.toArray(a, v, idx);
            }), _defineProperty(_type2writer, GFXType.FLOAT4, function (a, v) {
              var idx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
              return Vec4.toArray(a, v, idx);
            }), _defineProperty(_type2writer, GFXType.MAT3, function (a, v) {
              var idx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
              return Mat3.toArray(a, v, idx);
            }), _defineProperty(_type2writer, GFXType.MAT4, function (a, v) {
              var idx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
              return Mat4.toArray(a, v, idx);
            }), _type2writer));
            var defaultValues = [Object.freeze([0]), Object.freeze([0, 0]), Object.freeze([0, 0, 0, 0]), Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])];
            /**
             * @en Gets the default values for the given type of uniform
             * @zh 根据指定的 Uniform 类型来获取默认值
             * @param type The type of the uniform
             */

            function getDefaultFromType(type) {
              switch (type) {
                case GFXType.BOOL:
                case GFXType.INT:
                case GFXType.UINT:
                case GFXType.FLOAT:
                  return defaultValues[0];

                case GFXType.BOOL2:
                case GFXType.INT2:
                case GFXType.UINT2:
                case GFXType.FLOAT2:
                  return defaultValues[1];

                case GFXType.BOOL4:
                case GFXType.INT4:
                case GFXType.UINT4:
                case GFXType.FLOAT4:
                  return defaultValues[2];

                case GFXType.MAT4:
                  return defaultValues[3];

                case GFXType.SAMPLER2D:
                  return 'default-texture';

                case GFXType.SAMPLER_CUBE:
                  return 'default-cube-texture';
              }

              return defaultValues[0];
            }
            /**
             * @en Combination of preprocess macros
             * @zh 预处理宏组合
             */

            /**
             * @en Override the preprocess macros
             * @zh 覆写预处理宏
             * @param target Target preprocess macros to be overridden
             * @param source Preprocess macros used for override
             */
            function overrideMacros(target, source) {
              var entries = Object.entries(source);
              var isDifferent = false;

              for (var i = 0; i < entries.length; i++) {
                if (target[entries[i][0]] !== entries[i][1]) {
                  target[entries[i][0]] = entries[i][1];
                  isDifferent = true;
                }
              }

              return isDifferent;
            }

            var _dec$6, _class$6, _temp$6;
            var INSET_LEFT = 0;
            var INSET_TOP = 1;
            var INSET_RIGHT = 2;
            var INSET_BOTTOM = 3;
            var temp_uvs = [{
              u: 0,
              v: 0
            }, {
              u: 0,
              v: 0
            }, {
              u: 0,
              v: 0
            }, {
              u: 0,
              v: 0
            }];
            /**
             * @en
             * A `SpriteFrame` support several types
             *  1. Rectangle sprite frame
             *  2. Sliced 9 sprite frame
             *  3. Mesh sprite frame
             * It mainly contains:<br/>
             *  - texture: A [[TextureBase]] or [[RenderTexture]] that will be used by render process<br/>
             *  - rectangle: A rectangle of the texture
             *  - Sliced 9 border insets: The distance of each side from the internal rect to the sprite frame rect
             *  - vertices: Vertex list for the mesh type sprite frame
             *  - uv: The quad uv
             *  - uvSliced: The sliced 9 uv
             *
             * @zh
             * 精灵帧资源。
             * 一个 SpriteFrame 支持多种类型
             *  1. 矩形精灵帧
             *  2. 九宫格精灵帧
             *  3. 网格精灵帧
             * 它主要包含下列数据：<br/>
             *  - 纹理：会被渲染流程使用的 [[TextureBase]] or [[RenderTexture]] 资源。<br/>
             *  - 矩形：在纹理中的矩形区域。
             *  - 九宫格信息：九宫格的内部矩形四个边距离 SpriteFrame 外部矩形的距离
             *  - 网格信息：网格类型精灵帧的所有顶点列表
             *  - uv: 四边形 UV
             *  - uvSliced: 九宫格 UV
             * 可通过 `SpriteFrame` 获取该组件。
             *
             * @example
             * ```ts
             * import { loader } from 'cc';
             * // First way to use a SpriteFrame
             * const url = "assets/PurpleMonster/icon/spriteFrame";
             * loader.loadRes(url, (err, spriteFrame) => {
             *   const node = new Node("New Sprite");
             *   const sprite = node.addComponent(Sprite);
             *   sprite.spriteFrame = spriteFrame;
             *   node.parent = self.node;
             * });
             *
             * // Second way to use a SpriteFrame
             * const self = this;
             * const url = "test_assets/PurpleMonster";
             * loader.loadRes(url, (err, imageAsset) => {
             *  if(err){
             *    return;
             *  }
             *
             *  const node = new Node("New Sprite");
             *  const sprite = node.addComponent(Sprite);
             *  const spriteFrame = new SpriteFrame();
             *  const tex = imageAsset._texture;
             *  spriteFrame.texture = tex;
             *  sprite.spriteFrame = spriteFrame;
             *  node.parent = self.node;
             * });
             *
             * // Third way to use a SpriteFrame
             * const self = this;
             * const cameraComp = this.getComponent(Camera);
             * const renderTexture = new RenderTexture();
             * rendetTex.reset({
             *   width: 512,
             *   height: 512,
             *   depthStencilFormat: RenderTexture.DepthStencilFormat.DEPTH_24_STENCIL_8
             * });
             *
             * cameraComp.targetTexture = renderTexture;
             * const spriteFrame = new SpriteFrame();
             * spriteFrame.texture = renderTexture;
             * ```
             */

            var SpriteFrame = exports('b7', (_dec$6 = ccclass('cc.SpriteFrame'), _dec$6(_class$6 = (_temp$6 = /*#__PURE__*/function (_Asset) {
              _inherits(SpriteFrame, _Asset);

              _createClass(SpriteFrame, [{
                key: "insetTop",

                /**
                 * @en Top border distance of sliced 9 rect.
                 * @zh 九宫格内部矩形顶部边框距离 SpriteFrame 矩形的距离。
                 */
                get: function get() {
                  return this._capInsets[INSET_TOP];
                },
                set: function set(value) {
                  if (this._capInsets[INSET_TOP] === value) {
                    return;
                  }

                  this._capInsets[INSET_TOP] = value;

                  if (this._texture) {
                    this._calculateSlicedUV();
                  }
                }
                /**
                 * @en Bottom border distance of sliced 9 rect.
                 * @zh 九宫格内部矩形底部边框距离 SpriteFrame 矩形的距离。
                 */

              }, {
                key: "insetBottom",
                get: function get() {
                  return this._capInsets[INSET_BOTTOM];
                },
                set: function set(value) {
                  if (this._capInsets[INSET_BOTTOM] === value) {
                    return;
                  }

                  this._capInsets[INSET_BOTTOM] = value;

                  if (this._texture) {
                    this._calculateSlicedUV();
                  }
                }
                /**
                 * @en Left border distance of sliced 9 rect.
                 * @zh 九宫格内部矩形左边框距离 SpriteFrame 矩形的距离。
                 */

              }, {
                key: "insetLeft",
                get: function get() {
                  return this._capInsets[INSET_LEFT];
                },
                set: function set(value) {
                  if (this._capInsets[INSET_LEFT] === value) {
                    return;
                  }

                  this._capInsets[INSET_LEFT] = value;

                  if (this._texture) {
                    this._calculateSlicedUV();
                  }
                }
                /**
                 * @en Right border distance of sliced 9 rect.
                 * @zh 九宫格内部矩形右边框距离 SpriteFrame 矩形的距离。
                 */

              }, {
                key: "insetRight",
                get: function get() {
                  return this._capInsets[INSET_RIGHT];
                },
                set: function set(value) {
                  if (this._capInsets[INSET_RIGHT] === value) {
                    return;
                  }

                  this._capInsets[INSET_RIGHT] = value;

                  if (this._texture) {
                    this._calculateSlicedUV();
                  }
                }
                /**
                 * @en Returns the rect of the sprite frame in the texture.
                 * If it's an atlas texture, a transparent pixel area is proposed for the actual mapping of the current texture.
                 * @zh 获取 SpriteFrame 的纹理矩形区域。
                 * 如果是一个 atlas 的贴图，则为当前贴图的实际剔除透明像素区域。
                 */

              }, {
                key: "rect",
                get: function get() {
                  return this._rect;
                },
                set: function set(value) {
                  if (this._rect.equals(value)) {
                    return;
                  }

                  this._rect.set(value);

                  if (this._texture) {
                    this._calculateUV();
                  }
                }
                /**
                 * @en The original size before trimmed.
                 * @zh 修剪前的原始大小。
                 */

              }, {
                key: "originalSize",
                get: function get() {
                  return this._originalSize;
                },
                set: function set(value) {
                  if (this._originalSize.equals(value)) {
                    return;
                  }

                  this._originalSize.set(value);

                  if (this._texture) {
                    this._calculateUV();
                  }
                }
                /**
                 * @en The offset of the sprite frame center.
                 * Sprite frame in an atlas texture could be trimmed for clipping the transparent pixels, so the trimmed rect is smaller than the original one,
                 * the offset defines the distance from the original center to the trimmed center.
                 * @zh 精灵帧偏移量。
                 * 在图集中的精灵帧可能会被剔除透明像素以获得更高的空间利用李，剔除后的矩形尺寸比剪裁前更小，偏移量指的是从原始矩形的中心到剪裁后的矩形中心的距离。
                 */

              }, {
                key: "offset",
                get: function get() {
                  return this._offset;
                },
                set: function set(value) {
                  this._offset.set(value);
                }
                /**
                 * @en Whether the content of sprite frame is rotated.
                 * @zh 是否旋转。
                 */

              }, {
                key: "rotated",
                get: function get() {
                  return this._rotated;
                },
                set: function set(rotated) {
                  if (this._rotated === rotated) {
                    return;
                  }

                  this._rotated = rotated;

                  if (this._texture) {
                    this._calculateUV();
                  }
                }
                /**
                 * @en The texture of the sprite frame, could be [[TextureBase]] or [[RenderTexture]]
                 * @zh 贴图对象资源，可以是 [[TextureBase]] 或 [[RenderTexture]] 类型
                 */

              }, {
                key: "texture",
                get: function get() {
                  return this._texture;
                },
                set: function set(value) {
                  if (!value) {
                    console.warn("Error Texture in ".concat(this.name));
                    return;
                  }

                  this.reset({
                    texture: value
                  }, true);
                }
                /**
                 * @en The uuid of the atlas asset, if exist
                 * @zh 图集资源的 uuid。
                 */

              }, {
                key: "atlasUuid",
                get: function get() {
                  return this._atlasUuid;
                },
                set: function set(value) {
                  this._atlasUuid = value;
                }
                /**
                 * @en The pixel width of the sprite frame
                 * @zh 精灵帧的像素宽度
                 */

              }, {
                key: "width",
                get: function get() {
                  return this._texture.width;
                }
                /**
                 * @en The pixel height of the sprite frame
                 * @zh 精灵帧的像素高度
                 */

              }, {
                key: "height",
                get: function get() {
                  return this._texture.height;
                }
              }, {
                key: "_textureSource",
                set: function set(value) {
                  if (value) {
                    this._refreshTexture(value);

                    this._calculateUV();
                  }
                }
                /**
                 * @en Vertex list for the mesh type sprite frame
                 * @zh 网格类型精灵帧的所有顶点列表
                 */

              }], [{
                key: "createWithImage",

                /**
                 * @en Create a SpriteFrame object by an image asset or an native image asset
                 * @zh 通过 Image 资源或者平台相关 Image 对象创建一个 SpriteFrame 对象
                 * @param imageSourceOrImageAsset ImageAsset or ImageSource, ImageSource support HTMLCanvasElement HTMLImageElement IMemoryImageSource
                 */
                value: function createWithImage(imageSourceOrImageAsset) {
                  var img = imageSourceOrImageAsset instanceof ImageAsset ? imageSourceOrImageAsset : new ImageAsset(imageSourceOrImageAsset);
                  var tex = new Texture2D();
                  tex.image = img;
                  var spf = new SpriteFrame();
                  spf.texture = tex;
                  return spf;
                }
              }]);

              function SpriteFrame() {
                var _this;

                _classCallCheck(this, SpriteFrame);

                _this = _possibleConstructorReturn(this, _getPrototypeOf(SpriteFrame).call(this));
                _this.vertices = null;
                _this.uv = [];
                _this.uvHash = 0;
                _this.uvSliced = [];
                _this._rect = new Rect();
                _this._offset = new Vec2();
                _this._originalSize = new Size();
                _this._rotated = false;
                _this._capInsets = [0, 0, 0, 0];
                _this._atlasUuid = '';
                _this._texture = void 0;
                _this._flipUv = false;

                return _this;
              }
              /**
               * @en
               * Returns whether the texture have been loaded.
               * @zh
               * 返回是否已加载精灵帧。
               */


              _createClass(SpriteFrame, [{
                key: "textureLoaded",
                value: function textureLoaded() {
                  return this.texture && this.texture.loaded;
                }
                /**
                 * @en
                 * Returns whether the sprite frame is rotated in the texture.
                 * @zh
                 * 获取 SpriteFrame 是否旋转。
                 * @deprecated since v1.2, please use [[rotated]] instead
                 */

              }, {
                key: "isRotated",
                value: function isRotated() {
                  return this._rotated;
                }
                /**
                 * @en
                 * Set whether the sprite frame is rotated in the texture.
                 * @zh
                 * 设置 SpriteFrame 是否旋转。
                 * @param value
                 * @deprecated since v1.2, please use [[rotated]] instead
                 */

              }, {
                key: "setRotated",
                value: function setRotated(rotated) {
                  this.rotated = rotated;
                }
                /**
                 * @en Returns the rect of the sprite frame in the texture.
                 * If it's an atlas texture, a transparent pixel area is proposed for the actual mapping of the current texture.
                 * @zh 获取 SpriteFrame 的纹理矩形区域。
                 * 如果是一个 atlas 的贴图，则为当前贴图的实际剔除透明像素区域。
                 * @deprecated since v1.2, please use [[rect]]
                 */

              }, {
                key: "getRect",
                value: function getRect(out) {
                  if (out) {
                    out.set(this._rect);
                    return out;
                  }

                  return this._rect.clone();
                }
                /**
                 * @en Sets the rect of the sprite frame in the texture.
                 * @zh 设置 SpriteFrame 的纹理矩形区域。
                 * @deprecated since v1.2, please use [[rect]]
                 */

              }, {
                key: "setRect",
                value: function setRect(rect) {
                  this.rect = rect;
                }
                /**
                 * @en Returns the original size before trimmed.
                 * @zh 获取修剪前的原始大小。
                 * @deprecated since v1.2, please use [[originalSize]]
                 */

              }, {
                key: "getOriginalSize",
                value: function getOriginalSize(out) {
                  if (out) {
                    out.set(this._originalSize);
                    return out;
                  }

                  return this._originalSize.clone();
                }
                /**
                 * @en Sets the original size before trimmed.
                 * @zh 设置修剪前的原始大小。
                 * @param size The new original size
                 * @deprecated since v1.2, please use [[originalSize]]
                 */

              }, {
                key: "setOriginalSize",
                value: function setOriginalSize(size) {
                  this.originalSize = size;
                }
                /**
                 * @en Returns the offset of the frame
                 * @zh 获取偏移量。
                 * @param out The output offset object
                 * @deprecated since v1.2, please use [[offset]]
                 */

              }, {
                key: "getOffset",
                value: function getOffset(out) {
                  if (out) {
                    out.set(this._offset);
                    return out;
                  }

                  return this._offset.clone();
                }
                /**
                 * @en Sets the offset of the frame
                 * @zh 设置偏移量。
                 * @param offset The new offset
                 * @deprecated since v1.2, please use [[offset]]
                 */

              }, {
                key: "setOffset",
                value: function setOffset(offset) {
                  this.offset = offset;
                }
                /**
                 * @en Gets the related [[GFXTexture]] resource
                 * @zh 获取渲染贴图的 GFX 资源
                 */

              }, {
                key: "getGFXTexture",
                value: function getGFXTexture() {
                  return this._texture.getGFXTexture();
                }
                /**
                 * @en Gets the sampler resource of its texture
                 * @zh 贴图资源的采样器
                 */

              }, {
                key: "getGFXSampler",
                value: function getGFXSampler() {
                  return this._texture.getGFXSampler();
                }
                /**
                 * @en Resets the sprite frame data
                 * @zh 重置 SpriteFrame 数据。
                 * @param info SpriteFrame initialization information
                 */

              }, {
                key: "reset",
                value: function reset(info) {
                  var clearData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                  var calUV = false;

                  if (clearData) {
                    this._originalSize.set(0, 0);

                    this._rect.set(0, 0, 0, 0);

                    this._offset.set(0, 0);

                    this._capInsets = [0, 0, 0, 0];
                    this._rotated = false;
                    calUV = true;
                  }

                  if (info) {
                    if (info.texture) {
                      this.loaded = false;
                      this._rect.x = this._rect.y = 0;
                      this._rect.width = info.texture.width;
                      this._rect.height = info.texture.height;

                      this._refreshTexture(info.texture);

                      this.checkRect(this._texture);
                    }

                    if (info.originalSize) {
                      this._originalSize.set(info.originalSize);
                    }

                    if (info.rect) {
                      this._rect.set(info.rect);
                    }

                    if (info.offset) {
                      this._offset.set(info.offset);
                    }

                    if (info.borderTop !== undefined) {
                      this._capInsets[INSET_TOP] = info.borderTop;
                    }

                    if (info.borderBottom !== undefined) {
                      this._capInsets[INSET_BOTTOM] = info.borderBottom;
                    }

                    if (info.borderLeft !== undefined) {
                      this._capInsets[INSET_LEFT] = info.borderLeft;
                    }

                    if (info.borderRight !== undefined) {
                      this._capInsets[INSET_RIGHT] = info.borderRight;
                    }

                    if (info.isRotate !== undefined) {
                      this._rotated = !!info.isRotate;
                    }

                    if (info.isFlipUv !== undefined) {
                      this._flipUv = !!info.isFlipUv;
                    }

                    calUV = true;
                  }

                  if (calUV && this.texture) {
                    this._calculateUV();
                  }
                }
                /**
                 * @en Check whether the rect of the sprite frame is out of the texture boundary
                 * @zh 判断精灵计算的矩形区域是否越界。
                 * @param texture
                 */

              }, {
                key: "checkRect",
                value: function checkRect(texture) {
                  var rect = this._rect;
                  var maxX = rect.x;
                  var maxY = rect.y;

                  if (this._rotated) {
                    maxX += rect.height;
                    maxY += rect.width;
                  } else {
                    maxX += rect.width;
                    maxY += rect.height;
                  }

                  if (maxX > texture.width) {
                    errorID(3300, this.name + '/' + texture.name, maxX, texture.width);
                    return false;
                  }

                  if (maxY > texture.height) {
                    errorID(3301, this.name + '/' + texture.name, maxY, texture.height);
                    return false;
                  }

                  return true;
                }
              }, {
                key: "onLoaded",
                value: function onLoaded() {
                  this.loaded = true;
                  this.emit('load');
                }
              }, {
                key: "destroy",
                value: function destroy() {
                  return _get(_getPrototypeOf(SpriteFrame.prototype), "destroy", this).call(this);
                } // Calculate UV for sliced

              }, {
                key: "_calculateSlicedUV",
                value: function _calculateSlicedUV() {
                  var rect = this._rect; // const texture = this._getCalculateTarget()!;

                  var tex = this.texture;
                  var atlasWidth = tex.width;
                  var atlasHeight = tex.height;
                  var leftWidth = this._capInsets[INSET_LEFT];
                  var rightWidth = this._capInsets[INSET_RIGHT];
                  var centerWidth = rect.width - leftWidth - rightWidth;
                  var topHeight = this._capInsets[INSET_TOP];
                  var bottomHeight = this._capInsets[INSET_BOTTOM];
                  var centerHeight = rect.height - topHeight - bottomHeight;
                  var uvSliced = this.uvSliced;
                  uvSliced.length = 0;

                  if (this._rotated) {
                    // Canceling out the floating-point rounding errors by slightly nudging the UV coordinates
                    temp_uvs[0].u = (rect.x + 0.5) / atlasWidth;
                    temp_uvs[1].u = (rect.x + bottomHeight) / atlasWidth;
                    temp_uvs[2].u = (rect.x + bottomHeight + centerHeight) / atlasWidth;
                    temp_uvs[3].u = (rect.x + rect.height - 0.5) / atlasWidth;
                    temp_uvs[3].v = (rect.y + 0.5) / atlasHeight;
                    temp_uvs[2].v = (rect.y + leftWidth) / atlasHeight;
                    temp_uvs[1].v = (rect.y + leftWidth + centerWidth) / atlasHeight;
                    temp_uvs[0].v = (rect.y + rect.width - 0.5) / atlasHeight;

                    for (var row = 0; row < 4; ++row) {
                      var rowD = temp_uvs[row];

                      for (var col = 0; col < 4; ++col) {
                        var colD = temp_uvs[3 - col];
                        uvSliced.push({
                          u: rowD.u,
                          v: colD.v
                        });
                      }
                    }
                  } else {
                    // Canceling out the floating-point rounding errors by slightly nudging the UV coordinates
                    temp_uvs[0].u = (rect.x + 0.5) / atlasWidth;
                    temp_uvs[1].u = (rect.x + leftWidth) / atlasWidth;
                    temp_uvs[2].u = (rect.x + leftWidth + centerWidth) / atlasWidth;
                    temp_uvs[3].u = (rect.x + rect.width - 0.5) / atlasWidth;
                    temp_uvs[3].v = (rect.y + 0.5) / atlasHeight;
                    temp_uvs[2].v = (rect.y + topHeight) / atlasHeight;
                    temp_uvs[1].v = (rect.y + topHeight + centerHeight) / atlasHeight;
                    temp_uvs[0].v = (rect.y + rect.height - 0.5) / atlasHeight;

                    for (var _row = 0; _row < 4; ++_row) {
                      var _rowD = temp_uvs[_row];

                      for (var _col = 0; _col < 4; ++_col) {
                        var _colD = temp_uvs[_col];
                        uvSliced.push({
                          u: _colD.u,
                          v: _rowD.v
                        });
                      }
                    }
                  }
                } // Calculate UV

              }, {
                key: "_calculateUV",
                value: function _calculateUV() {
                  var rect = this._rect;
                  var uv = this.uv;
                  var tex = this.texture;
                  var texw = tex.width;
                  var texh = tex.height;

                  if (this._rotated) {
                    // Canceling out the floating-point rounding errors by slightly nudging the UV coordinates
                    var l = texw === 0 ? 0 : (rect.x + 0.5) / texw;
                    var r = texw === 0 ? 0 : (rect.x + rect.height - 0.5) / texw;
                    var t = texh === 0 ? 0 : (rect.y + 0.5) / texh;
                    var b = texh === 0 ? 0 : (rect.y + rect.width - 0.5) / texh;

                    if (this._flipUv) {
                      uv[0] = l;
                      uv[1] = t;
                      uv[2] = l;
                      uv[3] = b;
                      uv[4] = r;
                      uv[5] = t;
                      uv[6] = r;
                      uv[7] = b;
                    } else {
                      uv[0] = l;
                      uv[1] = t;
                      uv[2] = l;
                      uv[3] = b;
                      uv[4] = r;
                      uv[5] = t;
                      uv[6] = r;
                      uv[7] = b;
                    }
                  } else {
                    // Canceling out the floating-point rounding errors by slightly nudging the UV coordinates
                    var _l = texw === 0 ? 0 : (rect.x + 0.5) / texw;

                    var _r = texw === 0 ? 0 : (rect.x + rect.width - 0.5) / texw;

                    var _b = texh === 0 ? 0 : (rect.y + rect.height - 0.5) / texh;

                    var _t = texh === 0 ? 0 : (rect.y + 0.5) / texh;

                    if (this._flipUv) {
                      uv[0] = _l;
                      uv[1] = _t;
                      uv[2] = _r;
                      uv[3] = _t;
                      uv[4] = _l;
                      uv[5] = _b;
                      uv[6] = _r;
                      uv[7] = _b;
                    } else {
                      uv[0] = _l;
                      uv[1] = _b;
                      uv[2] = _r;
                      uv[3] = _b;
                      uv[4] = _l;
                      uv[5] = _t;
                      uv[6] = _r;
                      uv[7] = _t;
                    }
                  }

                  var uvHashStr = '';

                  for (var i = 0; i < uv.length; i++) {
                    uvHashStr += uv[i];
                  }

                  this.uvHash = murmurhash2_32_gc(uvHashStr, 666);
                  var vertices = this.vertices;

                  if (vertices) {
                    vertices.nu.length = 0;
                    vertices.nv.length = 0;

                    for (var _i = 0; _i < vertices.u.length; _i++) {
                      vertices.nu[_i] = vertices.u[_i] / texw;
                      vertices.nv[_i] = vertices.v[_i] / texh;
                    }
                  }

                  this._calculateSlicedUV();
                } // SERIALIZATION

              }, {
                key: "_serialize",
                value: function _serialize(exporting) {
                  var rect = this._rect;
                  var offset = this._offset;
                  var originalSize = this._originalSize;
                  var uuid = this._uuid;
                  var texture;

                  if (this._texture) {
                    texture = this._texture._uuid;
                  }

                  if (uuid && exporting) {
                    uuid = EditorExtends.UuidUtils.compressUuid(uuid, true);
                  }

                  if (texture && exporting) {
                    texture = EditorExtends.UuidUtils.compressUuid(texture, true);
                  }

                  var vertices;

                  if (this.vertices) {
                    vertices = {
                      triangles: this.vertices.triangles,
                      x: this.vertices.x,
                      y: this.vertices.y,
                      u: this.vertices.u,
                      v: this.vertices.v
                    };
                  }

                  var serialize = {
                    name: this._name,
                    atlas: exporting ? undefined : this._atlasUuid,
                    // strip from json if exporting
                    rect: rect,
                    offset: offset,
                    originalSize: originalSize,
                    rotated: this._rotated,
                    capInsets: this._capInsets,
                    vertices: vertices,
                    texture: texture
                  }; // 为 underfined 的数据则不在序列化文件里显示

                  return serialize;
                }
              }, {
                key: "_deserialize",
                value: function _deserialize(serializeData, handle) {
                  var data = serializeData;
                  var rect = data.rect;

                  if (rect) {
                    this._rect = new Rect(rect.x, rect.y, rect.width, rect.height);
                  }

                  var offset = data.offset;

                  if (data.offset) {
                    this._offset = new Vec2(offset.x, offset.y);
                  }

                  var originalSize = data.originalSize;

                  if (data.originalSize) {
                    this._originalSize = new Size(originalSize.width, originalSize.height);
                  }

                  this._rotated = !!data.rotated;
                  this._name = data.name;
                  var capInsets = data.capInsets;

                  if (capInsets) {
                    this._capInsets[INSET_LEFT] = capInsets[INSET_LEFT];
                    this._capInsets[INSET_TOP] = capInsets[INSET_TOP];
                    this._capInsets[INSET_RIGHT] = capInsets[INSET_RIGHT];
                    this._capInsets[INSET_BOTTOM] = capInsets[INSET_BOTTOM];
                  }

                  if (data.texture) {
                    handle.result.push(this, '_textureSource', data.texture);
                  }

                  this.vertices = data.vertices;

                  if (this.vertices) {
                    // initialize normal uv arrays
                    this.vertices.nu = [];
                    this.vertices.nv = [];
                  }
                }
              }, {
                key: "_textureLoaded",
                value: function _textureLoaded() {
                  var tex = this._texture;
                  var config = {};
                  var isReset = false;

                  if (this._rect.width === 0 || this._rect.height === 0 || !this.checkRect(tex)) {
                    config.rect = new Rect(0, 0, tex.width, tex.height);
                    isReset = true;
                  } // If original size is not set or rect check failed, we should reset the original size


                  if (this._originalSize.width === 0 || this._originalSize.height === 0 || isReset) {
                    config.originalSize = new Size(tex.width, tex.height);
                    isReset = true;
                  }

                  if (isReset) {
                    this.reset(config);
                    this.onLoaded();
                  }
                }
              }, {
                key: "_refreshTexture",
                value: function _refreshTexture(texture) {
                  this._texture = texture;

                  if (texture.loaded) {
                    this._textureLoaded();
                  } else {
                    texture.once('load', this._textureLoaded, this);
                  }
                }
              }]);

              return SpriteFrame;
            }(Asset), _temp$6)) || _class$6));
            legacyCC.SpriteFrame = SpriteFrame;

            var _dec$7, _class$7, _class2$5, _descriptor$4, _class3$2, _temp$7;

            /**
             * @en The index for all faces of the cube
             * @zh 立方体每个面的约定索引。
             */
            var FaceIndex;
            /**
             * @en The texture cube asset.
             * Each mipmap level of a texture cube have 6 [[ImageAsset]], represents 6 faces of the cube.
             * @zh 立方体贴图资源。
             * 立方体贴图资源的每个 Mipmap 层级都为 6 张 [[ImageAsset]]，分别代表了立方体贴图的 6 个面。
             */

            (function (FaceIndex) {
              FaceIndex[FaceIndex["right"] = 0] = "right";
              FaceIndex[FaceIndex["left"] = 1] = "left";
              FaceIndex[FaceIndex["top"] = 2] = "top";
              FaceIndex[FaceIndex["bottom"] = 3] = "bottom";
              FaceIndex[FaceIndex["front"] = 4] = "front";
              FaceIndex[FaceIndex["back"] = 5] = "back";
            })(FaceIndex || (FaceIndex = {}));

            var TextureCube = exports('aZ', (_dec$7 = ccclass('cc.TextureCube'), _dec$7(_class$7 = (_class2$5 = (_temp$7 = _class3$2 = /*#__PURE__*/function (_SimpleTexture) {
              _inherits(TextureCube, _SimpleTexture);

              function TextureCube() {
                var _getPrototypeOf2;

                var _this;

                _classCallCheck(this, TextureCube);

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(TextureCube)).call.apply(_getPrototypeOf2, [this].concat(args)));

                _initializerDefineProperty(_this, "_mipmaps", _descriptor$4, _assertThisInitialized(_this));

                return _this;
              }

              _createClass(TextureCube, [{
                key: "onLoaded",
                value: function onLoaded() {
                  this.mipmaps = this._mipmaps;
                  this.loaded = true;
                  this.emit('load');
                }
                /**
                 * @en Reset the current texture with given size, pixel format and mipmap images.
                 * After reset, the gfx resource will become invalid, you must use [[uploadData]] explicitly to upload the new mipmaps to GPU resources.
                 * @zh 将当前贴图重置为指定尺寸、像素格式以及指定 mipmap 层级。重置后，贴图的像素数据将变为未定义。
                 * mipmap 图像的数据不会自动更新到贴图中，你必须显式调用 [[uploadData]] 来上传贴图数据。
                 * @param info The create information
                 */

              }, {
                key: "reset",
                value: function reset(info) {
                  this._width = info.width;
                  this._height = info.height;

                  this._setGFXFormat(info.format);

                  this._setMipmapLevel(info.mipmapLevel || 1);

                  this._tryReset();
                }
              }, {
                key: "updateMipmaps",
                value: function updateMipmaps() {
                  var _this2 = this;

                  var firstLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                  var count = arguments.length > 1 ? arguments[1] : undefined;

                  if (firstLevel >= this._mipmaps.length) {
                    return;
                  }

                  var nUpdate = Math.min(count === undefined ? this._mipmaps.length : count, this._mipmaps.length - firstLevel);

                  var _loop = function _loop(i) {
                    var level = firstLevel + i;

                    _forEachFace(_this2._mipmaps[level], function (face, faceIndex) {
                      _this2._assignImage(face, level, faceIndex);
                    });
                  };

                  for (var i = 0; i < nUpdate; ++i) {
                    _loop(i);
                  }
                }
                /**
                 * 销毁此贴图，清空所有 Mipmap 并释放占用的 GPU 资源。
                 */

              }, {
                key: "destroy",
                value: function destroy() {
                  this._mipmaps = [];
                  return _get(_getPrototypeOf(TextureCube.prototype), "destroy", this).call(this);
                }
                /**
                 * @en Release used GPU resources.
                 * @zh 释放占用的 GPU 资源。
                 * @deprecated please use [[destroy]] instead
                 */

              }, {
                key: "releaseTexture",
                value: function releaseTexture() {
                  this.mipmaps = [];
                }
              }, {
                key: "_serialize",
                value: function _serialize(exporting) {
                  return {
                    base: _get(_getPrototypeOf(TextureCube.prototype), "_serialize", this).call(this),
                    mipmaps: this._mipmaps.map(function (mipmap) {
                      return exporting ? {
                        front: EditorExtends.UuidUtils.compressUuid(mipmap.front._uuid, true),
                        back: EditorExtends.UuidUtils.compressUuid(mipmap.back._uuid, true),
                        left: EditorExtends.UuidUtils.compressUuid(mipmap.left._uuid, true),
                        right: EditorExtends.UuidUtils.compressUuid(mipmap.right._uuid, true),
                        top: EditorExtends.UuidUtils.compressUuid(mipmap.top._uuid, true),
                        bottom: EditorExtends.UuidUtils.compressUuid(mipmap.bottom._uuid, true)
                      } : {
                        front: mipmap.front._uuid,
                        back: mipmap.back._uuid,
                        left: mipmap.left._uuid,
                        right: mipmap.right._uuid,
                        top: mipmap.top._uuid,
                        bottom: mipmap.bottom._uuid
                      };
                    })
                  };
                }
              }, {
                key: "_deserialize",
                value: function _deserialize(serializedData, handle) {
                  var data = serializedData;

                  _get(_getPrototypeOf(TextureCube.prototype), "_deserialize", this).call(this, data.base, handle);

                  this._mipmaps = new Array(data.mipmaps.length);

                  for (var i = 0; i < data.mipmaps.length; ++i) {
                    // Prevent resource load failed
                    this._mipmaps[i] = {
                      front: new ImageAsset(),
                      back: new ImageAsset(),
                      left: new ImageAsset(),
                      right: new ImageAsset(),
                      top: new ImageAsset(),
                      bottom: new ImageAsset()
                    };
                    var mipmap = data.mipmaps[i];
                    handle.result.push(this._mipmaps[i], "front", mipmap.front);
                    handle.result.push(this._mipmaps[i], "back", mipmap.back);
                    handle.result.push(this._mipmaps[i], "left", mipmap.left);
                    handle.result.push(this._mipmaps[i], "right", mipmap.right);
                    handle.result.push(this._mipmaps[i], "top", mipmap.top);
                    handle.result.push(this._mipmaps[i], "bottom", mipmap.bottom);
                  }
                }
              }, {
                key: "_getGfxTextureCreateInfo",
                value: function _getGfxTextureCreateInfo(presumed) {
                  var result = Object.assign({
                    type: GFXTextureType.CUBE,
                    width: this._width,
                    height: this._height,
                    layerCount: 6
                  }, presumed);
                  result.flags = (result.flags || 0) | GFXTextureFlagBit.CUBEMAP;
                  return result;
                }
              }, {
                key: "mipmaps",

                /**
                 * @en All levels of mipmap images, be noted, automatically generated mipmaps are not included.
                 * When setup mipmap, the size of the texture and pixel format could be modified.
                 * @zh 所有层级 Mipmap，注意，这里不包含自动生成的 Mipmap。
                 * 当设置 Mipmap 时，贴图的尺寸以及像素格式可能会改变。
                 */
                get: function get() {
                  return this._mipmaps;
                },
                set: function set(value) {
                  var _this3 = this;

                  this._mipmaps = value;

                  this._setMipmapLevel(this._mipmaps.length);

                  if (this._mipmaps.length > 0) {
                    var imageAsset = this._mipmaps[0].front;
                    this.reset({
                      width: imageAsset.width,
                      height: imageAsset.height,
                      format: imageAsset.format,
                      mipmapLevel: this._mipmaps.length
                    });

                    this._mipmaps.forEach(function (mipmap, level) {
                      _forEachFace(mipmap, function (face, faceIndex) {
                        _this3._assignImage(face, level, faceIndex);
                      });
                    });
                  } else {
                    this.reset({
                      width: 0,
                      height: 0,
                      mipmapLevel: this._mipmaps.length
                    });
                  }
                }
                /**
                 * @en Level 0 mipmap image.
                 * Be noted, `this.image = img` equals `this.mipmaps = [img]`, 
                 * sets image will clear all previous mipmaps.
                 * @zh 0 级 Mipmap。
                 * 注意，`this.image = img` 等价于 `this.mipmaps = [img]`，
                 * 也就是说，通过 `this.image` 设置 0 级 Mipmap 时将隐式地清除之前的所有 Mipmap。
                 */

              }, {
                key: "image",
                get: function get() {
                  return this._mipmaps.length === 0 ? null : this._mipmaps[0];
                },
                set: function set(value) {
                  this.mipmaps = value ? [value] : [];
                }
                /**
                 * @en Create a texture cube with an array of [[Texture2D]] which represents 6 faces of the texture cube.
                 * @zh 通过二维贴图数组指定每个 Mipmap 的每个面创建立方体贴图。
                 * @param textures Texture array, the texture count must be multiple of 6. Every 6 textures are 6 faces of a mipmap level. The order should obey [[FaceIndex]] order.
                 * @param out Output texture cube, if not given, will create a new texture cube.
                 * @returns The created texture cube.
                 * @example
                 * ```ts
                 * const textures = new Array<Texture2D>(6);
                 * textures[TextureCube.FaceIndex.front] = frontImage;
                 * textures[TextureCube.FaceIndex.back] = backImage;
                 * textures[TextureCube.FaceIndex.left] = leftImage;
                 * textures[TextureCube.FaceIndex.right] = rightImage;
                 * textures[TextureCube.FaceIndex.top] = topImage;
                 * textures[TextureCube.FaceIndex.bottom] = bottomImage;
                 * const textureCube = TextureCube.fromTexture2DArray(textures);
                 * ```
                 */

              }], [{
                key: "fromTexture2DArray",
                value: function fromTexture2DArray(textures, out) {
                  var mipmaps = [];
                  var nMipmaps = textures.length / 6;

                  for (var i = 0; i < nMipmaps; i++) {
                    var x = i * 6;
                    mipmaps.push({
                      front: textures[x + FaceIndex.front].image,
                      back: textures[x + FaceIndex.back].image,
                      left: textures[x + FaceIndex.left].image,
                      right: textures[x + FaceIndex.right].image,
                      top: textures[x + FaceIndex.top].image,
                      bottom: textures[x + FaceIndex.bottom].image
                    });
                  }

                  out = out || new TextureCube();
                  out.mipmaps = mipmaps;
                  return out;
                }
              }]);

              return TextureCube;
            }(SimpleTexture), _class3$2.FaceIndex = FaceIndex, _temp$7), (_descriptor$4 = _applyDecoratedDescriptor(_class2$5.prototype, "_mipmaps", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [];
              }
            })), _class2$5)) || _class$7));
            legacyCC.TextureCube = TextureCube;

            /**
             * @param {Mipmap} mipmap
             * @param {(face: ImageAsset) => void} callback
             */
            function _forEachFace(mipmap, callback) {
              callback(mipmap.front, FaceIndex.front);
              callback(mipmap.back, FaceIndex.back);
              callback(mipmap.left, FaceIndex.left);
              callback(mipmap.right, FaceIndex.right);
              callback(mipmap.top, FaceIndex.top);
              callback(mipmap.bottom, FaceIndex.bottom);
            }

            // tslint:disable
            // absolute essential effects
            var effects = exports('d1', [{
              "name": "builtin-billboard",
              "_uuid": "711ebe11-f673-4cd9-9a83-63c60ba54c5b",
              "techniques": [{
                "name": "add",
                "passes": [{
                  "rasterizerState": {
                    "cullMode": 0
                  },
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 2,
                      "blendDst": 1,
                      "blendSrcAlpha": 2,
                      "blendDstAlpha": 1
                    }]
                  },
                  "program": "builtin-billboard|vert:vs_main|tinted-fs:add",
                  "depthStencilState": {
                    "depthTest": true,
                    "depthWrite": false
                  },
                  "properties": {
                    "mainTexture": {
                      "value": "grey",
                      "type": 28
                    },
                    "mainTiling_Offset": {
                      "value": [1, 1, 0, 0],
                      "type": 16
                    },
                    "tintColor": {
                      "value": [0.5, 0.5, 0.5, 0.5],
                      "type": 16
                    }
                  }
                }]
              }],
              "shaders": [{
                "name": "builtin-billboard|vert:vs_main|tinted-fs:add",
                "hash": 2143664850,
                "glsl3": {
                  "vert": "\nprecision mediump float;\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n  , mat4 viewInv\n) {\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n}\nin vec3 a_position;\nin vec2 a_texCoord;\nin vec4 a_color;\nlayout(std140) uniform builtin {\n  vec4 cc_size_rotation;\n};\nvec4 vs_main() {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matWorld * pos;\n  vec2 vertOffset = a_texCoord.xy - 0.5;\n  computeVertPos(pos, vertOffset, quaternionFromEuler(vec3(0., 0., cc_size_rotation.z)), vec3(cc_size_rotation.xy, 0.), cc_matViewInv);\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.xy;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }",
                  "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
                },
                "glsl1": {
                  "vert": "\nprecision mediump float;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewInv;\nuniform highp mat4 cc_matViewProj;\nuniform highp mat4 cc_matWorld;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n  , mat4 viewInv\n) {\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n}\nattribute vec3 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nuniform vec4 cc_size_rotation;\nvec4 vs_main() {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matWorld * pos;\n  vec2 vertOffset = a_texCoord.xy - 0.5;\n  computeVertPos(pos, vertOffset, quaternionFromEuler(vec3(0., 0., cc_size_rotation.z)), vec3(cc_size_rotation.xy, 0.), cc_matViewInv);\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.xy;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }",
                  "frag": "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"
                },
                "glsl4": {
                  "vert": "\nprecision mediump float;\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n  , mat4 viewInv\n) {\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec2 a_texCoord;\nlayout(location = 2) in vec4 a_color;\nlayout(set = 1, binding = 1) uniform builtin {\n  vec4 cc_size_rotation;\n};\nvec4 vs_main() {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matWorld * pos;\n  vec2 vertOffset = a_texCoord.xy - 0.5;\n  computeVertPos(pos, vertOffset, quaternionFromEuler(vec3(0., 0., cc_size_rotation.z)), vec3(cc_size_rotation.xy, 0.), cc_matViewInv);\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.xy;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }",
                  "frag": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 3) uniform sampler2D mainTexture;\nlayout(set = 1, binding = 2) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
                },
                "builtins": {
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }],
                    "samplers": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCLocal",
                      "defines": []
                    }],
                    "samplers": []
                  }
                },
                "defines": [{
                  "name": "CC_USE_HDR",
                  "type": "boolean"
                }],
                "blocks": [{
                  "name": "Constants",
                  "defines": [],
                  "binding": 0,
                  "stageFlags": 1,
                  "members": [{
                    "name": "mainTiling_Offset",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "frameTile_velLenScale",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "scale",
                    "type": 16,
                    "count": 1
                  }]
                }, {
                  "name": "builtin",
                  "defines": [],
                  "binding": 1,
                  "stageFlags": 1,
                  "members": [{
                    "name": "cc_size_rotation",
                    "type": 16,
                    "count": 1
                  }]
                }, {
                  "name": "FragConstants",
                  "defines": [],
                  "binding": 2,
                  "stageFlags": 16,
                  "members": [{
                    "name": "tintColor",
                    "type": 16,
                    "count": 1
                  }]
                }],
                "samplers": [{
                  "name": "mainTexture",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 3
                }],
                "attributes": [{
                  "name": "a_position",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_texCoord",
                  "type": 14,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 21,
                  "location": 1
                }, {
                  "name": "a_color",
                  "type": 16,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 2
                }]
              }]
            }, {
              "name": "builtin-graphics",
              "_uuid": "1c02ae6f-4492-4915-b8f8-7492a3b1e4cd",
              "techniques": [{
                "passes": [{
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 1,
                      "blendDst": 4,
                      "blendSrcAlpha": 1,
                      "blendDstAlpha": 4
                    }]
                  },
                  "rasterizerState": {
                    "cullMode": 0
                  },
                  "program": "builtin-graphics|vs:vert|fs:frag"
                }]
              }],
              "shaders": [{
                "name": "builtin-graphics|vs:vert|fs:frag",
                "hash": 3946667351,
                "glsl3": {
                  "vert": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\nin float a_dist;\nout float v_dist;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matViewProj * cc_matWorld * pos;\n  v_color = a_color;\n  v_dist = a_dist;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }",
                  "frag": "\nprecision highp float;\nin vec4 v_color;\nin float v_dist;\nvec4 frag () {\n  vec4 o = v_color;\n    float aa = fwidth(v_dist);\n  float alpha = 1. - smoothstep(-aa, 0., abs(v_dist) - 1.0);\n  o.rgb *= o.a;\n  o *= alpha;\n  return o;\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
                },
                "glsl1": {
                  "vert": "\nprecision highp float;\nuniform highp mat4 cc_matViewProj;\nuniform highp mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\nattribute float a_dist;\nvarying float v_dist;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matViewProj * cc_matWorld * pos;\n  v_color = a_color;\n  v_dist = a_dist;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }",
                  "frag": "\n#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives: enable\n#endif\nprecision highp float;\nvarying vec4 v_color;\nvarying float v_dist;\nvec4 frag () {\n  vec4 o = v_color;\n    #ifdef GL_OES_standard_derivatives\n      float aa = fwidth(v_dist);\n    #else\n      float aa = 0.05;\n    #endif\n  float alpha = 1. - smoothstep(-aa, 0., abs(v_dist) - 1.0);\n  o.rgb *= o.a;\n  o *= alpha;\n  return o;\n}\nvoid main() { gl_FragColor = frag(); }"
                },
                "glsl4": {
                  "vert": "\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec4 a_color;\nlayout(location = 0) out vec4 v_color;\nlayout(location = 2) in float a_dist;\nlayout(location = 1) out float v_dist;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  pos = cc_matViewProj * cc_matWorld * pos;\n  v_color = a_color;\n  v_dist = a_dist;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }",
                  "frag": "\nprecision highp float;\nlayout(location = 0) in vec4 v_color;\nlayout(location = 1) in float v_dist;\nvec4 frag () {\n  vec4 o = v_color;\n    float aa = fwidth(v_dist);\n  float alpha = 1. - smoothstep(-aa, 0., abs(v_dist) - 1.0);\n  o.rgb *= o.a;\n  o *= alpha;\n  return o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
                },
                "builtins": {
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }],
                    "samplers": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCLocal",
                      "defines": []
                    }],
                    "samplers": []
                  }
                },
                "defines": [],
                "blocks": [],
                "samplers": [],
                "attributes": [{
                  "name": "a_position",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_color",
                  "type": 16,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 1
                }, {
                  "name": "a_dist",
                  "type": 13,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 11,
                  "location": 2
                }]
              }]
            }, {
              "name": "builtin-particle-gpu",
              "_uuid": "971bdb23-3ff6-43eb-b422-1c30165a3663",
              "techniques": [{
                "name": "add",
                "passes": [{
                  "rasterizerState": {
                    "cullMode": 0
                  },
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 2,
                      "blendDst": 1,
                      "blendSrcAlpha": 2,
                      "blendDstAlpha": 1
                    }]
                  },
                  "program": "builtin-particle-gpu|particle-vs-gpu:gpvs_main|tinted-fs:add",
                  "depthStencilState": {
                    "depthTest": true,
                    "depthWrite": false
                  },
                  "properties": {
                    "mainTexture": {
                      "value": "grey",
                      "type": 28
                    },
                    "mainTiling_Offset": {
                      "value": [1, 1, 0, 0],
                      "type": 16
                    },
                    "tintColor": {
                      "value": [0.5, 0.5, 0.5, 0.5],
                      "type": 16
                    }
                  }
                }]
              }],
              "shaders": [{
                "name": "builtin-particle-gpu|particle-vs-gpu:gpvs_main|tinted-fs:add",
                "hash": 3696836305,
                "glsl3": {
                  "vert": "\nprecision mediump float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(std140) uniform SampleConstants {\n  vec4 u_sampleInfo;\n};\nlayout(std140) uniform TickConstants {\n  vec4 u_worldRot;\n  vec4 u_timeDelta;\n};\nin vec4 a_position_starttime;\nin vec4 a_size_uv;\nin vec4 a_rotation_uv;\nin vec4 a_color;\nin vec4 a_dir_life;\nin float a_rndSeed;\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord;\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec3 unpackCurveData (sampler2D tex, vec2 coord) {\n    vec4 a = texture(tex, coord);\n    vec4 b = texture(tex, coord + u_sampleInfo.y);\n    float c = fract(coord.x * u_sampleInfo.x);\n    return mix(a.xyz, b.xyz, c);\n}\nvec3 unpackCurveData (sampler2D tex, vec2 coord, out float w) {\n    vec4 a = texture(tex, coord);\n    vec4 b = texture(tex, coord + u_sampleInfo.y);\n    float c = fract(coord.x * u_sampleInfo.x);\n    w = mix(a.w, b.w, c);\n    return mix(a.xyz, b.xyz, c);\n}\nfloat pseudoRandom (float seed) {\n  seed = mod(seed, 233280.);\n  float q = (seed * 9301. + 49297.) / 233280.;\n  return fract(q);\n}\n#if COLOR_OVER_TIME_MODULE_ENABLE\n  uniform sampler2D color_over_time_tex0;\n  layout(std140) uniform ColorConstant {\n    int u_color_mode;\n  };\n#endif\n#if ROTATION_OVER_TIME_MODULE_ENABLE\n  uniform sampler2D rotation_over_time_tex0;\n  layout(std140) uniform RotationConstant {\n    int u_rotation_mode;\n  };\n#endif\n#if SIZE_OVER_TIME_MODULE_ENABLE\n  uniform sampler2D size_over_time_tex0;\n  layout(std140) uniform SizeConstant {\n    int u_size_mode;\n  };\n#endif\n#if FORCE_OVER_TIME_MODULE_ENABLE\n  uniform sampler2D force_over_time_tex0;\n  layout(std140) uniform ForceConstant {\n    int u_force_mode;\n    int u_force_space;\n  };\n#endif\n#if VELOCITY_OVER_TIME_MODULE_ENABLE\n  uniform sampler2D velocity_over_time_tex0;\n  layout(std140) uniform VelocityConstant {\n    int u_velocity_mode;\n    int u_velocity_space;\n  };\n#endif\n#if TEXTURE_ANIMATION_MODULE_ENABLE\n  uniform sampler2D texture_animation_tex0;\n  layout(std140) uniform AnimationConstant {\n    vec4 u_anim_info;\n  };\n#endif\nfloat repeat (float t, float length) {\n  return t - floor(t / length) * length;\n}\nvec4 rotateQuat (vec4 p, vec4 q) {\n  vec3 iv = cross(q.xyz, p.xyz) + q.w * p.xyz;\n  vec3 res = p.xyz + 2.0 * cross(q.xyz, iv);\n  return vec4(res.xyz, p.w);\n}\nvec4 gpvs_main () {\n  float activeTime = u_timeDelta.x - a_position_starttime.w;\n  float normalizedTime = clamp(activeTime / a_dir_life.w, 0.0, 1.0);\n  vec2 timeCoord0 = vec2(normalizedTime, 0.);\n  vec2 timeCoord1 = vec2(normalizedTime, 1.);\n  #if CC_RENDER_MODE == 4\n    vec2 vertIdx = vec2(a_texCoord.x, a_texCoord.y);\n  #else\n    vec2 vertIdx = vec2(a_size_uv.w, a_rotation_uv.w);\n  #endif\n  vec4 velocity = vec4(a_dir_life.xyz, 0.);\n  vec4 pos = vec4(a_position_starttime.xyz, 1.);\n  vec3 size = a_size_uv.xyz;\n  #if SIZE_OVER_TIME_MODULE_ENABLE\n    if (u_size_mode == 1) {\n      size *= unpackCurveData(size_over_time_tex0, timeCoord0);\n    } else {\n      vec3 size_0 = unpackCurveData(size_over_time_tex0, timeCoord0);\n      vec3 size_1 = unpackCurveData(size_over_time_tex0, timeCoord1);\n      float factor_s = pseudoRandom(a_rndSeed + 39825.);\n      size *= mix(size_0, size_1, factor_s);\n    }\n  #endif\n  vec3 compScale = scale.xyz * size;\n  #if FORCE_OVER_TIME_MODULE_ENABLE\n    vec3 forceAnim = vec3(0.);\n    if (u_force_mode == 1) {\n      forceAnim = unpackCurveData(force_over_time_tex0, timeCoord0);\n    } else {\n      vec3 force_0 = unpackCurveData(force_over_time_tex0, timeCoord0);\n      vec3 force_1 = unpackCurveData(force_over_time_tex0, timeCoord1);\n      float factor_f =  pseudoRandom(a_rndSeed + 212165.);\n      forceAnim = mix(force_0, force_1, factor_f);\n    }\n    vec4 forceTrack = vec4(forceAnim, 0.);\n    if (u_force_space == 0) {\n      forceTrack = rotateQuat(forceTrack, u_worldRot);\n    }\n    velocity.xyz += forceTrack.xyz;\n  #endif\n  #if VELOCITY_OVER_TIME_MODULE_ENABLE\n    float speedModifier0 = 1.;\n    float speedModifier1 = 1.;\n    vec3 velocityAnim = vec3(0.);\n    if (u_velocity_mode == 1) {\n      velocityAnim = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\n    } else {\n      vec3 vectory_0 = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\n      vec3 vectory_1 = unpackCurveData(velocity_over_time_tex0, timeCoord1, speedModifier1);\n      float factor_v = pseudoRandom(a_rndSeed + 197866.);\n      velocityAnim = mix(vectory_0, vectory_1, factor_v);\n      speedModifier0 = mix(speedModifier0, speedModifier1, factor_v);\n    }\n    vec4 velocityTrack = vec4(velocityAnim, 0.);\n    if (u_velocity_space == 0) {\n      velocityTrack = rotateQuat(velocityTrack, u_worldRot);\n    }\n    velocity.xyz += velocityTrack.xyz;\n    velocity.xyz *= speedModifier0;\n  #endif\n  pos.xyz += velocity.xyz * normalizedTime * a_dir_life.w;\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = rotateQuat(velocity, u_worldRot);\n    #endif\n  #endif\n  vec3 rotation = a_rotation_uv.xyz;\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    if (u_rotation_mode == 1) {\n      rotation += unpackCurveData(rotation_over_time_tex0, timeCoord0) * normalizedTime * a_dir_life.w;\n    } else {\n      vec3 rotation_0 = unpackCurveData(rotation_over_time_tex0, timeCoord0);\n      vec3 rotation_1 = unpackCurveData(rotation_over_time_tex0, timeCoord1);\n      float factor_r = pseudoRandom(a_rndSeed + 125292.);\n      rotation += mix(rotation_0, rotation_1, factor_r) * normalizedTime * a_dir_life.w;\n    }\n  #endif\n  #if COLOR_OVER_TIME_MODULE_ENABLE\n    if (u_color_mode == 1) {\n      color = a_color * texture(color_over_time_tex0, timeCoord0);\n    } else {\n      vec4 color_0 = texture(color_over_time_tex0, timeCoord0);\n      vec4 color_1 = texture(color_over_time_tex0, timeCoord1);\n      float factor_c = pseudoRandom(a_rndSeed + 91041.);\n      color = a_color * mix(color_0, color_1, factor_c);\n    }\n  #else\n    color = a_color;\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((vertIdx - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = rotation.xyz;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., rotation.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n      #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n        , cc_matViewInv\n      #endif\n      #if CC_RENDER_MODE == 1\n        , cc_cameraPos.xyz\n        , velocity\n        , frameTile_velLenScale.z\n        , frameTile_velLenScale.w\n        , a_size_uv.w\n      #endif\n    );\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(rotation), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(rotation), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color *= a_color1;\n  #endif\n  pos = cc_matViewProj * pos;\n  float frameIndex = 0.;\n  #if TEXTURE_ANIMATION_MODULE_ENABLE\n    float startFrame = 0.;\n    vec3 frameInfo = vec3(0.);\n    if (int(u_anim_info.x) == 1) {\n      frameInfo = unpackCurveData(texture_animation_tex0, timeCoord0);\n    } else {\n      vec3 frameInfo0 = unpackCurveData(texture_animation_tex0, timeCoord0);\n      vec3 frameInfo1 = unpackCurveData(texture_animation_tex0, timeCoord1);\n      float factor_t = pseudoRandom(a_rndSeed + 90794.);\n      frameInfo = mix(frameInfo0, frameInfo1, factor_t);\n    }\n    startFrame = frameInfo.x / u_anim_info.y;\n    frameIndex = repeat(u_anim_info.z * (frameInfo.y + startFrame), 1.);\n  #endif\n  uv = computeUV(frameIndex, vertIdx, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  return pos;\n}\nvoid main() { gl_Position = gpvs_main(); }",
                  "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
                },
                "glsl1": {
                  "vert": "\nprecision mediump float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nuniform vec4 mainTiling_Offset;\nuniform vec4 frameTile_velLenScale;\nuniform vec4 scale;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewInv;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nuniform vec4 u_sampleInfo;\nuniform vec4 u_worldRot;\nuniform vec4 u_timeDelta;\nattribute vec4 a_position_starttime;\nattribute vec4 a_size_uv;\nattribute vec4 a_rotation_uv;\nattribute vec4 a_color;\nattribute vec4 a_dir_life;\nattribute float a_rndSeed;\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord;\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec3 unpackCurveData (sampler2D tex, vec2 coord) {\n    vec4 a = texture2D(tex, coord);\n    vec4 b = texture2D(tex, coord + u_sampleInfo.y);\n    float c = fract(coord.x * u_sampleInfo.x);\n    return mix(a.xyz, b.xyz, c);\n}\nvec3 unpackCurveData (sampler2D tex, vec2 coord, out float w) {\n    vec4 a = texture2D(tex, coord);\n    vec4 b = texture2D(tex, coord + u_sampleInfo.y);\n    float c = fract(coord.x * u_sampleInfo.x);\n    w = mix(a.w, b.w, c);\n    return mix(a.xyz, b.xyz, c);\n}\nfloat pseudoRandom (float seed) {\n  seed = mod(seed, 233280.);\n  float q = (seed * 9301. + 49297.) / 233280.;\n  return fract(q);\n}\n#if COLOR_OVER_TIME_MODULE_ENABLE\n  uniform sampler2D color_over_time_tex0;\n  uniform int u_color_mode;\n#endif\n#if ROTATION_OVER_TIME_MODULE_ENABLE\n  uniform sampler2D rotation_over_time_tex0;\n  uniform int u_rotation_mode;\n#endif\n#if SIZE_OVER_TIME_MODULE_ENABLE\n  uniform sampler2D size_over_time_tex0;\n  uniform int u_size_mode;\n#endif\n#if FORCE_OVER_TIME_MODULE_ENABLE\n  uniform sampler2D force_over_time_tex0;\n  uniform int u_force_mode;\nuniform int u_force_space;\n#endif\n#if VELOCITY_OVER_TIME_MODULE_ENABLE\n  uniform sampler2D velocity_over_time_tex0;\n  uniform int u_velocity_mode;\nuniform int u_velocity_space;\n#endif\n#if TEXTURE_ANIMATION_MODULE_ENABLE\n  uniform sampler2D texture_animation_tex0;\n  uniform vec4 u_anim_info;\n#endif\nfloat repeat (float t, float length) {\n  return t - floor(t / length) * length;\n}\nvec4 rotateQuat (vec4 p, vec4 q) {\n  vec3 iv = cross(q.xyz, p.xyz) + q.w * p.xyz;\n  vec3 res = p.xyz + 2.0 * cross(q.xyz, iv);\n  return vec4(res.xyz, p.w);\n}\nvec4 gpvs_main () {\n  float activeTime = u_timeDelta.x - a_position_starttime.w;\n  float normalizedTime = clamp(activeTime / a_dir_life.w, 0.0, 1.0);\n  vec2 timeCoord0 = vec2(normalizedTime, 0.);\n  vec2 timeCoord1 = vec2(normalizedTime, 1.);\n  #if CC_RENDER_MODE == 4\n    vec2 vertIdx = vec2(a_texCoord.x, a_texCoord.y);\n  #else\n    vec2 vertIdx = vec2(a_size_uv.w, a_rotation_uv.w);\n  #endif\n  vec4 velocity = vec4(a_dir_life.xyz, 0.);\n  vec4 pos = vec4(a_position_starttime.xyz, 1.);\n  vec3 size = a_size_uv.xyz;\n  #if SIZE_OVER_TIME_MODULE_ENABLE\n    if (u_size_mode == 1) {\n      size *= unpackCurveData(size_over_time_tex0, timeCoord0);\n    } else {\n      vec3 size_0 = unpackCurveData(size_over_time_tex0, timeCoord0);\n      vec3 size_1 = unpackCurveData(size_over_time_tex0, timeCoord1);\n      float factor_s = pseudoRandom(a_rndSeed + 39825.);\n      size *= mix(size_0, size_1, factor_s);\n    }\n  #endif\n  vec3 compScale = scale.xyz * size;\n  #if FORCE_OVER_TIME_MODULE_ENABLE\n    vec3 forceAnim = vec3(0.);\n    if (u_force_mode == 1) {\n      forceAnim = unpackCurveData(force_over_time_tex0, timeCoord0);\n    } else {\n      vec3 force_0 = unpackCurveData(force_over_time_tex0, timeCoord0);\n      vec3 force_1 = unpackCurveData(force_over_time_tex0, timeCoord1);\n      float factor_f =  pseudoRandom(a_rndSeed + 212165.);\n      forceAnim = mix(force_0, force_1, factor_f);\n    }\n    vec4 forceTrack = vec4(forceAnim, 0.);\n    if (u_force_space == 0) {\n      forceTrack = rotateQuat(forceTrack, u_worldRot);\n    }\n    velocity.xyz += forceTrack.xyz;\n  #endif\n  #if VELOCITY_OVER_TIME_MODULE_ENABLE\n    float speedModifier0 = 1.;\n    float speedModifier1 = 1.;\n    vec3 velocityAnim = vec3(0.);\n    if (u_velocity_mode == 1) {\n      velocityAnim = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\n    } else {\n      vec3 vectory_0 = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\n      vec3 vectory_1 = unpackCurveData(velocity_over_time_tex0, timeCoord1, speedModifier1);\n      float factor_v = pseudoRandom(a_rndSeed + 197866.);\n      velocityAnim = mix(vectory_0, vectory_1, factor_v);\n      speedModifier0 = mix(speedModifier0, speedModifier1, factor_v);\n    }\n    vec4 velocityTrack = vec4(velocityAnim, 0.);\n    if (u_velocity_space == 0) {\n      velocityTrack = rotateQuat(velocityTrack, u_worldRot);\n    }\n    velocity.xyz += velocityTrack.xyz;\n    velocity.xyz *= speedModifier0;\n  #endif\n  pos.xyz += velocity.xyz * normalizedTime * a_dir_life.w;\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = rotateQuat(velocity, u_worldRot);\n    #endif\n  #endif\n  vec3 rotation = a_rotation_uv.xyz;\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    if (u_rotation_mode == 1) {\n      rotation += unpackCurveData(rotation_over_time_tex0, timeCoord0) * normalizedTime * a_dir_life.w;\n    } else {\n      vec3 rotation_0 = unpackCurveData(rotation_over_time_tex0, timeCoord0);\n      vec3 rotation_1 = unpackCurveData(rotation_over_time_tex0, timeCoord1);\n      float factor_r = pseudoRandom(a_rndSeed + 125292.);\n      rotation += mix(rotation_0, rotation_1, factor_r) * normalizedTime * a_dir_life.w;\n    }\n  #endif\n  #if COLOR_OVER_TIME_MODULE_ENABLE\n    if (u_color_mode == 1) {\n      color = a_color * texture2D(color_over_time_tex0, timeCoord0);\n    } else {\n      vec4 color_0 = texture2D(color_over_time_tex0, timeCoord0);\n      vec4 color_1 = texture2D(color_over_time_tex0, timeCoord1);\n      float factor_c = pseudoRandom(a_rndSeed + 91041.);\n      color = a_color * mix(color_0, color_1, factor_c);\n    }\n  #else\n    color = a_color;\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((vertIdx - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = rotation.xyz;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., rotation.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n      #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n        , cc_matViewInv\n      #endif\n      #if CC_RENDER_MODE == 1\n        , cc_cameraPos.xyz\n        , velocity\n        , frameTile_velLenScale.z\n        , frameTile_velLenScale.w\n        , a_size_uv.w\n      #endif\n    );\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(rotation), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(rotation), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color *= a_color1;\n  #endif\n  pos = cc_matViewProj * pos;\n  float frameIndex = 0.;\n  #if TEXTURE_ANIMATION_MODULE_ENABLE\n    float startFrame = 0.;\n    vec3 frameInfo = vec3(0.);\n    if (int(u_anim_info.x) == 1) {\n      frameInfo = unpackCurveData(texture_animation_tex0, timeCoord0);\n    } else {\n      vec3 frameInfo0 = unpackCurveData(texture_animation_tex0, timeCoord0);\n      vec3 frameInfo1 = unpackCurveData(texture_animation_tex0, timeCoord1);\n      float factor_t = pseudoRandom(a_rndSeed + 90794.);\n      frameInfo = mix(frameInfo0, frameInfo1, factor_t);\n    }\n    startFrame = frameInfo.x / u_anim_info.y;\n    frameIndex = repeat(u_anim_info.z * (frameInfo.y + startFrame), 1.);\n  #endif\n  uv = computeUV(frameIndex, vertIdx, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  return pos;\n}\nvoid main() { gl_Position = gpvs_main(); }",
                  "frag": "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"
                },
                "glsl4": {
                  "vert": "\nprecision mediump float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(set = 1, binding = 1) uniform SampleConstants {\n  vec4 u_sampleInfo;\n};\nlayout(set = 1, binding = 2) uniform TickConstants {\n  vec4 u_worldRot;\n  vec4 u_timeDelta;\n};\nlayout(location = 0) in vec4 a_position_starttime;\nlayout(location = 1) in vec4 a_size_uv;\nlayout(location = 2) in vec4 a_rotation_uv;\nlayout(location = 3) in vec4 a_color;\nlayout(location = 4) in vec4 a_dir_life;\nlayout(location = 5) in float a_rndSeed;\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord;\n  layout(location = 7) in vec3 a_texCoord3;\n  layout(location = 8) in vec3 a_normal;\n  layout(location = 9) in vec4 a_color1;\n#endif\nvec3 unpackCurveData (sampler2D tex, vec2 coord) {\n    vec4 a = texture(tex, coord);\n    vec4 b = texture(tex, coord + u_sampleInfo.y);\n    float c = fract(coord.x * u_sampleInfo.x);\n    return mix(a.xyz, b.xyz, c);\n}\nvec3 unpackCurveData (sampler2D tex, vec2 coord, out float w) {\n    vec4 a = texture(tex, coord);\n    vec4 b = texture(tex, coord + u_sampleInfo.y);\n    float c = fract(coord.x * u_sampleInfo.x);\n    w = mix(a.w, b.w, c);\n    return mix(a.xyz, b.xyz, c);\n}\nfloat pseudoRandom (float seed) {\n  seed = mod(seed, 233280.);\n  float q = (seed * 9301. + 49297.) / 233280.;\n  return fract(q);\n}\n#if COLOR_OVER_TIME_MODULE_ENABLE\n  layout(set = 1, binding = 10) uniform sampler2D color_over_time_tex0;\n  layout(set = 1, binding = 3) uniform ColorConstant {\n    int u_color_mode;\n  };\n#endif\n#if ROTATION_OVER_TIME_MODULE_ENABLE\n  layout(set = 1, binding = 11) uniform sampler2D rotation_over_time_tex0;\n  layout(set = 1, binding = 4) uniform RotationConstant {\n    int u_rotation_mode;\n  };\n#endif\n#if SIZE_OVER_TIME_MODULE_ENABLE\n  layout(set = 1, binding = 12) uniform sampler2D size_over_time_tex0;\n  layout(set = 1, binding = 5) uniform SizeConstant {\n    int u_size_mode;\n  };\n#endif\n#if FORCE_OVER_TIME_MODULE_ENABLE\n  layout(set = 1, binding = 13) uniform sampler2D force_over_time_tex0;\n  layout(set = 1, binding = 6) uniform ForceConstant {\n    int u_force_mode;\n    int u_force_space;\n  };\n#endif\n#if VELOCITY_OVER_TIME_MODULE_ENABLE\n  layout(set = 1, binding = 14) uniform sampler2D velocity_over_time_tex0;\n  layout(set = 1, binding = 7) uniform VelocityConstant {\n    int u_velocity_mode;\n    int u_velocity_space;\n  };\n#endif\n#if TEXTURE_ANIMATION_MODULE_ENABLE\n  layout(set = 1, binding = 15) uniform sampler2D texture_animation_tex0;\n  layout(set = 1, binding = 8) uniform AnimationConstant {\n    vec4 u_anim_info;\n  };\n#endif\nfloat repeat (float t, float length) {\n  return t - floor(t / length) * length;\n}\nvec4 rotateQuat (vec4 p, vec4 q) {\n  vec3 iv = cross(q.xyz, p.xyz) + q.w * p.xyz;\n  vec3 res = p.xyz + 2.0 * cross(q.xyz, iv);\n  return vec4(res.xyz, p.w);\n}\nvec4 gpvs_main () {\n  float activeTime = u_timeDelta.x - a_position_starttime.w;\n  float normalizedTime = clamp(activeTime / a_dir_life.w, 0.0, 1.0);\n  vec2 timeCoord0 = vec2(normalizedTime, 0.);\n  vec2 timeCoord1 = vec2(normalizedTime, 1.);\n  #if CC_RENDER_MODE == 4\n    vec2 vertIdx = vec2(a_texCoord.x, a_texCoord.y);\n  #else\n    vec2 vertIdx = vec2(a_size_uv.w, a_rotation_uv.w);\n  #endif\n  vec4 velocity = vec4(a_dir_life.xyz, 0.);\n  vec4 pos = vec4(a_position_starttime.xyz, 1.);\n  vec3 size = a_size_uv.xyz;\n  #if SIZE_OVER_TIME_MODULE_ENABLE\n    if (u_size_mode == 1) {\n      size *= unpackCurveData(size_over_time_tex0, timeCoord0);\n    } else {\n      vec3 size_0 = unpackCurveData(size_over_time_tex0, timeCoord0);\n      vec3 size_1 = unpackCurveData(size_over_time_tex0, timeCoord1);\n      float factor_s = pseudoRandom(a_rndSeed + 39825.);\n      size *= mix(size_0, size_1, factor_s);\n    }\n  #endif\n  vec3 compScale = scale.xyz * size;\n  #if FORCE_OVER_TIME_MODULE_ENABLE\n    vec3 forceAnim = vec3(0.);\n    if (u_force_mode == 1) {\n      forceAnim = unpackCurveData(force_over_time_tex0, timeCoord0);\n    } else {\n      vec3 force_0 = unpackCurveData(force_over_time_tex0, timeCoord0);\n      vec3 force_1 = unpackCurveData(force_over_time_tex0, timeCoord1);\n      float factor_f =  pseudoRandom(a_rndSeed + 212165.);\n      forceAnim = mix(force_0, force_1, factor_f);\n    }\n    vec4 forceTrack = vec4(forceAnim, 0.);\n    if (u_force_space == 0) {\n      forceTrack = rotateQuat(forceTrack, u_worldRot);\n    }\n    velocity.xyz += forceTrack.xyz;\n  #endif\n  #if VELOCITY_OVER_TIME_MODULE_ENABLE\n    float speedModifier0 = 1.;\n    float speedModifier1 = 1.;\n    vec3 velocityAnim = vec3(0.);\n    if (u_velocity_mode == 1) {\n      velocityAnim = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\n    } else {\n      vec3 vectory_0 = unpackCurveData(velocity_over_time_tex0, timeCoord0, speedModifier0);\n      vec3 vectory_1 = unpackCurveData(velocity_over_time_tex0, timeCoord1, speedModifier1);\n      float factor_v = pseudoRandom(a_rndSeed + 197866.);\n      velocityAnim = mix(vectory_0, vectory_1, factor_v);\n      speedModifier0 = mix(speedModifier0, speedModifier1, factor_v);\n    }\n    vec4 velocityTrack = vec4(velocityAnim, 0.);\n    if (u_velocity_space == 0) {\n      velocityTrack = rotateQuat(velocityTrack, u_worldRot);\n    }\n    velocity.xyz += velocityTrack.xyz;\n    velocity.xyz *= speedModifier0;\n  #endif\n  pos.xyz += velocity.xyz * normalizedTime * a_dir_life.w;\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = rotateQuat(velocity, u_worldRot);\n    #endif\n  #endif\n  vec3 rotation = a_rotation_uv.xyz;\n  #if ROTATION_OVER_TIME_MODULE_ENABLE\n    if (u_rotation_mode == 1) {\n      rotation += unpackCurveData(rotation_over_time_tex0, timeCoord0) * normalizedTime * a_dir_life.w;\n    } else {\n      vec3 rotation_0 = unpackCurveData(rotation_over_time_tex0, timeCoord0);\n      vec3 rotation_1 = unpackCurveData(rotation_over_time_tex0, timeCoord1);\n      float factor_r = pseudoRandom(a_rndSeed + 125292.);\n      rotation += mix(rotation_0, rotation_1, factor_r) * normalizedTime * a_dir_life.w;\n    }\n  #endif\n  #if COLOR_OVER_TIME_MODULE_ENABLE\n    if (u_color_mode == 1) {\n      color = a_color * texture(color_over_time_tex0, timeCoord0);\n    } else {\n      vec4 color_0 = texture(color_over_time_tex0, timeCoord0);\n      vec4 color_1 = texture(color_over_time_tex0, timeCoord1);\n      float factor_c = pseudoRandom(a_rndSeed + 91041.);\n      color = a_color * mix(color_0, color_1, factor_c);\n    }\n  #else\n    color = a_color;\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((vertIdx - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = rotation.xyz;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., rotation.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n      #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n        , cc_matViewInv\n      #endif\n      #if CC_RENDER_MODE == 1\n        , cc_cameraPos.xyz\n        , velocity\n        , frameTile_velLenScale.z\n        , frameTile_velLenScale.w\n        , a_size_uv.w\n      #endif\n    );\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(rotation), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(rotation), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color *= a_color1;\n  #endif\n  pos = cc_matViewProj * pos;\n  float frameIndex = 0.;\n  #if TEXTURE_ANIMATION_MODULE_ENABLE\n    float startFrame = 0.;\n    vec3 frameInfo = vec3(0.);\n    if (int(u_anim_info.x) == 1) {\n      frameInfo = unpackCurveData(texture_animation_tex0, timeCoord0);\n    } else {\n      vec3 frameInfo0 = unpackCurveData(texture_animation_tex0, timeCoord0);\n      vec3 frameInfo1 = unpackCurveData(texture_animation_tex0, timeCoord1);\n      float factor_t = pseudoRandom(a_rndSeed + 90794.);\n      frameInfo = mix(frameInfo0, frameInfo1, factor_t);\n    }\n    startFrame = frameInfo.x / u_anim_info.y;\n    frameIndex = repeat(u_anim_info.z * (frameInfo.y + startFrame), 1.);\n  #endif\n  uv = computeUV(frameIndex, vertIdx, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  return pos;\n}\nvoid main() { gl_Position = gpvs_main(); }",
                  "frag": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 16) uniform sampler2D mainTexture;\nlayout(set = 1, binding = 9) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
                },
                "builtins": {
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }],
                    "samplers": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCLocal",
                      "defines": []
                    }],
                    "samplers": []
                  }
                },
                "defines": [{
                  "name": "CC_RENDER_MODE",
                  "type": "number",
                  "range": [0, 4]
                }, {
                  "name": "COLOR_OVER_TIME_MODULE_ENABLE",
                  "type": "boolean"
                }, {
                  "name": "ROTATION_OVER_TIME_MODULE_ENABLE",
                  "type": "boolean"
                }, {
                  "name": "SIZE_OVER_TIME_MODULE_ENABLE",
                  "type": "boolean"
                }, {
                  "name": "FORCE_OVER_TIME_MODULE_ENABLE",
                  "type": "boolean"
                }, {
                  "name": "VELOCITY_OVER_TIME_MODULE_ENABLE",
                  "type": "boolean"
                }, {
                  "name": "TEXTURE_ANIMATION_MODULE_ENABLE",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_WORLD_SPACE",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_HDR",
                  "type": "boolean"
                }],
                "blocks": [{
                  "name": "Constants",
                  "defines": [],
                  "binding": 0,
                  "stageFlags": 1,
                  "members": [{
                    "name": "mainTiling_Offset",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "frameTile_velLenScale",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "scale",
                    "type": 16,
                    "count": 1
                  }]
                }, {
                  "name": "SampleConstants",
                  "defines": [],
                  "binding": 1,
                  "stageFlags": 1,
                  "members": [{
                    "name": "u_sampleInfo",
                    "type": 16,
                    "count": 1
                  }]
                }, {
                  "name": "TickConstants",
                  "defines": [],
                  "binding": 2,
                  "stageFlags": 1,
                  "members": [{
                    "name": "u_worldRot",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "u_timeDelta",
                    "type": 16,
                    "count": 1
                  }]
                }, {
                  "name": "ColorConstant",
                  "defines": ["COLOR_OVER_TIME_MODULE_ENABLE"],
                  "binding": 3,
                  "stageFlags": 1,
                  "members": [{
                    "name": "u_color_mode",
                    "type": 5,
                    "count": 1
                  }]
                }, {
                  "name": "RotationConstant",
                  "defines": ["ROTATION_OVER_TIME_MODULE_ENABLE"],
                  "binding": 4,
                  "stageFlags": 1,
                  "members": [{
                    "name": "u_rotation_mode",
                    "type": 5,
                    "count": 1
                  }]
                }, {
                  "name": "SizeConstant",
                  "defines": ["SIZE_OVER_TIME_MODULE_ENABLE"],
                  "binding": 5,
                  "stageFlags": 1,
                  "members": [{
                    "name": "u_size_mode",
                    "type": 5,
                    "count": 1
                  }]
                }, {
                  "name": "ForceConstant",
                  "defines": ["FORCE_OVER_TIME_MODULE_ENABLE"],
                  "binding": 6,
                  "stageFlags": 1,
                  "members": [{
                    "name": "u_force_mode",
                    "type": 5,
                    "count": 1
                  }, {
                    "name": "u_force_space",
                    "type": 5,
                    "count": 1
                  }]
                }, {
                  "name": "VelocityConstant",
                  "defines": ["VELOCITY_OVER_TIME_MODULE_ENABLE"],
                  "binding": 7,
                  "stageFlags": 1,
                  "members": [{
                    "name": "u_velocity_mode",
                    "type": 5,
                    "count": 1
                  }, {
                    "name": "u_velocity_space",
                    "type": 5,
                    "count": 1
                  }]
                }, {
                  "name": "AnimationConstant",
                  "defines": ["TEXTURE_ANIMATION_MODULE_ENABLE"],
                  "binding": 8,
                  "stageFlags": 1,
                  "members": [{
                    "name": "u_anim_info",
                    "type": 16,
                    "count": 1
                  }]
                }, {
                  "name": "FragConstants",
                  "defines": [],
                  "binding": 9,
                  "stageFlags": 16,
                  "members": [{
                    "name": "tintColor",
                    "type": 16,
                    "count": 1
                  }]
                }],
                "samplers": [{
                  "name": "color_over_time_tex0",
                  "type": 28,
                  "count": 1,
                  "defines": ["COLOR_OVER_TIME_MODULE_ENABLE"],
                  "stageFlags": 1,
                  "binding": 10
                }, {
                  "name": "rotation_over_time_tex0",
                  "type": 28,
                  "count": 1,
                  "defines": ["ROTATION_OVER_TIME_MODULE_ENABLE"],
                  "stageFlags": 1,
                  "binding": 11
                }, {
                  "name": "size_over_time_tex0",
                  "type": 28,
                  "count": 1,
                  "defines": ["SIZE_OVER_TIME_MODULE_ENABLE"],
                  "stageFlags": 1,
                  "binding": 12
                }, {
                  "name": "force_over_time_tex0",
                  "type": 28,
                  "count": 1,
                  "defines": ["FORCE_OVER_TIME_MODULE_ENABLE"],
                  "stageFlags": 1,
                  "binding": 13
                }, {
                  "name": "velocity_over_time_tex0",
                  "type": 28,
                  "count": 1,
                  "defines": ["VELOCITY_OVER_TIME_MODULE_ENABLE"],
                  "stageFlags": 1,
                  "binding": 14
                }, {
                  "name": "texture_animation_tex0",
                  "type": 28,
                  "count": 1,
                  "defines": ["TEXTURE_ANIMATION_MODULE_ENABLE"],
                  "stageFlags": 1,
                  "binding": 15
                }, {
                  "name": "mainTexture",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 16
                }],
                "attributes": [{
                  "name": "a_position_starttime",
                  "type": 16,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 0
                }, {
                  "name": "a_size_uv",
                  "type": 16,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 1
                }, {
                  "name": "a_rotation_uv",
                  "type": 16,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 2
                }, {
                  "name": "a_color",
                  "type": 16,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 3
                }, {
                  "name": "a_dir_life",
                  "type": 16,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 4
                }, {
                  "name": "a_rndSeed",
                  "type": 13,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 11,
                  "location": 5
                }, {
                  "name": "a_texCoord",
                  "type": 15,
                  "count": 1,
                  "defines": ["CC_RENDER_MODE"],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 6
                }, {
                  "name": "a_texCoord3",
                  "type": 15,
                  "count": 1,
                  "defines": ["CC_RENDER_MODE"],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 7
                }, {
                  "name": "a_normal",
                  "type": 15,
                  "count": 1,
                  "defines": ["CC_RENDER_MODE"],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 8
                }, {
                  "name": "a_color1",
                  "type": 16,
                  "count": 1,
                  "defines": ["CC_RENDER_MODE"],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 9
                }]
              }]
            }, {
              "name": "builtin-particle-trail",
              "_uuid": "17debcc3-0a6b-4b8a-b00b-dc58b885581e",
              "techniques": [{
                "name": "add",
                "passes": [{
                  "rasterizerState": {
                    "cullMode": 0
                  },
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 2,
                      "blendDst": 1,
                      "blendSrcAlpha": 2,
                      "blendDstAlpha": 1
                    }]
                  },
                  "program": "builtin-particle-trail|particle-trail:vs_main|tinted-fs:add",
                  "depthStencilState": {
                    "depthTest": true,
                    "depthWrite": false
                  },
                  "properties": {
                    "mainTexture": {
                      "value": "grey",
                      "type": 28
                    },
                    "mainTiling_Offset": {
                      "value": [1, 1, 0, 0],
                      "type": 16
                    },
                    "frameTile_velLenScale": {
                      "value": [1, 1, 0, 0],
                      "type": 16
                    },
                    "tintColor": {
                      "value": [0.5, 0.5, 0.5, 0.5],
                      "type": 16
                    }
                  }
                }]
              }],
              "shaders": [{
                "name": "builtin-particle-trail|particle-trail:vs_main|tinted-fs:add",
                "hash": 4115155772,
                "glsl3": {
                  "vert": "\nprecision mediump float;\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nin vec3 a_position;\nin vec4 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_DRAW_WIRE_FRAME\n  out vec3 vBarycentric;\n#endif\nvec4 vs_main() {\n  highp vec4 pos = vec4(a_position, 1);\n  vec4 velocity = vec4(a_texCoord1.xyz, 0);\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    velocity = cc_matWorld * velocity;\n  #endif\n  float vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\n  vec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\n  pos.xyz += camUp * vertOffset;\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\n  color = a_color;\n  #if CC_DRAW_WIRE_FRAME\n    vBarycentric = a_texCoord2;\n  #endif\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }",
                  "frag": "\n  precision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\n  in vec2 uv;\n  in vec4 color;\n  #if CC_DRAW_WIRE_FRAME\n    in vec3 vBarycentric;\n  #endif\n  uniform sampler2D mainTexture;\n  layout(std140) uniform FragConstants {\n    vec4 tintColor;\n  };\n  vec4 add () {\n    vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n#if CC_DRAW_WIRE_FRAME\n    if (any(lessThan(vBarycentric, vec3(0.02)))) {\n        col = vec4(0., 1., 1., 1.);\n    }\n#endif\n    return CCFragOutput(col);\n  }\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
                },
                "glsl1": {
                  "vert": "\nprecision mediump float;\nuniform vec4 mainTiling_Offset;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nattribute vec3 a_position;\nattribute vec4 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_DRAW_WIRE_FRAME\n  varying vec3 vBarycentric;\n#endif\nvec4 vs_main() {\n  highp vec4 pos = vec4(a_position, 1);\n  vec4 velocity = vec4(a_texCoord1.xyz, 0);\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    velocity = cc_matWorld * velocity;\n  #endif\n  float vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\n  vec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\n  pos.xyz += camUp * vertOffset;\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\n  color = a_color;\n  #if CC_DRAW_WIRE_FRAME\n    vBarycentric = a_texCoord2;\n  #endif\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }",
                  "frag": "\n  precision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\n  varying vec2 uv;\n  varying vec4 color;\n  #if CC_DRAW_WIRE_FRAME\n    varying vec3 vBarycentric;\n  #endif\n  uniform sampler2D mainTexture;\n  uniform vec4 tintColor;\n  vec4 add () {\n    vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n#if CC_DRAW_WIRE_FRAME\n    if (any(lessThan(vBarycentric, vec3(0.02)))) {\n        col = vec4(0., 1., 1., 1.);\n    }\n#endif\n    return CCFragOutput(col);\n  }\nvoid main() { gl_FragColor = add(); }"
                },
                "glsl4": {
                  "vert": "\nprecision mediump float;\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec4 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_DRAW_WIRE_FRAME\n  layout(location = 2) out vec3 vBarycentric;\n#endif\nvec4 vs_main() {\n  highp vec4 pos = vec4(a_position, 1);\n  vec4 velocity = vec4(a_texCoord1.xyz, 0);\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    velocity = cc_matWorld * velocity;\n  #endif\n  float vertOffset = (a_texCoord.x - 0.5) * a_texCoord.y;\n  vec3 camUp = normalize(cross(pos.xyz - cc_cameraPos.xyz, velocity.xyz));\n  pos.xyz += camUp * vertOffset;\n  pos = cc_matViewProj * pos;\n  uv = a_texCoord.zw * mainTiling_Offset.xy + mainTiling_Offset.zw;;\n  color = a_color;\n  #if CC_DRAW_WIRE_FRAME\n    vBarycentric = a_texCoord2;\n  #endif\n  return pos;\n}\nvoid main() { gl_Position = vs_main(); }",
                  "frag": "\n  precision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\n  layout(location = 0) in vec2 uv;\n  layout(location = 1) in vec4 color;\n  #if CC_DRAW_WIRE_FRAME\n    layout(location = 2) in vec3 vBarycentric;\n  #endif\n  layout(set = 1, binding = 2) uniform sampler2D mainTexture;\n  layout(set = 1, binding = 1) uniform FragConstants {\n    vec4 tintColor;\n  };\n  vec4 add () {\n    vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n#if CC_DRAW_WIRE_FRAME\n    if (any(lessThan(vBarycentric, vec3(0.02)))) {\n        col = vec4(0., 1., 1., 1.);\n    }\n#endif\n    return CCFragOutput(col);\n  }\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
                },
                "builtins": {
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }],
                    "samplers": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCLocal",
                      "defines": []
                    }],
                    "samplers": []
                  }
                },
                "defines": [{
                  "name": "CC_RENDER_MODE",
                  "type": "number",
                  "range": [0, 4]
                }, {
                  "name": "CC_DRAW_WIRE_FRAME",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_WORLD_SPACE",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_HDR",
                  "type": "boolean"
                }],
                "blocks": [{
                  "name": "Constants",
                  "defines": [],
                  "binding": 0,
                  "stageFlags": 1,
                  "members": [{
                    "name": "mainTiling_Offset",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "frameTile_velLenScale",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "scale",
                    "type": 16,
                    "count": 1
                  }]
                }, {
                  "name": "FragConstants",
                  "defines": [],
                  "binding": 1,
                  "stageFlags": 16,
                  "members": [{
                    "name": "tintColor",
                    "type": 16,
                    "count": 1
                  }]
                }],
                "samplers": [{
                  "name": "mainTexture",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 2
                }],
                "attributes": [{
                  "name": "a_position",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_texCoord",
                  "type": 16,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 1
                }, {
                  "name": "a_texCoord1",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 2
                }, {
                  "name": "a_texCoord2",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 3
                }, {
                  "name": "a_color",
                  "type": 16,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 4
                }]
              }]
            }, {
              "name": "builtin-particle",
              "_uuid": "d1346436-ac96-4271-b863-1f4fdead95b0",
              "techniques": [{
                "name": "add",
                "passes": [{
                  "rasterizerState": {
                    "cullMode": 0
                  },
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 2,
                      "blendDst": 1,
                      "blendSrcAlpha": 2,
                      "blendDstAlpha": 1
                    }]
                  },
                  "program": "builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add",
                  "depthStencilState": {
                    "depthTest": true,
                    "depthWrite": false
                  },
                  "properties": {
                    "mainTexture": {
                      "value": "grey",
                      "type": 28
                    },
                    "mainTiling_Offset": {
                      "value": [1, 1, 0, 0],
                      "type": 16
                    },
                    "tintColor": {
                      "value": [0.5, 0.5, 0.5, 0.5],
                      "type": 16
                    }
                  }
                }]
              }],
              "shaders": [{
                "name": "builtin-particle|particle-vs-legacy:lpvs_main|tinted-fs:add",
                "hash": 66662317,
                "glsl3": {
                  "vert": "\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(std140) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nout mediump vec2 uv;\nout mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nin vec3 a_position;\nin vec3 a_texCoord;\nin vec3 a_texCoord1;\nin vec3 a_texCoord2;\nin vec4 a_color;\n#if CC_RENDER_MODE == 1\n  in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  in vec3 a_texCoord3;\n  in vec3 a_normal;\n  in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }",
                  "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 uv;\nin vec4 color;\nuniform sampler2D mainTexture;\nlayout(std140) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
                },
                "glsl1": {
                  "vert": "\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nuniform vec4 mainTiling_Offset;\nuniform vec4 frameTile_velLenScale;\nuniform vec4 scale;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matViewInv;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform highp mat4 cc_matWorld;\nvarying mediump vec2 uv;\nvarying mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nattribute vec3 a_position;\nattribute vec3 a_texCoord;\nattribute vec3 a_texCoord1;\nattribute vec3 a_texCoord2;\nattribute vec4 a_color;\n#if CC_RENDER_MODE == 1\n  attribute vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  attribute vec3 a_texCoord3;\n  attribute vec3 a_normal;\n  attribute vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }",
                  "frag": "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 uv;\nvarying vec4 color;\nuniform sampler2D mainTexture;\nuniform vec4 tintColor;\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture2D(mainTexture, uv);\n  return CCFragOutput(col);\n}\nvoid main() { gl_FragColor = add(); }"
                },
                "glsl4": {
                  "vert": "\nprecision highp float;\nvec4 quaternionFromAxis (vec3 xAxis,vec3 yAxis,vec3 zAxis){\n  mat3 m = mat3(xAxis,yAxis,zAxis);\n  float trace = m[0][0] + m[1][1] + m[2][2];\n  vec4 quat;\n  if (trace > 0.) {\n    float s = 0.5 / sqrt(trace + 1.0);\n    quat.w = 0.25 / s;\n    quat.x = (m[2][1] - m[1][2]) * s;\n    quat.y = (m[0][2] - m[2][0]) * s;\n    quat.z = (m[1][0] - m[0][1]) * s;\n  } else if ((m[0][0] > m[1][1]) && (m[0][0] > m[2][2])) {\n    float s = 2.0 * sqrt(1.0 + m[0][0] - m[1][1] - m[2][2]);\n    quat.w = (m[2][1] - m[1][2]) / s;\n    quat.x = 0.25 * s;\n    quat.y = (m[0][1] + m[1][0]) / s;\n    quat.z = (m[0][2] + m[2][0]) / s;\n  } else if (m[1][1] > m[2][2]) {\n    float s = 2.0 * sqrt(1.0 + m[1][1] - m[0][0] - m[2][2]);\n    quat.w = (m[0][2] - m[2][0]) / s;\n    quat.x = (m[0][1] + m[1][0]) / s;\n    quat.y = 0.25 * s;\n    quat.z = (m[1][2] + m[2][1]) / s;\n  } else {\n    float s = 2.0 * sqrt(1.0 + m[2][2] - m[0][0] - m[1][1]);\n    quat.w = (m[1][0] - m[0][1]) / s;\n    quat.x = (m[0][2] + m[2][0]) / s;\n    quat.y = (m[1][2] + m[2][1]) / s;\n    quat.z = 0.25 * s;\n  }\n  float len = quat.x * quat.x + quat.y * quat.y + quat.z * quat.z + quat.w * quat.w;\n  if (len > 0.) {\n    len = 1. / sqrt(len);\n    quat.x = quat.x * len;\n    quat.y = quat.y * len;\n    quat.z = quat.z * len;\n    quat.w = quat.w * len;\n  }\n  return quat;\n}\nvec4 quaternionFromEuler (vec3 angle){\n  float x = angle.x / 2.;\n  float y = angle.y / 2.;\n  float z = angle.z / 2.;\n  float sx = sin(x);\n  float cx = cos(x);\n  float sy = sin(y);\n  float cy = cos(y);\n  float sz = sin(z);\n  float cz = cos(z);\n  vec4 quat = vec4(0);\n  quat.x = sx * cy * cz + cx * sy * sz;\n  quat.y = cx * sy * cz + sx * cy * sz;\n  quat.z = cx * cy * sz - sx * sy * cz;\n  quat.w = cx * cy * cz - sx * sy * sz;\n  return quat;\n}\nmat4 matrixFromRT (vec4 q, vec3 p){\n  float x2 = q.x + q.x;\n  float y2 = q.y + q.y;\n  float z2 = q.z + q.z;\n  float xx = q.x * x2;\n  float xy = q.x * y2;\n  float xz = q.x * z2;\n  float yy = q.y * y2;\n  float yz = q.y * z2;\n  float zz = q.z * z2;\n  float wx = q.w * x2;\n  float wy = q.w * y2;\n  float wz = q.w * z2;\n  return mat4(\n    1. - (yy + zz), xy + wz, xz - wy, 0,\n    xy - wz, 1. - (xx + zz), yz + wx, 0,\n    xz + wy, yz - wx, 1. - (xx + yy), 0,\n    p.x, p.y, p.z, 1\n  );\n}\nmat4 matFromRTS (vec4 q, vec3 t, vec3 s){\n  float x = q.x, y = q.y, z = q.z, w = q.w;\n  float x2 = x + x;\n  float y2 = y + y;\n  float z2 = z + z;\n  float xx = x * x2;\n  float xy = x * y2;\n  float xz = x * z2;\n  float yy = y * y2;\n  float yz = y * z2;\n  float zz = z * z2;\n  float wx = w * x2;\n  float wy = w * y2;\n  float wz = w * z2;\n  float sx = s.x;\n  float sy = s.y;\n  float sz = s.z;\n  return mat4((1. - (yy + zz)) * sx, (xy + wz) * sx, (xz - wy) * sx, 0,\n    (xy - wz) * sy, (1. - (xx + zz)) * sy, (yz + wx) * sy, 0,\n    (xz + wy) * sz, (yz - wx) * sz, (1. - (xx + yy)) * sz, 0,\n    t.x, t.y, t.z, 1);\n}\nvec4 quatMultiply (vec4 a, vec4 b){\n  vec4 quat;\n  quat.x = a.x * b.w + a.w * b.x + a.y * b.z - a.z * b.y;\n  quat.y = a.y * b.w + a.w * b.y + a.z * b.x - a.x * b.z;\n  quat.z = a.z * b.w + a.w * b.z + a.x * b.y - a.y * b.x;\n  quat.w = a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z;\n  return quat;\n}\nvoid rotateVecFromQuat (inout vec3 v, vec4 q){\n  float ix = q.w * v.x + q.y * v.z - q.z * v.y;\n  float iy = q.w * v.y + q.z * v.x - q.x * v.z;\n  float iz = q.w * v.z + q.x * v.y - q.y * v.x;\n  float iw = -q.x * v.x - q.y * v.y - q.z * v.z;\n  v.x = ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y;\n  v.y = iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z;\n  v.z = iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x;\n}\nvec3 rotateInLocalSpace (vec3 pos, vec3 xAxis, vec3 yAxis, vec3 zAxis, vec4 q){\n  vec4 viewQuat = quaternionFromAxis(xAxis, yAxis, zAxis);\n  vec4 rotQuat = quatMultiply(viewQuat, q);\n  rotateVecFromQuat(pos, rotQuat);\n  return pos;\n}\nvoid rotateCorner (inout vec2 corner, float angle){\n  float xOS = cos(angle) * corner.x - sin(angle) * corner.y;\n  float yOS = sin(angle) * corner.x + cos(angle) * corner.y;\n  corner.x = xOS;\n  corner.y = yOS;\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 mainTiling_Offset;\n  vec4 frameTile_velLenScale;\n  vec4 scale;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nlayout(location = 0) out mediump vec2 uv;\nlayout(location = 1) out mediump vec4 color;\nvoid computeVertPos (inout vec4 pos, vec2 vertOffset, vec4 q, vec3 s\n#if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n  , mat4 viewInv\n#endif\n#if CC_RENDER_MODE == 1\n  , vec3 eye\n  , vec4 velocity\n  , float velocityScale\n  , float lengthScale\n  , float xIndex\n#endif\n) {\n#if CC_RENDER_MODE == 0\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = normalize(vec3(viewInv[0][0], viewInv[1][0], viewInv[2][0]));\n  vec3 camY = normalize(vec3(viewInv[0][1], viewInv[1][1], viewInv[2][1]));\n  vec3 camZ = normalize(vec3(viewInv[0][2], viewInv[1][2], viewInv[2][2]));\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, camZ, q);\n#elif CC_RENDER_MODE == 1\n  vec3 camRight = normalize(cross(pos.xyz - eye, velocity.xyz)) * s.x;\n  vec3 camUp = velocity.xyz * velocityScale + normalize(velocity.xyz) * lengthScale * s.y;\n  pos.xyz += (camRight * abs(vertOffset.x) * sign(vertOffset.y)) - camUp * xIndex;\n#elif CC_RENDER_MODE == 2\n  vec3 viewSpaceVert = vec3(vertOffset.x * s.x, vertOffset.y * s.y, 0.);\n  vec3 camX = vec3(1, 0, 0);\n  vec3 camY = vec3(0, 0, -1);\n  pos.xyz += rotateInLocalSpace(viewSpaceVert, camX, camY, cross(camX, camY), q);\n#elif CC_RENDER_MODE == 3\n  vec2 viewSpaceVert = vec2(vertOffset.x * s.x, vertOffset.y * s.y);\n  rotateCorner(viewSpaceVert, q.z);\n  vec3 camX = normalize(vec3(cc_matView[0][0], cc_matView[1][0], cc_matView[2][0]));\n  vec3 camY = vec3(0, 1, 0);\n  vec3 offset = camX * viewSpaceVert.x + camY * viewSpaceVert.y;\n  pos.xyz += offset;\n#else\n  pos.x += vertOffset.x;\n  pos.y += vertOffset.y;\n#endif\n}\nvec2 computeUV (float frameIndex, vec2 vertIndex, vec2 frameTile){\n  vec2 aniUV = vec2(0, floor(frameIndex * frameTile.y));\n  aniUV.x = floor(frameIndex * frameTile.x * frameTile.y - aniUV.y * frameTile.x);\n#if CC_RENDER_MODE != 4\n  vertIndex.y = 1. - vertIndex.y;\n#endif\n  return (aniUV.xy + vertIndex) / vec2(frameTile.x, frameTile.y);\n}\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_texCoord;\nlayout(location = 2) in vec3 a_texCoord1;\nlayout(location = 3) in vec3 a_texCoord2;\nlayout(location = 4) in vec4 a_color;\n#if CC_RENDER_MODE == 1\n  layout(location = 5) in vec3 a_color1;\n#endif\n#if CC_RENDER_MODE == 4\n  layout(location = 6) in vec3 a_texCoord3;\n  layout(location = 7) in vec3 a_normal;\n  layout(location = 5) in vec4 a_color1;\n#endif\nvec4 lpvs_main () {\n  vec3 compScale = scale.xyz * a_texCoord1;\n  vec4 pos = vec4(a_position, 1);\n  #if CC_RENDER_MODE == 1\n    vec4 velocity = vec4(a_color1.xyz, 0);\n  #endif\n  #if !CC_USE_WORLD_SPACE\n    pos = cc_matWorld * pos;\n    #if CC_RENDER_MODE == 1\n      velocity = cc_matWorld * velocity;\n    #endif\n  #endif\n  #if CC_RENDER_MODE != 4\n    vec2 cornerOffset = vec2((a_texCoord.xy - 0.5));\n    #if CC_RENDER_MODE == 0\n      vec3 rotEuler = a_texCoord2;\n    #elif CC_RENDER_MODE == 1\n      vec3 rotEuler = vec3(0.);\n    #else\n      vec3 rotEuler = vec3(0., 0., a_texCoord2.z);\n    #endif\n    computeVertPos(pos, cornerOffset, quaternionFromEuler(rotEuler), compScale\n    #if CC_RENDER_MODE == 0 || CC_RENDER_MODE == 3\n      , cc_matViewInv\n    #endif\n    #if CC_RENDER_MODE == 1\n      , cc_cameraPos.xyz\n      , velocity\n      , frameTile_velLenScale.z\n      , frameTile_velLenScale.w\n      , a_texCoord.x\n    #endif\n    );\n    color = a_color;\n  #else\n    mat4 xformNoScale = matrixFromRT(quaternionFromEuler(a_texCoord2), pos.xyz);\n    mat4 xform = matFromRTS(quaternionFromEuler(a_texCoord2), pos.xyz, compScale);\n    pos = xform * vec4(a_texCoord3, 1);\n    vec4 normal = xformNoScale * vec4(a_normal, 0);\n    color = a_color * a_color1;\n  #endif\n  uv = computeUV(a_texCoord.z, a_texCoord.xy, frameTile_velLenScale.xy) * mainTiling_Offset.xy + mainTiling_Offset.zw;\n  pos = cc_matViewProj * pos;\n  return pos;\n}\nvoid main() { gl_Position = lpvs_main(); }",
                  "frag": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nlayout(location = 0) in vec2 uv;\nlayout(location = 1) in vec4 color;\nlayout(set = 1, binding = 2) uniform sampler2D mainTexture;\nlayout(set = 1, binding = 1) uniform FragConstants {\n  vec4 tintColor;\n};\nvec4 add () {\n  vec4 col = 2.0 * color * tintColor * texture(mainTexture, uv);\n  return CCFragOutput(col);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = add(); }"
                },
                "builtins": {
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }],
                    "samplers": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCLocal",
                      "defines": []
                    }],
                    "samplers": []
                  }
                },
                "defines": [{
                  "name": "CC_RENDER_MODE",
                  "type": "number",
                  "range": [0, 4]
                }, {
                  "name": "CC_USE_WORLD_SPACE",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_HDR",
                  "type": "boolean"
                }],
                "blocks": [{
                  "name": "Constants",
                  "defines": [],
                  "binding": 0,
                  "stageFlags": 1,
                  "members": [{
                    "name": "mainTiling_Offset",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "frameTile_velLenScale",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "scale",
                    "type": 16,
                    "count": 1
                  }]
                }, {
                  "name": "FragConstants",
                  "defines": [],
                  "binding": 1,
                  "stageFlags": 16,
                  "members": [{
                    "name": "tintColor",
                    "type": 16,
                    "count": 1
                  }]
                }],
                "samplers": [{
                  "name": "mainTexture",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 2
                }],
                "attributes": [{
                  "name": "a_position",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_texCoord",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 1
                }, {
                  "name": "a_texCoord1",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 2
                }, {
                  "name": "a_texCoord2",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 3
                }, {
                  "name": "a_color",
                  "type": 16,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 4
                }, {
                  "name": "a_color1",
                  "type": 15,
                  "count": 1,
                  "defines": ["CC_RENDER_MODE"],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 5
                }, {
                  "name": "a_texCoord3",
                  "type": 15,
                  "count": 1,
                  "defines": ["CC_RENDER_MODE"],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 6
                }, {
                  "name": "a_normal",
                  "type": 15,
                  "count": 1,
                  "defines": ["CC_RENDER_MODE"],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 7
                }]
              }]
            }, {
              "name": "builtin-sprite",
              "_uuid": "60f7195c-ec2a-45eb-ba94-8955f60e81d0",
              "techniques": [{
                "passes": [{
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 2,
                      "blendDst": 4,
                      "blendDstAlpha": 4
                    }]
                  },
                  "rasterizerState": {
                    "cullMode": 0
                  },
                  "program": "builtin-sprite|sprite-vs:vert|sprite-fs:frag",
                  "depthStencilState": {
                    "depthTest": false,
                    "depthWrite": false
                  }
                }]
              }],
              "shaders": [{
                "name": "builtin-sprite|sprite-vs:vert|sprite-fs:frag",
                "hash": 2679078392,
                "glsl3": {
                  "vert": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_LOCAL\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\n#endif\nin vec3 a_position;\nin vec2 a_texCoord;\nin vec4 a_color;\nout vec4 color;\nout vec2 uv0;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    pos = cc_matWorld * pos;\n  #endif\n  #if USE_PIXEL_ALIGNMENT\n    pos = cc_matView * pos;\n    pos.xyz = floor(pos.xyz);\n    pos = cc_matProj * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  uv0 = a_texCoord;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }",
                  "frag": "\nprecision highp float;\nvec4 CCSampleTexture(sampler2D tex, vec2 uv) {\n#if CC_USE_EMBEDDED_ALPHA\n    return vec4(texture(tex, uv).rgb, texture(tex, uv + vec2(0.0, 0.5)).r);\n#else\n    return texture(tex, uv);\n#endif\n}\nin vec4 color;\n#if USE_TEXTURE\n  in vec2 uv0;\n  uniform sampler2D cc_spriteTexture;\n#endif\nvec4 frag () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n    o *= CCSampleTexture(cc_spriteTexture, uv0);\n    #if IS_GRAY\n      float gray  = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;\n      o.r = o.g = o.b = gray;\n    #endif\n  #endif\n  o *= color;\n  return o;\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
                },
                "glsl1": {
                  "vert": "\nprecision highp float;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\nuniform highp mat4 cc_matViewProj;\n#if USE_LOCAL\nuniform highp mat4 cc_matWorld;\n#endif\nattribute vec3 a_position;\nattribute vec2 a_texCoord;\nattribute vec4 a_color;\nvarying vec4 color;\nvarying vec2 uv0;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    pos = cc_matWorld * pos;\n  #endif\n  #if USE_PIXEL_ALIGNMENT\n    pos = cc_matView * pos;\n    pos.xyz = floor(pos.xyz);\n    pos = cc_matProj * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  uv0 = a_texCoord;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }",
                  "frag": "\nprecision highp float;\nvec4 CCSampleTexture(sampler2D tex, vec2 uv) {\n#if CC_USE_EMBEDDED_ALPHA\n    return vec4(texture2D(tex, uv).rgb, texture2D(tex, uv + vec2(0.0, 0.5)).r);\n#else\n    return texture2D(tex, uv);\n#endif\n}\nvarying vec4 color;\n#if USE_TEXTURE\n  varying vec2 uv0;\n  uniform sampler2D cc_spriteTexture;\n#endif\nvec4 frag () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n    o *= CCSampleTexture(cc_spriteTexture, uv0);\n    #if IS_GRAY\n      float gray  = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;\n      o.r = o.g = o.b = gray;\n    #endif\n  #endif\n  o *= color;\n  return o;\n}\nvoid main() { gl_FragColor = frag(); }"
                },
                "glsl4": {
                  "vert": "\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_LOCAL\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\n#endif\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec2 a_texCoord;\nlayout(location = 2) in vec4 a_color;\nlayout(location = 0) out vec4 color;\nlayout(location = 1) out vec2 uv0;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 1);\n  #if USE_LOCAL\n    pos = cc_matWorld * pos;\n  #endif\n  #if USE_PIXEL_ALIGNMENT\n    pos = cc_matView * pos;\n    pos.xyz = floor(pos.xyz);\n    pos = cc_matProj * pos;\n  #else\n    pos = cc_matViewProj * pos;\n  #endif\n  uv0 = a_texCoord;\n  color = a_color;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }",
                  "frag": "\nprecision highp float;\nvec4 CCSampleTexture(sampler2D tex, vec2 uv) {\n#if CC_USE_EMBEDDED_ALPHA\n    return vec4(texture(tex, uv).rgb, texture(tex, uv + vec2(0.0, 0.5)).r);\n#else\n    return texture(tex, uv);\n#endif\n}\nlayout(location = 0) in vec4 color;\n#if USE_TEXTURE\n  layout(location = 1) in vec2 uv0;\n  layout(set = 2, binding = 10) uniform sampler2D cc_spriteTexture;\n#endif\nvec4 frag () {\n  vec4 o = vec4(1, 1, 1, 1);\n  #if USE_TEXTURE\n    o *= CCSampleTexture(cc_spriteTexture, uv0);\n    #if IS_GRAY\n      float gray  = 0.2126 * o.r + 0.7152 * o.g + 0.0722 * o.b;\n      o.r = o.g = o.b = gray;\n    #endif\n  #endif\n  o *= color;\n  return o;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
                },
                "builtins": {
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }],
                    "samplers": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCLocal",
                      "defines": ["USE_LOCAL"]
                    }],
                    "samplers": [{
                      "name": "cc_spriteTexture",
                      "defines": ["USE_TEXTURE"]
                    }]
                  }
                },
                "defines": [{
                  "name": "USE_LOCAL",
                  "type": "boolean"
                }, {
                  "name": "USE_PIXEL_ALIGNMENT",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_EMBEDDED_ALPHA",
                  "type": "boolean"
                }, {
                  "name": "USE_TEXTURE",
                  "type": "boolean"
                }, {
                  "name": "IS_GRAY",
                  "type": "boolean"
                }],
                "blocks": [],
                "samplers": [],
                "attributes": [{
                  "name": "a_position",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_texCoord",
                  "type": 14,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 21,
                  "location": 1
                }, {
                  "name": "a_color",
                  "type": 16,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 2
                }]
              }]
            }, {
              "name": "builtin-standard",
              "_uuid": "1baf0fc9-befa-459c-8bdd-af1a450a0319",
              "techniques": [{
                "name": "opaque",
                "passes": [{
                  "program": "builtin-standard|standard-vs:vert|standard-fs:frag",
                  "properties": {
                    "tilingOffset": {
                      "value": [1, 1, 0, 0],
                      "type": 16
                    },
                    "mainColor": {
                      "value": [1, 1, 1, 1],
                      "type": 16,
                      "handleInfo": ["albedo", 0, 16]
                    },
                    "albedoScale": {
                      "value": [1, 1, 1],
                      "type": 15,
                      "handleInfo": ["albedoScaleAndCutoff", 0, 15]
                    },
                    "alphaThreshold": {
                      "value": [0.5],
                      "type": 13,
                      "handleInfo": ["albedoScaleAndCutoff", 3, 13]
                    },
                    "occlusion": {
                      "value": [1],
                      "type": 13,
                      "handleInfo": ["pbrParams", 0, 13]
                    },
                    "roughness": {
                      "value": [0.8],
                      "type": 13,
                      "handleInfo": ["pbrParams", 1, 13]
                    },
                    "metallic": {
                      "value": [0.6],
                      "type": 13,
                      "handleInfo": ["pbrParams", 2, 13]
                    },
                    "normalStrenth": {
                      "value": [1],
                      "type": 13,
                      "handleInfo": ["pbrParams", 3, 13]
                    },
                    "emissive": {
                      "value": [0, 0, 0, 1],
                      "type": 16
                    },
                    "emissiveScale": {
                      "value": [1, 1, 1],
                      "type": 15,
                      "handleInfo": ["emissiveScaleParam", 0, 15]
                    },
                    "mainTexture": {
                      "value": "grey",
                      "type": 28,
                      "handleInfo": ["albedoMap", 0, 28]
                    },
                    "normalMap": {
                      "value": "normal",
                      "type": 28
                    },
                    "pbrMap": {
                      "value": "grey",
                      "type": 28
                    },
                    "metallicRoughnessMap": {
                      "value": "grey",
                      "type": 28
                    },
                    "occlusionMap": {
                      "value": "white",
                      "type": 28
                    },
                    "emissiveMap": {
                      "value": "grey",
                      "type": 28
                    },
                    "albedo": {
                      "type": 16,
                      "value": [1, 1, 1, 1]
                    },
                    "albedoScaleAndCutoff": {
                      "type": 16,
                      "value": [1, 1, 1, 0.5]
                    },
                    "pbrParams": {
                      "type": 16,
                      "value": [1, 0.8, 0.6, 1]
                    },
                    "emissiveScaleParam": {
                      "type": 16,
                      "value": [1, 1, 1, 0]
                    },
                    "albedoMap": {
                      "type": 28,
                      "value": "grey"
                    }
                  }
                }, {
                  "phase": "forward-add",
                  "propertyIndex": 0,
                  "embeddedMacros": {
                    "CC_FORWARD_ADD": true
                  },
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 1,
                      "blendDst": 1,
                      "blendSrcAlpha": 0,
                      "blendDstAlpha": 1
                    }]
                  },
                  "program": "builtin-standard|standard-vs:vert|standard-fs:frag",
                  "depthStencilState": {
                    "depthFunc": 2,
                    "depthTest": true,
                    "depthWrite": false
                  },
                  "properties": {
                    "tilingOffset": {
                      "value": [1, 1, 0, 0],
                      "type": 16
                    },
                    "mainColor": {
                      "value": [1, 1, 1, 1],
                      "type": 16,
                      "handleInfo": ["albedo", 0, 16]
                    },
                    "albedoScale": {
                      "value": [1, 1, 1],
                      "type": 15,
                      "handleInfo": ["albedoScaleAndCutoff", 0, 15]
                    },
                    "alphaThreshold": {
                      "value": [0.5],
                      "type": 13,
                      "handleInfo": ["albedoScaleAndCutoff", 3, 13]
                    },
                    "occlusion": {
                      "value": [1],
                      "type": 13,
                      "handleInfo": ["pbrParams", 0, 13]
                    },
                    "roughness": {
                      "value": [0.8],
                      "type": 13,
                      "handleInfo": ["pbrParams", 1, 13]
                    },
                    "metallic": {
                      "value": [0.6],
                      "type": 13,
                      "handleInfo": ["pbrParams", 2, 13]
                    },
                    "normalStrenth": {
                      "value": [1],
                      "type": 13,
                      "handleInfo": ["pbrParams", 3, 13]
                    },
                    "emissive": {
                      "value": [0, 0, 0, 1],
                      "type": 16
                    },
                    "emissiveScale": {
                      "value": [1, 1, 1],
                      "type": 15,
                      "handleInfo": ["emissiveScaleParam", 0, 15]
                    },
                    "mainTexture": {
                      "value": "grey",
                      "type": 28,
                      "handleInfo": ["albedoMap", 0, 28]
                    },
                    "normalMap": {
                      "value": "normal",
                      "type": 28
                    },
                    "pbrMap": {
                      "value": "grey",
                      "type": 28
                    },
                    "metallicRoughnessMap": {
                      "value": "grey",
                      "type": 28
                    },
                    "occlusionMap": {
                      "value": "white",
                      "type": 28
                    },
                    "emissiveMap": {
                      "value": "grey",
                      "type": 28
                    },
                    "albedo": {
                      "type": 16,
                      "value": [1, 1, 1, 1]
                    },
                    "albedoScaleAndCutoff": {
                      "type": 16,
                      "value": [1, 1, 1, 0.5]
                    },
                    "pbrParams": {
                      "type": 16,
                      "value": [1, 0.8, 0.6, 1]
                    },
                    "emissiveScaleParam": {
                      "type": 16,
                      "value": [1, 1, 1, 0]
                    },
                    "albedoMap": {
                      "type": 28,
                      "value": "grey"
                    }
                  }
                }, {
                  "phase": "shadow-add",
                  "propertyIndex": 0,
                  "rasterizerState": {
                    "cullMode": 2
                  },
                  "program": "builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag"
                }]
              }],
              "shaders": [{
                "name": "builtin-standard|standard-vs:vert|standard-fs:frag",
                "hash": 3803722737,
                "glsl3": {
                  "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n        return int(a_vertexId);\n    }\nlayout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_SUPPORT_FLOAT_TEXTURE\n        vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n            ivec2 texSize = textureSize(tex, 0);\n            return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n        }\n#else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex * 4;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n        return vec4(\n            decode32(texture(tex, x)),\n            decode32(texture(tex, y)),\n            decode32(texture(tex, z)),\n            1.0\n        );\n    }\n#endif\nfloat getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n        return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n        return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n        return cc_displacementWeights[quot].z;\n    } else {\n        return cc_displacementWeights[quot].w;\n    }\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\n    vec3 result = vec3(0, 0, 0);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        int dataPixelStart = int(fetchVec3ArrayFromTexture(tex, iTarget).r);\n        result += (fetchVec3ArrayFromTexture(tex, dataPixelStart + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n  #if USE_INSTANCING\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(std140) uniform CCSkinningTexture {\n    highp vec4 cc_jointTextureInfo;\n  };\n  layout(std140) uniform CCSkinningAnimation {\n    highp vec4 cc_jointAnimInfo;\n  };\n  uniform highp sampler2D cc_jointTexture;\n  #else\n  layout(std140) uniform CCSkinning {\n    highp vec4 cc_joints[30 * 3];\n  };\n#endif\n#if CC_USE_BAKED_ANIMATION\n  #if CC_SUPPORT_FLOAT_TEXTURE\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n      vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n      vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #else\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n      );\n      vec4 v2 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n      );\n      vec4 v3 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n      );\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n#else\n  mat4 getJointMatrix (float i) {\n    int idx = int(i);\n    vec4 v1 = cc_joints[idx * 3];\n    vec4 v2 = cc_joints[idx * 3 + 1];\n    vec4 v3 = cc_joints[idx * 3 + 2];\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n       + getJointMatrix(a_joints.y) * a_weights.y\n       + getJointMatrix(a_joints.z) * a_weights.z\n       + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n    vec4 wPos = pos;\n    float cam_dis = distance(cc_cameraPos, wPos);\n    float fogStart = cc_fogBase.x;\n    float fogEnd = cc_fogBase.y;\n    return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * fogDensity);\n    return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n    return f;\n}\nfloat LayeredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float _FogTop = cc_fogAdd.x;\n    float _FogRange = cc_fogAdd.y;\n    vec3 camWorldProj = cc_cameraPos.xyz;\n    camWorldProj.y = 0.;\n    vec3 worldPosProj = wPos.xyz;\n    worldPosProj.y = 0.;\n    float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n    float fDeltaY, fDensityIntegral;\n    if (cc_cameraPos.y > _FogTop) {\n        if (wPos.y < _FogTop) {\n            fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n            fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n        } else {\n            fDeltaY = 0.;\n            fDensityIntegral = 0.;\n        }\n    } else {\n        if (wPos.y < _FogTop) {\n            float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n            fDeltaY = abs(fDeltaA - fDeltaB);\n            fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n        } else {\n            fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n        }\n    }\n    float fDensity;\n    if (fDeltaY != 0.) {\n        fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n    } else {\n        fDensity = 0.;\n    }\n    float f = exp(-fDensity);\n    return f;\n}\nfloat CC_TRANSFER_FOG(vec4 pos) {\n    #if CC_USE_FOG == 1\n        return LinearFog(pos);\n\t#elif CC_USE_FOG == 2\n        return ExpFog(pos);\n    #elif CC_USE_FOG == 3\n        return ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 4\n        return LayeredFog(pos);\n    #endif\n    return 1.;\n}\nout vec4 v_shadowPos;\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightViewProj;\n  lowp vec4 cc_shadowColor;\n  lowp vec4 cc_shadowPCF;\n  lowp vec4 cc_shadowSize;\n};\n#if USE_VERTEX_COLOR\n  in vec3 a_color;\n  out vec3 v_color;\n#endif\nout vec3 v_position;\nout vec3 v_normal;\nout vec2 v_uv;\nout vec2 v_uv1;\nout float v_fog_factor;\n#if USE_NORMAL_MAP\n  out vec3 v_tangent;\n  out vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  out vec2 v_luv;\nvoid CCLightingMapCaclUV()\n{\n#if !USE_INSTANCING\n      v_luv = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\n#else\n      v_luv = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\n#endif\n}\n#endif\nvec4 vert () {\n  StandardVertInput In;\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n  In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In);\n  #endif\n  mat4 matWorld, matWorldIT;\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  v_fog_factor = CC_TRANSFER_FOG(matWorld * In.position);\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n    v_shadowPos = cc_matLightViewProj * pos;\n  return cc_matProj * (cc_matView * matWorld) * In.position;\n}\nvoid main() { gl_Position = vert(); }",
                  "frag": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightViewProj;\n  lowp vec4 cc_shadowColor;\n  lowp vec4 cc_shadowPCF;\n  lowp vec4 cc_shadowSize;\n};\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  in vec2 v_luv;\nuniform sampler2D cc_lightingMap;\n#endif\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness*0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\nstruct StandardSurface {\n  vec4 albedo;\n  vec3 position;\n  vec3 normal;\n  vec3 emissive;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\n#if CC_FORWARD_ADD\nlayout(std140) uniform CCForwardLight {\n  highp vec4 cc_lightPos[1];\n  vec4 cc_lightColor[1];\n  vec4 cc_lightSizeRangeAngle[1];\n  vec4 cc_lightDir[1];\n};\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\n  vec4 CCStandardShading (StandardSurface s) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    for (int i = 0; i < 1; i++) {\n      vec3 SLU = cc_lightPos[i].xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      finalColor += SNL * cc_lightColor[i].rgb * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    finalColor = finalColor * s.occlusion;\n    return vec4(finalColor, 0.0);\n  }\n#else\n  #if CC_RECEIVE_SHADOW\nin vec4 v_shadowPos;\nuniform sampler2D cc_shadowMap;\nfloat CCGetShadowFactorX1 () {\n  vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n  float closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n  float shadow = step(closestDepth, clipPos.z - 0.001);\n  return shadow;\n}\nfloat CCGetShadowFactorX5 () {\n  vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n  float offsetx = 1.0 / cc_shadowSize.x;\n  float offsety = 1.0 / cc_shadowSize.y;\n  float shadow = 0.0;\n  float closestDepth = 0.0;\n  closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n  shadow += step(closestDepth, clipPos.z - 0.001);\n  closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n  shadow += step(closestDepth, clipPos.z - 0.001);\n  closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n  shadow += step(closestDepth, clipPos.z - 0.001);\n  closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n  shadow += step(closestDepth, clipPos.z - 0.001);\n  closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n  shadow += step(closestDepth, clipPos.z - 0.001);\n  return shadow /= 5.0;\n}\nfloat CCGetShadowFactorX9 () {\n  vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n  float offsetx = 1.0 / cc_shadowSize.x;\n  float offsety = 1.0 / cc_shadowSize.y;\n  float shadow = 0.0;\n  for (int i = -1; i <= 1; i++) {\n    for (int j = -1; j <= 1; j++) {\n      float closestDepth = dot(texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, clipPos.z - 0.001);\n    }\n  }\n  return shadow /= 9.0;\n}\nfloat CCGetShadowFactorX25 () {\n  vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n  float offsetx = 1.0 / cc_shadowSize.x;\n  float offsety = 1.0 / cc_shadowSize.y;\n  float shadow = 0.0;\n  for (int i = -2; i <= 2; i++) {\n    for (int j = -2; j <= 2; j++) {\n      float closestDepth = dot(texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, clipPos.z - 0.001);\n    }\n  }\n  return shadow /= 25.0;\n}\n  #endif\n  vec4 CCStandardShading (StandardSurface s) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 L = normalize(-cc_mainLitDir.xyz);\n    vec3 H = normalize(L+V);\n    float NH = max(dot(N, H), 0.0);\n    float NL = max(dot(N, L), 0.001);\n    vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n    #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n      vec4 lightmap = texture(cc_lightingMap, v_luv);\n      finalColor = lightmap.a * lightmap.rgb + (1.0 - lightmap.a) * finalColor;\n    #endif\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n    finalColor *= (diffuseContrib + specularContrib);\n    float fAmb = 0.5 - N.y * 0.5;\n    vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n    finalColor += (ambDiff.rgb * diffuse);\n    #if CC_USE_IBL\n      vec3 R = normalize(reflect(-V, N));\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n      finalColor += env * cc_ambientSky.w * specular;\n    #endif\n    finalColor = finalColor * s.occlusion;\n    #if CC_USE_HDR\n      s.emissive *= cc_exposure.w;\n    #endif\n    finalColor += s.emissive;\n    #if CC_RECEIVE_SHADOW\n      float pcf = cc_shadowPCF.x + 0.001;\n      float shadowAttenuation = 0.0;\n      if (pcf > 3.0) {shadowAttenuation = CCGetShadowFactorX25();}\n      else if (3.0 > pcf && pcf > 2.0) {shadowAttenuation = CCGetShadowFactorX9();}\n      else if (2.0 > pcf && pcf > 1.0) {shadowAttenuation = CCGetShadowFactorX5();}\n      else {shadowAttenuation = CCGetShadowFactorX1();}\n      vec3 shadowColor = cc_shadowColor.rgb * cc_shadowColor.a + finalColor * (1.0 - cc_shadowColor.a);\n      finalColor = shadowColor.rgb * shadowAttenuation + finalColor.rgb * (1.0 - shadowAttenuation);\n    #endif\n    return vec4(finalColor, s.albedo.a);\n  }\n#endif\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nin vec3 v_position;\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec3 v_normal;\nin float v_fog_factor;\n#if USE_VERTEX_COLOR\n  in vec3 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  in vec3 v_tangent;\n  in vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= v_color;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * pbrParams.w) * normalize(v_tangent) +\n      (nmmp.y * pbrParams.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = clamp(pbr.x, 0.0, 0.96);\n  s.roughness = clamp(pbr.y, 0.04, 1.0);\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\nvec4 frag () {\n  StandardSurface s; surf(s);\n  vec4 color = CCStandardShading(s);\n  color = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\n  return CCFragOutput(color);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
                },
                "glsl1": {
                  "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n        return int(a_vertexId);\n    }\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_SUPPORT_FLOAT_TEXTURE\n        vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n            int pixelIndex = elementIndex;\n            vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n            vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n            return texture2D(tex, uv);\n        }\n#else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex * 4;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n        return vec4(\n            decode32(texture2D(tex, x)),\n            decode32(texture2D(tex, y)),\n            decode32(texture2D(tex, z)),\n            1.0\n        );\n    }\n#endif\nfloat getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n        return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n        return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n        return cc_displacementWeights[quot].z;\n    } else {\n        return cc_displacementWeights[quot].w;\n    }\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\n    vec3 result = vec3(0, 0, 0);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        int dataPixelStart = int(fetchVec3ArrayFromTexture(tex, iTarget).r);\n        result += (fetchVec3ArrayFromTexture(tex, dataPixelStart + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n  #if USE_INSTANCING\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  uniform highp vec4 cc_jointTextureInfo;\n  uniform highp vec4 cc_jointAnimInfo;\n  uniform highp sampler2D cc_jointTexture;\n  #else\n  uniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n  #if CC_SUPPORT_FLOAT_TEXTURE\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n      vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n      vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #else\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n      );\n      vec4 v2 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n      );\n      vec4 v3 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n      );\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n#else\n  mat4 getJointMatrix (float i) {\n    int idx = int(i);\n    vec4 v1 = cc_joints[idx * 3];\n    vec4 v2 = cc_joints[idx * 3 + 1];\n    vec4 v3 = cc_joints[idx * 3 + 2];\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n       + getJointMatrix(a_joints.y) * a_weights.y\n       + getJointMatrix(a_joints.z) * a_weights.z\n       + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_fogBase;\nuniform mediump vec4 cc_fogAdd;\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\nuniform highp mat4 cc_matWorldIT;\nuniform highp vec4 cc_lightingMapUVParam;\n#endif\nuniform vec4 tilingOffset;\nfloat LinearFog(vec4 pos) {\n    vec4 wPos = pos;\n    float cam_dis = distance(cc_cameraPos, wPos);\n    float fogStart = cc_fogBase.x;\n    float fogEnd = cc_fogBase.y;\n    return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * fogDensity);\n    return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n    return f;\n}\nfloat LayeredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float _FogTop = cc_fogAdd.x;\n    float _FogRange = cc_fogAdd.y;\n    vec3 camWorldProj = cc_cameraPos.xyz;\n    camWorldProj.y = 0.;\n    vec3 worldPosProj = wPos.xyz;\n    worldPosProj.y = 0.;\n    float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n    float fDeltaY, fDensityIntegral;\n    if (cc_cameraPos.y > _FogTop) {\n        if (wPos.y < _FogTop) {\n            fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n            fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n        } else {\n            fDeltaY = 0.;\n            fDensityIntegral = 0.;\n        }\n    } else {\n        if (wPos.y < _FogTop) {\n            float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n            fDeltaY = abs(fDeltaA - fDeltaB);\n            fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n        } else {\n            fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n        }\n    }\n    float fDensity;\n    if (fDeltaY != 0.) {\n        fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n    } else {\n        fDensity = 0.;\n    }\n    float f = exp(-fDensity);\n    return f;\n}\nfloat CC_TRANSFER_FOG(vec4 pos) {\n    #if CC_USE_FOG == 1\n        return LinearFog(pos);\n\t#elif CC_USE_FOG == 2\n        return ExpFog(pos);\n    #elif CC_USE_FOG == 3\n        return ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 4\n        return LayeredFog(pos);\n    #endif\n    return 1.;\n}\nvarying vec4 v_shadowPos;\nuniform highp mat4 cc_matLightViewProj;\n#if USE_VERTEX_COLOR\n  attribute vec3 a_color;\n  varying vec3 v_color;\n#endif\nvarying vec3 v_position;\nvarying vec3 v_normal;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying float v_fog_factor;\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying vec2 v_luv;\nvoid CCLightingMapCaclUV()\n{\n#if !USE_INSTANCING\n      v_luv = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\n#else\n      v_luv = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\n#endif\n}\n#endif\nvec4 vert () {\n  StandardVertInput In;\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n  In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In);\n  #endif\n  mat4 matWorld, matWorldIT;\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  v_fog_factor = CC_TRANSFER_FOG(matWorld * In.position);\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n    v_shadowPos = cc_matLightViewProj * pos;\n  return cc_matProj * (cc_matView * matWorld) * In.position;\n}\nvoid main() { gl_Position = vert(); }",
                  "frag": "\n#ifdef GL_EXT_shader_texture_lod\n#extension GL_EXT_shader_texture_lod: enable\n#endif\nprecision highp float;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_exposure;\nuniform mediump vec4 cc_mainLitDir;\nuniform mediump vec4 cc_mainLitColor;\nuniform mediump vec4 cc_ambientSky;\nuniform mediump vec4 cc_ambientGround;\nuniform mediump vec4 cc_fogColor;\nuniform lowp vec4 cc_shadowColor;\nuniform lowp vec4 cc_shadowPCF;\nuniform lowp vec4 cc_shadowSize;\n#if CC_USE_IBL\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return texture2DLodEXT(tex, coord, lod);\n    #else\n      return texture2D(tex, coord, lod);\n    #endif\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    #ifdef GL_EXT_shader_texture_lod\n      return textureCubeLodEXT(tex, coord, lod);\n    #else\n      return textureCube(tex, coord, lod);\n    #endif\n}\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  varying vec2 v_luv;\nuniform sampler2D cc_lightingMap;\n#endif\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness*0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\nstruct StandardSurface {\n  vec4 albedo;\n  vec3 position;\n  vec3 normal;\n  vec3 emissive;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\n#if CC_FORWARD_ADD\nuniform highp vec4 cc_lightPos[1];\nuniform vec4 cc_lightColor[1];\nuniform vec4 cc_lightSizeRangeAngle[1];\nuniform vec4 cc_lightDir[1];\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\n  vec4 CCStandardShading (StandardSurface s) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    for (int i = 0; i < 1; i++) {\n      vec3 SLU = cc_lightPos[i].xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      finalColor += SNL * cc_lightColor[i].rgb * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    finalColor = finalColor * s.occlusion;\n    return vec4(finalColor, 0.0);\n  }\n#else\n  #if CC_RECEIVE_SHADOW\nvarying vec4 v_shadowPos;\nuniform sampler2D cc_shadowMap;\nfloat CCGetShadowFactorX1 () {\n  vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n  float closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n  float shadow = step(closestDepth, clipPos.z - 0.001);\n  return shadow;\n}\nfloat CCGetShadowFactorX5 () {\n  vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n  float offsetx = 1.0 / cc_shadowSize.x;\n  float offsety = 1.0 / cc_shadowSize.y;\n  float shadow = 0.0;\n  float closestDepth = 0.0;\n  closestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n  shadow += step(closestDepth, clipPos.z - 0.001);\n  closestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n  shadow += step(closestDepth, clipPos.z - 0.001);\n  closestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n  shadow += step(closestDepth, clipPos.z - 0.001);\n  closestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n  shadow += step(closestDepth, clipPos.z - 0.001);\n  closestDepth = dot(texture2D(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n  shadow += step(closestDepth, clipPos.z - 0.001);\n  return shadow /= 5.0;\n}\nfloat CCGetShadowFactorX9 () {\n  vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n  float offsetx = 1.0 / cc_shadowSize.x;\n  float offsety = 1.0 / cc_shadowSize.y;\n  float shadow = 0.0;\n  for (int i = -1; i <= 1; i++) {\n    for (int j = -1; j <= 1; j++) {\n      float closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, clipPos.z - 0.001);\n    }\n  }\n  return shadow /= 9.0;\n}\nfloat CCGetShadowFactorX25 () {\n  vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n  float offsetx = 1.0 / cc_shadowSize.x;\n  float offsety = 1.0 / cc_shadowSize.y;\n  float shadow = 0.0;\n  for (int i = -2; i <= 2; i++) {\n    for (int j = -2; j <= 2; j++) {\n      float closestDepth = dot(texture2D(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, clipPos.z - 0.001);\n    }\n  }\n  return shadow /= 25.0;\n}\n  #endif\n  vec4 CCStandardShading (StandardSurface s) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 L = normalize(-cc_mainLitDir.xyz);\n    vec3 H = normalize(L+V);\n    float NH = max(dot(N, H), 0.0);\n    float NL = max(dot(N, L), 0.001);\n    vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n    #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n      vec4 lightmap = texture2D(cc_lightingMap, v_luv);\n      finalColor = lightmap.a * lightmap.rgb + (1.0 - lightmap.a) * finalColor;\n    #endif\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n    finalColor *= (diffuseContrib + specularContrib);\n    float fAmb = 0.5 - N.y * 0.5;\n    vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n    finalColor += (ambDiff.rgb * diffuse);\n    #if CC_USE_IBL\n      vec3 R = normalize(reflect(-V, N));\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n      finalColor += env * cc_ambientSky.w * specular;\n    #endif\n    finalColor = finalColor * s.occlusion;\n    #if CC_USE_HDR\n      s.emissive *= cc_exposure.w;\n    #endif\n    finalColor += s.emissive;\n    #if CC_RECEIVE_SHADOW\n      float pcf = cc_shadowPCF.x + 0.001;\n      float shadowAttenuation = 0.0;\n      if (pcf > 3.0) {shadowAttenuation = CCGetShadowFactorX25();}\n      else if (3.0 > pcf && pcf > 2.0) {shadowAttenuation = CCGetShadowFactorX9();}\n      else if (2.0 > pcf && pcf > 1.0) {shadowAttenuation = CCGetShadowFactorX5();}\n      else {shadowAttenuation = CCGetShadowFactorX1();}\n      vec3 shadowColor = cc_shadowColor.rgb * cc_shadowColor.a + finalColor * (1.0 - cc_shadowColor.a);\n      finalColor = shadowColor.rgb * shadowAttenuation + finalColor.rgb * (1.0 - shadowAttenuation);\n    #endif\n    return vec4(finalColor, s.albedo.a);\n  }\n#endif\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nuniform vec4 albedo;\nuniform vec4 albedoScaleAndCutoff;\nuniform vec4 pbrParams;\nuniform vec4 emissive;\nuniform vec4 emissiveScaleParam;\nvarying vec3 v_position;\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec3 v_normal;\nvarying float v_fog_factor;\n#if USE_VERTEX_COLOR\n  varying vec3 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  varying vec3 v_tangent;\n  varying vec3 v_bitangent;\n  uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= v_color;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture2D(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture2D(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * pbrParams.w) * normalize(v_tangent) +\n      (nmmp.y * pbrParams.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture2D(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture2D(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture2D(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = clamp(pbr.x, 0.0, 0.96);\n  s.roughness = clamp(pbr.y, 0.04, 1.0);\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture2D(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\nvec4 frag () {\n  StandardSurface s; surf(s);\n  vec4 color = CCStandardShading(s);\n  color = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\n  return CCFragOutput(color);\n}\nvoid main() { gl_FragColor = frag(); }"
                },
                "glsl4": {
                  "vert": "\n#ifdef GL_EXT_shader_explicit_arithmetic_types_int16\n#extension GL_EXT_shader_explicit_arithmetic_types_int16: enable\n#endif\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n        return gl_VertexIndex;\n    }\nlayout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_SUPPORT_FLOAT_TEXTURE\n        vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n            ivec2 texSize = textureSize(tex, 0);\n            return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n        }\n#else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex * 4;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n        return vec4(\n            decode32(texture(tex, x)),\n            decode32(texture(tex, y)),\n            decode32(texture(tex, z)),\n            1.0\n        );\n    }\n#endif\nfloat getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n        return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n        return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n        return cc_displacementWeights[quot].z;\n    } else {\n        return cc_displacementWeights[quot].w;\n    }\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\n    vec3 result = vec3(0, 0, 0);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        int dataPixelStart = int(fetchVec3ArrayFromTexture(tex, iTarget).r);\n        result += (fetchVec3ArrayFromTexture(tex, dataPixelStart + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 6) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 7) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 8) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nlayout(location = 4) in u16vec4 a_joints;\nlayout(location = 5) in vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n  #if USE_INSTANCING\n    layout(location = 7) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(set = 2, binding = 3) uniform CCSkinningTexture {\n    highp vec4 cc_jointTextureInfo;\n  };\n  layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n    highp vec4 cc_jointAnimInfo;\n  };\n  layout(set = 2, binding = 5) uniform highp sampler2D cc_jointTexture;\n  #else\n  layout(set = 2, binding = 3) uniform CCSkinning {\n    highp vec4 cc_joints[30 * 3];\n  };\n#endif\n#if CC_USE_BAKED_ANIMATION\n  #if CC_SUPPORT_FLOAT_TEXTURE\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n      vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n      vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #else\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n      );\n      vec4 v2 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n      );\n      vec4 v3 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n      );\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n#else\n  mat4 getJointMatrix (float i) {\n    int idx = int(i);\n    vec4 v1 = cc_joints[idx * 3];\n    vec4 v2 = cc_joints[idx * 3 + 1];\n    vec4 v3 = cc_joints[idx * 3 + 2];\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n       + getJointMatrix(a_joints.y) * a_weights.y\n       + getJointMatrix(a_joints.z) * a_weights.z\n       + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\n  layout(location = 8) in vec4 a_matWorld0;\n  layout(location = 9) in vec4 a_matWorld1;\n  layout(location = 10) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 11) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\n#endif\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nfloat LinearFog(vec4 pos) {\n    vec4 wPos = pos;\n    float cam_dis = distance(cc_cameraPos, wPos);\n    float fogStart = cc_fogBase.x;\n    float fogEnd = cc_fogBase.y;\n    return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * fogDensity);\n    return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n    return f;\n}\nfloat LayeredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float _FogTop = cc_fogAdd.x;\n    float _FogRange = cc_fogAdd.y;\n    vec3 camWorldProj = cc_cameraPos.xyz;\n    camWorldProj.y = 0.;\n    vec3 worldPosProj = wPos.xyz;\n    worldPosProj.y = 0.;\n    float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n    float fDeltaY, fDensityIntegral;\n    if (cc_cameraPos.y > _FogTop) {\n        if (wPos.y < _FogTop) {\n            fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n            fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n        } else {\n            fDeltaY = 0.;\n            fDensityIntegral = 0.;\n        }\n    } else {\n        if (wPos.y < _FogTop) {\n            float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n            fDeltaY = abs(fDeltaA - fDeltaB);\n            fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n        } else {\n            fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n        }\n    }\n    float fDensity;\n    if (fDeltaY != 0.) {\n        fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n    } else {\n        fDensity = 0.;\n    }\n    float f = exp(-fDensity);\n    return f;\n}\nfloat CC_TRANSFER_FOG(vec4 pos) {\n    #if CC_USE_FOG == 1\n        return LinearFog(pos);\n\t#elif CC_USE_FOG == 2\n        return ExpFog(pos);\n    #elif CC_USE_FOG == 3\n        return ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 4\n        return LayeredFog(pos);\n    #endif\n    return 1.;\n}\nlayout(location = 0) out vec4 v_shadowPos;\nlayout(set = 0, binding = 1) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightViewProj;\n  lowp vec4 cc_shadowColor;\n  lowp vec4 cc_shadowPCF;\n  lowp vec4 cc_shadowSize;\n};\n#if USE_VERTEX_COLOR\n  layout(location = 13) in vec3 a_color;\n  layout(location = 1) out vec3 v_color;\n#endif\nlayout(location = 2) out vec3 v_position;\nlayout(location = 3) out vec3 v_normal;\nlayout(location = 4) out vec2 v_uv;\nlayout(location = 5) out vec2 v_uv1;\nlayout(location = 6) out float v_fog_factor;\n#if USE_NORMAL_MAP\n  layout(location = 7) out vec3 v_tangent;\n  layout(location = 8) out vec3 v_bitangent;\n#endif\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  layout(location = 14) in vec2 a_texCoord1;\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 9) out vec2 v_luv;\nvoid CCLightingMapCaclUV()\n{\n#if !USE_INSTANCING\n      v_luv = cc_lightingMapUVParam.xy + a_texCoord1 * cc_lightingMapUVParam.zw;\n#else\n      v_luv = a_lightingMapUVParam.xy + a_texCoord1 * a_lightingMapUVParam.zw;\n#endif\n}\n#endif\nvec4 vert () {\n  StandardVertInput In;\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n  In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In);\n  #endif\n  mat4 matWorld, matWorldIT;\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n  vec4 pos = matWorld * In.position;\n  v_position = pos.xyz;\n  v_normal = normalize((matWorldIT * vec4(In.normal, 0.0)).xyz);\n  #if USE_NORMAL_MAP\n    v_tangent = normalize((matWorld * vec4(In.tangent.xyz, 0.0)).xyz);\n    v_bitangent = cross(v_normal, v_tangent) * In.tangent.w;\n  #endif\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  v_fog_factor = CC_TRANSFER_FOG(matWorld * In.position);\n  #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n    CCLightingMapCaclUV();\n  #endif\n    v_shadowPos = cc_matLightViewProj * pos;\n  return cc_matProj * (cc_matView * matWorld) * In.position;\n}\nvoid main() { gl_Position = vert(); }",
                  "frag": "\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 0, binding = 1) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightViewProj;\n  lowp vec4 cc_shadowColor;\n  lowp vec4 cc_shadowPCF;\n  lowp vec4 cc_shadowSize;\n};\n#if CC_USE_IBL\nlayout(set = 0, binding = 3) uniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec4 fragTextureLod (sampler2D tex, vec2 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\nvec4 fragTextureLod (samplerCube tex, vec3 coord, float lod) {\n    return textureLod(tex, coord, lod);\n}\n#endif\n#if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n  layout(location = 9) in vec2 v_luv;\nlayout(set = 2, binding = 9) uniform sampler2D cc_lightingMap;\n#endif\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nfloat GGXMobile (float roughness, float NoH, vec3 H, vec3 N) {\n  vec3 NxH = cross(N, H);\n  float OneMinusNoHSqr = dot(NxH, NxH);\n  float a = roughness * roughness;\n  float n = NoH * a;\n  float p = a / (OneMinusNoHSqr + n * n);\n  return p * p;\n}\nfloat CalcSpecular (float roughness, float NoH, vec3 H, vec3 N) {\n  return (roughness*0.25 + 0.25) * GGXMobile(roughness, NoH, H, N);\n}\nvec3 BRDFApprox (vec3 specular, float roughness, float NoV) {\n  const vec4 c0 = vec4(-1.0, -0.0275, -0.572, 0.022);\n  const vec4 c1 = vec4(1.0, 0.0425, 1.04, -0.04);\n  vec4 r = roughness * c0 + c1;\n  float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n  vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n  AB.y *= clamp(50.0 * specular.g, 0.0, 1.0);\n  return specular * AB.x + AB.y;\n}\nstruct StandardSurface {\n  vec4 albedo;\n  vec3 position;\n  vec3 normal;\n  vec3 emissive;\n  float roughness;\n  float metallic;\n  float occlusion;\n};\n#if CC_FORWARD_ADD\nlayout(set = 2, binding = 1) uniform CCForwardLight {\n  highp vec4 cc_lightPos[1];\n  vec4 cc_lightColor[1];\n  vec4 cc_lightSizeRangeAngle[1];\n  vec4 cc_lightDir[1];\n};\nfloat SmoothDistAtt (float distSqr, float invSqrAttRadius) {\n  float factor = distSqr * invSqrAttRadius;\n  float smoothFactor = clamp(1.0 - factor * factor, 0.0, 1.0);\n  return smoothFactor * smoothFactor;\n}\nfloat GetDistAtt (float distSqr, float invSqrAttRadius) {\n  float attenuation = 1.0 / max(distSqr, 0.01*0.01);\n  attenuation *= SmoothDistAtt(distSqr , invSqrAttRadius);\n  return attenuation;\n}\nfloat GetAngleAtt (vec3 L, vec3 litDir, float litAngleScale, float litAngleOffset) {\n  float cd = dot(litDir, L);\n  float attenuation = clamp(cd * litAngleScale + litAngleOffset, 0.0, 1.0);\n  return (attenuation * attenuation);\n}\n  vec4 CCStandardShading (StandardSurface s) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 finalColor = vec3(0.0);\n    for (int i = 0; i < 1; i++) {\n      vec3 SLU = cc_lightPos[i].xyz - s.position;\n      vec3 SL = normalize(SLU);\n      vec3 SH = normalize(SL + V);\n      float SNL = max(dot(N, SL), 0.001);\n      float SNH = max(dot(N, SH), 0.0);\n      float distSqr = dot(SLU, SLU);\n      float litRadius = cc_lightSizeRangeAngle[i].x;\n      float litRadiusSqr = litRadius * litRadius;\n      float illum = 3.14159265359 * (litRadiusSqr / max(litRadiusSqr , distSqr));\n      float attRadiusSqrInv = 1.0 / max(cc_lightSizeRangeAngle[i].y, 0.01);\n      attRadiusSqrInv *= attRadiusSqrInv;\n      float att = GetDistAtt(distSqr, attRadiusSqrInv);\n      vec3 lspec = specular * CalcSpecular(s.roughness, SNH, SH, N);\n      if (cc_lightPos[i].w > 0.0) {\n        float cosInner = max(dot(-cc_lightDir[i].xyz, SL), 0.01);\n        float cosOuter = cc_lightSizeRangeAngle[i].z;\n        float litAngleScale = 1.0 / max(0.001, cosInner - cosOuter);\n        float litAngleOffset = -cosOuter * litAngleScale;\n        att *= GetAngleAtt(SL, -cc_lightDir[i].xyz, litAngleScale, litAngleOffset);\n      }\n      finalColor += SNL * cc_lightColor[i].rgb * cc_lightColor[i].w * illum * att * (diffuseContrib + lspec);\n    }\n    finalColor = finalColor * s.occlusion;\n    return vec4(finalColor, 0.0);\n  }\n#else\n  #if CC_RECEIVE_SHADOW\nlayout(location = 0) in vec4 v_shadowPos;\nlayout(set = 0, binding = 4) uniform sampler2D cc_shadowMap;\nfloat CCGetShadowFactorX1 () {\n  vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n  float closestDepth = dot(texture(cc_shadowMap, clipPos.xy), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n  float shadow = step(closestDepth, clipPos.z - 0.001);\n  return shadow;\n}\nfloat CCGetShadowFactorX5 () {\n  vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n  float offsetx = 1.0 / cc_shadowSize.x;\n  float offsety = 1.0 / cc_shadowSize.y;\n  float shadow = 0.0;\n  float closestDepth = 0.0;\n  closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n  shadow += step(closestDepth, clipPos.z - 0.001);\n  closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x - offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n  shadow += step(closestDepth, clipPos.z - 0.001);\n  closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x, clipPos.y)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n  shadow += step(closestDepth, clipPos.z - 0.001);\n  closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y - offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n  shadow += step(closestDepth, clipPos.z - 0.001);\n  closestDepth = dot(texture(cc_shadowMap, vec2(clipPos.x + offsetx, clipPos.y + offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n  shadow += step(closestDepth, clipPos.z - 0.001);\n  return shadow /= 5.0;\n}\nfloat CCGetShadowFactorX9 () {\n  vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n  float offsetx = 1.0 / cc_shadowSize.x;\n  float offsety = 1.0 / cc_shadowSize.y;\n  float shadow = 0.0;\n  for (int i = -1; i <= 1; i++) {\n    for (int j = -1; j <= 1; j++) {\n      float closestDepth = dot(texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, clipPos.z - 0.001);\n    }\n  }\n  return shadow /= 9.0;\n}\nfloat CCGetShadowFactorX25 () {\n  vec3 clipPos = v_shadowPos.xyz / v_shadowPos.w * 0.5 + 0.5;\n  float offsetx = 1.0 / cc_shadowSize.x;\n  float offsety = 1.0 / cc_shadowSize.y;\n  float shadow = 0.0;\n  for (int i = -2; i <= 2; i++) {\n    for (int j = -2; j <= 2; j++) {\n      float closestDepth = dot(texture(cc_shadowMap, clipPos.xy + vec2(i, j) * vec2(offsetx, offsety)), vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n      shadow += step(closestDepth, clipPos.z - 0.001);\n    }\n  }\n  return shadow /= 25.0;\n}\n  #endif\n  vec4 CCStandardShading (StandardSurface s) {\n    vec3 diffuse = s.albedo.rgb * (1.0 - s.metallic);\n    vec3 specular = mix(vec3(0.04), s.albedo.rgb, s.metallic);\n    vec3 N = normalize(s.normal);\n    vec3 V = normalize(cc_cameraPos.xyz - s.position);\n    float NV = max(abs(dot(N, V)), 0.001);\n    specular = BRDFApprox(specular, s.roughness, NV);\n    vec3 L = normalize(-cc_mainLitDir.xyz);\n    vec3 H = normalize(L+V);\n    float NH = max(dot(N, H), 0.0);\n    float NL = max(dot(N, L), 0.001);\n    vec3 finalColor = NL * cc_mainLitColor.rgb * cc_mainLitColor.w;\n    #if USE_LIGHTMAP && !USE_BATCHING && !CC_FORWARD_ADD\n      vec4 lightmap = texture(cc_lightingMap, v_luv);\n      finalColor = lightmap.a * lightmap.rgb + (1.0 - lightmap.a) * finalColor;\n    #endif\n    vec3 diffuseContrib = diffuse / 3.14159265359;\n    vec3 specularContrib = specular * CalcSpecular(s.roughness, NH, H, N);\n    finalColor *= (diffuseContrib + specularContrib);\n    float fAmb = 0.5 - N.y * 0.5;\n    vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n    finalColor += (ambDiff.rgb * diffuse);\n    #if CC_USE_IBL\n      vec3 R = normalize(reflect(-V, N));\n      vec4 envmap = fragTextureLod(cc_environment, R, s.roughness * cc_ambientGround.w);\n      #if CC_USE_IBL == 2\n        vec3 env = unpackRGBE(envmap);\n      #else\n        vec3 env = SRGBToLinear(envmap.rgb);\n      #endif\n      finalColor += env * cc_ambientSky.w * specular;\n    #endif\n    finalColor = finalColor * s.occlusion;\n    #if CC_USE_HDR\n      s.emissive *= cc_exposure.w;\n    #endif\n    finalColor += s.emissive;\n    #if CC_RECEIVE_SHADOW\n      float pcf = cc_shadowPCF.x + 0.001;\n      float shadowAttenuation = 0.0;\n      if (pcf > 3.0) {shadowAttenuation = CCGetShadowFactorX25();}\n      else if (3.0 > pcf && pcf > 2.0) {shadowAttenuation = CCGetShadowFactorX9();}\n      else if (2.0 > pcf && pcf > 1.0) {shadowAttenuation = CCGetShadowFactorX5();}\n      else {shadowAttenuation = CCGetShadowFactorX1();}\n      vec3 shadowColor = cc_shadowColor.rgb * cc_shadowColor.a + finalColor * (1.0 - cc_shadowColor.a);\n      finalColor = shadowColor.rgb * shadowAttenuation + finalColor.rgb * (1.0 - shadowAttenuation);\n    #endif\n    return vec4(finalColor, s.albedo.a);\n  }\n#endif\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nlayout(location = 2) in vec3 v_position;\nlayout(location = 4) in vec2 v_uv;\nlayout(location = 5) in vec2 v_uv1;\nlayout(location = 3) in vec3 v_normal;\nlayout(location = 6) in float v_fog_factor;\n#if USE_VERTEX_COLOR\n  layout(location = 1) in vec3 v_color;\n#endif\n#if USE_ALBEDO_MAP\n  layout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_NORMAL_MAP\n  layout(location = 7) in vec3 v_tangent;\n  layout(location = 8) in vec3 v_bitangent;\n  layout(set = 1, binding = 2) uniform sampler2D normalMap;\n#endif\n#if USE_PBR_MAP\n  layout(set = 1, binding = 3) uniform sampler2D pbrMap;\n#endif\n#if USE_METALLIC_ROUGHNESS_MAP\n  layout(set = 1, binding = 4) uniform sampler2D metallicRoughnessMap;\n#endif\n#if USE_OCCLUSION_MAP\n  layout(set = 1, binding = 5) uniform sampler2D occlusionMap;\n#endif\n#if USE_EMISSIVE_MAP\n  layout(set = 1, binding = 6) uniform sampler2D emissiveMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvoid surf (out StandardSurface s) {\n  vec4 baseColor = albedo;\n  #if USE_VERTEX_COLOR\n    baseColor.rgb *= v_color;\n  #endif\n  #if USE_ALBEDO_MAP\n    vec4 texColor = texture(albedoMap, ALBEDO_UV);\n    texColor.rgb = SRGBToLinear(texColor.rgb);\n    baseColor *= texColor;\n  #endif\n  s.albedo = baseColor;\n  s.albedo.rgb *= albedoScaleAndCutoff.xyz;\n  #if USE_ALPHA_TEST\n    if (s.albedo.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  s.normal = v_normal;\n  #if USE_NORMAL_MAP\n    vec3 nmmp = texture(normalMap, NORMAL_UV).xyz - vec3(0.5);\n    s.normal =\n      (nmmp.x * pbrParams.w) * normalize(v_tangent) +\n      (nmmp.y * pbrParams.w) * normalize(v_bitangent) +\n      nmmp.z * normalize(s.normal);\n  #endif\n  s.position = v_position;\n  vec4 pbr = pbrParams;\n  #if USE_PBR_MAP\n    vec4 res = texture(pbrMap, PBR_UV);\n    pbr.x *= res.r;\n    pbr.y *= res.g;\n    pbr.z *= res.b;\n  #endif\n  #if USE_METALLIC_ROUGHNESS_MAP\n    vec4 metallicRoughness = texture(metallicRoughnessMap, PBR_UV);\n    pbr.z *= metallicRoughness.b;\n    pbr.y *= metallicRoughness.g;\n  #endif\n  #if USE_OCCLUSION_MAP\n    pbr.x *= texture(occlusionMap, PBR_UV).r;\n  #endif\n  s.occlusion = clamp(pbr.x, 0.0, 0.96);\n  s.roughness = clamp(pbr.y, 0.04, 1.0);\n  s.metallic = pbr.z;\n  s.emissive = emissive.rgb * emissiveScaleParam.xyz;\n  #if USE_EMISSIVE_MAP\n    s.emissive *= SRGBToLinear(texture(emissiveMap, EMISSIVE_UV).rgb);\n  #endif\n}\nvec4 frag () {\n  StandardSurface s; surf(s);\n  vec4 color = CCStandardShading(s);\n  color = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, v_fog_factor), color.a);\n  return CCFragOutput(color);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
                },
                "builtins": {
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCShadow",
                      "defines": []
                    }],
                    "samplers": [{
                      "name": "cc_environment",
                      "defines": ["CC_USE_IBL"]
                    }, {
                      "name": "cc_shadowMap",
                      "defines": ["!CC_FORWARD_ADD", "CC_RECEIVE_SHADOW"]
                    }]
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCMorph",
                      "defines": ["CC_USE_MORPH"]
                    }, {
                      "name": "CCSkinningTexture",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCSkinningAnimation",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCSkinning",
                      "defines": ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCLocalBatched",
                      "defines": ["!USE_INSTANCING", "USE_BATCHING"]
                    }, {
                      "name": "CCLocal",
                      "defines": ["!USE_INSTANCING", "!USE_BATCHING"]
                    }, {
                      "name": "CCForwardLight",
                      "defines": ["CC_FORWARD_ADD"]
                    }],
                    "samplers": [{
                      "name": "cc_PositionDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
                    }, {
                      "name": "cc_NormalDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
                    }, {
                      "name": "cc_TangentDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
                    }, {
                      "name": "cc_jointTexture",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "cc_lightingMap",
                      "defines": ["USE_LIGHTMAP", "!USE_BATCHING", "!CC_FORWARD_ADD"]
                    }]
                  }
                },
                "defines": [{
                  "name": "CC_USE_MORPH",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_COUNT",
                  "type": "number",
                  "range": [2, 8]
                }, {
                  "name": "CC_SUPPORT_FLOAT_TEXTURE",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_PRECOMPUTED",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_POSITION",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_NORMAL",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_TANGENT",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_SKINNING",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_BAKED_ANIMATION",
                  "type": "boolean"
                }, {
                  "name": "USE_INSTANCING",
                  "type": "boolean"
                }, {
                  "name": "USE_BATCHING",
                  "type": "boolean"
                }, {
                  "name": "USE_LIGHTMAP",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_FOG",
                  "type": "number",
                  "range": [0, 4]
                }, {
                  "name": "CC_FORWARD_ADD",
                  "type": "boolean"
                }, {
                  "name": "USE_VERTEX_COLOR",
                  "type": "boolean"
                }, {
                  "name": "USE_NORMAL_MAP",
                  "type": "boolean"
                }, {
                  "name": "HAS_SECOND_UV",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_IBL",
                  "type": "number",
                  "range": [0, 2]
                }, {
                  "name": "CC_RECEIVE_SHADOW",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_HDR",
                  "type": "boolean"
                }, {
                  "name": "USE_ALBEDO_MAP",
                  "type": "boolean"
                }, {
                  "name": "ALBEDO_UV",
                  "type": "string",
                  "options": ["v_uv", "v_uv1"]
                }, {
                  "name": "NORMAL_UV",
                  "type": "string",
                  "options": ["v_uv", "v_uv1"]
                }, {
                  "name": "PBR_UV",
                  "type": "string",
                  "options": ["v_uv", "v_uv1"]
                }, {
                  "name": "USE_PBR_MAP",
                  "type": "boolean"
                }, {
                  "name": "USE_METALLIC_ROUGHNESS_MAP",
                  "type": "boolean"
                }, {
                  "name": "USE_OCCLUSION_MAP",
                  "type": "boolean"
                }, {
                  "name": "USE_EMISSIVE_MAP",
                  "type": "boolean"
                }, {
                  "name": "EMISSIVE_UV",
                  "type": "string",
                  "options": ["v_uv", "v_uv1"]
                }, {
                  "name": "USE_ALPHA_TEST",
                  "type": "boolean"
                }, {
                  "name": "ALPHA_TEST_CHANNEL",
                  "type": "string",
                  "options": ["a", "r"]
                }],
                "blocks": [{
                  "name": "Constants",
                  "defines": [],
                  "binding": 0,
                  "stageFlags": 17,
                  "members": [{
                    "name": "tilingOffset",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "albedo",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "albedoScaleAndCutoff",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "pbrParams",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "emissive",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "emissiveScaleParam",
                    "type": 16,
                    "count": 1
                  }]
                }],
                "samplers": [{
                  "name": "albedoMap",
                  "type": 28,
                  "count": 1,
                  "defines": ["USE_ALBEDO_MAP"],
                  "stageFlags": 16,
                  "binding": 1
                }, {
                  "name": "normalMap",
                  "type": 28,
                  "count": 1,
                  "defines": ["USE_NORMAL_MAP"],
                  "stageFlags": 16,
                  "binding": 2
                }, {
                  "name": "pbrMap",
                  "type": 28,
                  "count": 1,
                  "defines": ["USE_PBR_MAP"],
                  "stageFlags": 16,
                  "binding": 3
                }, {
                  "name": "metallicRoughnessMap",
                  "type": 28,
                  "count": 1,
                  "defines": ["USE_METALLIC_ROUGHNESS_MAP"],
                  "stageFlags": 16,
                  "binding": 4
                }, {
                  "name": "occlusionMap",
                  "type": 28,
                  "count": 1,
                  "defines": ["USE_OCCLUSION_MAP"],
                  "stageFlags": 16,
                  "binding": 5
                }, {
                  "name": "emissiveMap",
                  "type": 28,
                  "count": 1,
                  "defines": ["USE_EMISSIVE_MAP"],
                  "stageFlags": 16,
                  "binding": 6
                }],
                "attributes": [{
                  "name": "a_position",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_normal",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 1
                }, {
                  "name": "a_texCoord",
                  "type": 14,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 21,
                  "location": 2
                }, {
                  "name": "a_tangent",
                  "type": 16,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 3
                }, {
                  "name": "a_vertexId",
                  "type": 13,
                  "count": 1,
                  "defines": ["CC_USE_MORPH"],
                  "stageFlags": 1,
                  "format": 11,
                  "location": 6
                }, {
                  "name": "a_joints",
                  "type": 12,
                  "count": 1,
                  "defines": ["CC_USE_SKINNING"],
                  "stageFlags": 1,
                  "format": 42,
                  "location": 4
                }, {
                  "name": "a_weights",
                  "type": 16,
                  "count": 1,
                  "defines": ["CC_USE_SKINNING"],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 5
                }, {
                  "name": "a_jointAnimInfo",
                  "type": 16,
                  "count": 1,
                  "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION", "USE_INSTANCING"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 7
                }, {
                  "name": "a_matWorld0",
                  "type": 16,
                  "count": 1,
                  "defines": ["USE_INSTANCING"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 8
                }, {
                  "name": "a_matWorld1",
                  "type": 16,
                  "count": 1,
                  "defines": ["USE_INSTANCING"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 9
                }, {
                  "name": "a_matWorld2",
                  "type": 16,
                  "count": 1,
                  "defines": ["USE_INSTANCING"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 10
                }, {
                  "name": "a_lightingMapUVParam",
                  "type": 16,
                  "count": 1,
                  "defines": ["USE_INSTANCING", "USE_LIGHTMAP"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 11
                }, {
                  "name": "a_dyn_batch_id",
                  "type": 13,
                  "count": 1,
                  "defines": ["!USE_INSTANCING", "USE_BATCHING"],
                  "stageFlags": 1,
                  "format": 11,
                  "location": 12
                }, {
                  "name": "a_color",
                  "type": 15,
                  "count": 1,
                  "defines": ["USE_VERTEX_COLOR"],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 13
                }, {
                  "name": "a_texCoord1",
                  "type": 14,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 21,
                  "location": 14
                }]
              }, {
                "name": "builtin-standard|shadow-caster-vs:vert|shadow-caster-fs:frag",
                "hash": 868488122,
                "glsl3": {
                  "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n        return int(a_vertexId);\n    }\nlayout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_SUPPORT_FLOAT_TEXTURE\n        vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n            ivec2 texSize = textureSize(tex, 0);\n            return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n        }\n#else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex * 4;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n        return vec4(\n            decode32(texture(tex, x)),\n            decode32(texture(tex, y)),\n            decode32(texture(tex, z)),\n            1.0\n        );\n    }\n#endif\nfloat getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n        return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n        return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n        return cc_displacementWeights[quot].z;\n    } else {\n        return cc_displacementWeights[quot].w;\n    }\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\n    vec3 result = vec3(0, 0, 0);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        int dataPixelStart = int(fetchVec3ArrayFromTexture(tex, iTarget).r);\n        result += (fetchVec3ArrayFromTexture(tex, dataPixelStart + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n  #if USE_INSTANCING\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(std140) uniform CCSkinningTexture {\n    highp vec4 cc_jointTextureInfo;\n  };\n  layout(std140) uniform CCSkinningAnimation {\n    highp vec4 cc_jointAnimInfo;\n  };\n  uniform highp sampler2D cc_jointTexture;\n  #else\n  layout(std140) uniform CCSkinning {\n    highp vec4 cc_joints[30 * 3];\n  };\n#endif\n#if CC_USE_BAKED_ANIMATION\n  #if CC_SUPPORT_FLOAT_TEXTURE\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n      vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n      vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #else\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n      );\n      vec4 v2 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n      );\n      vec4 v3 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n      );\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n#else\n  mat4 getJointMatrix (float i) {\n    int idx = int(i);\n    vec4 v1 = cc_joints[idx * 3];\n    vec4 v2 = cc_joints[idx * 3 + 1];\n    vec4 v3 = cc_joints[idx * 3 + 2];\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n       + getJointMatrix(a_joints.y) * a_weights.y\n       + getJointMatrix(a_joints.z) * a_weights.z\n       + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\n#endif\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightViewProj;\n  lowp vec4 cc_shadowColor;\n  lowp vec4 cc_shadowPCF;\n  lowp vec4 cc_shadowSize;\n};\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  in vec2 a_texCoord1;\n#endif\nout vec2 v_uv;\nout vec2 v_uv1;\nout vec2 v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n  In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In);\n  #endif\n  mat4 matWorld, matWorldIT;\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n  vec4 worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.zw;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }",
                  "frag": "\nprecision highp float;\nlayout(std140) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\n  ret = fract(ret);\n  ret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n  return ret;\n}\nin vec2 v_uv;\nin vec2 v_uv1;\nin vec2 v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  return packDepthToRGBA(v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
                },
                "glsl1": {
                  "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n        return int(a_vertexId);\n    }\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_SUPPORT_FLOAT_TEXTURE\n        vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n            int pixelIndex = elementIndex;\n            vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n            vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n            return texture2D(tex, uv);\n        }\n#else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex * 4;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n        return vec4(\n            decode32(texture2D(tex, x)),\n            decode32(texture2D(tex, y)),\n            decode32(texture2D(tex, z)),\n            1.0\n        );\n    }\n#endif\nfloat getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n        return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n        return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n        return cc_displacementWeights[quot].z;\n    } else {\n        return cc_displacementWeights[quot].w;\n    }\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\n    vec3 result = vec3(0, 0, 0);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        int dataPixelStart = int(fetchVec3ArrayFromTexture(tex, iTarget).r);\n        result += (fetchVec3ArrayFromTexture(tex, dataPixelStart + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n  #if USE_INSTANCING\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  uniform highp vec4 cc_jointTextureInfo;\n  uniform highp vec4 cc_jointAnimInfo;\n  uniform highp sampler2D cc_jointTexture;\n  #else\n  uniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n  #if CC_SUPPORT_FLOAT_TEXTURE\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n      vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n      vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #else\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n      );\n      vec4 v2 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n      );\n      vec4 v3 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n      );\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n#else\n  mat4 getJointMatrix (float i) {\n    int idx = int(i);\n    vec4 v1 = cc_joints[idx * 3];\n    vec4 v2 = cc_joints[idx * 3 + 1];\n    vec4 v3 = cc_joints[idx * 3 + 2];\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n       + getJointMatrix(a_joints.y) * a_weights.y\n       + getJointMatrix(a_joints.z) * a_weights.z\n       + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\nuniform highp mat4 cc_matWorldIT;\n#endif\nuniform vec4 tilingOffset;\nuniform highp mat4 cc_matLightViewProj;\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  attribute vec2 a_texCoord1;\n#endif\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec2 v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n  In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In);\n  #endif\n  mat4 matWorld, matWorldIT;\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n  vec4 worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.zw;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }",
                  "frag": "\nprecision highp float;\nuniform vec4 albedo;\nuniform vec4 albedoScaleAndCutoff;\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\n  ret = fract(ret);\n  ret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n  return ret;\n}\nvarying vec2 v_uv;\nvarying vec2 v_uv1;\nvarying vec2 v_clip_depth;\n#if USE_ALBEDO_MAP\n  uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture2D(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  return packDepthToRGBA(v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5);\n}\nvoid main() { gl_FragColor = frag(); }"
                },
                "glsl4": {
                  "vert": "\n#ifdef GL_EXT_shader_explicit_arithmetic_types_int16\n#extension GL_EXT_shader_explicit_arithmetic_types_int16: enable\n#endif\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n        return gl_VertexIndex;\n    }\nlayout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_SUPPORT_FLOAT_TEXTURE\n        vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n            ivec2 texSize = textureSize(tex, 0);\n            return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n        }\n#else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex * 4;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n        return vec4(\n            decode32(texture(tex, x)),\n            decode32(texture(tex, y)),\n            decode32(texture(tex, z)),\n            1.0\n        );\n    }\n#endif\nfloat getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n        return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n        return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n        return cc_displacementWeights[quot].z;\n    } else {\n        return cc_displacementWeights[quot].w;\n    }\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\n    vec3 result = vec3(0, 0, 0);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        int dataPixelStart = int(fetchVec3ArrayFromTexture(tex, iTarget).r);\n        result += (fetchVec3ArrayFromTexture(tex, dataPixelStart + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 6) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 7) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 8) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nlayout(location = 4) in u16vec4 a_joints;\nlayout(location = 5) in vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n  #if USE_INSTANCING\n    layout(location = 7) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(set = 2, binding = 3) uniform CCSkinningTexture {\n    highp vec4 cc_jointTextureInfo;\n  };\n  layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n    highp vec4 cc_jointAnimInfo;\n  };\n  layout(set = 2, binding = 5) uniform highp sampler2D cc_jointTexture;\n  #else\n  layout(set = 2, binding = 3) uniform CCSkinning {\n    highp vec4 cc_joints[30 * 3];\n  };\n#endif\n#if CC_USE_BAKED_ANIMATION\n  #if CC_SUPPORT_FLOAT_TEXTURE\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n      vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n      vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #else\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n      );\n      vec4 v2 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n      );\n      vec4 v3 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n      );\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n#else\n  mat4 getJointMatrix (float i) {\n    int idx = int(i);\n    vec4 v1 = cc_joints[idx * 3];\n    vec4 v2 = cc_joints[idx * 3 + 1];\n    vec4 v3 = cc_joints[idx * 3 + 2];\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n       + getJointMatrix(a_joints.y) * a_weights.y\n       + getJointMatrix(a_joints.z) * a_weights.z\n       + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\n#if USE_INSTANCING\n  layout(location = 8) in vec4 a_matWorld0;\n  layout(location = 9) in vec4 a_matWorld1;\n  layout(location = 10) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 11) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\n#endif\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nlayout(set = 0, binding = 1) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightViewProj;\n  lowp vec4 cc_shadowColor;\n  lowp vec4 cc_shadowPCF;\n  lowp vec4 cc_shadowSize;\n};\n#if HAS_SECOND_UV || USE_LIGHTMAP\n  layout(location = 13) in vec2 a_texCoord1;\n#endif\nlayout(location = 0) out vec2 v_uv;\nlayout(location = 1) out vec2 v_uv1;\nlayout(location = 2) out vec2 v_clip_depth;\nvec4 vert () {\n  StandardVertInput In;\n  In.position = vec4(a_position, 1.0);\n  In.normal = a_normal;\n  In.tangent = a_tangent;\n  #if CC_USE_MORPH\n    applyMorph(In);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(In);\n  #endif\n  mat4 matWorld, matWorldIT;\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n    matWorldIT = matWorld;\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n    matWorldIT = matWorld;\n  #else\n    matWorld = cc_matWorld;\n    matWorldIT = cc_matWorldIT;\n  #endif\n  vec4 worldPos = matWorld * In.position;\n  vec4 clipPos = cc_matLightViewProj * worldPos;\n  v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #if HAS_SECOND_UV\n    v_uv1 = a_texCoord1 * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  v_clip_depth = clipPos.zw;\n  return clipPos;\n}\nvoid main() { gl_Position = vert(); }",
                  "frag": "\nprecision highp float;\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 tilingOffset;\n  vec4 albedo;\n  vec4 albedoScaleAndCutoff;\n  vec4 pbrParams;\n  vec4 emissive;\n  vec4 emissiveScaleParam;\n};\nvec4 packDepthToRGBA (float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\n  ret = fract(ret);\n  ret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n  return ret;\n}\nlayout(location = 0) in vec2 v_uv;\nlayout(location = 1) in vec2 v_uv1;\nlayout(location = 2) in vec2 v_clip_depth;\n#if USE_ALBEDO_MAP\n  layout(set = 1, binding = 1) uniform sampler2D albedoMap;\n#endif\n#if USE_ALPHA_TEST\n#endif\nvec4 frag () {\n  vec4 baseColor = albedo;\n  #if USE_ALBEDO_MAP\n    baseColor *= texture(albedoMap, ALBEDO_UV);\n  #endif\n  #if USE_ALPHA_TEST\n    if (baseColor.ALPHA_TEST_CHANNEL < albedoScaleAndCutoff.w) discard;\n  #endif\n  return packDepthToRGBA(v_clip_depth.x / v_clip_depth.y * 0.5 + 0.5);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
                },
                "builtins": {
                  "globals": {
                    "blocks": [{
                      "name": "CCShadow",
                      "defines": []
                    }],
                    "samplers": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCMorph",
                      "defines": ["CC_USE_MORPH"]
                    }, {
                      "name": "CCSkinningTexture",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCSkinningAnimation",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCSkinning",
                      "defines": ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCLocalBatched",
                      "defines": ["!USE_INSTANCING", "USE_BATCHING"]
                    }, {
                      "name": "CCLocal",
                      "defines": ["!USE_INSTANCING", "!USE_BATCHING"]
                    }],
                    "samplers": [{
                      "name": "cc_PositionDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
                    }, {
                      "name": "cc_NormalDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
                    }, {
                      "name": "cc_TangentDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
                    }, {
                      "name": "cc_jointTexture",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }]
                  }
                },
                "defines": [{
                  "name": "CC_USE_MORPH",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_COUNT",
                  "type": "number",
                  "range": [2, 8]
                }, {
                  "name": "CC_SUPPORT_FLOAT_TEXTURE",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_PRECOMPUTED",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_POSITION",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_NORMAL",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_TANGENT",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_SKINNING",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_BAKED_ANIMATION",
                  "type": "boolean"
                }, {
                  "name": "USE_INSTANCING",
                  "type": "boolean"
                }, {
                  "name": "USE_BATCHING",
                  "type": "boolean"
                }, {
                  "name": "USE_LIGHTMAP",
                  "type": "boolean"
                }, {
                  "name": "HAS_SECOND_UV",
                  "type": "boolean"
                }, {
                  "name": "USE_ALBEDO_MAP",
                  "type": "boolean"
                }, {
                  "name": "ALBEDO_UV",
                  "type": "string",
                  "options": ["v_uv", "v_uv1"]
                }, {
                  "name": "USE_ALPHA_TEST",
                  "type": "boolean"
                }, {
                  "name": "ALPHA_TEST_CHANNEL",
                  "type": "string",
                  "options": ["a", "r"]
                }],
                "blocks": [{
                  "name": "Constants",
                  "defines": [],
                  "binding": 0,
                  "stageFlags": 17,
                  "members": [{
                    "name": "tilingOffset",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "albedo",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "albedoScaleAndCutoff",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "pbrParams",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "emissive",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "emissiveScaleParam",
                    "type": 16,
                    "count": 1
                  }]
                }],
                "samplers": [{
                  "name": "albedoMap",
                  "type": 28,
                  "count": 1,
                  "defines": ["USE_ALBEDO_MAP"],
                  "stageFlags": 16,
                  "binding": 1
                }],
                "attributes": [{
                  "name": "a_position",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_normal",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 1
                }, {
                  "name": "a_texCoord",
                  "type": 14,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 21,
                  "location": 2
                }, {
                  "name": "a_tangent",
                  "type": 16,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 3
                }, {
                  "name": "a_vertexId",
                  "type": 13,
                  "count": 1,
                  "defines": ["CC_USE_MORPH"],
                  "stageFlags": 1,
                  "format": 11,
                  "location": 6
                }, {
                  "name": "a_joints",
                  "type": 12,
                  "count": 1,
                  "defines": ["CC_USE_SKINNING"],
                  "stageFlags": 1,
                  "format": 42,
                  "location": 4
                }, {
                  "name": "a_weights",
                  "type": 16,
                  "count": 1,
                  "defines": ["CC_USE_SKINNING"],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 5
                }, {
                  "name": "a_jointAnimInfo",
                  "type": 16,
                  "count": 1,
                  "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION", "USE_INSTANCING"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 7
                }, {
                  "name": "a_matWorld0",
                  "type": 16,
                  "count": 1,
                  "defines": ["USE_INSTANCING"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 8
                }, {
                  "name": "a_matWorld1",
                  "type": 16,
                  "count": 1,
                  "defines": ["USE_INSTANCING"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 9
                }, {
                  "name": "a_matWorld2",
                  "type": 16,
                  "count": 1,
                  "defines": ["USE_INSTANCING"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 10
                }, {
                  "name": "a_lightingMapUVParam",
                  "type": 16,
                  "count": 1,
                  "defines": ["USE_INSTANCING", "USE_LIGHTMAP"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 11
                }, {
                  "name": "a_dyn_batch_id",
                  "type": 13,
                  "count": 1,
                  "defines": ["!USE_INSTANCING", "USE_BATCHING"],
                  "stageFlags": 1,
                  "format": 11,
                  "location": 12
                }, {
                  "name": "a_texCoord1",
                  "type": 14,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 21,
                  "location": 13
                }]
              }]
            }, {
              "name": "builtin-terrain",
              "_uuid": "1d08ef62-a503-4ce2-8b9a-46c90873f7d3",
              "techniques": [{
                "name": "opaque",
                "passes": [{
                  "program": "builtin-terrain|terrain-vs:vert|terrain-fs:frag",
                  "properties": {
                    "UVScale": {
                      "value": [1, 1, 1, 1],
                      "type": 16
                    },
                    "lightMapUVParam": {
                      "value": [0, 0, 0, 0],
                      "type": 16
                    },
                    "weightMap": {
                      "value": "black",
                      "type": 28
                    },
                    "detailMap0": {
                      "value": "grey",
                      "type": 28
                    },
                    "detailMap1": {
                      "value": "grey",
                      "type": 28
                    },
                    "detailMap2": {
                      "value": "grey",
                      "type": 28
                    },
                    "detailMap3": {
                      "value": "grey",
                      "type": 28
                    },
                    "lightMap": {
                      "value": "grey",
                      "type": 28
                    }
                  }
                }]
              }],
              "shaders": [{
                "name": "builtin-terrain|terrain-vs:vert|terrain-fs:frag",
                "hash": 298856331,
                "glsl3": {
                  "vert": "\n  precision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nfloat LinearFog(vec4 pos) {\n    vec4 wPos = pos;\n    float cam_dis = distance(cc_cameraPos, wPos);\n    float fogStart = cc_fogBase.x;\n    float fogEnd = cc_fogBase.y;\n    return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * fogDensity);\n    return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n    return f;\n}\nfloat LayeredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float _FogTop = cc_fogAdd.x;\n    float _FogRange = cc_fogAdd.y;\n    vec3 camWorldProj = cc_cameraPos.xyz;\n    camWorldProj.y = 0.;\n    vec3 worldPosProj = wPos.xyz;\n    worldPosProj.y = 0.;\n    float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n    float fDeltaY, fDensityIntegral;\n    if (cc_cameraPos.y > _FogTop) {\n        if (wPos.y < _FogTop) {\n            fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n            fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n        } else {\n            fDeltaY = 0.;\n            fDensityIntegral = 0.;\n        }\n    } else {\n        if (wPos.y < _FogTop) {\n            float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n            fDeltaY = abs(fDeltaA - fDeltaB);\n            fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n        } else {\n            fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n        }\n    }\n    float fDensity;\n    if (fDeltaY != 0.) {\n        fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n    } else {\n        fDensity = 0.;\n    }\n    float f = exp(-fDensity);\n    return f;\n}\nfloat CC_TRANSFER_FOG(vec4 pos) {\n    #if CC_USE_FOG == 1\n        return LinearFog(pos);\n\t#elif CC_USE_FOG == 2\n        return ExpFog(pos);\n    #elif CC_USE_FOG == 3\n        return ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 4\n        return LayeredFog(pos);\n    #endif\n    return 1.;\n}\n  in vec3 a_position;\n  in vec3 a_normal;\n  in vec2 a_texCoord;\n  out vec2 uvw;\n  out vec2 uv0;\n  out vec2 uv1;\n  out vec2 uv2;\n  out vec2 uv3;\n  out vec2 luv;\n  out vec3 diffuse;\n  out float factor_fog;\n  layout(std140) uniform TexCoords {\n    vec4 UVScale;\n    vec4 lightMapUVParam;\n  };\n  vec4 vert () {\n    vec3 worldPos;\n    worldPos.x = cc_matWorld[3][0] + a_position.x;\n    worldPos.y = cc_matWorld[3][1] + a_position.y;\n    worldPos.z = cc_matWorld[3][2] + a_position.z;\n    vec4 pos = vec4(worldPos, 1);\n    pos = cc_matViewProj * pos;\n    uvw = a_texCoord;\n    uv0 = a_position.xz * UVScale.x;\n    uv1 = a_position.xz * UVScale.y;\n    uv2 = a_position.xz * UVScale.z;\n    uv3 = a_position.xz * UVScale.w;\n    float fAmb = dot(a_normal, vec3(0.0, -1.0, 0.0)) * 0.5 + 0.5;\n    vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n#if LIGHT_MAP == 0\n    vec3 L = normalize(-cc_mainLitDir.xyz);\n    vec3 N = a_normal;\n    diffuse = ambDiff + vec3(dot(N, L)) * cc_mainLitColor.rgb;\n#else\n    diffuse = ambDiff;\n    luv = lightMapUVParam.xy + a_texCoord * lightMapUVParam.zw;\n#endif\n    factor_fog = CC_TRANSFER_FOG(vec4(worldPos, 1));\n    return pos;\n  }\nvoid main() { gl_Position = vert(); }",
                  "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\n  in vec2 uvw;\n  in vec2 uv0;\n  in vec2 uv1;\n  in vec2 uv2;\n  in vec2 uv3;\n  in vec3 diffuse;\n  in vec2 luv;\n  uniform sampler2D weightMap;\n  uniform sampler2D detailMap0;\n  uniform sampler2D detailMap1;\n  uniform sampler2D detailMap2;\n  uniform sampler2D detailMap3;\n  uniform sampler2D lightMap;\n  in float factor_fog;\nvec4 frag () {\n  vec4 color = vec4(0, 0, 0, 0);\n  #if LAYERS == 1\n    color = texture(detailMap0, uv0);\n  #elif LAYERS == 2\n    vec4 w = texture(weightMap, uvw);\n    color += texture(detailMap0, uv0) * w.r;\n    color += texture(detailMap1, uv1) * w.g;\n  #elif LAYERS == 3\n    vec4 w = texture(weightMap, uvw);\n    color += texture(detailMap0, uv0) * w.r;\n    color += texture(detailMap1, uv1) * w.g;\n    color += texture(detailMap2, uv2) * w.b;\n  #elif LAYERS == 4\n    vec4 w = texture(weightMap, uvw);\n    color += texture(detailMap0, uv0) * w.r;\n    color += texture(detailMap1, uv1) * w.g;\n    color += texture(detailMap2, uv2) * w.b;\n    color += texture(detailMap3, uv3) * w.a;\n  #else\n    color = texture(detailMap0, uv0);\n  #endif\n  vec3 lighting = diffuse;\n  #if LIGHT_MAP == 1\n    lighting += texture(lightMap, luv).rgb;\n  #endif\n  color.rgb *= lighting;\n  color = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, factor_fog), color.a);\n  return CCFragOutput(color);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
                },
                "glsl1": {
                  "vert": "\n  precision mediump float;\nuniform highp mat4 cc_matViewProj;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_mainLitDir;\nuniform mediump vec4 cc_mainLitColor;\nuniform mediump vec4 cc_ambientSky;\nuniform mediump vec4 cc_ambientGround;\nuniform mediump vec4 cc_fogBase;\nuniform mediump vec4 cc_fogAdd;\nuniform highp mat4 cc_matWorld;\nfloat LinearFog(vec4 pos) {\n    vec4 wPos = pos;\n    float cam_dis = distance(cc_cameraPos, wPos);\n    float fogStart = cc_fogBase.x;\n    float fogEnd = cc_fogBase.y;\n    return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * fogDensity);\n    return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n    return f;\n}\nfloat LayeredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float _FogTop = cc_fogAdd.x;\n    float _FogRange = cc_fogAdd.y;\n    vec3 camWorldProj = cc_cameraPos.xyz;\n    camWorldProj.y = 0.;\n    vec3 worldPosProj = wPos.xyz;\n    worldPosProj.y = 0.;\n    float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n    float fDeltaY, fDensityIntegral;\n    if (cc_cameraPos.y > _FogTop) {\n        if (wPos.y < _FogTop) {\n            fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n            fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n        } else {\n            fDeltaY = 0.;\n            fDensityIntegral = 0.;\n        }\n    } else {\n        if (wPos.y < _FogTop) {\n            float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n            fDeltaY = abs(fDeltaA - fDeltaB);\n            fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n        } else {\n            fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n        }\n    }\n    float fDensity;\n    if (fDeltaY != 0.) {\n        fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n    } else {\n        fDensity = 0.;\n    }\n    float f = exp(-fDensity);\n    return f;\n}\nfloat CC_TRANSFER_FOG(vec4 pos) {\n    #if CC_USE_FOG == 1\n        return LinearFog(pos);\n\t#elif CC_USE_FOG == 2\n        return ExpFog(pos);\n    #elif CC_USE_FOG == 3\n        return ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 4\n        return LayeredFog(pos);\n    #endif\n    return 1.;\n}\n  attribute vec3 a_position;\n  attribute vec3 a_normal;\n  attribute vec2 a_texCoord;\n  varying vec2 uvw;\n  varying vec2 uv0;\n  varying vec2 uv1;\n  varying vec2 uv2;\n  varying vec2 uv3;\n  varying vec2 luv;\n  varying vec3 diffuse;\n  varying float factor_fog;\n  uniform vec4 UVScale;\nuniform vec4 lightMapUVParam;\n  vec4 vert () {\n    vec3 worldPos;\n    worldPos.x = cc_matWorld[3][0] + a_position.x;\n    worldPos.y = cc_matWorld[3][1] + a_position.y;\n    worldPos.z = cc_matWorld[3][2] + a_position.z;\n    vec4 pos = vec4(worldPos, 1);\n    pos = cc_matViewProj * pos;\n    uvw = a_texCoord;\n    uv0 = a_position.xz * UVScale.x;\n    uv1 = a_position.xz * UVScale.y;\n    uv2 = a_position.xz * UVScale.z;\n    uv3 = a_position.xz * UVScale.w;\n    float fAmb = dot(a_normal, vec3(0.0, -1.0, 0.0)) * 0.5 + 0.5;\n    vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n#if LIGHT_MAP == 0\n    vec3 L = normalize(-cc_mainLitDir.xyz);\n    vec3 N = a_normal;\n    diffuse = ambDiff + vec3(dot(N, L)) * cc_mainLitColor.rgb;\n#else\n    diffuse = ambDiff;\n    luv = lightMapUVParam.xy + a_texCoord * lightMapUVParam.zw;\n#endif\n    factor_fog = CC_TRANSFER_FOG(vec4(worldPos, 1));\n    return pos;\n  }\nvoid main() { gl_Position = vert(); }",
                  "frag": "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nuniform mediump vec4 cc_fogColor;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\n  varying vec2 uvw;\n  varying vec2 uv0;\n  varying vec2 uv1;\n  varying vec2 uv2;\n  varying vec2 uv3;\n  varying vec3 diffuse;\n  varying vec2 luv;\n  uniform sampler2D weightMap;\n  uniform sampler2D detailMap0;\n  uniform sampler2D detailMap1;\n  uniform sampler2D detailMap2;\n  uniform sampler2D detailMap3;\n  uniform sampler2D lightMap;\n  varying float factor_fog;\nvec4 frag () {\n  vec4 color = vec4(0, 0, 0, 0);\n  #if LAYERS == 1\n    color = texture2D(detailMap0, uv0);\n  #elif LAYERS == 2\n    vec4 w = texture2D(weightMap, uvw);\n    color += texture2D(detailMap0, uv0) * w.r;\n    color += texture2D(detailMap1, uv1) * w.g;\n  #elif LAYERS == 3\n    vec4 w = texture2D(weightMap, uvw);\n    color += texture2D(detailMap0, uv0) * w.r;\n    color += texture2D(detailMap1, uv1) * w.g;\n    color += texture2D(detailMap2, uv2) * w.b;\n  #elif LAYERS == 4\n    vec4 w = texture2D(weightMap, uvw);\n    color += texture2D(detailMap0, uv0) * w.r;\n    color += texture2D(detailMap1, uv1) * w.g;\n    color += texture2D(detailMap2, uv2) * w.b;\n    color += texture2D(detailMap3, uv3) * w.a;\n  #else\n    color = texture2D(detailMap0, uv0);\n  #endif\n  vec3 lighting = diffuse;\n  #if LIGHT_MAP == 1\n    lighting += texture2D(lightMap, luv).rgb;\n  #endif\n  color.rgb *= lighting;\n  color = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, factor_fog), color.a);\n  return CCFragOutput(color);\n}\nvoid main() { gl_FragColor = frag(); }"
                },
                "glsl4": {
                  "vert": "\n  precision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\nfloat LinearFog(vec4 pos) {\n    vec4 wPos = pos;\n    float cam_dis = distance(cc_cameraPos, wPos);\n    float fogStart = cc_fogBase.x;\n    float fogEnd = cc_fogBase.y;\n    return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * fogDensity);\n    return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n    return f;\n}\nfloat LayeredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float _FogTop = cc_fogAdd.x;\n    float _FogRange = cc_fogAdd.y;\n    vec3 camWorldProj = cc_cameraPos.xyz;\n    camWorldProj.y = 0.;\n    vec3 worldPosProj = wPos.xyz;\n    worldPosProj.y = 0.;\n    float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n    float fDeltaY, fDensityIntegral;\n    if (cc_cameraPos.y > _FogTop) {\n        if (wPos.y < _FogTop) {\n            fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n            fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n        } else {\n            fDeltaY = 0.;\n            fDensityIntegral = 0.;\n        }\n    } else {\n        if (wPos.y < _FogTop) {\n            float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n            fDeltaY = abs(fDeltaA - fDeltaB);\n            fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n        } else {\n            fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n        }\n    }\n    float fDensity;\n    if (fDeltaY != 0.) {\n        fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n    } else {\n        fDensity = 0.;\n    }\n    float f = exp(-fDensity);\n    return f;\n}\nfloat CC_TRANSFER_FOG(vec4 pos) {\n    #if CC_USE_FOG == 1\n        return LinearFog(pos);\n\t#elif CC_USE_FOG == 2\n        return ExpFog(pos);\n    #elif CC_USE_FOG == 3\n        return ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 4\n        return LayeredFog(pos);\n    #endif\n    return 1.;\n}\n  layout(location = 0) in vec3 a_position;\n  layout(location = 1) in vec3 a_normal;\n  layout(location = 2) in vec2 a_texCoord;\n  layout(location = 0) out vec2 uvw;\n  layout(location = 1) out vec2 uv0;\n  layout(location = 2) out vec2 uv1;\n  layout(location = 3) out vec2 uv2;\n  layout(location = 4) out vec2 uv3;\n  layout(location = 5) out vec2 luv;\n  layout(location = 6) out vec3 diffuse;\n  layout(location = 7) out float factor_fog;\n  layout(set = 1, binding = 0) uniform TexCoords {\n    vec4 UVScale;\n    vec4 lightMapUVParam;\n  };\n  vec4 vert () {\n    vec3 worldPos;\n    worldPos.x = cc_matWorld[3][0] + a_position.x;\n    worldPos.y = cc_matWorld[3][1] + a_position.y;\n    worldPos.z = cc_matWorld[3][2] + a_position.z;\n    vec4 pos = vec4(worldPos, 1);\n    pos = cc_matViewProj * pos;\n    uvw = a_texCoord;\n    uv0 = a_position.xz * UVScale.x;\n    uv1 = a_position.xz * UVScale.y;\n    uv2 = a_position.xz * UVScale.z;\n    uv3 = a_position.xz * UVScale.w;\n    float fAmb = dot(a_normal, vec3(0.0, -1.0, 0.0)) * 0.5 + 0.5;\n    vec3 ambDiff = mix(cc_ambientSky.rgb, cc_ambientGround.rgb, fAmb) * cc_ambientSky.w;\n#if LIGHT_MAP == 0\n    vec3 L = normalize(-cc_mainLitDir.xyz);\n    vec3 N = a_normal;\n    diffuse = ambDiff + vec3(dot(N, L)) * cc_mainLitColor.rgb;\n#else\n    diffuse = ambDiff;\n    luv = lightMapUVParam.xy + a_texCoord * lightMapUVParam.zw;\n#endif\n    factor_fog = CC_TRANSFER_FOG(vec4(worldPos, 1));\n    return pos;\n  }\nvoid main() { gl_Position = vert(); }",
                  "frag": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\n  layout(location = 0) in vec2 uvw;\n  layout(location = 1) in vec2 uv0;\n  layout(location = 2) in vec2 uv1;\n  layout(location = 3) in vec2 uv2;\n  layout(location = 4) in vec2 uv3;\n  layout(location = 6) in vec3 diffuse;\n  layout(location = 5) in vec2 luv;\n  layout(set = 1, binding = 1) uniform sampler2D weightMap;\n  layout(set = 1, binding = 2) uniform sampler2D detailMap0;\n  layout(set = 1, binding = 3) uniform sampler2D detailMap1;\n  layout(set = 1, binding = 4) uniform sampler2D detailMap2;\n  layout(set = 1, binding = 5) uniform sampler2D detailMap3;\n  layout(set = 1, binding = 6) uniform sampler2D lightMap;\n  layout(location = 7) in float factor_fog;\nvec4 frag () {\n  vec4 color = vec4(0, 0, 0, 0);\n  #if LAYERS == 1\n    color = texture(detailMap0, uv0);\n  #elif LAYERS == 2\n    vec4 w = texture(weightMap, uvw);\n    color += texture(detailMap0, uv0) * w.r;\n    color += texture(detailMap1, uv1) * w.g;\n  #elif LAYERS == 3\n    vec4 w = texture(weightMap, uvw);\n    color += texture(detailMap0, uv0) * w.r;\n    color += texture(detailMap1, uv1) * w.g;\n    color += texture(detailMap2, uv2) * w.b;\n  #elif LAYERS == 4\n    vec4 w = texture(weightMap, uvw);\n    color += texture(detailMap0, uv0) * w.r;\n    color += texture(detailMap1, uv1) * w.g;\n    color += texture(detailMap2, uv2) * w.b;\n    color += texture(detailMap3, uv3) * w.a;\n  #else\n    color = texture(detailMap0, uv0);\n  #endif\n  vec3 lighting = diffuse;\n  #if LIGHT_MAP == 1\n    lighting += texture(lightMap, luv).rgb;\n  #endif\n  color.rgb *= lighting;\n  color = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, color.rgb, factor_fog), color.a);\n  return CCFragOutput(color);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
                },
                "builtins": {
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }],
                    "samplers": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCLocal",
                      "defines": []
                    }],
                    "samplers": []
                  }
                },
                "defines": [{
                  "name": "CC_USE_FOG",
                  "type": "number",
                  "range": [0, 4]
                }, {
                  "name": "CC_FORWARD_ADD",
                  "type": "boolean"
                }, {
                  "name": "LIGHT_MAP",
                  "type": "number",
                  "range": [0, 3]
                }, {
                  "name": "CC_USE_HDR",
                  "type": "boolean"
                }, {
                  "name": "LAYERS",
                  "type": "number",
                  "range": [0, 4]
                }],
                "blocks": [{
                  "name": "TexCoords",
                  "defines": [],
                  "binding": 0,
                  "stageFlags": 1,
                  "members": [{
                    "name": "UVScale",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "lightMapUVParam",
                    "type": 16,
                    "count": 1
                  }]
                }],
                "samplers": [{
                  "name": "weightMap",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 1
                }, {
                  "name": "detailMap0",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 2
                }, {
                  "name": "detailMap1",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 3
                }, {
                  "name": "detailMap2",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 4
                }, {
                  "name": "detailMap3",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 5
                }, {
                  "name": "lightMap",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 6
                }],
                "attributes": [{
                  "name": "a_position",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_normal",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 1
                }, {
                  "name": "a_texCoord",
                  "type": 14,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 21,
                  "location": 2
                }]
              }]
            }, {
              "name": "builtin-unlit",
              "_uuid": "a3cd009f-0ab0-420d-9278-b9fdab939bbc",
              "techniques": [{
                "name": "opaque",
                "passes": [{
                  "program": "builtin-unlit|unlit-vs:vert|unlit-fs:frag",
                  "properties": {
                    "mainTexture": {
                      "value": "grey",
                      "type": 28
                    },
                    "tilingOffset": {
                      "value": [1, 1, 0, 0],
                      "type": 16
                    },
                    "mainColor": {
                      "value": [1, 1, 1, 1],
                      "type": 16
                    },
                    "colorScale": {
                      "value": [1, 1, 1],
                      "type": 15,
                      "handleInfo": ["colorScaleAndCutoff", 0, 15]
                    },
                    "alphaThreshold": {
                      "value": [0.5],
                      "type": 13,
                      "handleInfo": ["colorScaleAndCutoff", 3, 13]
                    },
                    "color": {
                      "type": 16,
                      "handleInfo": ["mainColor", 0, 16]
                    },
                    "colorScaleAndCutoff": {
                      "type": 16,
                      "value": [1, 1, 1, 0.5]
                    }
                  }
                }]
              }],
              "shaders": [{
                "name": "builtin-unlit|unlit-vs:vert|unlit-fs:frag",
                "hash": 4280240937,
                "glsl3": {
                  "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n        return int(a_vertexId);\n    }\nlayout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_SUPPORT_FLOAT_TEXTURE\n        vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n            ivec2 texSize = textureSize(tex, 0);\n            return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n        }\n#else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex * 4;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n        return vec4(\n            decode32(texture(tex, x)),\n            decode32(texture(tex, y)),\n            decode32(texture(tex, z)),\n            1.0\n        );\n    }\n#endif\nfloat getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n        return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n        return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n        return cc_displacementWeights[quot].z;\n    } else {\n        return cc_displacementWeights[quot].w;\n    }\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\n    vec3 result = vec3(0, 0, 0);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        int dataPixelStart = int(fetchVec3ArrayFromTexture(tex, iTarget).r);\n        result += (fetchVec3ArrayFromTexture(tex, dataPixelStart + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n  #if USE_INSTANCING\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(std140) uniform CCSkinningTexture {\n    highp vec4 cc_jointTextureInfo;\n  };\n  layout(std140) uniform CCSkinningAnimation {\n    highp vec4 cc_jointAnimInfo;\n  };\n  uniform highp sampler2D cc_jointTexture;\n  #else\n  layout(std140) uniform CCSkinning {\n    highp vec4 cc_joints[30 * 3];\n  };\n#endif\n#if CC_USE_BAKED_ANIMATION\n  #if CC_SUPPORT_FLOAT_TEXTURE\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n      vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n      vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #else\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n      );\n      vec4 v2 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n      );\n      vec4 v3 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n      );\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n#else\n  mat4 getJointMatrix (float i) {\n    int idx = int(i);\n    vec4 v1 = cc_joints[idx * 3];\n    vec4 v2 = cc_joints[idx * 3 + 1];\n    vec4 v3 = cc_joints[idx * 3 + 2];\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n       + getJointMatrix(a_joints.y) * a_weights.y\n       + getJointMatrix(a_joints.z) * a_weights.z\n       + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\n#endif\nfloat LinearFog(vec4 pos) {\n    vec4 wPos = pos;\n    float cam_dis = distance(cc_cameraPos, wPos);\n    float fogStart = cc_fogBase.x;\n    float fogEnd = cc_fogBase.y;\n    return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * fogDensity);\n    return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n    return f;\n}\nfloat LayeredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float _FogTop = cc_fogAdd.x;\n    float _FogRange = cc_fogAdd.y;\n    vec3 camWorldProj = cc_cameraPos.xyz;\n    camWorldProj.y = 0.;\n    vec3 worldPosProj = wPos.xyz;\n    worldPosProj.y = 0.;\n    float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n    float fDeltaY, fDensityIntegral;\n    if (cc_cameraPos.y > _FogTop) {\n        if (wPos.y < _FogTop) {\n            fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n            fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n        } else {\n            fDeltaY = 0.;\n            fDensityIntegral = 0.;\n        }\n    } else {\n        if (wPos.y < _FogTop) {\n            float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n            fDeltaY = abs(fDeltaA - fDeltaB);\n            fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n        } else {\n            fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n        }\n    }\n    float fDensity;\n    if (fDeltaY != 0.) {\n        fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n    } else {\n        fDensity = 0.;\n    }\n    float f = exp(-fDensity);\n    return f;\n}\nfloat CC_TRANSFER_FOG(vec4 pos) {\n    #if CC_USE_FOG == 1\n        return LinearFog(pos);\n\t#elif CC_USE_FOG == 2\n        return ExpFog(pos);\n    #elif CC_USE_FOG == 3\n        return ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 4\n        return LayeredFog(pos);\n    #endif\n    return 1.;\n}\n#if USE_VERTEX_COLOR\n  in lowp vec4 a_color;\n  out lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\n  out vec2 v_uv;\n  layout(std140) uniform TexCoords {\n    vec4 tilingOffset;\n  };\n#endif\nout float factor_fog;\nvec4 vert () {\n  vec4 position;\n  position = vec4(a_position, 1.0);\n  #if CC_USE_MORPH\n    applyMorph(position);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(position);\n  #endif\n  mat4 matWorld;\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n  #if USE_TEXTURE\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  factor_fog = CC_TRANSFER_FOG(matWorld * position);\n  return cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }",
                  "frag": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\n  in vec2 v_uv;\n  uniform sampler2D mainTexture;\n#endif\nlayout(std140) uniform Constant {\n  vec4 mainColor;\n  vec4 colorScaleAndCutoff;\n};\n#if USE_VERTEX_COLOR\n  in lowp vec4 v_color;\n#endif\nin float factor_fog;\nvec4 frag () {\n  vec4 o = mainColor;\n  o.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_VERTEX_COLOR\n    o *= v_color;\n  #endif\n  #if USE_TEXTURE\n    o *= texture(mainTexture, v_uv);\n  #endif\n  #if USE_ALPHA_TEST\n    if (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  o = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, o.rgb, factor_fog), o.a);\n  return CCFragOutput(o);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
                },
                "glsl1": {
                  "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n        return int(a_vertexId);\n    }\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_SUPPORT_FLOAT_TEXTURE\n        vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n            int pixelIndex = elementIndex;\n            vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n            vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n            return texture2D(tex, uv);\n        }\n#else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex * 4;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n        return vec4(\n            decode32(texture2D(tex, x)),\n            decode32(texture2D(tex, y)),\n            decode32(texture2D(tex, z)),\n            1.0\n        );\n    }\n#endif\nfloat getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n        return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n        return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n        return cc_displacementWeights[quot].z;\n    } else {\n        return cc_displacementWeights[quot].w;\n    }\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\n    vec3 result = vec3(0, 0, 0);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        int dataPixelStart = int(fetchVec3ArrayFromTexture(tex, iTarget).r);\n        result += (fetchVec3ArrayFromTexture(tex, dataPixelStart + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n  #if USE_INSTANCING\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  uniform highp vec4 cc_jointTextureInfo;\n  uniform highp vec4 cc_jointAnimInfo;\n  uniform highp sampler2D cc_jointTexture;\n  #else\n  uniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n  #if CC_SUPPORT_FLOAT_TEXTURE\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n      vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n      vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #else\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n      );\n      vec4 v2 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n      );\n      vec4 v3 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n      );\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n#else\n  mat4 getJointMatrix (float i) {\n    int idx = int(i);\n    vec4 v1 = cc_joints[idx * 3];\n    vec4 v2 = cc_joints[idx * 3 + 1];\n    vec4 v3 = cc_joints[idx * 3 + 2];\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n       + getJointMatrix(a_joints.y) * a_weights.y\n       + getJointMatrix(a_joints.z) * a_weights.z\n       + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\nuniform highp vec4 cc_cameraPos;\nuniform mediump vec4 cc_fogBase;\nuniform mediump vec4 cc_fogAdd;\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\n#endif\nfloat LinearFog(vec4 pos) {\n    vec4 wPos = pos;\n    float cam_dis = distance(cc_cameraPos, wPos);\n    float fogStart = cc_fogBase.x;\n    float fogEnd = cc_fogBase.y;\n    return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * fogDensity);\n    return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n    return f;\n}\nfloat LayeredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float _FogTop = cc_fogAdd.x;\n    float _FogRange = cc_fogAdd.y;\n    vec3 camWorldProj = cc_cameraPos.xyz;\n    camWorldProj.y = 0.;\n    vec3 worldPosProj = wPos.xyz;\n    worldPosProj.y = 0.;\n    float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n    float fDeltaY, fDensityIntegral;\n    if (cc_cameraPos.y > _FogTop) {\n        if (wPos.y < _FogTop) {\n            fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n            fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n        } else {\n            fDeltaY = 0.;\n            fDensityIntegral = 0.;\n        }\n    } else {\n        if (wPos.y < _FogTop) {\n            float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n            fDeltaY = abs(fDeltaA - fDeltaB);\n            fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n        } else {\n            fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n        }\n    }\n    float fDensity;\n    if (fDeltaY != 0.) {\n        fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n    } else {\n        fDensity = 0.;\n    }\n    float f = exp(-fDensity);\n    return f;\n}\nfloat CC_TRANSFER_FOG(vec4 pos) {\n    #if CC_USE_FOG == 1\n        return LinearFog(pos);\n\t#elif CC_USE_FOG == 2\n        return ExpFog(pos);\n    #elif CC_USE_FOG == 3\n        return ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 4\n        return LayeredFog(pos);\n    #endif\n    return 1.;\n}\n#if USE_VERTEX_COLOR\n  attribute lowp vec4 a_color;\n  varying lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\n  varying vec2 v_uv;\n  uniform vec4 tilingOffset;\n#endif\nvarying float factor_fog;\nvec4 vert () {\n  vec4 position;\n  position = vec4(a_position, 1.0);\n  #if CC_USE_MORPH\n    applyMorph(position);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(position);\n  #endif\n  mat4 matWorld;\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n  #if USE_TEXTURE\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  factor_fog = CC_TRANSFER_FOG(matWorld * position);\n  return cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }",
                  "frag": "\nprecision highp float;\nuniform mediump vec4 cc_exposure;\nuniform mediump vec4 cc_fogColor;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\n  varying vec2 v_uv;\n  uniform sampler2D mainTexture;\n#endif\nuniform vec4 mainColor;\nuniform vec4 colorScaleAndCutoff;\n#if USE_VERTEX_COLOR\n  varying lowp vec4 v_color;\n#endif\nvarying float factor_fog;\nvec4 frag () {\n  vec4 o = mainColor;\n  o.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_VERTEX_COLOR\n    o *= v_color;\n  #endif\n  #if USE_TEXTURE\n    o *= texture2D(mainTexture, v_uv);\n  #endif\n  #if USE_ALPHA_TEST\n    if (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  o = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, o.rgb, factor_fog), o.a);\n  return CCFragOutput(o);\n}\nvoid main() { gl_FragColor = frag(); }"
                },
                "glsl4": {
                  "vert": "\n#ifdef GL_EXT_shader_explicit_arithmetic_types_int16\n#extension GL_EXT_shader_explicit_arithmetic_types_int16: enable\n#endif\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n        return gl_VertexIndex;\n    }\nlayout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_SUPPORT_FLOAT_TEXTURE\n        vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n            ivec2 texSize = textureSize(tex, 0);\n            return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n        }\n#else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex * 4;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n        return vec4(\n            decode32(texture(tex, x)),\n            decode32(texture(tex, y)),\n            decode32(texture(tex, z)),\n            1.0\n        );\n    }\n#endif\nfloat getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n        return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n        return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n        return cc_displacementWeights[quot].z;\n    } else {\n        return cc_displacementWeights[quot].w;\n    }\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\n    vec3 result = vec3(0, 0, 0);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        int dataPixelStart = int(fetchVec3ArrayFromTexture(tex, iTarget).r);\n        result += (fetchVec3ArrayFromTexture(tex, dataPixelStart + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 6) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 7) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 8) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nlayout(location = 4) in u16vec4 a_joints;\nlayout(location = 5) in vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n  #if USE_INSTANCING\n    layout(location = 7) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(set = 2, binding = 3) uniform CCSkinningTexture {\n    highp vec4 cc_jointTextureInfo;\n  };\n  layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n    highp vec4 cc_jointAnimInfo;\n  };\n  layout(set = 2, binding = 5) uniform highp sampler2D cc_jointTexture;\n  #else\n  layout(set = 2, binding = 3) uniform CCSkinning {\n    highp vec4 cc_joints[30 * 3];\n  };\n#endif\n#if CC_USE_BAKED_ANIMATION\n  #if CC_SUPPORT_FLOAT_TEXTURE\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n      vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n      vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #else\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n      );\n      vec4 v2 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n      );\n      vec4 v3 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n      );\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n#else\n  mat4 getJointMatrix (float i) {\n    int idx = int(i);\n    vec4 v1 = cc_joints[idx * 3];\n    vec4 v2 = cc_joints[idx * 3 + 1];\n    vec4 v3 = cc_joints[idx * 3 + 2];\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n       + getJointMatrix(a_joints.y) * a_weights.y\n       + getJointMatrix(a_joints.z) * a_weights.z\n       + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\n  layout(location = 8) in vec4 a_matWorld0;\n  layout(location = 9) in vec4 a_matWorld1;\n  layout(location = 10) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 11) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\n#endif\nfloat LinearFog(vec4 pos) {\n    vec4 wPos = pos;\n    float cam_dis = distance(cc_cameraPos, wPos);\n    float fogStart = cc_fogBase.x;\n    float fogEnd = cc_fogBase.y;\n    return clamp((fogEnd - cam_dis) / (fogEnd - fogStart), 0., 1.);\n}\nfloat ExpFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * fogDensity);\n    return f;\n}\nfloat ExpSquaredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float fogDensity = cc_fogBase.z;\n    float cam_dis = distance(cc_cameraPos, wPos) / fogAtten * 4.;\n    float f = exp(-cam_dis * cam_dis * fogDensity * fogDensity);\n    return f;\n}\nfloat LayeredFog(vec4 pos) {\n    vec4 wPos = pos;\n    float fogAtten = cc_fogAdd.z;\n    float _FogTop = cc_fogAdd.x;\n    float _FogRange = cc_fogAdd.y;\n    vec3 camWorldProj = cc_cameraPos.xyz;\n    camWorldProj.y = 0.;\n    vec3 worldPosProj = wPos.xyz;\n    worldPosProj.y = 0.;\n    float fDeltaD = distance(worldPosProj, camWorldProj) / fogAtten * 2.0;\n    float fDeltaY, fDensityIntegral;\n    if (cc_cameraPos.y > _FogTop) {\n        if (wPos.y < _FogTop) {\n            fDeltaY = (_FogTop - wPos.y) / _FogRange * 2.0;\n            fDensityIntegral = fDeltaY * fDeltaY * 0.5;\n        } else {\n            fDeltaY = 0.;\n            fDensityIntegral = 0.;\n        }\n    } else {\n        if (wPos.y < _FogTop) {\n            float fDeltaA = (_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            float fDeltaB = (_FogTop - wPos.y) / _FogRange * 2.;\n            fDeltaY = abs(fDeltaA - fDeltaB);\n            fDensityIntegral = abs((fDeltaA * fDeltaA * 0.5) - (fDeltaB * fDeltaB * 0.5));\n        } else {\n            fDeltaY = abs(_FogTop - cc_cameraPos.y) / _FogRange * 2.;\n            fDensityIntegral = abs(fDeltaY * fDeltaY * 0.5);\n        }\n    }\n    float fDensity;\n    if (fDeltaY != 0.) {\n        fDensity = (sqrt(1.0 + ((fDeltaD / fDeltaY) * (fDeltaD / fDeltaY)))) * fDensityIntegral;\n    } else {\n        fDensity = 0.;\n    }\n    float f = exp(-fDensity);\n    return f;\n}\nfloat CC_TRANSFER_FOG(vec4 pos) {\n    #if CC_USE_FOG == 1\n        return LinearFog(pos);\n\t#elif CC_USE_FOG == 2\n        return ExpFog(pos);\n    #elif CC_USE_FOG == 3\n        return ExpSquaredFog(pos);\n    #elif CC_USE_FOG == 4\n        return LayeredFog(pos);\n    #endif\n    return 1.;\n}\n#if USE_VERTEX_COLOR\n  layout(location = 13) in lowp vec4 a_color;\n  layout(location = 0) out lowp vec4 v_color;\n#endif\n#if USE_TEXTURE\n  layout(location = 1) out vec2 v_uv;\n  layout(set = 1, binding = 0) uniform TexCoords {\n    vec4 tilingOffset;\n  };\n#endif\nlayout(location = 2) out float factor_fog;\nvec4 vert () {\n  vec4 position;\n  position = vec4(a_position, 1.0);\n  #if CC_USE_MORPH\n    applyMorph(position);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(position);\n  #endif\n  mat4 matWorld;\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n  #if USE_TEXTURE\n    v_uv = a_texCoord * tilingOffset.xy + tilingOffset.zw;\n  #endif\n  #if USE_VERTEX_COLOR\n    v_color = a_color;\n  #endif\n  factor_fog = CC_TRANSFER_FOG(matWorld * position);\n  return cc_matProj * (cc_matView * matWorld) * position;\n}\nvoid main() { gl_Position = vert(); }",
                  "frag": "\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\n#if USE_ALPHA_TEST\n#endif\n#if USE_TEXTURE\n  layout(location = 1) in vec2 v_uv;\n  layout(set = 1, binding = 2) uniform sampler2D mainTexture;\n#endif\nlayout(set = 1, binding = 1) uniform Constant {\n  vec4 mainColor;\n  vec4 colorScaleAndCutoff;\n};\n#if USE_VERTEX_COLOR\n  layout(location = 0) in lowp vec4 v_color;\n#endif\nlayout(location = 2) in float factor_fog;\nvec4 frag () {\n  vec4 o = mainColor;\n  o.rgb *= colorScaleAndCutoff.xyz;\n  #if USE_VERTEX_COLOR\n    o *= v_color;\n  #endif\n  #if USE_TEXTURE\n    o *= texture(mainTexture, v_uv);\n  #endif\n  #if USE_ALPHA_TEST\n    if (o.ALPHA_TEST_CHANNEL < colorScaleAndCutoff.w) discard;\n  #endif\n  o = vec4(mix(CC_FORWARD_ADD > 0 ? vec3(0.0) : cc_fogColor.rgb, o.rgb, factor_fog), o.a);\n  return CCFragOutput(o);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
                },
                "builtins": {
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }],
                    "samplers": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCMorph",
                      "defines": ["CC_USE_MORPH"]
                    }, {
                      "name": "CCSkinningTexture",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCSkinningAnimation",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCSkinning",
                      "defines": ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCLocalBatched",
                      "defines": ["!USE_INSTANCING", "USE_BATCHING"]
                    }, {
                      "name": "CCLocal",
                      "defines": ["!USE_INSTANCING", "!USE_BATCHING"]
                    }],
                    "samplers": [{
                      "name": "cc_PositionDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
                    }, {
                      "name": "cc_NormalDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
                    }, {
                      "name": "cc_TangentDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
                    }, {
                      "name": "cc_jointTexture",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }]
                  }
                },
                "defines": [{
                  "name": "CC_USE_MORPH",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_COUNT",
                  "type": "number",
                  "range": [2, 8]
                }, {
                  "name": "CC_SUPPORT_FLOAT_TEXTURE",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_PRECOMPUTED",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_POSITION",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_NORMAL",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_TANGENT",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_SKINNING",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_BAKED_ANIMATION",
                  "type": "boolean"
                }, {
                  "name": "USE_INSTANCING",
                  "type": "boolean"
                }, {
                  "name": "USE_BATCHING",
                  "type": "boolean"
                }, {
                  "name": "USE_LIGHTMAP",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_FOG",
                  "type": "number",
                  "range": [0, 4]
                }, {
                  "name": "CC_FORWARD_ADD",
                  "type": "boolean"
                }, {
                  "name": "USE_VERTEX_COLOR",
                  "type": "boolean"
                }, {
                  "name": "USE_TEXTURE",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_HDR",
                  "type": "boolean"
                }, {
                  "name": "USE_ALPHA_TEST",
                  "type": "boolean"
                }, {
                  "name": "ALPHA_TEST_CHANNEL",
                  "type": "string",
                  "options": ["a", "r", "g", "b"]
                }],
                "blocks": [{
                  "name": "TexCoords",
                  "defines": ["USE_TEXTURE"],
                  "binding": 0,
                  "stageFlags": 1,
                  "members": [{
                    "name": "tilingOffset",
                    "type": 16,
                    "count": 1
                  }]
                }, {
                  "name": "Constant",
                  "defines": [],
                  "binding": 1,
                  "stageFlags": 16,
                  "members": [{
                    "name": "mainColor",
                    "type": 16,
                    "count": 1
                  }, {
                    "name": "colorScaleAndCutoff",
                    "type": 16,
                    "count": 1
                  }]
                }],
                "samplers": [{
                  "name": "mainTexture",
                  "type": 28,
                  "count": 1,
                  "defines": ["USE_TEXTURE"],
                  "stageFlags": 16,
                  "binding": 2
                }],
                "attributes": [{
                  "name": "a_position",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_normal",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 1
                }, {
                  "name": "a_texCoord",
                  "type": 14,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 21,
                  "location": 2
                }, {
                  "name": "a_tangent",
                  "type": 16,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 3
                }, {
                  "name": "a_vertexId",
                  "type": 13,
                  "count": 1,
                  "defines": ["CC_USE_MORPH"],
                  "stageFlags": 1,
                  "format": 11,
                  "location": 6
                }, {
                  "name": "a_joints",
                  "type": 12,
                  "count": 1,
                  "defines": ["CC_USE_SKINNING"],
                  "stageFlags": 1,
                  "format": 42,
                  "location": 4
                }, {
                  "name": "a_weights",
                  "type": 16,
                  "count": 1,
                  "defines": ["CC_USE_SKINNING"],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 5
                }, {
                  "name": "a_jointAnimInfo",
                  "type": 16,
                  "count": 1,
                  "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION", "USE_INSTANCING"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 7
                }, {
                  "name": "a_matWorld0",
                  "type": 16,
                  "count": 1,
                  "defines": ["USE_INSTANCING"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 8
                }, {
                  "name": "a_matWorld1",
                  "type": 16,
                  "count": 1,
                  "defines": ["USE_INSTANCING"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 9
                }, {
                  "name": "a_matWorld2",
                  "type": 16,
                  "count": 1,
                  "defines": ["USE_INSTANCING"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 10
                }, {
                  "name": "a_lightingMapUVParam",
                  "type": 16,
                  "count": 1,
                  "defines": ["USE_INSTANCING", "USE_LIGHTMAP"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 11
                }, {
                  "name": "a_dyn_batch_id",
                  "type": 13,
                  "count": 1,
                  "defines": ["!USE_INSTANCING", "USE_BATCHING"],
                  "stageFlags": 1,
                  "format": 11,
                  "location": 12
                }, {
                  "name": "a_color",
                  "type": 16,
                  "count": 1,
                  "defines": ["USE_VERTEX_COLOR"],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 13
                }]
              }]
            }, {
              "name": "pipeline/planar-shadow",
              "_uuid": "9361fd90-ba52-4f84-aa93-6e878fd576ca",
              "techniques": [{
                "passes": [{
                  "phase": "planarShadow",
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 2,
                      "blendDst": 4,
                      "blendDstAlpha": 4
                    }]
                  },
                  "program": "pipeline/planar-shadow|planar-shadow-vs:vert|planar-shadow-fs:frag",
                  "depthStencilState": {
                    "depthTest": true,
                    "depthWrite": false,
                    "stencilTestFront": true,
                    "stencilFuncFront": 5,
                    "stencilPassOpFront": 2,
                    "stencilRefBack": 128,
                    "stencilRefFront": 128,
                    "stencilReadMaskBack": 128,
                    "stencilReadMaskFront": 128,
                    "stencilWriteMaskBack": 128,
                    "stencilWriteMaskFront": 128
                  }
                }]
              }],
              "shaders": [{
                "name": "pipeline/planar-shadow|planar-shadow-vs:vert|planar-shadow-fs:frag",
                "hash": 2804795238,
                "glsl3": {
                  "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\n#if CC_USE_MORPH\n    in float a_vertexId;\n    int getVertexId() {\n        return int(a_vertexId);\n    }\nlayout(std140) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_SUPPORT_FLOAT_TEXTURE\n        vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n            ivec2 texSize = textureSize(tex, 0);\n            return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n        }\n#else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex * 4;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n        return vec4(\n            decode32(texture(tex, x)),\n            decode32(texture(tex, y)),\n            decode32(texture(tex, z)),\n            1.0\n        );\n    }\n#endif\nfloat getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n        return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n        return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n        return cc_displacementWeights[quot].z;\n    } else {\n        return cc_displacementWeights[quot].w;\n    }\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\n    vec3 result = vec3(0, 0, 0);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        int dataPixelStart = int(fetchVec3ArrayFromTexture(tex, iTarget).r);\n        result += (fetchVec3ArrayFromTexture(tex, dataPixelStart + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nin vec4 a_joints;\nin vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n  #if USE_INSTANCING\n    in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(std140) uniform CCSkinningTexture {\n    highp vec4 cc_jointTextureInfo;\n  };\n  layout(std140) uniform CCSkinningAnimation {\n    highp vec4 cc_jointAnimInfo;\n  };\n  uniform highp sampler2D cc_jointTexture;\n  #else\n  layout(std140) uniform CCSkinning {\n    highp vec4 cc_joints[30 * 3];\n  };\n#endif\n#if CC_USE_BAKED_ANIMATION\n  #if CC_SUPPORT_FLOAT_TEXTURE\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n      vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n      vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #else\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n      );\n      vec4 v2 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n      );\n      vec4 v3 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n      );\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n#else\n  mat4 getJointMatrix (float i) {\n    int idx = int(i);\n    vec4 v1 = cc_joints[idx * 3];\n    vec4 v2 = cc_joints[idx * 3 + 1];\n    vec4 v3 = cc_joints[idx * 3 + 2];\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n       + getJointMatrix(a_joints.y) * a_weights.y\n       + getJointMatrix(a_joints.z) * a_weights.z\n       + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\n  in vec4 a_matWorld0;\n  in vec4 a_matWorld1;\n  in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  in float a_dyn_batch_id;\n  layout(std140) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\nlayout(std140) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\n#endif\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightViewProj;\n  lowp vec4 cc_shadowColor;\n  lowp vec4 cc_shadowPCF;\n  lowp vec4 cc_shadowSize;\n};\nvec4 vert () {\n  vec4 position;\n  position = vec4(a_position, 1.0);\n  #if CC_USE_MORPH\n    applyMorph(position);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(position);\n  #endif\n  mat4 matWorld;\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n  position = cc_matProj * (cc_matView * cc_matLightPlaneProj * matWorld) * position;\n  position.z -= 0.0001;\n  return position;\n}\nvoid main() { gl_Position = vert(); }",
                  "frag": "\nprecision mediump float;\nlayout(std140) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightViewProj;\n  lowp vec4 cc_shadowColor;\n  lowp vec4 cc_shadowPCF;\n  lowp vec4 cc_shadowSize;\n};\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvec4 frag () {\n  return CCFragOutput(cc_shadowColor);\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
                },
                "glsl1": {
                  "vert": "\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\n#if CC_USE_MORPH\n    attribute float a_vertexId;\n    int getVertexId() {\n        return int(a_vertexId);\n    }\nuniform vec4 cc_displacementWeights[15];\nuniform vec4 cc_displacementTextureInfo;\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_SUPPORT_FLOAT_TEXTURE\n        vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n            int pixelIndex = elementIndex;\n            vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n            vec2 uv = getPixelCoordFromLocation(location, cc_displacementTextureInfo.xy);\n            return texture2D(tex, uv);\n        }\n#else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex * 4;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n        return vec4(\n            decode32(texture2D(tex, x)),\n            decode32(texture2D(tex, y)),\n            decode32(texture2D(tex, z)),\n            1.0\n        );\n    }\n#endif\nfloat getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n        return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n        return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n        return cc_displacementWeights[quot].z;\n    } else {\n        return cc_displacementWeights[quot].w;\n    }\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\n    vec3 result = vec3(0, 0, 0);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        int dataPixelStart = int(fetchVec3ArrayFromTexture(tex, iTarget).r);\n        result += (fetchVec3ArrayFromTexture(tex, dataPixelStart + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\n    uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nattribute vec4 a_joints;\nattribute vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n  #if USE_INSTANCING\n    attribute highp vec4 a_jointAnimInfo;\n  #endif\n  uniform highp vec4 cc_jointTextureInfo;\n  uniform highp vec4 cc_jointAnimInfo;\n  uniform highp sampler2D cc_jointTexture;\n  #else\n  uniform highp vec4 cc_joints[90];\n#endif\n#if CC_USE_BAKED_ANIMATION\n  #if CC_SUPPORT_FLOAT_TEXTURE\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n      vec4 v2 = texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n      vec4 v3 = texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #else\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n      );\n      vec4 v2 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n      );\n      vec4 v3 = vec4(\n        decode32(texture2D(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n        decode32(texture2D(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n      );\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n#else\n  mat4 getJointMatrix (float i) {\n    int idx = int(i);\n    vec4 v1 = cc_joints[idx * 3];\n    vec4 v2 = cc_joints[idx * 3 + 1];\n    vec4 v3 = cc_joints[idx * 3 + 2];\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n       + getJointMatrix(a_joints.y) * a_weights.y\n       + getJointMatrix(a_joints.z) * a_weights.z\n       + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\n#if USE_INSTANCING\n  attribute vec4 a_matWorld0;\n  attribute vec4 a_matWorld1;\n  attribute vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    attribute vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  attribute float a_dyn_batch_id;\n  uniform highp mat4 cc_matWorlds[10];\n#else\nuniform highp mat4 cc_matWorld;\n#endif\nuniform highp mat4 cc_matLightPlaneProj;\nvec4 vert () {\n  vec4 position;\n  position = vec4(a_position, 1.0);\n  #if CC_USE_MORPH\n    applyMorph(position);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(position);\n  #endif\n  mat4 matWorld;\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n  position = cc_matProj * (cc_matView * cc_matLightPlaneProj * matWorld) * position;\n  position.z -= 0.0001;\n  return position;\n}\nvoid main() { gl_Position = vert(); }",
                  "frag": "\nprecision mediump float;\nuniform lowp vec4 cc_shadowColor;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvec4 frag () {\n  return CCFragOutput(cc_shadowColor);\n}\nvoid main() { gl_FragColor = frag(); }"
                },
                "glsl4": {
                  "vert": "\n#ifdef GL_EXT_shader_explicit_arithmetic_types_int16\n#extension GL_EXT_shader_explicit_arithmetic_types_int16: enable\n#endif\nprecision highp float;\nhighp float decode32 (highp vec4 rgba) {\n  rgba = rgba * 255.0;\n  highp float Sign = 1.0 - (step(128.0, (rgba[3]) + 0.5)) * 2.0;\n  highp float Exponent = 2.0 * (mod(float(int((rgba[3]) + 0.5)), 128.0)) + (step(128.0, (rgba[2]) + 0.5)) - 127.0;\n  highp float Mantissa = (mod(float(int((rgba[2]) + 0.5)), 128.0)) * 65536.0 + rgba[1] * 256.0 + rgba[0] + 8388608.0;\n  return Sign * exp2(Exponent - 23.0) * Mantissa;\n}\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\n#if CC_USE_MORPH\n    int getVertexId() {\n        return gl_VertexIndex;\n    }\nlayout(set = 2, binding = 4) uniform CCMorph {\n    vec4 cc_displacementWeights[15];\n    vec4 cc_displacementTextureInfo;\n};\nvec2 getPixelLocation(vec2 textureResolution, int pixelIndex) {\n    float pixelIndexF = float(pixelIndex);\n    float x = mod(pixelIndexF, textureResolution.x);\n    float y = floor(pixelIndexF / textureResolution.x);\n    return vec2(x, y);\n}\nvec2 getPixelCoordFromLocation(vec2 location, vec2 textureResolution) {\n    return (vec2(location.x, location.y) + .5) / textureResolution;\n}\n#if CC_SUPPORT_FLOAT_TEXTURE\n        vec4 fetchVec3ArrayFromTexture(sampler2D tex, int pixelIndex) {\n            ivec2 texSize = textureSize(tex, 0);\n            return texelFetch(tex, ivec2(pixelIndex % texSize.x, pixelIndex / texSize.x), 0);\n        }\n#else\n    vec4 fetchVec3ArrayFromTexture(sampler2D tex, int elementIndex) {\n        int pixelIndex = elementIndex * 4;\n        vec2 location = getPixelLocation(cc_displacementTextureInfo.xy, pixelIndex);\n        vec2 x = getPixelCoordFromLocation(location + vec2(0.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 y = getPixelCoordFromLocation(location + vec2(1.0, 0.0), cc_displacementTextureInfo.xy);\n        vec2 z = getPixelCoordFromLocation(location + vec2(2.0, 0.0), cc_displacementTextureInfo.xy);\n        return vec4(\n            decode32(texture(tex, x)),\n            decode32(texture(tex, y)),\n            decode32(texture(tex, z)),\n            1.0\n        );\n    }\n#endif\nfloat getDisplacementWeight(int index) {\n    int quot = index / 4;\n    int remainder = index - quot * 4;\n    if (remainder == 0) {\n        return cc_displacementWeights[quot].x;\n    } else if (remainder == 1) {\n        return cc_displacementWeights[quot].y;\n    } else if (remainder == 2) {\n        return cc_displacementWeights[quot].z;\n    } else {\n        return cc_displacementWeights[quot].w;\n    }\n}\nvec3 getVec3DisplacementFromTexture(sampler2D tex, int vertexIndex) {\n#if CC_MORPH_PRECOMPUTED\n    return fetchVec3ArrayFromTexture(tex, vertexIndex).rgb;\n#else\n    vec3 result = vec3(0, 0, 0);\n    for (int iTarget = 0; iTarget < CC_MORPH_TARGET_COUNT; ++iTarget) {\n        int dataPixelStart = int(fetchVec3ArrayFromTexture(tex, iTarget).r);\n        result += (fetchVec3ArrayFromTexture(tex, dataPixelStart + vertexIndex).rgb * getDisplacementWeight(iTarget));\n    }\n    return result;\n#endif\n}\n#if CC_MORPH_TARGET_HAS_POSITION\n    layout(set = 2, binding = 6) uniform sampler2D cc_PositionDisplacements;\n    vec3 getPositionDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_PositionDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    layout(set = 2, binding = 7) uniform sampler2D cc_NormalDisplacements;\n    vec3 getNormalDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_NormalDisplacements, vertexId);\n    }\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    layout(set = 2, binding = 8) uniform sampler2D cc_TangentDisplacements;\n    vec3 getTangentDisplacement(int vertexId) {\n        return getVec3DisplacementFromTexture(cc_TangentDisplacements, vertexId);\n    }\n#endif\nvoid applyMorph (inout StandardVertInput attr) {\n    int vertexId = getVertexId();\n#if CC_MORPH_TARGET_HAS_POSITION\n    attr.position.xyz = attr.position.xyz + getPositionDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_NORMAL\n    attr.normal.xyz = attr.normal.xyz + getNormalDisplacement(vertexId);\n#endif\n#if CC_MORPH_TARGET_HAS_TANGENT\n    attr.tangent.xyz = attr.tangent.xyz + getTangentDisplacement(vertexId);\n#endif\n}\nvoid applyMorph (inout vec4 position) {\n#if CC_MORPH_TARGET_HAS_POSITION\n    position.xyz = position.xyz + getPositionDisplacement(getVertexId());\n#endif\n}\n#endif\n#if CC_USE_SKINNING\nlayout(location = 4) in u16vec4 a_joints;\nlayout(location = 5) in vec4 a_weights;\n#if CC_USE_BAKED_ANIMATION\n  #if USE_INSTANCING\n    layout(location = 7) in highp vec4 a_jointAnimInfo;\n  #endif\n  layout(set = 2, binding = 3) uniform CCSkinningTexture {\n    highp vec4 cc_jointTextureInfo;\n  };\n  layout(set = 2, binding = 2) uniform CCSkinningAnimation {\n    highp vec4 cc_jointAnimInfo;\n  };\n  layout(set = 2, binding = 5) uniform highp sampler2D cc_jointTexture;\n  #else\n  layout(set = 2, binding = 3) uniform CCSkinning {\n    highp vec4 cc_joints[30 * 3];\n  };\n#endif\n#if CC_USE_BAKED_ANIMATION\n  #if CC_SUPPORT_FLOAT_TEXTURE\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 3.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 3.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = texture(cc_jointTexture, vec2((x + 0.5) * invSize, y));\n      vec4 v2 = texture(cc_jointTexture, vec2((x + 1.5) * invSize, y));\n      vec4 v3 = texture(cc_jointTexture, vec2((x + 2.5) * invSize, y));\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #else\n    mat4 getJointMatrix (float i) {\n    #if USE_INSTANCING\n      highp float j = 12.0 * (a_jointAnimInfo.x * a_jointAnimInfo.y + i) + a_jointAnimInfo.z;\n    #else\n      highp float j = 12.0 * (cc_jointAnimInfo.x * cc_jointTextureInfo.y + i) + cc_jointTextureInfo.z;\n    #endif\n    highp float invSize = cc_jointTextureInfo.w;\n    highp float y = floor(j * invSize);\n    highp float x = j - y * cc_jointTextureInfo.x;\n    y = (y + 0.5) * invSize;\n      vec4 v1 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 0.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 1.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 2.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 3.5) * invSize, y)))\n      );\n      vec4 v2 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 4.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 5.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 6.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 7.5) * invSize, y)))\n      );\n      vec4 v3 = vec4(\n        decode32(texture(cc_jointTexture, vec2((x + 8.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 9.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 10.5) * invSize, y))),\n        decode32(texture(cc_jointTexture, vec2((x + 11.5) * invSize, y)))\n      );\n      return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n    }\n  #endif\n#else\n  mat4 getJointMatrix (float i) {\n    int idx = int(i);\n    vec4 v1 = cc_joints[idx * 3];\n    vec4 v2 = cc_joints[idx * 3 + 1];\n    vec4 v3 = cc_joints[idx * 3 + 2];\n    return mat4(vec4(v1.xyz, 0.0), vec4(v2.xyz, 0.0), vec4(v3.xyz, 0.0), vec4(v1.w, v2.w, v3.w, 1.0));\n  }\n#endif\nmat4 skinMatrix () {\n  return getJointMatrix(a_joints.x) * a_weights.x\n       + getJointMatrix(a_joints.y) * a_weights.y\n       + getJointMatrix(a_joints.z) * a_weights.z\n       + getJointMatrix(a_joints.w) * a_weights.w;\n}\nvoid CCSkin (inout vec4 position) {\n  mat4 m = skinMatrix();\n  position = m * position;\n}\nvoid CCSkin (inout StandardVertInput attr) {\n  mat4 m = skinMatrix();\n  attr.position = m * attr.position;\n  attr.normal = (m * vec4(attr.normal, 0.0)).xyz;\n  attr.tangent.xyz = (m * vec4(attr.tangent.xyz, 0.0)).xyz;\n}\n#endif\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\n#if USE_INSTANCING\n  layout(location = 8) in vec4 a_matWorld0;\n  layout(location = 9) in vec4 a_matWorld1;\n  layout(location = 10) in vec4 a_matWorld2;\n  #if USE_LIGHTMAP\n    layout(location = 11) in vec4 a_lightingMapUVParam;\n  #endif\n#elif USE_BATCHING\n  layout(location = 12) in float a_dyn_batch_id;\n  layout(set = 2, binding = 0) uniform CCLocalBatched {\n    highp mat4 cc_matWorlds[10];\n  };\n#else\nlayout(set = 2, binding = 0) uniform CCLocal {\n  highp mat4 cc_matWorld;\n  highp mat4 cc_matWorldIT;\n  highp vec4 cc_lightingMapUVParam;\n};\n#endif\nlayout(set = 0, binding = 1) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightViewProj;\n  lowp vec4 cc_shadowColor;\n  lowp vec4 cc_shadowPCF;\n  lowp vec4 cc_shadowSize;\n};\nvec4 vert () {\n  vec4 position;\n  position = vec4(a_position, 1.0);\n  #if CC_USE_MORPH\n    applyMorph(position);\n  #endif\n  #if CC_USE_SKINNING\n    CCSkin(position);\n  #endif\n  mat4 matWorld;\n  #if USE_INSTANCING\n    matWorld = mat4(\n      vec4(a_matWorld0.xyz, 0.0),\n      vec4(a_matWorld1.xyz, 0.0),\n      vec4(a_matWorld2.xyz, 0.0),\n      vec4(a_matWorld0.w, a_matWorld1.w, a_matWorld2.w, 1.0)\n    );\n  #elif USE_BATCHING\n    matWorld = cc_matWorlds[int(a_dyn_batch_id)];\n  #else\n    matWorld = cc_matWorld;\n  #endif\n  position = cc_matProj * (cc_matView * cc_matLightPlaneProj * matWorld) * position;\n  position.z -= 0.0001;\n  return position;\n}\nvoid main() { gl_Position = vert(); }",
                  "frag": "\nprecision mediump float;\nlayout(set = 0, binding = 1) uniform CCShadow {\n  highp mat4 cc_matLightPlaneProj;\n  highp mat4 cc_matLightViewProj;\n  lowp vec4 cc_shadowColor;\n  lowp vec4 cc_shadowPCF;\n  lowp vec4 cc_shadowSize;\n};\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvec4 frag () {\n  return CCFragOutput(cc_shadowColor);\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
                },
                "builtins": {
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }, {
                      "name": "CCShadow",
                      "defines": []
                    }],
                    "samplers": []
                  },
                  "locals": {
                    "blocks": [{
                      "name": "CCMorph",
                      "defines": ["CC_USE_MORPH"]
                    }, {
                      "name": "CCSkinningTexture",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCSkinningAnimation",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCSkinning",
                      "defines": ["CC_USE_SKINNING", "!CC_USE_BAKED_ANIMATION"]
                    }, {
                      "name": "CCLocalBatched",
                      "defines": ["!USE_INSTANCING", "USE_BATCHING"]
                    }, {
                      "name": "CCLocal",
                      "defines": ["!USE_INSTANCING", "!USE_BATCHING"]
                    }],
                    "samplers": [{
                      "name": "cc_PositionDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_POSITION"]
                    }, {
                      "name": "cc_NormalDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_NORMAL"]
                    }, {
                      "name": "cc_TangentDisplacements",
                      "defines": ["CC_USE_MORPH", "CC_MORPH_TARGET_HAS_TANGENT"]
                    }, {
                      "name": "cc_jointTexture",
                      "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION"]
                    }]
                  }
                },
                "defines": [{
                  "name": "CC_USE_MORPH",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_COUNT",
                  "type": "number",
                  "range": [2, 8]
                }, {
                  "name": "CC_SUPPORT_FLOAT_TEXTURE",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_PRECOMPUTED",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_POSITION",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_NORMAL",
                  "type": "boolean"
                }, {
                  "name": "CC_MORPH_TARGET_HAS_TANGENT",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_SKINNING",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_BAKED_ANIMATION",
                  "type": "boolean"
                }, {
                  "name": "USE_INSTANCING",
                  "type": "boolean"
                }, {
                  "name": "USE_BATCHING",
                  "type": "boolean"
                }, {
                  "name": "USE_LIGHTMAP",
                  "type": "boolean"
                }, {
                  "name": "CC_USE_HDR",
                  "type": "boolean"
                }],
                "blocks": [],
                "samplers": [],
                "attributes": [{
                  "name": "a_position",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_normal",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 1
                }, {
                  "name": "a_texCoord",
                  "type": 14,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 21,
                  "location": 2
                }, {
                  "name": "a_tangent",
                  "type": 16,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 3
                }, {
                  "name": "a_vertexId",
                  "type": 13,
                  "count": 1,
                  "defines": ["CC_USE_MORPH"],
                  "stageFlags": 1,
                  "format": 11,
                  "location": 6
                }, {
                  "name": "a_joints",
                  "type": 12,
                  "count": 1,
                  "defines": ["CC_USE_SKINNING"],
                  "stageFlags": 1,
                  "format": 42,
                  "location": 4
                }, {
                  "name": "a_weights",
                  "type": 16,
                  "count": 1,
                  "defines": ["CC_USE_SKINNING"],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 5
                }, {
                  "name": "a_jointAnimInfo",
                  "type": 16,
                  "count": 1,
                  "defines": ["CC_USE_SKINNING", "CC_USE_BAKED_ANIMATION", "USE_INSTANCING"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 7
                }, {
                  "name": "a_matWorld0",
                  "type": 16,
                  "count": 1,
                  "defines": ["USE_INSTANCING"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 8
                }, {
                  "name": "a_matWorld1",
                  "type": 16,
                  "count": 1,
                  "defines": ["USE_INSTANCING"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 9
                }, {
                  "name": "a_matWorld2",
                  "type": 16,
                  "count": 1,
                  "defines": ["USE_INSTANCING"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 10
                }, {
                  "name": "a_lightingMapUVParam",
                  "type": 16,
                  "count": 1,
                  "defines": ["USE_INSTANCING", "USE_LIGHTMAP"],
                  "stageFlags": 1,
                  "format": 44,
                  "isInstanced": true,
                  "location": 11
                }, {
                  "name": "a_dyn_batch_id",
                  "type": 13,
                  "count": 1,
                  "defines": ["!USE_INSTANCING", "USE_BATCHING"],
                  "stageFlags": 1,
                  "format": 11,
                  "location": 12
                }]
              }]
            }, {
              "name": "pipeline/skybox",
              "_uuid": "511d2633-09a7-4bdd-ac42-f778032124b3",
              "techniques": [{
                "passes": [{
                  "rasterizerState": {
                    "cullMode": 0
                  },
                  "program": "pipeline/skybox|sky-vs:vert|sky-fs:frag",
                  "priority": 245,
                  "depthStencilState": {
                    "depthTest": true,
                    "depthWrite": false
                  }
                }]
              }],
              "shaders": [{
                "name": "pipeline/skybox|sky-vs:vert|sky-fs:frag",
                "hash": 629379420,
                "glsl3": {
                  "vert": "\nprecision highp float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nin vec3 a_position;\nin vec3 a_normal;\nin vec2 a_texCoord;\nin vec4 a_tangent;\nout mediump vec4 viewDir;\nvec4 vert () {\n  viewDir = vec4(a_position, 1.0);\n  mat4 matViewRotOnly = mat4(mat3(cc_matView));\n  vec4 pos = matViewRotOnly * viewDir;\n  vec2 f = cc_matProj[3][3] > 0.0 ? vec2(4.8, 2.4) : vec2(cc_matProj[1][1]);\n  pos.xy *= vec2(cc_matProj[0][0] / cc_matProj[1][1] * cc_cameraPos.w, 1.0) * f;\n  pos.zw = vec2(-0.99999 * pos.z, -pos.z);\n  return pos;\n}\nvoid main() { gl_Position = vert(); }",
                  "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nin mediump vec4 viewDir;\nvec4 frag () {\n  #if USE_RGBE_CUBEMAP\n    vec3 c = unpackRGBE(texture(cc_environment, viewDir.xyz));\n  #else\n    vec3 c = SRGBToLinear(texture(cc_environment, viewDir.xyz).rgb);\n  #endif\n  return CCFragOutput(vec4(c * cc_ambientSky.w, 1.0));\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
                },
                "glsl1": {
                  "vert": "\nprecision highp float;\nuniform highp mat4 cc_matView;\nuniform highp mat4 cc_matProj;\nuniform highp vec4 cc_cameraPos;\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nattribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec2 a_texCoord;\nattribute vec4 a_tangent;\nvarying mediump vec4 viewDir;\nvec4 vert () {\n  viewDir = vec4(a_position, 1.0);\n  mat4 matViewRotOnly = mat4(mat3(cc_matView));\n  vec4 pos = matViewRotOnly * viewDir;\n  vec2 f = cc_matProj[3][3] > 0.0 ? vec2(4.8, 2.4) : vec2(cc_matProj[1][1]);\n  pos.xy *= vec2(cc_matProj[0][0] / cc_matProj[1][1] * cc_cameraPos.w, 1.0) * f;\n  pos.zw = vec2(-0.99999 * pos.z, -pos.z);\n  return pos;\n}\nvoid main() { gl_Position = vert(); }",
                  "frag": "\nprecision mediump float;\nuniform mediump vec4 cc_ambientSky;\nuniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nvarying mediump vec4 viewDir;\nvec4 frag () {\n  #if USE_RGBE_CUBEMAP\n    vec3 c = unpackRGBE(textureCube(cc_environment, viewDir.xyz));\n  #else\n    vec3 c = SRGBToLinear(textureCube(cc_environment, viewDir.xyz).rgb);\n  #endif\n  return CCFragOutput(vec4(c * cc_ambientSky.w, 1.0));\n}\nvoid main() { gl_FragColor = frag(); }"
                },
                "glsl4": {
                  "vert": "\nprecision highp float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nstruct StandardVertInput {\n  highp vec4 position;\n  vec3 normal;\n  vec4 tangent;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec3 a_normal;\nlayout(location = 2) in vec2 a_texCoord;\nlayout(location = 3) in vec4 a_tangent;\nlayout(location = 0) out mediump vec4 viewDir;\nvec4 vert () {\n  viewDir = vec4(a_position, 1.0);\n  mat4 matViewRotOnly = mat4(mat3(cc_matView));\n  vec4 pos = matViewRotOnly * viewDir;\n  vec2 f = cc_matProj[3][3] > 0.0 ? vec2(4.8, 2.4) : vec2(cc_matProj[1][1]);\n  pos.xy *= vec2(cc_matProj[0][0] / cc_matProj[1][1] * cc_cameraPos.w, 1.0) * f;\n  pos.zw = vec2(-0.99999 * pos.z, -pos.z);\n  return pos;\n}\nvoid main() { gl_Position = vert(); }",
                  "frag": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(set = 0, binding = 3) uniform samplerCube cc_environment;\nvec3 unpackRGBE (vec4 rgbe) {\n  return rgbe.rgb * pow(2.0, rgbe.a * 255.0 - 128.0);\n}\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec3 ACESToneMap (vec3 color) {\n  color = min(color, vec3(8.0));\n  const float A = 2.51;\n  const float B = 0.03;\n  const float C = 2.43;\n  const float D = 0.59;\n  const float E = 0.14;\n  return (color * (A * color + B)) / (color * (C * color + D) + E);\n}\nvec4 CCFragOutput (vec4 color) {\n  #if !CC_USE_HDR\n    color.rgb = sqrt(ACESToneMap(color.rgb));\n  #endif\n  return color;\n}\nlayout(location = 0) in mediump vec4 viewDir;\nvec4 frag () {\n  #if USE_RGBE_CUBEMAP\n    vec3 c = unpackRGBE(texture(cc_environment, viewDir.xyz));\n  #else\n    vec3 c = SRGBToLinear(texture(cc_environment, viewDir.xyz).rgb);\n  #endif\n  return CCFragOutput(vec4(c * cc_ambientSky.w, 1.0));\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
                },
                "builtins": {
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }],
                    "samplers": [{
                      "name": "cc_environment",
                      "defines": []
                    }]
                  },
                  "locals": {
                    "blocks": [],
                    "samplers": []
                  }
                },
                "defines": [{
                  "name": "CC_USE_IBL",
                  "type": "number",
                  "range": [0, 2]
                }, {
                  "name": "CC_USE_HDR",
                  "type": "boolean"
                }, {
                  "name": "USE_RGBE_CUBEMAP",
                  "type": "boolean"
                }],
                "blocks": [],
                "samplers": [],
                "attributes": [{
                  "name": "a_position",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_normal",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 1
                }, {
                  "name": "a_texCoord",
                  "type": 14,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 21,
                  "location": 2
                }, {
                  "name": "a_tangent",
                  "type": 16,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 3
                }]
              }]
            }, {
              "name": "util/profiler",
              "_uuid": "871c3b6c-7379-419d-bda3-794b239ab90d",
              "techniques": [{
                "passes": [{
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 2,
                      "blendDst": 4,
                      "blendDstAlpha": 4
                    }]
                  },
                  "rasterizerState": {
                    "cullMode": 0
                  },
                  "program": "util/profiler|profiler-vs:vert|profiler-fs:frag",
                  "depthStencilState": {
                    "depthTest": false,
                    "depthWrite": false
                  }
                }]
              }],
              "shaders": [{
                "name": "util/profiler|profiler-vs:vert|profiler-fs:frag",
                "hash": 4021376818,
                "glsl3": {
                  "vert": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec2 v_uv;\nlayout(std140) uniform Constants {\n  vec4 offset;\n};\nlayout(std140) uniform PerFrameInfo {\n  vec4 digits[8 * 10 / 4];\n};\nfloat getComponent(vec4 v, float i) {\n  if (i < 1.0) { return v.x; }\n  else if (i < 2.0) { return v.y; }\n  else if (i < 3.0) { return v.z; }\n  else { return v.w; }\n}\nvec4 vert () {\n  vec4 position = vec4(a_position, 1.0);\n  position.x *= cc_screenSize.y * cc_screenSize.z;\n  position.xy += offset.xy;\n  v_uv = a_color.xy;\n  if (a_color.z >= 0.0) {\n    float n = getComponent(digits[int(a_color.z)], a_color.w);\n    v_uv += vec2(offset.z * n, 0.0);\n  }\n  return position;\n}\nvoid main() { gl_Position = vert(); }",
                  "frag": "\nprecision mediump float;\nlayout(std140) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nin vec2 v_uv;\nuniform sampler2D mainTexture;\nvec4 frag () {\n  return CCFragOutput(texture(mainTexture, v_uv));\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
                },
                "glsl1": {
                  "vert": "\nprecision mediump float;\nuniform mediump vec4 cc_screenSize;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec2 v_uv;\nuniform vec4 offset;\nuniform vec4 digits[20];\nfloat getComponent(vec4 v, float i) {\n  if (i < 1.0) { return v.x; }\n  else if (i < 2.0) { return v.y; }\n  else if (i < 3.0) { return v.z; }\n  else { return v.w; }\n}\nvec4 vert () {\n  vec4 position = vec4(a_position, 1.0);\n  position.x *= cc_screenSize.y * cc_screenSize.z;\n  position.xy += offset.xy;\n  v_uv = a_color.xy;\n  if (a_color.z >= 0.0) {\n    float n = getComponent(digits[int(a_color.z)], a_color.w);\n    v_uv += vec2(offset.z * n, 0.0);\n  }\n  return position;\n}\nvoid main() { gl_Position = vert(); }",
                  "frag": "\nprecision mediump float;\nuniform mediump vec4 cc_exposure;\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nvarying vec2 v_uv;\nuniform sampler2D mainTexture;\nvec4 frag () {\n  return CCFragOutput(texture2D(mainTexture, v_uv));\n}\nvoid main() { gl_FragColor = frag(); }"
                },
                "glsl4": {
                  "vert": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nlayout(location = 0) in vec3 a_position;\nlayout(location = 1) in vec4 a_color;\nlayout(location = 0) out vec2 v_uv;\nlayout(set = 1, binding = 0) uniform Constants {\n  vec4 offset;\n};\nlayout(set = 1, binding = 1) uniform PerFrameInfo {\n  vec4 digits[8 * 10 / 4];\n};\nfloat getComponent(vec4 v, float i) {\n  if (i < 1.0) { return v.x; }\n  else if (i < 2.0) { return v.y; }\n  else if (i < 3.0) { return v.z; }\n  else { return v.w; }\n}\nvec4 vert () {\n  vec4 position = vec4(a_position, 1.0);\n  position.x *= cc_screenSize.y * cc_screenSize.z;\n  position.xy += offset.xy;\n  v_uv = a_color.xy;\n  if (a_color.z >= 0.0) {\n    float n = getComponent(digits[int(a_color.z)], a_color.w);\n    v_uv += vec2(offset.z * n, 0.0);\n  }\n  return position;\n}\nvoid main() { gl_Position = vert(); }",
                  "frag": "\nprecision mediump float;\nlayout(set = 0, binding = 0) uniform CCGlobal {\n  highp   vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n  mediump vec4 cc_nativeSize;\n  highp   mat4 cc_matView;\n  highp   mat4 cc_matViewInv;\n  highp   mat4 cc_matProj;\n  highp   mat4 cc_matProjInv;\n  highp   mat4 cc_matViewProj;\n  highp   mat4 cc_matViewProjInv;\n  highp   vec4 cc_cameraPos;\n  mediump vec4 cc_exposure;\n  mediump vec4 cc_mainLitDir;\n  mediump vec4 cc_mainLitColor;\n  mediump vec4 cc_ambientSky;\n  mediump vec4 cc_ambientGround;\n  mediump vec4 cc_fogColor;\n  mediump vec4 cc_fogBase;\n  mediump vec4 cc_fogAdd;\n};\nvec3 SRGBToLinear (vec3 gamma) {\n  return gamma * gamma;\n}\nvec4 CCFragOutput (vec4 color) {\n  #if CC_USE_HDR\n    color.rgb = mix(color.rgb, SRGBToLinear(color.rgb) * cc_exposure.w, vec3(cc_exposure.z));\n  #endif\n  return color;\n}\nlayout(location = 0) in vec2 v_uv;\nlayout(set = 1, binding = 2) uniform sampler2D mainTexture;\nvec4 frag () {\n  return CCFragOutput(texture(mainTexture, v_uv));\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
                },
                "builtins": {
                  "globals": {
                    "blocks": [{
                      "name": "CCGlobal",
                      "defines": []
                    }],
                    "samplers": []
                  },
                  "locals": {
                    "blocks": [],
                    "samplers": []
                  }
                },
                "defines": [{
                  "name": "CC_USE_HDR",
                  "type": "boolean"
                }],
                "blocks": [{
                  "name": "Constants",
                  "defines": [],
                  "binding": 0,
                  "stageFlags": 1,
                  "members": [{
                    "name": "offset",
                    "type": 16,
                    "count": 1
                  }]
                }, {
                  "name": "PerFrameInfo",
                  "defines": [],
                  "binding": 1,
                  "stageFlags": 1,
                  "members": [{
                    "name": "digits",
                    "type": 16,
                    "count": 20
                  }]
                }],
                "samplers": [{
                  "name": "mainTexture",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 2
                }],
                "attributes": [{
                  "name": "a_position",
                  "type": 15,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 32,
                  "location": 0
                }, {
                  "name": "a_color",
                  "type": 16,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 44,
                  "location": 1
                }]
              }]
            }, {
              "name": "util/splash-screen",
              "_uuid": "970b0598-bcb0-4714-91fb-2e81440dccd8",
              "techniques": [{
                "passes": [{
                  "blendState": {
                    "targets": [{
                      "blend": true,
                      "blendSrc": 2,
                      "blendDst": 4,
                      "blendDstAlpha": 4
                    }]
                  },
                  "rasterizerState": {
                    "cullMode": 0
                  },
                  "program": "util/splash-screen|splash-screen-vs:vert|splash-screen-fs:frag",
                  "depthStencilState": {
                    "depthTest": false,
                    "depthWrite": false
                  }
                }]
              }],
              "shaders": [{
                "name": "util/splash-screen|splash-screen-vs:vert|splash-screen-fs:frag",
                "hash": 2106901053,
                "glsl3": {
                  "vert": "\nprecision mediump float;\nin vec2 a_position;\nin vec2 a_texCoord;\nout vec2 v_uv;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 0, 1);\n  v_uv = a_texCoord;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }",
                  "frag": "\nprecision mediump float;\nin vec2 v_uv;\nuniform sampler2D mainTexture;\nlayout(std140) uniform splashFrag {\n  float u_precent;\n};\nvec4 frag () {\n  vec4 color = texture(mainTexture, v_uv);\n  float precent = clamp(u_precent, 0.0, 1.0);\n  color.xyz *= precent;\n  return color;\n}\nout vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
                },
                "glsl1": {
                  "vert": "\nprecision mediump float;\nattribute vec2 a_position;\nattribute vec2 a_texCoord;\nvarying vec2 v_uv;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 0, 1);\n  v_uv = a_texCoord;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }",
                  "frag": "\nprecision mediump float;\nvarying vec2 v_uv;\nuniform sampler2D mainTexture;\nuniform float u_precent;\nvec4 frag () {\n  vec4 color = texture2D(mainTexture, v_uv);\n  float precent = clamp(u_precent, 0.0, 1.0);\n  color.xyz *= precent;\n  return color;\n}\nvoid main() { gl_FragColor = frag(); }"
                },
                "glsl4": {
                  "vert": "\nprecision mediump float;\nlayout(location = 0) in vec2 a_position;\nlayout(location = 1) in vec2 a_texCoord;\nlayout(location = 0) out vec2 v_uv;\nvec4 vert () {\n  vec4 pos = vec4(a_position, 0, 1);\n  v_uv = a_texCoord;\n  return pos;\n}\nvoid main() { gl_Position = vert(); }",
                  "frag": "\nprecision mediump float;\nlayout(location = 0) in vec2 v_uv;\nlayout(set = 1, binding = 1) uniform sampler2D mainTexture;\nlayout(set = 1, binding = 0) uniform splashFrag {\n  float u_precent;\n};\nvec4 frag () {\n  vec4 color = texture(mainTexture, v_uv);\n  float precent = clamp(u_precent, 0.0, 1.0);\n  color.xyz *= precent;\n  return color;\n}\nlayout(location = 0) out vec4 cc_FragColor;\nvoid main() { cc_FragColor = frag(); }"
                },
                "builtins": {
                  "globals": {
                    "blocks": [],
                    "samplers": []
                  },
                  "locals": {
                    "blocks": [],
                    "samplers": []
                  }
                },
                "defines": [],
                "blocks": [{
                  "name": "splashFrag",
                  "defines": [],
                  "binding": 0,
                  "stageFlags": 16,
                  "members": [{
                    "name": "u_precent",
                    "type": 13,
                    "count": 1
                  }]
                }],
                "samplers": [{
                  "name": "mainTexture",
                  "type": 28,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 16,
                  "binding": 1
                }],
                "attributes": [{
                  "name": "a_position",
                  "type": 14,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 21,
                  "location": 0
                }, {
                  "name": "a_texCoord",
                  "type": 14,
                  "count": 1,
                  "defines": [],
                  "stageFlags": 1,
                  "format": 21,
                  "location": 1
                }]
              }]
            }]);

            var BuiltinResMgr = /*#__PURE__*/function () {
              function BuiltinResMgr() {
                _classCallCheck(this, BuiltinResMgr);

                this._device = null;
                this._resources = {};
              }

              _createClass(BuiltinResMgr, [{
                key: "initBuiltinRes",
                // this should be called after renderer initialized
                value: function initBuiltinRes(device) {
                  this._device = device;
                  var resources = this._resources;
                  var canvas = document.createElement('canvas');
                  var context = canvas.getContext('2d');
                  var imgAsset = new ImageAsset(canvas);
                  var l = canvas.width = canvas.height = 2; // ============================
                  // builtin textures
                  // ============================
                  // black texture

                  context.fillStyle = '#000';
                  context.fillRect(0, 0, l, l);
                  var blackTexture = new Texture2D();
                  blackTexture._uuid = 'black-texture';
                  blackTexture.image = imgAsset;
                  resources[blackTexture._uuid] = blackTexture; // empty texture

                  context.fillStyle = 'rgba(0,0,0,0)';
                  context.fillRect(0, 0, l, l);
                  var emptyBuffer = new Uint8Array(4 * 4);

                  for (var i = 0; i < emptyBuffer.length; ++i) {
                    emptyBuffer[i] = 0;
                  }

                  var emptyTexture = new Texture2D();
                  emptyTexture._uuid = 'empty-texture';
                  emptyTexture.image = imgAsset;
                  emptyTexture.uploadData(emptyBuffer);
                  resources[emptyTexture._uuid] = emptyTexture; // black texture

                  var blackCubeTexture = new TextureCube();
                  blackCubeTexture._uuid = 'black-cube-texture';
                  blackCubeTexture.setMipFilter(TextureCube.Filter.LINEAR);
                  blackCubeTexture.image = {
                    front: new ImageAsset(canvas),
                    back: new ImageAsset(canvas),
                    left: new ImageAsset(canvas),
                    right: new ImageAsset(canvas),
                    top: new ImageAsset(canvas),
                    bottom: new ImageAsset(canvas)
                  };
                  resources[blackCubeTexture._uuid] = blackCubeTexture; // grey texture

                  context.fillStyle = '#777';
                  context.fillRect(0, 0, l, l);
                  var greyTexture = new Texture2D();
                  greyTexture._uuid = 'grey-texture';
                  greyTexture.image = imgAsset;
                  resources[greyTexture._uuid] = greyTexture; // white texture

                  context.fillStyle = '#fff';
                  context.fillRect(0, 0, l, l);
                  var whiteTexture = new Texture2D();
                  whiteTexture._uuid = 'white-texture';
                  whiteTexture.image = imgAsset;
                  resources[whiteTexture._uuid] = whiteTexture; // white cube texture

                  var whiteCubeTexture = new TextureCube();
                  whiteCubeTexture._uuid = 'white-cube-texture';
                  whiteCubeTexture.setMipFilter(TextureCube.Filter.LINEAR);
                  whiteCubeTexture.image = {
                    front: new ImageAsset(canvas),
                    back: new ImageAsset(canvas),
                    left: new ImageAsset(canvas),
                    right: new ImageAsset(canvas),
                    top: new ImageAsset(canvas),
                    bottom: new ImageAsset(canvas)
                  };
                  resources[whiteCubeTexture._uuid] = whiteCubeTexture; // normal texture

                  context.fillStyle = '#7f7fff';
                  context.fillRect(0, 0, l, l);
                  var normalTexture = new Texture2D();
                  normalTexture._uuid = 'normal-texture';
                  normalTexture.image = imgAsset;
                  resources[normalTexture._uuid] = normalTexture; // default texture

                  canvas.width = canvas.height = 16;
                  context.fillStyle = '#ddd';
                  context.fillRect(0, 0, 16, 16);
                  context.fillStyle = '#555';
                  context.fillRect(0, 0, 8, 8);
                  context.fillStyle = '#555';
                  context.fillRect(8, 8, 8, 8);
                  var defaultTexture = new Texture2D();
                  defaultTexture._uuid = 'default-texture';
                  defaultTexture.image = imgAsset;
                  resources[defaultTexture._uuid] = defaultTexture; // default cube texture

                  var defaultCubeTexture = new TextureCube();
                  defaultCubeTexture.setMipFilter(TextureCube.Filter.LINEAR);
                  defaultCubeTexture._uuid = 'default-cube-texture';
                  defaultCubeTexture.image = {
                    front: new ImageAsset(canvas),
                    back: new ImageAsset(canvas),
                    left: new ImageAsset(canvas),
                    right: new ImageAsset(canvas),
                    top: new ImageAsset(canvas),
                    bottom: new ImageAsset(canvas)
                  };
                  resources[defaultCubeTexture._uuid] = defaultCubeTexture;
                  var spriteFrame = new SpriteFrame();
                  var texture = imgAsset._texture;
                  spriteFrame.texture = texture;
                  spriteFrame._uuid = 'default-spriteframe';
                  resources[spriteFrame._uuid] = spriteFrame; // builtin effects

                  effects.forEach(function (e) {
                    var effect = Object.assign(new legacyCC.EffectAsset(), e);
                    effect.onLoaded();
                  }); // standard material

                  var standardMtl = new legacyCC.Material();
                  standardMtl._uuid = 'standard-material';
                  standardMtl.initialize({
                    effectName: 'builtin-standard'
                  });
                  resources[standardMtl._uuid] = standardMtl; // material indicating missing effect (yellow)

                  var missingEfxMtl = new legacyCC.Material();
                  missingEfxMtl._uuid = 'missing-effect-material';
                  missingEfxMtl.initialize({
                    effectName: 'builtin-unlit',
                    defines: {
                      USE_COLOR: true
                    }
                  });
                  missingEfxMtl.setProperty('mainColor', legacyCC.color('#ffff00'));
                  resources[missingEfxMtl._uuid] = missingEfxMtl; // material indicating missing material (purple)

                  var missingMtl = new legacyCC.Material();
                  missingMtl._uuid = 'missing-material';
                  missingMtl.initialize({
                    effectName: 'builtin-unlit',
                    defines: {
                      USE_COLOR: true
                    }
                  });
                  missingMtl.setProperty('mainColor', legacyCC.color('#ff00ff'));
                  resources[missingMtl._uuid] = missingMtl; // sprite material

                  var spriteMtl = new legacyCC.Material();
                  spriteMtl._uuid = 'ui-base-material';
                  spriteMtl.initialize({
                    defines: {
                      USE_TEXTURE: false
                    },
                    effectName: 'builtin-sprite'
                  });
                  resources[spriteMtl._uuid] = spriteMtl; // sprite material

                  var spriteColorMtl = new legacyCC.Material();
                  spriteColorMtl._uuid = 'ui-sprite-material';
                  spriteColorMtl.initialize({
                    defines: {
                      USE_TEXTURE: true,
                      CC_USE_EMBEDDED_ALPHA: false,
                      IS_GRAY: false
                    },
                    effectName: 'builtin-sprite'
                  });
                  resources[spriteColorMtl._uuid] = spriteColorMtl; // sprite gray material

                  var spriteGrayMtl = new legacyCC.Material();
                  spriteGrayMtl._uuid = 'ui-sprite-gray-material';
                  spriteGrayMtl.initialize({
                    defines: {
                      USE_TEXTURE: true,
                      CC_USE_EMBEDDED_ALPHA: false,
                      IS_GRAY: true
                    },
                    effectName: 'builtin-sprite'
                  });
                  resources[spriteGrayMtl._uuid] = spriteGrayMtl; // sprite alpha material

                  var spriteAlphaMtl = new legacyCC.Material();
                  spriteAlphaMtl._uuid = 'ui-sprite-alpha-sep-material';
                  spriteAlphaMtl.initialize({
                    defines: {
                      USE_TEXTURE: true,
                      CC_USE_EMBEDDED_ALPHA: true,
                      IS_GRAY: false
                    },
                    effectName: 'builtin-sprite'
                  });
                  resources[spriteAlphaMtl._uuid] = spriteAlphaMtl; // sprite alpha & gray material

                  var spriteAlphaGrayMtl = new legacyCC.Material();
                  spriteAlphaGrayMtl._uuid = 'ui-sprite-gray-alpha-sep-material';
                  spriteAlphaGrayMtl.initialize({
                    defines: {
                      USE_TEXTURE: true,
                      CC_USE_EMBEDDED_ALPHA: true,
                      IS_GRAY: true
                    },
                    effectName: 'builtin-sprite'
                  });
                  resources[spriteAlphaGrayMtl._uuid] = spriteAlphaGrayMtl; // ui graphics material

                  var defaultGraphicsMtl = new legacyCC.Material();
                  defaultGraphicsMtl._uuid = 'ui-graphics-material';
                  defaultGraphicsMtl.initialize({
                    effectName: 'builtin-graphics'
                  });
                  resources[defaultGraphicsMtl._uuid] = defaultGraphicsMtl; // default particle material

                  var defaultParticleMtl = new legacyCC.Material();
                  defaultParticleMtl._uuid = 'default-particle-material';
                  defaultParticleMtl.initialize({
                    effectName: 'builtin-particle'
                  });
                  resources[defaultParticleMtl._uuid] = defaultParticleMtl; // default particle gpu material

                  var defaultParticleGPUMtl = new legacyCC.Material();
                  defaultParticleGPUMtl._uuid = 'default-particle-gpu-material';
                  defaultParticleGPUMtl.initialize({
                    effectName: 'builtin-particle-gpu'
                  });
                  resources[defaultParticleGPUMtl._uuid] = defaultParticleGPUMtl; // default particle material

                  var defaultTrailMtl = new legacyCC.Material();
                  defaultTrailMtl._uuid = 'default-trail-material';
                  defaultTrailMtl.initialize({
                    effectName: 'builtin-particle-trail'
                  });
                  resources[defaultTrailMtl._uuid] = defaultTrailMtl; // default particle material

                  var defaultBillboardMtl = new legacyCC.Material();
                  defaultBillboardMtl._uuid = 'default-billboard-material';
                  defaultBillboardMtl.initialize({
                    effectName: 'builtin-billboard'
                  });
                  resources[defaultBillboardMtl._uuid] = defaultBillboardMtl;
                }
              }, {
                key: "get",
                value: function get(uuid) {
                  return this._resources[uuid];
                }
              }]);

              return BuiltinResMgr;
            }();

            var builtinResMgr = exports('d2', legacyCC.builtinResMgr = new BuiltinResMgr());

            /**
             * @hidden
             */
            var getPhaseID = function () {
              var phases = new Map();
              var phaseNum = 0;
              return function (phaseName) {
                if (typeof phaseName === 'number') {
                  return phaseName;
                }

                if (!phases.has(phaseName)) {
                  phases.set(phaseName, 1 << phaseNum);
                  phaseNum++;
                }

                return phases.get(phaseName);
              };
            }();

            /*
             Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

             http://www.cocos.com

             Permission is hereby granted, free of charge, to any person obtaining a copy
             of this software and associated engine source code (the "Software"), a limited,
              worldwide, royalty-free, non-assignable, revocable and non-exclusive license
             to use Cocos Creator solely to develop games on your target platforms. You shall
              not use Cocos Creator software for developing other software or tools that's
              used for developing games. You are not granted to publish, distribute,
              sublicense, and/or sell copies of Cocos Creator.

             The software or tools in this License Agreement are licensed, not sold.
             Xiamen Yaji Software Co., Ltd. reserves all rights not expressly granted to you.

             THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
             THE SOFTWARE.
            */

            /**
             * @hidden
             */
            var NativeBufferPool = /*#__PURE__*/function () {
              function NativeBufferPool(dataType, entryBits, stride) {
                _classCallCheck(this, NativeBufferPool);

                this._arrayBuffers = [];
                this._chunkSize = void 0;
                this._chunkSize = stride * (1 << entryBits);
              }

              _createClass(NativeBufferPool, [{
                key: "allocateNewChunk",
                value: function allocateNewChunk() {
                  return new ArrayBuffer(this._chunkSize);
                }
              }]);

              return NativeBufferPool;
            }();
            var NativeObjectPool = function NativeObjectPool(dataType, array) {
              _classCallCheck(this, NativeObjectPool);
            };

            var BufferPool = /*#__PURE__*/function () {
              // naming convension:
              // this._bufferViews[chunk][entry][element]
              function BufferPool(dataType, viewCtor, enumType) {
                var entryBits = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 8;

                _classCallCheck(this, BufferPool);

                this._viewCtor = void 0;
                this._elementCount = void 0;
                this._entryBits = void 0;
                this._stride = void 0;
                this._entriesPerChunk = void 0;
                this._entryMask = void 0;
                this._chunkMask = void 0;
                this._poolFlag = void 0;
                this._arrayBuffers = [];
                this._freelists = [];
                this._bufferViews = [];
                this._nativePool = void 0;
                this._viewCtor = viewCtor;
                this._elementCount = enumType.COUNT;
                this._entryBits = entryBits;
                var bytesPerElement = viewCtor.BYTES_PER_ELEMENT || 1;
                this._stride = bytesPerElement * this._elementCount;
                this._entriesPerChunk = 1 << entryBits;
                this._entryMask = this._entriesPerChunk - 1;
                this._poolFlag = 1 << 30;
                this._chunkMask = ~(this._entryMask | this._poolFlag);
                this._nativePool = new NativeBufferPool(dataType, entryBits, this._stride);
              }

              _createClass(BufferPool, [{
                key: "alloc",
                value: function alloc() {
                  var i = 0;

                  for (; i < this._freelists.length; i++) {
                    var list = this._freelists[i];

                    if (list.length) {
                      var j = list[list.length - 1];
                      list.length--;
                      return (i << this._entryBits) + j + this._poolFlag;
                    }
                  } // add a new chunk


                  var buffer = this._nativePool.allocateNewChunk();

                  var bufferViews = [];
                  var freelist = [];

                  for (var _j = 0; _j < this._entriesPerChunk; _j++) {
                    bufferViews.push(new this._viewCtor(buffer, this._stride * _j, this._elementCount));

                    if (_j) {
                      freelist.push(_j);
                    }
                  }

                  this._arrayBuffers.push(buffer);

                  this._bufferViews.push(bufferViews);

                  this._freelists.push(freelist);

                  return (i << this._entryBits) + this._poolFlag; // guarantees the handle is always not zero
                }
                /**
                 * Get the specified element out from buffer pool.
                 *
                 * Note the type inference does not work when `element` is not directly
                 * an pre-declared enum value: (e.g. when doing arithmetic operations)
                 * ```ts
                 * SubModelPool.get(handle, SubModelView.SHADER_0 + passIndex); // the return value will have type GeneralBufferElement
                 * ```
                 *
                 * To properly declare the variable type, you have two options:
                 * ```ts
                 * const hShader = SubModelPool.get(handle, SubModelView.SHADER_0 + passIndex) as ShaderHandle; // option #1
                 * const hShader = SubModelPool.get<SubModelView.SHADER_0>(handle, SubModelView.SHADER_0 + passIndex); // option #2
                 * ```
                 */

              }, {
                key: "get",
                value: function get(handle, element) {
                  var chunk = (this._chunkMask & handle) >> this._entryBits;
                  var entry = this._entryMask & handle;

                  if ( (!handle || chunk < 0 || chunk >= this._bufferViews.length || entry < 0 || entry >= this._entriesPerChunk || this._freelists[chunk].find(function (n) {
                    return n === entry;
                  }))) {
                    console.warn('invalid native buffer pool handle');
                    return 0;
                  }

                  return this._bufferViews[chunk][entry][element];
                }
              }, {
                key: "set",
                value: function set(handle, element, value) {
                  var chunk = (this._chunkMask & handle) >> this._entryBits;
                  var entry = this._entryMask & handle;

                  if ( (!handle || chunk < 0 || chunk >= this._bufferViews.length || entry < 0 || entry >= this._entriesPerChunk || this._freelists[chunk].find(function (n) {
                    return n === entry;
                  }))) {
                    console.warn('invalid native buffer pool handle');
                    return;
                  }

                  this._bufferViews[chunk][entry][element] = value;
                }
              }, {
                key: "free",
                value: function free(handle) {
                  var chunk = (this._chunkMask & handle) >> this._entryBits;
                  var entry = this._entryMask & handle;

                  if ( (!handle || chunk < 0 || chunk >= this._freelists.length || entry < 0 || entry >= this._entriesPerChunk || this._freelists[chunk].find(function (n) {
                    return n === entry;
                  }))) {
                    console.warn('invalid native buffer pool handle');
                    return;
                  }

                  this._bufferViews[chunk][entry].fill(0);

                  this._freelists[chunk].push(entry);
                }
              }]);

              return BufferPool;
            }();

            var ObjectPool = /*#__PURE__*/function () {
              function ObjectPool(dataType, ctor, dtor) {
                _classCallCheck(this, ObjectPool);

                this._ctor = void 0;
                this._dtor = void 0;
                this._indexMask = void 0;
                this._poolFlag = void 0;
                this._array = [];
                this._freelist = [];
                this._nativePool = void 0;
                this._ctor = ctor;

                if (dtor) {
                  this._dtor = dtor;
                }

                this._poolFlag = 1 << 29;
                this._indexMask = ~this._poolFlag;
                this._nativePool = new NativeObjectPool(dataType, this._array);
              }

              _createClass(ObjectPool, [{
                key: "alloc",
                value: function alloc() {
                  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = arguments[_key];
                  }

                  var freelist = this._freelist;
                  var i = -1;

                  if (freelist.length) {
                    i = freelist[freelist.length - 1];
                    freelist.length--;
                    this._array[i] = this._ctor(arguments, this._array[i]);
                  }

                  if (i < 0) {
                    i = this._array.length;

                    var _obj = this._ctor(arguments);

                    if (!_obj) {
                      return 0;
                    }

                    this._array.push(_obj);
                  }

                  return i + this._poolFlag; // guarantees the handle is always not zero
                }
              }, {
                key: "get",
                value: function get(handle) {
                  var index = this._indexMask & handle;

                  if ( (!handle || index < 0 || index >= this._array.length || this._freelist.find(function (n) {
                    return n === index;
                  }))) {
                    console.warn('invalid native object pool handle');
                    return null;
                  }

                  return this._array[index];
                }
              }, {
                key: "free",
                value: function free(handle) {
                  var index = this._indexMask & handle;

                  if ( (!handle || index < 0 || index >= this._array.length || this._freelist.find(function (n) {
                    return n === index;
                  }))) {
                    console.warn('invalid native object pool handle');
                    return;
                  }

                  if (this._dtor) {
                    this._dtor(this._array[index]);
                  }

                  this._freelist.push(index);
                }
              }]);

              return ObjectPool;
            }();

            var PoolType;

            (function (PoolType) {
              PoolType[PoolType["RASTERIZER_STATE"] = 0] = "RASTERIZER_STATE";
              PoolType[PoolType["DEPTH_STENCIL_STATE"] = 1] = "DEPTH_STENCIL_STATE";
              PoolType[PoolType["BLEND_STATE"] = 2] = "BLEND_STATE";
              PoolType[PoolType["DESCRIPTOR_SETS"] = 3] = "DESCRIPTOR_SETS";
              PoolType[PoolType["SHADER"] = 4] = "SHADER";
              PoolType[PoolType["INPUT_ASSEMBLER"] = 5] = "INPUT_ASSEMBLER";
              PoolType[PoolType["PIPELINE_LAYOUT"] = 6] = "PIPELINE_LAYOUT";
              PoolType[PoolType["PASS"] = 7] = "PASS";
              PoolType[PoolType["SUB_MODEL"] = 8] = "SUB_MODEL";
            })(PoolType || (PoolType = {}));

            var NULL_HANDLE = exports('dh', 0);
            // don't reuse any of these data-only structs, for GFX objects may directly reference them
            var RasterizerStatePool = new ObjectPool(PoolType.RASTERIZER_STATE, function () {
              return new GFXRasterizerState();
            });
            var DepthStencilStatePool = new ObjectPool(PoolType.DEPTH_STENCIL_STATE, function () {
              return new GFXDepthStencilState();
            });
            var BlendStatePool = new ObjectPool(PoolType.BLEND_STATE, function () {
              return new GFXBlendState();
            });
            var ShaderPool = exports('dY', new ObjectPool(PoolType.SHADER, function (args, obj) {
              return obj ? (obj.initialize(args[1]), obj) : args[0].createShader(args[1]);
            }, function (obj) {
              return obj && obj.destroy();
            }));
            var DSPool = exports('dl', new ObjectPool(PoolType.DESCRIPTOR_SETS, function (args, obj) {
              return obj ? (obj.initialize(args[1]), obj) : args[0].createDescriptorSet(args[1]);
            }, function (obj) {
              return obj && obj.destroy();
            }));
            var IAPool = exports('dg', new ObjectPool(PoolType.INPUT_ASSEMBLER, function (args, obj) {
              return obj ? (obj.initialize(args[1]), obj) : args[0].createInputAssembler(args[1]);
            }, function (obj) {
              return obj && obj.destroy();
            }));
            var PipelineLayoutPool = new ObjectPool(PoolType.PIPELINE_LAYOUT, function (args, obj) {
              return obj ? (obj.initialize(args[1]), obj) : args[0].createPipelineLayout(args[1]);
            }, function (obj) {
              return obj && obj.destroy();
            });
            var PassView;

            (function (PassView) {
              PassView[PassView["PRIORITY"] = 0] = "PRIORITY";
              PassView[PassView["STAGE"] = 1] = "STAGE";
              PassView[PassView["PHASE"] = 2] = "PHASE";
              PassView[PassView["BATCHING_SCHEME"] = 3] = "BATCHING_SCHEME";
              PassView[PassView["PRIMITIVE"] = 4] = "PRIMITIVE";
              PassView[PassView["DYNAMIC_STATES"] = 5] = "DYNAMIC_STATES";
              PassView[PassView["HASH"] = 6] = "HASH";
              PassView[PassView["RASTERIZER_STATE"] = 7] = "RASTERIZER_STATE";
              PassView[PassView["DEPTH_STENCIL_STATE"] = 8] = "DEPTH_STENCIL_STATE";
              PassView[PassView["BLEND_STATE"] = 9] = "BLEND_STATE";
              PassView[PassView["DESCRIPTOR_SET"] = 10] = "DESCRIPTOR_SET";
              PassView[PassView["PIPELINE_LAYOUT"] = 11] = "PIPELINE_LAYOUT";
              PassView[PassView["COUNT"] = 12] = "COUNT";
            })(PassView || (PassView = exports('dp', {})));

            // Theoretically we only have to declare the type view here while all the other arguments can be inferred.
            // but before the official support of Partial Type Argument Inference releases, (microsoft/TypeScript#26349)
            // we'll have to explicitly declare all these types.
            var PassPool = exports('dn', new BufferPool(PoolType.PASS, Uint32Array, PassView));
            var SubModelView;

            (function (SubModelView) {
              SubModelView[SubModelView["PRIORITY"] = 0] = "PRIORITY";
              SubModelView[SubModelView["PASS_COUNT"] = 1] = "PASS_COUNT";
              SubModelView[SubModelView["PASS_0"] = 2] = "PASS_0";
              SubModelView[SubModelView["PASS_1"] = 3] = "PASS_1";
              SubModelView[SubModelView["PASS_2"] = 4] = "PASS_2";
              SubModelView[SubModelView["PASS_3"] = 5] = "PASS_3";
              SubModelView[SubModelView["SHADER_0"] = 6] = "SHADER_0";
              SubModelView[SubModelView["SHADER_1"] = 7] = "SHADER_1";
              SubModelView[SubModelView["SHADER_2"] = 8] = "SHADER_2";
              SubModelView[SubModelView["SHADER_3"] = 9] = "SHADER_3";
              SubModelView[SubModelView["DESCRIPTOR_SET"] = 10] = "DESCRIPTOR_SET";
              SubModelView[SubModelView["INPUT_ASSEMBLER"] = 11] = "INPUT_ASSEMBLER";
              SubModelView[SubModelView["COUNT"] = 12] = "COUNT";
            })(SubModelView || (SubModelView = exports('dj', {})));

            // Theoretically we only have to declare the type view here while all the other arguments can be inferred.
            // but before the official support of Partial Type Argument Inference releases, (microsoft/TypeScript#26349)
            // we'll have to explicitly declare all these types.
            var SubModelPool = exports('di', new BufferPool(PoolType.SUB_MODEL, Uint32Array, SubModelView));

            function getBitCount(cnt) {
              return Math.ceil(Math.log2(Math.max(cnt, 2)));
            }

            function mapDefine(info, def) {
              switch (info.type) {
                case 'boolean':
                  return (typeof def === 'number' ? def : def ? 1 : 0) + '';

                case 'string':
                  return def !== undefined ? def : info.options[0];

                case 'number':
                  return (def !== undefined ? def : info.range[0]) + '';
              }

              console.warn("unknown define type '".concat(info.type, "'"));
              return '-1'; // should neven happen
            }

            function prepareDefines(defs, tDefs) {
              var macros = [];

              for (var i = 0; i < tDefs.length; i++) {
                var tmpl = tDefs[i];
                var name = tmpl.name;
                var v = defs[name];

                var _value = mapDefine(tmpl, v);

                var isDefault = !v || v === '0';
                macros.push({
                  name: name,
                  value: _value,
                  isDefault: isDefault
                });
              }

              return macros;
            }

            function getShaderInstanceName(name, macros) {
              return name + macros.reduce(function (acc, cur) {
                return cur.isDefault ? acc : "".concat(acc, "|").concat(cur.name).concat(cur.value);
              }, '');
            }

            function insertBuiltinBindings(tmpl, source, type) {
              var target = tmpl.builtins[type];
              var blocks = tmpl.blocks;

              for (var i = 0; i < target.blocks.length; i++) {
                var b = target.blocks[i];
                var info = source.record[b.name];

                if (!info || !(source.bindings[info.binding].descriptorType & DESCRIPTOR_BUFFER_TYPE)) {
                  console.warn("builtin UBO '".concat(b.name, "' not available!"));
                  continue;
                }

                var builtin = Object.assign({
                  size: getSize(info)
                }, info);
                blocks.push(builtin);
              }

              var samplers = tmpl.samplers;

              for (var _i = 0; _i < target.samplers.length; _i++) {
                var s = target.samplers[_i];
                var _info = source.record[s.name];

                if (!_info || !(source.bindings[_info.binding].descriptorType & DESCRIPTOR_SAMPLER_TYPE)) {
                  console.warn("builtin sampler '".concat(s.name, "' not available!"));
                  continue;
                }

                samplers.push(_info);
              }
            }

            function getSize(block) {
              return block.members.reduce(function (s, m) {
                return s + GFXGetTypeSize(m.type) * m.count;
              }, 0);
            }

            function genHandles(tmpl) {
              var handleMap = {}; // block member handles

              for (var i = 0; i < tmpl.blocks.length; i++) {
                var block = tmpl.blocks[i];
                var members = block.members;
                var offset = 0;

                for (var j = 0; j < members.length; j++) {
                  var uniform = members[j];
                  handleMap[uniform.name] = genHandle(PropertyType.UBO, block.set, block.binding, uniform.type, offset);
                  offset += (GFXGetTypeSize(uniform.type) >> 2) * uniform.count;
                }
              } // sampler handles


              for (var _i2 = 0; _i2 < tmpl.samplers.length; _i2++) {
                var sampler = tmpl.samplers[_i2];
                handleMap[sampler.name] = genHandle(PropertyType.SAMPLER, sampler.set, sampler.binding, sampler.type);
              }

              return handleMap;
            }

            function dependencyCheck(dependencies, defines) {
              for (var i = 0; i < dependencies.length; i++) {
                var d = dependencies[i];

                if (d[0] === '!') {
                  if (defines[d.slice(1)]) {
                    return false;
                  }
                } // negative dependency
                else if (!defines[d]) {
                    return false;
                  }
              }

              return true;
            }

            function getActiveAttributes(tmpl, defines, outAttributes) {
              var attributes = tmpl.attributes;

              for (var i = 0; i < attributes.length; i++) {
                var attribute = attributes[i];

                if (!dependencyCheck(attribute.defines, defines)) {
                  continue;
                }

                outAttributes.push(attribute);
              }
            }

            var _dsLayout = null;
            /**
             * @en The global maintainer of all shader resources.
             * @zh 维护 shader 资源实例的全局管理器。
             */

            var ProgramLib = /*#__PURE__*/function () {
              function ProgramLib() {
                _classCallCheck(this, ProgramLib);

                this._templates = {};
                this._pipelineLayouts = {};
                this._cache = {};
              }

              _createClass(ProgramLib, [{
                key: "define",

                /**
                 * @en Register the shader template with the given info
                 * @zh 根据 effect 信息注册 shader 模板。
                 * @param name Target shader name
                 */
                value: function define(prog) {
                  var curTmpl = this._templates[prog.name];

                  if (curTmpl && curTmpl.hash === prog.hash) {
                    return;
                  }

                  var tmpl = prog; // calculate option mask offset

                  var offset = 0;

                  var _loop = function _loop(i) {
                    var def = tmpl.defines[i];
                    var cnt = 1;

                    if (def.type === 'number') {
                      var range = def.range;
                      cnt = getBitCount(range[1] - range[0] + 1); // inclusive on both ends

                      def._map = function (value) {
                        return value - range[0];
                      };
                    } else if (def.type === 'string') {
                      cnt = getBitCount(def.options.length);

                      def._map = function (value) {
                        return Math.max(0, def.options.findIndex(function (s) {
                          return s === value;
                        }));
                      };
                    } else if (def.type === 'boolean') {
                      def._map = function (value) {
                        return value ? 1 : 0;
                      };
                    }

                    def._offset = offset;
                    offset += cnt;
                  };

                  for (var i = 0; i < tmpl.defines.length; i++) {
                    _loop(i);
                  }

                  if (offset > 31) {
                    tmpl.uber = true;
                  } // cache material-specific descriptor set layout


                  tmpl.samplerStartBinding = tmpl.blocks.length;
                  tmpl.bindings = tmpl.blocks.concat(tmpl.samplers);

                  for (var _i3 = 0; _i3 < tmpl.blocks.length; _i3++) {
                    var block = tmpl.blocks[_i3];
                    block.count = 1; // effect compiler guarantees this

                    block.size = getSize(block);
                    block.set = SetIndex.MATERIAL;

                    if (!block.descriptorType) {
                      block.descriptorType = GFXDescriptorType.UNIFORM_BUFFER;
                    }
                  }

                  for (var _i4 = 0; _i4 < tmpl.samplers.length; _i4++) {
                    var sampler = tmpl.samplers[_i4];
                    sampler.set = SetIndex.MATERIAL;

                    if (!sampler.descriptorType) {
                      sampler.descriptorType = GFXDescriptorType.SAMPLER;
                    }
                  }

                  tmpl.handleMap = genHandles(tmpl); // store it

                  this._templates[prog.name] = tmpl; // const pl = this._pipelineLayouts[prog.name];
                  // if (pl) {
                  //     if (pl.hPipelineLayout) {
                  //         PipelineLayoutPool.free(pl.hPipelineLayout);
                  //     }
                  //     for (let i = 0; i < pl.setLayouts.length; i++) {
                  //         const setLayout = pl.setLayouts[i];
                  //         if (setLayout) setLayout.destroy();
                  //     }
                  // }

                  this._pipelineLayouts[prog.name] = {
                    hPipelineLayout: NULL_HANDLE,
                    setLayouts: []
                  };
                }
                /**
                 * @en Gets the shader template with its name
                 * @zh 通过名字获取 Shader 模板
                 * @param name Target shader name
                 */

              }, {
                key: "getTemplate",
                value: function getTemplate(name) {
                  return this._templates[name];
                }
                /**
                 * @en Gets the pipeline layout of the shader template given its name
                 * @zh 通过名字获取 Shader 模板相关联的管线布局
                 * @param name Target shader name
                 */

              }, {
                key: "getPipelineLayout",
                value: function getPipelineLayout(name) {
                  return this._pipelineLayouts[name];
                }
                /**
                 * @en
                 * Does this library has the specified program
                 * @zh
                 * 当前是否有已注册的指定名字的 shader
                 * @param name Target shader name
                 */

              }, {
                key: "hasProgram",
                value: function hasProgram(name) {
                  return this._templates[name] !== undefined;
                }
                /**
                 * @en Gets the shader key with the name and a macro combination
                 * @zh 根据 shader 名和预处理宏列表获取 shader key。
                 * @param name Target shader name
                 * @param defines The combination of preprocess macros
                 */

              }, {
                key: "getKey",
                value: function getKey(name, defines) {
                  var tmpl = this._templates[name];
                  var tmplDefs = tmpl.defines;

                  if (tmpl.uber) {
                    var key = '';

                    for (var i = 0; i < tmplDefs.length; i++) {
                      var tmplDef = tmplDefs[i];
                      var _value2 = defines[tmplDef.name];

                      if (!_value2 || !tmplDef._map) {
                        continue;
                      }

                      var mapped = tmplDef._map(_value2);

                      var offset = tmplDef._offset;
                      key += offset + (mapped + '|');
                    }

                    return key + tmpl.hash;
                  } else {
                    var _key = 0;

                    for (var _i5 = 0; _i5 < tmplDefs.length; _i5++) {
                      var _tmplDef = tmplDefs[_i5];
                      var _value3 = defines[_tmplDef.name];

                      if (!_value3 || !_tmplDef._map) {
                        continue;
                      }

                      var _mapped = _tmplDef._map(_value3);

                      var _offset = _tmplDef._offset;
                      _key |= _mapped << _offset;
                    }

                    return "".concat(_key.toString(16), "|").concat(tmpl.hash);
                  }
                }
                /**
                 * @en Destroy all shader instance match the preprocess macros
                 * @zh 销毁所有完全满足指定预处理宏特征的 shader 实例。
                 * @param defines The preprocess macros as filter
                 */

              }, {
                key: "destroyShaderByDefines",
                value: function destroyShaderByDefines(defines) {
                  var _this = this;

                  var names = Object.keys(defines);

                  if (!names.length) {
                    return;
                  }

                  var regexes = names.map(function (cur) {
                    var val = defines[cur];

                    if (typeof val === 'boolean') {
                      val = val ? '1' : '0';
                    }

                    return new RegExp(cur + val);
                  });
                  var keys = Object.keys(this._cache).filter(function (k) {
                    return regexes.every(function (re) {
                      return re.test(ShaderPool.get(_this._cache[k]).name);
                    });
                  });

                  for (var i = 0; i < keys.length; i++) {
                    var k = keys[i];
                    var prog = ShaderPool.get(this._cache[k]);
                    console.log("destroyed shader ".concat(prog.name));
                    prog.destroy();
                    delete this._cache[k];
                  }
                }
                /**
                 * @en Gets the shader resource instance with given information
                 * @zh 获取指定 shader 的渲染资源实例
                 * @param device The device
                 * @param name Shader name
                 * @param defines Preprocess macros
                 * @param pipeline The [[RenderPipeline]] which owns the render command
                 */

              }, {
                key: "getGFXShader",
                value: function getGFXShader(device, name, defines, pipeline, key) {
                  Object.assign(defines, pipeline.macros);
                  if (!key) key = this.getKey(name, defines);
                  var res = this._cache[key];

                  if (res) {
                    return res;
                  }

                  var tmpl = this._templates[name];
                  var layout = this._pipelineLayouts[name];

                  if (!layout.hPipelineLayout) {
                    insertBuiltinBindings(tmpl, pipeline.globalDescriptorSetLayout, 'globals');
                    insertBuiltinBindings(tmpl, pipeline.localDescriptorSetLayout, 'locals');
                    layout.setLayouts[SetIndex.GLOBAL] = pipeline.descriptorSetLayout; // material set layout should already been created in pass, but if not
                    // (like when the same shader is overriden) we create it again here

                    if (!layout.setLayouts[SetIndex.MATERIAL]) {
                      layout.setLayouts[SetIndex.MATERIAL] = device.createDescriptorSetLayout({
                        bindings: tmpl.bindings
                      });
                    }

                    layout.setLayouts[SetIndex.LOCAL] = _dsLayout = _dsLayout || device.createDescriptorSetLayout({
                      bindings: pipeline.localDescriptorSetLayout.bindings
                    });
                    layout.hPipelineLayout = PipelineLayoutPool.alloc(device, {
                      setLayouts: layout.setLayouts
                    });
                  }

                  var macroArray = prepareDefines(defines, tmpl.defines);
                  var prefix = macroArray.reduce(function (acc, cur) {
                    return "".concat(acc, "#define ").concat(cur.name, " ").concat(cur.value, "\n");
                  }, '') + '\n';
                  var src = tmpl.glsl3;

                  switch (device.gfxAPI) {
                    case GFXAPI.GLES2:
                    case GFXAPI.WEBGL:
                      src = tmpl.glsl1;
                      break;

                    case GFXAPI.GLES3:
                    case GFXAPI.WEBGL2:
                      src = tmpl.glsl3;
                      break;

                    case GFXAPI.VULKAN:
                    case GFXAPI.METAL:
                      src = tmpl.glsl4;
                      break;

                    default:
                      console.error('Invalid GFX API!');
                      break;
                  } // strip out the active attributes only, instancing depend on this


                  var attributes = [];
                  getActiveAttributes(tmpl, defines, attributes);
                  return this._cache[key] = ShaderPool.alloc(device, {
                    name: getShaderInstanceName(name, macroArray),
                    blocks: tmpl.blocks,
                    samplers: tmpl.samplers,
                    attributes: attributes,
                    stages: [{
                      stage: GFXShaderStageFlagBit.VERTEX,
                      source: prefix + src.vert
                    }, {
                      stage: GFXShaderStageFlagBit.FRAGMENT,
                      source: prefix + src.frag
                    }]
                  });
                }
              }]);

              return ProgramLib;
            }();

            var programLib = exports('aj', new ProgramLib());
            legacyCC.programLib = programLib;

            var _bufferInfo = {
              memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
              usage: GFXBufferUsageBit.UNIFORM,
              size: 0
            };
            var _bufferViewInfo = {
              buffer: null,
              offset: 0,
              range: 0
            };
            var _dsInfo = {
              layout: null
            };
            var BatchingSchemes;

            (function (BatchingSchemes) {
              BatchingSchemes[BatchingSchemes["INSTANCING"] = 1] = "INSTANCING";
              BatchingSchemes[BatchingSchemes["VB_MERGING"] = 2] = "VB_MERGING";
            })(BatchingSchemes || (BatchingSchemes = exports('ah', {})));

            // tslint:enable: no-shadowed-variable

            /**
             * @en Render pass, store actual resources for the rendering process
             * @zh 渲染 pass，储存实际描述绘制过程的各项资源。
             */
            var Pass = exports('ai', /*#__PURE__*/function () {
              _createClass(Pass, null, [{
                key: "fillPipelineInfo",

                /**
                 * @en The binding type enums of the property
                 * @zh Uniform 的绑定类型（UBO 或贴图等）
                 */

                /**
                 * @en Gets the binding type of the property with handle
                 * @zh 根据 handle 获取 uniform 的绑定类型（UBO 或贴图等）。
                 */

                /**
                 * @en Gets the type of member in uniform buffer object with the handle
                 * @zh 根据 handle 获取 UBO member 的具体类型。
                 */

                /**
                 * @en Gets the binding with handle
                 * @zh 根据 handle 获取 binding。
                 */

                /**
                 * @en Fill a pass represented by the given pass handle with the given override info
                 * @param hPass The pass handle point to the pass
                 * @param info The pass override info
                 */
                value: function fillPipelineInfo(hPass, info) {
                  if (info.priority !== undefined) {
                    PassPool.set(hPass, PassView.PRIORITY, info.priority);
                  }

                  if (info.primitive !== undefined) {
                    PassPool.set(hPass, PassView.PRIMITIVE, info.primitive);
                  }

                  if (info.stage !== undefined) {
                    PassPool.set(hPass, PassView.STAGE, info.stage);
                  }

                  if (info.dynamicStates !== undefined) {
                    PassPool.set(hPass, PassView.DYNAMIC_STATES, info.dynamicStates);
                  }

                  if (info.phase !== undefined) {
                    PassPool.set(hPass, PassView.PHASE, getPhaseID(info.phase));
                  }

                  var bs = BlendStatePool.get(PassPool.get(hPass, PassView.BLEND_STATE));

                  if (info.blendState) {
                    var bsInfo = info.blendState;

                    if (bsInfo.targets) {
                      bsInfo.targets.forEach(function (t, i) {
                        return Object.assign(bs.targets[i] || (bs.targets[i] = new GFXBlendTarget()), t);
                      });
                    }

                    if (bsInfo.isA2C !== undefined) {
                      bs.isA2C = bsInfo.isA2C;
                    }

                    if (bsInfo.isIndepend !== undefined) {
                      bs.isIndepend = bsInfo.isIndepend;
                    }

                    if (bsInfo.blendColor !== undefined) {
                      Object.assign(bs.blendColor, bsInfo.blendColor);
                    }
                  }

                  Object.assign(RasterizerStatePool.get(PassPool.get(hPass, PassView.RASTERIZER_STATE)), info.rasterizerState);
                  Object.assign(DepthStencilStatePool.get(PassPool.get(hPass, PassView.DEPTH_STENCIL_STATE)), info.depthStencilState);
                }
                /**
                 * @en Get pass hash value by [[Pass]] hash information.
                 * @zh 根据 [[Pass]] 的哈希信息获取哈希值。
                 *
                 * @param hPass Handle of the pass info used to compute hash value.
                 */

              }, {
                key: "getPassHash",
                value: function getPassHash(hPass, hShader) {
                  var res = hShader + ',' + PassPool.get(hPass, PassView.PRIMITIVE) + ',' + PassPool.get(hPass, PassView.DYNAMIC_STATES);
                  res += serializeBlendState(BlendStatePool.get(PassPool.get(hPass, PassView.BLEND_STATE)));
                  res += serializeDepthStencilState(DepthStencilStatePool.get(PassPool.get(hPass, PassView.DEPTH_STENCIL_STATE)));
                  res += serializeRasterizerState(RasterizerStatePool.get(PassPool.get(hPass, PassView.RASTERIZER_STATE)));
                  return murmurhash2_32_gc(res, 666);
                }
              }]);

              function Pass(root) {
                _classCallCheck(this, Pass);

                this._rootBuffer = null;
                this._rootBufferDirty = false;
                this._buffers = [];
                this._descriptorSet = null;
                this._passIndex = 0;
                this._propertyIndex = 0;
                this._programName = '';
                this._dynamics = {};
                this._propertyHandleMap = {};
                this._rootBlock = null;
                this._blocks = [];
                this._shaderInfo = null;
                this._defines = {};
                this._properties = {};
                this._root = void 0;
                this._device = void 0;
                this._hShaderDefault = NULL_HANDLE;
                this._handle = NULL_HANDLE;
                this._root = root;
                this._device = root.device;
              }
              /**
               * @en Initialize the pass with given pass info, shader will be compiled in the init process
               * @zh 根据指定参数初始化当前 pass，shader 会在这一阶段就尝试编译。
               */


              _createClass(Pass, [{
                key: "initialize",
                value: function initialize(info) {
                  this._doInit(info);

                  this.resetUBOs();
                  this.resetTextures();
                  this.tryCompile();
                }
                /**
                 * @en Get the handle of a UBO member, or specific channels of it.
                 * @zh 获取指定 UBO 成员，或其更具体分量的读写句柄。默认以成员自身的类型为目标读写类型（即读写时必须传入与成员类型相同的变量）。
                 * @param name Name of the target UBO member.
                 * @param offset Channel offset into the member.
                 * @param targetType Target type of the handle, i.e. the type of data when read/write to it.
                 * @example
                 * ```
                 * import { Vec3, GFXType } from 'cc';
                 * // say 'pbrParams' is a uniform vec4
                 * const hParams = pass.getHandle('pbrParams'); // get the default handle
                 * pass.setUniform(hAlbedo, new Vec3(1, 0, 0)); // wrong! pbrParams.w is NaN now
                 *
                 * // say 'albedoScale' is a uniform vec4, and we only want to modify the w component in the form of a single float
                 * const hThreshold = pass.getHandle('albedoScale', 3, GFXType.FLOAT);
                 * pass.setUniform(hThreshold, 0.5); // now, albedoScale.w = 0.5
                 * ```
                 */

              }, {
                key: "getHandle",
                value: function getHandle(name) {
                  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                  var targetType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : GFXType.UNKNOWN;
                  var handle = this._propertyHandleMap[name];

                  if (!handle) {
                    return 0;
                  }

                  if (targetType) {
                    handle = customizeType(handle, targetType);
                  } else if (offset) {
                    handle = customizeType(handle, getTypeFromHandle(handle) - offset);
                  }

                  return handle + offset;
                }
                /**
                 * @en Gets the uniform binding with its name
                 * @zh 获取指定 uniform 的 binding。
                 * @param name The name of target uniform
                 */

              }, {
                key: "getBinding",
                value: function getBinding(name) {
                  var handle = this.getHandle(name);

                  if (!handle) {
                    return -1;
                  }

                  return Pass.getBindingFromHandle(handle);
                }
                /**
                 * @en Sets a vector type uniform value, if a uniform requires frequent update, please use this method.
                 * @zh 设置指定普通向量类 uniform 的值，如果需要频繁更新请尽量使用此接口。
                 * @param handle The handle for the target uniform
                 * @param value New value
                 */

              }, {
                key: "setUniform",
                value: function setUniform(handle, value) {
                  var binding = Pass.getBindingFromHandle(handle);
                  var type = Pass.getTypeFromHandle(handle);
                  var ofs = Pass.getOffsetFromHandle(handle);
                  var block = this._blocks[binding];
                  type2writer[type](block, value, ofs);
                  this._rootBufferDirty = true;
                }
                /**
                 * @en Gets a uniform's value.
                 * @zh 获取指定普通向量类 uniform 的值。
                 * @param handle The handle for the target uniform
                 * @param out The output property to store the result
                 */

              }, {
                key: "getUniform",
                value: function getUniform(handle, out) {
                  var binding = Pass.getBindingFromHandle(handle);
                  var type = Pass.getTypeFromHandle(handle);
                  var ofs = Pass.getOffsetFromHandle(handle);
                  var block = this._blocks[binding];
                  return type2reader[type](block, out, ofs);
                }
                /**
                 * @en Sets an array type uniform value, if a uniform requires frequent update, please use this method.
                 * @zh 设置指定数组类 uniform 的值，如果需要频繁更新请尽量使用此接口。
                 * @param handle The handle for the target uniform
                 * @param value New value
                 */

              }, {
                key: "setUniformArray",
                value: function setUniformArray(handle, value) {
                  var binding = Pass.getBindingFromHandle(handle);
                  var type = Pass.getTypeFromHandle(handle);
                  var stride = GFXGetTypeSize(type) >> 2;
                  var block = this._blocks[binding];
                  var ofs = Pass.getOffsetFromHandle(handle);

                  for (var i = 0; i < value.length; i++, ofs += stride) {
                    if (value[i] === null) {
                      continue;
                    }

                    type2writer[type](block, value[i], ofs);
                  }

                  this._rootBufferDirty = true;
                }
                /**
                 * @en Bind a [[GFXTexture]] the the given uniform binding
                 * @zh 绑定实际 [[GFXTexture]] 到指定 binding。
                 * @param binding The binding for target uniform of texture type
                 * @param value Target texture
                 */

              }, {
                key: "bindTexture",
                value: function bindTexture(binding, value, index) {
                  this._descriptorSet.bindTexture(binding, value, index);
                }
                /**
                 * @en Bind a [[GFXSampler]] the the given uniform binding
                 * @zh 绑定实际 [[GFXSampler]] 到指定 binding。
                 * @param binding The binding for target uniform of sampler type
                 * @param value Target sampler
                 */

              }, {
                key: "bindSampler",
                value: function bindSampler(binding, value, index) {
                  this._descriptorSet.bindSampler(binding, value, index);
                }
                /**
                 * @en Sets the dynamic pipeline state property at runtime
                 * @zh 设置运行时 pass 内可动态更新的管线状态属性。
                 * @param state Target dynamic state
                 * @param value Target value
                 */

              }, {
                key: "setDynamicState",
                value: function setDynamicState(state, value) {
                  var ds = this._dynamics[state];

                  if (ds && ds.value === value) {
                    return;
                  }

                  ds.value = value;
                  ds.dirty = true;
                }
                /**
                 * @en Override all pipeline states with the given pass override info.
                 * @zh 重载当前所有管线状态。
                 * @param original The original pass info
                 * @param value The override pipeline state info
                 */

              }, {
                key: "overridePipelineStates",
                value: function overridePipelineStates(original, overrides) {
                  console.warn('base pass cannot override states, please use pass instance instead.');
                }
                /**
                 * @en Update the current uniforms data.
                 * @zh 更新当前 Uniform 数据。
                 */

              }, {
                key: "update",
                value: function update() {
                  if (this._rootBufferDirty && this._rootBuffer) {
                    this._rootBuffer.update(this._rootBlock);

                    this._rootBufferDirty = false;
                  }

                  this._descriptorSet.update();
                }
                /**
                 * @en Destroy the current pass.
                 * @zh 销毁当前 pass。
                 */

              }, {
                key: "destroy",
                value: function destroy() {
                  for (var i = 0; i < this._shaderInfo.blocks.length; i++) {
                    var u = this._shaderInfo.blocks[i];

                    if (isBuiltinBinding(u.set)) {
                      continue;
                    }

                    this._buffers[u.binding].destroy();
                  }

                  this._buffers = [];

                  if (this._rootBuffer) {
                    this._rootBuffer.destroy();

                    this._rootBlock = null;
                  } // textures are reused


                  this._descriptorSet = null;

                  if (this._handle) {
                    RasterizerStatePool.free(PassPool.get(this._handle, PassView.RASTERIZER_STATE));
                    DepthStencilStatePool.free(PassPool.get(this._handle, PassView.DEPTH_STENCIL_STATE));
                    BlendStatePool.free(PassPool.get(this._handle, PassView.BLEND_STATE));
                    DSPool.free(PassPool.get(this._handle, PassView.DESCRIPTOR_SET));
                    PassPool.free(this._handle);
                    this._handle = NULL_HANDLE;
                  }
                }
                /**
                 * @en Resets the value of the given uniform by name to the default value in [[EffectAsset]].
                 * This method does not support array type uniform.
                 * @zh 重置指定（非数组） Uniform 为 [[EffectAsset]] 默认值。
                 */

              }, {
                key: "resetUniform",
                value: function resetUniform(name) {
                  var handle = this.getHandle(name);
                  if (!handle) return;
                  var type = Pass.getTypeFromHandle(handle);
                  var binding = Pass.getBindingFromHandle(handle);
                  var ofs = Pass.getOffsetFromHandle(handle);
                  var block = this._blocks[binding];
                  var info = this._properties[name];
                  var value = info && info.value || getDefaultFromType(type);
                  type2writer[type](block, value, ofs);
                  this._rootBufferDirty = true;
                }
                /**
                 * @en Resets the value of the given texture by name to the default value in [[EffectAsset]].
                 * @zh 重置指定贴图为 [[EffectAsset]] 默认值。
                 */

              }, {
                key: "resetTexture",
                value: function resetTexture(name, index) {
                  var handle = this.getHandle(name);
                  if (!handle) return;
                  var type = Pass.getTypeFromHandle(handle);
                  var binding = Pass.getBindingFromHandle(handle);
                  var info = this._properties[name];
                  var value = info && info.value;
                  var texName = value ? value + '-texture' : getDefaultFromType(type);
                  var textureBase = builtinResMgr.get(texName);
                  var texture = textureBase && textureBase.getGFXTexture();
                  var samplerHash = info && info.samplerHash !== undefined ? info.samplerHash : textureBase && textureBase.getSamplerHash();
                  var sampler = samplerLib.getSampler(this._device, samplerHash);

                  this._descriptorSet.bindSampler(binding, sampler, index);

                  this._descriptorSet.bindTexture(binding, texture, index);
                }
                /**
                 * @en Resets all uniform buffer objects to the default values in [[EffectAsset]]
                 * @zh 重置所有 UBO 为默认值。
                 */

              }, {
                key: "resetUBOs",
                value: function resetUBOs() {
                  for (var i = 0; i < this._shaderInfo.blocks.length; i++) {
                    var u = this._shaderInfo.blocks[i];

                    if (isBuiltinBinding(u.set)) {
                      continue;
                    }

                    var block = this._blocks[u.binding];
                    var ofs = 0;

                    for (var j = 0; j < u.members.length; j++) {
                      var cur = u.members[j];
                      var info = this._properties[cur.name];
                      var givenDefault = info && info.value;
                      var value = givenDefault ? givenDefault : getDefaultFromType(cur.type);
                      var size = (GFXGetTypeSize(cur.type) >> 2) * cur.count;

                      for (var k = 0; k + value.length <= size; k += value.length) {
                        block.set(value, ofs + k);
                      }

                      ofs += size;
                    }
                  }

                  this._rootBufferDirty = true;
                }
                /**
                 * @en Resets all textures and samplers to the default values in [[EffectAsset]]
                 * @zh 重置所有 texture 和 sampler 为初始默认值。
                 */

              }, {
                key: "resetTextures",
                value: function resetTextures() {
                  for (var i = 0; i < this._shaderInfo.samplers.length; i++) {
                    var u = this._shaderInfo.samplers[i];

                    if (isBuiltinBinding(u.set)) {
                      continue;
                    }

                    for (var j = 0; j < u.count; j++) {
                      this.resetTexture(u.name, j);
                    }
                  }
                }
                /**
                 * @en Try to compile the shader and retrieve related resources references.
                 * @zh 尝试编译 shader 并获取相关资源引用。
                 */

              }, {
                key: "tryCompile",
                value: function tryCompile() {
                  var pipeline = this._root.pipeline;

                  if (!pipeline) {
                    return null;
                  }

                  this._syncBatchingScheme();

                  this._hShaderDefault = programLib.getGFXShader(this._device, this._programName, this._defines, pipeline);

                  if (!this._hShaderDefault) {
                    console.warn("create shader ".concat(this._programName, " failed"));
                    return false;
                  }

                  PassPool.set(this._handle, PassView.PIPELINE_LAYOUT, programLib.getPipelineLayout(this._programName).hPipelineLayout);
                  PassPool.set(this._handle, PassView.HASH, Pass.getPassHash(this._handle, this._hShaderDefault));
                  return true;
                }
                /**
                 * @en Gets the shader variant of the current pass and given macro patches
                 * @zh 结合指定的编译宏组合获取当前 Pass 的 Shader Variant
                 * @param patches The macro patches
                 */

              }, {
                key: "getShaderVariant",
                value: function getShaderVariant() {
                  var patches = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

                  if (!this._hShaderDefault && !this.tryCompile()) {
                    console.warn("pass resources incomplete");
                    return NULL_HANDLE;
                  }

                  if (!patches) {
                    return this._hShaderDefault;
                  }

                  var pipeline = this._root.pipeline;

                  for (var _i = 0; _i < patches.length; _i++) {
                    var patch = patches[_i];
                    this._defines[patch.name] = patch.value;
                  }

                  var hShader = programLib.getGFXShader(this._device, this._programName, this._defines, pipeline);

                  for (var _i2 = 0; _i2 < patches.length; _i2++) {
                    var _patch = patches[_i2];
                    delete this._defines[_patch.name];
                  }

                  return hShader;
                } // internal use

                /**
                 * @private
                 */

              }, {
                key: "beginChangeStatesSilently",
                value: function beginChangeStatesSilently() {}
                /**
                 * @private
                 */

              }, {
                key: "endChangeStatesSilently",
                value: function endChangeStatesSilently() {}
              }, {
                key: "_doInit",
                value: function _doInit(info) {
                  var copyDefines = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                  var handle = this._handle = PassPool.alloc();
                  PassPool.set(handle, PassView.PRIORITY, RenderPriority.DEFAULT);
                  PassPool.set(handle, PassView.STAGE, RenderPassStage.DEFAULT);
                  PassPool.set(handle, PassView.PHASE, getPhaseID('default'));
                  PassPool.set(handle, PassView.PRIMITIVE, GFXPrimitiveMode.TRIANGLE_LIST);
                  PassPool.set(handle, PassView.RASTERIZER_STATE, RasterizerStatePool.alloc());
                  PassPool.set(handle, PassView.DEPTH_STENCIL_STATE, DepthStencilStatePool.alloc());
                  PassPool.set(handle, PassView.BLEND_STATE, BlendStatePool.alloc());
                  this._passIndex = info.passIndex;
                  this._propertyIndex = info.propertyIndex !== undefined ? info.propertyIndex : info.passIndex;
                  this._programName = info.program;
                  this._defines = copyDefines ? Object.assign({}, info.defines) : info.defines;
                  this._shaderInfo = programLib.getTemplate(info.program);
                  this._properties = info.properties || this._properties; // pipeline state

                  var device = this._device;
                  Pass.fillPipelineInfo(handle, info);

                  if (info.stateOverrides) {
                    Pass.fillPipelineInfo(handle, info.stateOverrides);
                  } // init descriptor set


                  var setLayouts = programLib.getPipelineLayout(info.program).setLayouts;

                  if (!setLayouts[SetIndex.MATERIAL]) {
                    setLayouts[SetIndex.MATERIAL] = device.createDescriptorSetLayout({
                      bindings: this._shaderInfo.bindings
                    });
                  }

                  _dsInfo.layout = setLayouts[SetIndex.MATERIAL];
                  var dsHandle = DSPool.alloc(this._device, _dsInfo);
                  PassPool.set(this._handle, PassView.DESCRIPTOR_SET, dsHandle);
                  this._descriptorSet = DSPool.get(dsHandle); // calculate total size required

                  var blocks = this._shaderInfo.blocks;
                  var alignment = device.uboOffsetAlignment;
                  var startOffsets = [];
                  var lastSize = 0;
                  var lastOffset = 0;

                  for (var i = 0; i < blocks.length; i++) {
                    var _blocks$i = blocks[i],
                        size = _blocks$i.size,
                        set = _blocks$i.set;

                    if (isBuiltinBinding(set)) {
                      continue;
                    }

                    startOffsets.push(lastOffset);
                    lastOffset += Math.ceil(size / alignment) * alignment;
                    lastSize = size;
                  } // create gfx buffer resource


                  var totalSize = startOffsets[startOffsets.length - 1] + lastSize;

                  if (totalSize) {
                    // https://bugs.chromium.org/p/chromium/issues/detail?id=988988
                    _bufferInfo.size = Math.ceil(totalSize / 16) * 16;
                    this._rootBuffer = device.createBuffer(_bufferInfo);
                    this._rootBlock = new ArrayBuffer(totalSize);
                  } // create buffer views


                  for (var _i3 = 0, count = 0; _i3 < blocks.length; _i3++) {
                    var _blocks$_i = blocks[_i3],
                        _size = _blocks$_i.size,
                        _set = _blocks$_i.set,
                        binding = _blocks$_i.binding;

                    if (isBuiltinBinding(_set)) {
                      continue;
                    }

                    _bufferViewInfo.buffer = this._rootBuffer;
                    _bufferViewInfo.offset = startOffsets[count++];
                    _bufferViewInfo.range = Math.ceil(_size / 16) * 16;
                    var bufferView = this._buffers[binding] = device.createBuffer(_bufferViewInfo); // non-builtin UBO data pools, note that the effect compiler
                    // guarantees these bindings to be consecutive, starting from 0 and non-array-typed

                    this._blocks[binding] = new Float32Array(this._rootBlock, _bufferViewInfo.offset, _size / Float32Array.BYTES_PER_ELEMENT);

                    this._descriptorSet.bindBuffer(binding, bufferView);
                  } // store handles


                  var directHandleMap = this._propertyHandleMap = this._shaderInfo.handleMap;
                  var indirectHandleMap = {};

                  for (var name in this._properties) {
                    var prop = this._properties[name];

                    if (!prop.handleInfo) {
                      continue;
                    }

                    indirectHandleMap[name] = this.getHandle.apply(this, prop.handleInfo);
                  }

                  Object.assign(directHandleMap, indirectHandleMap);
                }
              }, {
                key: "_syncBatchingScheme",
                value: function _syncBatchingScheme() {
                  if (this._defines.USE_INSTANCING) {
                    if (this._device.hasFeature(GFXFeature.INSTANCED_ARRAYS)) {
                      PassPool.set(this._handle, PassView.BATCHING_SCHEME, BatchingSchemes.INSTANCING);
                    } else {
                      this._defines.USE_INSTANCING = false;
                      PassPool.set(this._handle, PassView.BATCHING_SCHEME, 0);
                    }
                  } else if (this._defines.USE_BATCHING) {
                    PassPool.set(this._handle, PassView.BATCHING_SCHEME, BatchingSchemes.VB_MERGING);
                  } else {
                    PassPool.set(this._handle, PassView.BATCHING_SCHEME, 0);
                  }
                } // infos

              }, {
                key: "root",
                get: function get() {
                  return this._root;
                }
              }, {
                key: "device",
                get: function get() {
                  return this._device;
                }
              }, {
                key: "shaderInfo",
                get: function get() {
                  return this._shaderInfo;
                }
              }, {
                key: "setLayouts",
                get: function get() {
                  return programLib.getPipelineLayout(this._programName).setLayouts;
                }
              }, {
                key: "program",
                get: function get() {
                  return this._programName;
                }
              }, {
                key: "properties",
                get: function get() {
                  return this._properties;
                }
              }, {
                key: "defines",
                get: function get() {
                  return this._defines;
                }
              }, {
                key: "passIndex",
                get: function get() {
                  return this._passIndex;
                }
              }, {
                key: "propertyIndex",
                get: function get() {
                  return this._propertyIndex;
                } // data

              }, {
                key: "dynamics",
                get: function get() {
                  return this._dynamics;
                }
              }, {
                key: "blocks",
                get: function get() {
                  return this._blocks;
                } // states

              }, {
                key: "handle",
                get: function get() {
                  return this._handle;
                }
              }, {
                key: "priority",
                get: function get() {
                  return PassPool.get(this._handle, PassView.PRIORITY);
                }
              }, {
                key: "primitive",
                get: function get() {
                  return PassPool.get(this._handle, PassView.PRIMITIVE);
                }
              }, {
                key: "stage",
                get: function get() {
                  return PassPool.get(this._handle, PassView.STAGE);
                }
              }, {
                key: "phase",
                get: function get() {
                  return PassPool.get(this._handle, PassView.PHASE);
                }
              }, {
                key: "rasterizerState",
                get: function get() {
                  return RasterizerStatePool.get(PassPool.get(this._handle, PassView.RASTERIZER_STATE));
                }
              }, {
                key: "depthStencilState",
                get: function get() {
                  return DepthStencilStatePool.get(PassPool.get(this._handle, PassView.DEPTH_STENCIL_STATE));
                }
              }, {
                key: "blendState",
                get: function get() {
                  return BlendStatePool.get(PassPool.get(this._handle, PassView.BLEND_STATE));
                }
              }, {
                key: "dynamicStates",
                get: function get() {
                  return PassPool.get(this._handle, PassView.DYNAMIC_STATES);
                }
              }, {
                key: "batchingScheme",
                get: function get() {
                  return PassPool.get(this._handle, PassView.BATCHING_SCHEME);
                }
              }, {
                key: "descriptorSet",
                get: function get() {
                  return this._descriptorSet;
                }
              }, {
                key: "hash",
                get: function get() {
                  return PassPool.get(this._handle, PassView.HASH);
                }
              }]);

              return Pass;
            }());
            Pass.PropertyType = PropertyType;
            Pass.getPropertyTypeFromHandle = getPropertyTypeFromHandle;
            Pass.getTypeFromHandle = getTypeFromHandle;
            Pass.getBindingFromHandle = getBindingFromHandle;
            Pass.getOffsetFromHandle = getOffsetFromHandle;

            function serializeBlendState(bs) {
              var res = ",bs,".concat(bs.isA2C, ",").concat(bs.blendColor);

              for (var _iterator = _createForOfIteratorHelperLoose(bs.targets), _step; !(_step = _iterator()).done;) {
                var t = _step.value;
                res += ",bt,".concat(t.blend, ",").concat(t.blendEq, ",").concat(t.blendAlphaEq, ",").concat(t.blendColorMask);
                res += ",".concat(t.blendSrc, ",").concat(t.blendDst, ",").concat(t.blendSrcAlpha, ",").concat(t.blendDstAlpha);
              }

              return res;
            }

            function serializeRasterizerState(rs) {
              return ',rs,' + rs.cullMode + ',' + rs.depthBias + ',' + rs.isFrontFaceCCW;
            }

            function serializeDepthStencilState(dss) {
              var res = ",dss,".concat(dss.depthTest, ",").concat(dss.depthWrite, ",").concat(dss.depthFunc);
              res += ",".concat(dss.stencilTestFront, ",").concat(dss.stencilFuncFront, ",").concat(dss.stencilRefFront, ",").concat(dss.stencilReadMaskFront);
              res += ",".concat(dss.stencilFailOpFront, ",").concat(dss.stencilZFailOpFront, ",").concat(dss.stencilPassOpFront, ",").concat(dss.stencilWriteMaskFront);
              res += ",".concat(dss.stencilTestBack, ",").concat(dss.stencilFuncBack, ",").concat(dss.stencilRefBack, ",").concat(dss.stencilReadMaskBack);
              res += ",".concat(dss.stencilFailOpBack, ",").concat(dss.stencilZFailOpBack, ",").concat(dss.stencilPassOpBack, ",").concat(dss.stencilWriteMaskBack);
              return res;
            }

            function nearestPOT(num) {
              --num;
              num |= num >> 16;
              num |= num >> 8;
              num |= num >> 4;
              num |= num >> 2;
              num |= num >> 1;
              ++num;
              return num;
            }

            function roundUp(n, alignment) {
              return Math.ceil(n / alignment) * alignment;
            }

            var TextureBufferPool = exports('ap', /*#__PURE__*/function () {
              function TextureBufferPool(device) {
                _classCallCheck(this, TextureBufferPool);

                this._device = void 0;
                this._format = GFXFormat.UNKNOWN;
                this._formatSize = 0;
                this._chunks = [];
                this._chunkCount = 0;
                this._handles = [];
                this._region0 = new GFXBufferTextureCopy();
                this._region1 = new GFXBufferTextureCopy();
                this._region2 = new GFXBufferTextureCopy();
                this._roundUpFn = null;
                this._bufferViewCtor = Uint8Array;
                this._channels = 4;
                this._alignment = 1;
                this._device = device;
              }

              _createClass(TextureBufferPool, [{
                key: "initialize",
                value: function initialize(info) {
                  var formatInfo = GFXFormatInfos[info.format];
                  this._format = info.format;
                  this._formatSize = formatInfo.size;
                  this._channels = formatInfo.count;
                  this._bufferViewCtor = getTypedArrayConstructor(formatInfo);
                  this._roundUpFn = info.roundUpFn || null;
                  this._alignment = info.alignment || 1;

                  if (info.inOrderFree) {
                    this.alloc = this._McDonaldAlloc;
                  }
                }
              }, {
                key: "destroy",
                value: function destroy() {
                  for (var i = 0; i < this._chunkCount; ++i) {
                    var chunk = this._chunks[i];
                    chunk.texture.destroy();
                  }

                  this._chunks.length = 0;
                  this._handles.length = 0;
                }
              }, {
                key: "alloc",
                value: function alloc(size, chunkIdx) {
                  size = roundUp(size, this._alignment);
                  var index = -1;
                  var start = -1;

                  if (chunkIdx !== undefined) {
                    index = chunkIdx;
                    start = this._findAvailableSpace(size, index);
                  }

                  if (start < 0) {
                    for (var i = 0; i < this._chunkCount; ++i) {
                      index = i;
                      start = this._findAvailableSpace(size, index);

                      if (start >= 0) {
                        break;
                      }
                    }
                  }

                  if (start >= 0) {
                    var chunk = this._chunks[index];
                    chunk.start += size;
                    var handle = {
                      chunkIdx: index,
                      start: start,
                      end: start + size,
                      texture: chunk.texture
                    };

                    this._handles.push(handle);

                    return handle;
                  } // create a new one


                  var targetSize = Math.sqrt(size / this._formatSize);
                  var texLength = this._roundUpFn && this._roundUpFn(targetSize, this._formatSize) || Math.max(1024, nearestPOT(targetSize));

                  var newChunk = this._chunks[this.createChunk(texLength)];

                  newChunk.start += size;
                  var texHandle = {
                    chunkIdx: this._chunkCount - 1,
                    start: 0,
                    end: size,
                    texture: newChunk.texture
                  };

                  this._handles.push(texHandle);

                  return texHandle;
                }
              }, {
                key: "free",
                value: function free(handle) {
                  for (var i = 0; i < this._handles.length; ++i) {
                    if (this._handles[i] === handle) {
                      this._chunks[handle.chunkIdx].end = handle.end;

                      this._handles.splice(i, 1);

                      return;
                    }
                  }
                }
              }, {
                key: "createChunk",
                value: function createChunk(length) {
                  var texSize = length * length * this._formatSize;
                  console.info('TextureBufferPool: Allocate chunk ' + this._chunkCount + ', size: ' + texSize + ', format: ' + this._format);

                  var texture = this._device.createTexture({
                    type: GFXTextureType.TEX2D,
                    usage: GFXTextureUsageBit.SAMPLED | GFXTextureUsageBit.TRANSFER_DST,
                    format: this._format,
                    width: length,
                    height: length,
                    levelCount: 1
                  });

                  var chunk = {
                    texture: texture,
                    size: texSize,
                    start: 0,
                    end: texSize
                  };
                  this._chunks[this._chunkCount] = chunk;
                  return this._chunkCount++;
                }
              }, {
                key: "update",
                value: function update(handle, buffer) {
                  var buffers = [];
                  var regions = [];
                  var start = handle.start / this._formatSize;
                  var remainSize = buffer.byteLength / this._formatSize;
                  var offsetX = start % handle.texture.width;
                  var offsetY = Math.floor(start / handle.texture.width);
                  var copySize = Math.min(handle.texture.width - offsetX, remainSize);
                  var begin = 0;

                  if (offsetX > 0) {
                    this._region0.texOffset.x = offsetX;
                    this._region0.texOffset.y = offsetY;
                    this._region0.texExtent.width = copySize;
                    this._region0.texExtent.height = 1;
                    buffers.push(new this._bufferViewCtor(buffer, begin * this._formatSize, copySize * this._channels));
                    regions.push(this._region0);
                    offsetX = 0;
                    offsetY += 1;
                    remainSize -= copySize;
                    begin += copySize;
                  }

                  if (remainSize > 0) {
                    this._region1.texOffset.x = offsetX;
                    this._region1.texOffset.y = offsetY;

                    if (remainSize > handle.texture.width) {
                      this._region1.texExtent.width = handle.texture.width;
                      this._region1.texExtent.height = Math.floor(remainSize / handle.texture.width);
                      copySize = this._region1.texExtent.width * this._region1.texExtent.height;
                    } else {
                      copySize = remainSize;
                      this._region1.texExtent.width = copySize;
                      this._region1.texExtent.height = 1;
                    }

                    buffers.push(new this._bufferViewCtor(buffer, begin * this._formatSize, copySize * this._channels));
                    regions.push(this._region1);
                    offsetX = 0;
                    offsetY += this._region1.texExtent.height;
                    remainSize -= copySize;
                    begin += copySize;
                  }

                  if (remainSize > 0) {
                    this._region2.texOffset.x = offsetX;
                    this._region2.texOffset.y = offsetY;
                    this._region2.texExtent.width = remainSize;
                    this._region2.texExtent.height = 1;
                    buffers.push(new this._bufferViewCtor(buffer, begin * this._formatSize, remainSize * this._channels));
                    regions.push(this._region2);
                  }

                  this._device.copyBuffersToTexture(buffers, handle.texture, regions);
                }
              }, {
                key: "_findAvailableSpace",
                value: function _findAvailableSpace(size, chunkIdx) {
                  var chunk = this._chunks[chunkIdx];
                  var isFound = false;
                  var start = chunk.start;

                  if (start + size <= chunk.size) {
                    isFound = true;
                  } else {
                    start = 0; // try to find from head again

                    var handles = this._handles.filter(function (h) {
                      return h.chunkIdx === chunkIdx;
                    }).sort(function (a, b) {
                      return a.start - b.start;
                    });

                    for (var i = 0; i < handles.length; i++) {
                      var handle = handles[i];

                      if (start + size <= handle.start) {
                        isFound = true;
                        break;
                      }

                      start = handle.end;
                    }

                    if (!isFound && start + size <= chunk.size) {
                      isFound = true;
                    }
                  }

                  return isFound ? start : -1;
                } // [McDonald 12] Efficient Buffer Management

              }, {
                key: "_McDonaldAlloc",
                value: function _McDonaldAlloc(size) {
                  size = roundUp(size, this._alignment);

                  for (var i = 0; i < this._chunkCount; ++i) {
                    var chunk = this._chunks[i];
                    var isFound = false;
                    var start = chunk.start;

                    if (start + size <= chunk.end) {
                      isFound = true;
                    } else if (start > chunk.end) {
                      if (start + size <= chunk.size) {
                        isFound = true;
                      } else if (size <= chunk.end) {
                        // Try to find from head again.
                        chunk.start = start = 0;
                        isFound = true;
                      }
                    } else if (start === chunk.end) {
                      chunk.start = start = 0;
                      chunk.end = chunk.size;

                      if (size <= chunk.end) {
                        isFound = true;
                      }
                    }

                    if (isFound) {
                      chunk.start += size;
                      var handle = {
                        chunkIdx: i,
                        start: start,
                        end: start + size,
                        texture: chunk.texture
                      };

                      this._handles.push(handle);

                      return handle;
                    }
                  } // create a new one


                  var targetSize = Math.sqrt(size / this._formatSize);
                  var texLength = this._roundUpFn && this._roundUpFn(targetSize, this._formatSize) || Math.max(1024, nearestPOT(targetSize));

                  var newChunk = this._chunks[this.createChunk(texLength)];

                  newChunk.start += size;
                  var texHandle = {
                    chunkIdx: this._chunkCount,
                    start: 0,
                    end: size,
                    texture: newChunk.texture
                  };

                  this._handles.push(texHandle);

                  return texHandle;
                }
              }]);

              return TextureBufferPool;
            }());

            var _dec$8, _class$8, _class2$6, _descriptor$5, _descriptor2$3, _descriptor3$3, _class3$3, _temp$8;
            var effects$1 = {};
            /**
             * @en Effect asset is the base template for instantiating material, all effects should be unique globally.
             * All effects are managed in a static map of EffectAsset.
             * @zh Effect 资源，作为材质实例初始化的模板，每个 effect 资源都应是全局唯一的。
             * 所有 Effect 资源都由此类的一个静态对象管理。
             */

            var EffectAsset = exports('b2', (_dec$8 = ccclass('cc.EffectAsset'), _dec$8(_class$8 = (_class2$6 = (_temp$8 = _class3$3 = /*#__PURE__*/function (_Asset) {
              _inherits(EffectAsset, _Asset);

              function EffectAsset() {
                var _getPrototypeOf2;

                var _this;

                _classCallCheck(this, EffectAsset);

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(EffectAsset)).call.apply(_getPrototypeOf2, [this].concat(args)));

                _initializerDefineProperty(_this, "techniques", _descriptor$5, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "shaders", _descriptor2$3, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "combinations", _descriptor3$3, _assertThisInitialized(_this));

                return _this;
              }

              _createClass(EffectAsset, [{
                key: "onLoaded",

                /**
                 * @en The loaded callback which should be invoked by the [[Loader]], will automatically register the effect.
                 * @zh 通过 [[Loader]] 加载完成时的回调，将自动注册 effect 资源。
                 */
                value: function onLoaded() {
                  this.shaders.forEach(function (s) {
                    return programLib.define(s);
                  });

                  {
                    legacyCC.game.once(legacyCC.Game.EVENT_ENGINE_INITED, this._precompile, this);
                  }

                  EffectAsset.register(this);
                }
              }, {
                key: "_precompile",
                value: function _precompile() {
                  var _this2 = this;

                  var root = legacyCC.director.root;

                  var _loop = function _loop(i) {
                    var shader = _this2.shaders[i];
                    var combination = _this2.combinations[i];

                    if (!combination) {
                      return "continue";
                    }

                    Object.keys(combination).reduce(function (out, name) {
                      return out.reduce(function (acc, cur) {
                        var choices = combination[name];
                        var next = [cur].concat(_toConsumableArray(Array(choices.length - 1)).map(function () {
                          return Object.assign({}, cur);
                        }));
                        next.forEach(function (defines, idx) {
                          return defines[name] = choices[idx];
                        });
                        return acc.concat(next);
                      }, []);
                    }, [{}]).forEach(function (defines) {
                      return programLib.getGFXShader(root.device, shader.name, defines, root.pipeline);
                    });
                  };

                  for (var i = 0; i < this.shaders.length; i++) {
                    var _ret = _loop(i);

                    if (_ret === "continue") continue;
                  }
                }
              }], [{
                key: "register",

                /**
                 * @en Register the effect asset to the static map
                 * @zh 将指定 effect 注册到全局管理器。
                 */
                value: function register(asset) {
                  effects$1[asset.name] = asset;
                }
                /**
                 * @en Unregister the effect asset from the static map
                 * @zh 将指定 effect 从全局管理器移除。
                 */

              }, {
                key: "remove",
                value: function remove(name) {
                  if (effects$1[name]) {
                    delete effects$1[name];
                    return;
                  }

                  for (var n in effects$1) {
                    if (effects$1[n]._uuid === name) {
                      delete effects$1[n];
                      return;
                    }
                  }
                }
                /**
                 * @en Get the effect asset by the given name.
                 * @zh 获取指定名字的 effect 资源。
                 */

              }, {
                key: "get",
                value: function get(name) {
                  if (effects$1[name]) {
                    return effects$1[name];
                  }

                  for (var n in effects$1) {
                    if (effects$1[n]._uuid === name) {
                      return effects$1[n];
                    }
                  }

                  return null;
                }
                /**
                 * @en Get all registered effect assets.
                 * @zh 获取所有已注册的 effect 资源。
                 */

              }, {
                key: "getAll",
                value: function getAll() {
                  return effects$1;
                }
              }]);

              return EffectAsset;
            }(Asset), _class3$3._effects = {}, _temp$8), (_descriptor$5 = _applyDecoratedDescriptor(_class2$6.prototype, "techniques", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [];
              }
            }), _descriptor2$3 = _applyDecoratedDescriptor(_class2$6.prototype, "shaders", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [];
              }
            }), _descriptor3$3 = _applyDecoratedDescriptor(_class2$6.prototype, "combinations", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [];
              }
            })), _class2$6)) || _class$8));
            legacyCC.EffectAsset = EffectAsset;

            var _dec$9, _dec2$1, _dec3, _dec4, _dec5, _class$9, _class2$7, _descriptor$6, _descriptor2$4, _temp$9;

            var _colorAttachment = new GFXColorAttachment();

            _colorAttachment.endLayout = GFXTextureLayout.SHADER_READONLY_OPTIMAL;

            var _depthStencilAttachment = new GFXDepthStencilAttachment();

            var passInfo = {
              colorAttachments: [_colorAttachment],
              depthStencilAttachment: _depthStencilAttachment
            };
            var _windowInfo = {
              width: 1,
              height: 1,
              renderPassInfo: passInfo
            };
            /**
             * @en Render texture is a render target for [[Camera]] or [[Canvas]] component, the render pipeline will use its [[RenderWindow]] as the target of the rendering process.
             * @zh 渲染贴图是 [[Camera]] 或 [[Canvas]] 组件的渲染目标对象，渲染管线会使用它的 [[RenderWindow]] 作为渲染的目标窗口。
             */

            var RenderTexture = exports('b6', (_dec$9 = ccclass('cc.RenderTexture'), _dec2$1 = rangeMin(), _dec3 = rangeMax(), _dec4 = rangeMin(), _dec5 = rangeMax(), _dec$9(_class$9 = (_class2$7 = (_temp$9 = /*#__PURE__*/function (_Asset) {
              _inherits(RenderTexture, _Asset);

              function RenderTexture() {
                var _getPrototypeOf2;

                var _this;

                _classCallCheck(this, RenderTexture);

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(RenderTexture)).call.apply(_getPrototypeOf2, [this].concat(args)));

                _initializerDefineProperty(_this, "_width", _descriptor$6, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_height", _descriptor2$4, _assertThisInitialized(_this));

                _this._window = null;
                return _this;
              }

              _createClass(RenderTexture, [{
                key: "initialize",
                value: function initialize(info) {
                  this._name = info.name || '';
                  this._width = info.width;
                  this._height = info.height;

                  this._initWindow(info);
                }
              }, {
                key: "reset",
                value: function reset(info) {
                  // to be consistent with other assets
                  this.initialize(info);
                }
              }, {
                key: "destroy",
                value: function destroy() {
                  if (this._window) {
                    var root = legacyCC.director.root;
                    root.destroyWindow(this._window);
                    this._window = null;
                  }

                  return _get(_getPrototypeOf(RenderTexture.prototype), "destroy", this).call(this);
                }
                /**
                 * @en Resize the render texture
                 * @zh 修改渲染贴图的尺寸
                 * @param width The pixel width
                 * @param height The pixel height
                 */

              }, {
                key: "resize",
                value: function resize(width, height) {
                  this._width = width;
                  this._height = height;

                  if (this._window) {
                    this._window.resize(width, height);
                  }

                  this.emit('resize', this._window);
                } // To be compatible with material property interface

                /**
                 * @en Gets the related [[GFXTexture]] resource, it's also the color attachment for the render window
                 * @zh 获取渲染贴图的 GFX 资源，同时也是渲染窗口所指向的颜色缓冲贴图资源
                 */

              }, {
                key: "getGFXTexture",
                value: function getGFXTexture() {
                  return this._window && this._window.framebuffer.colorTextures[0];
                }
                /**
                 * @en Gets the sampler resource for the render texture
                 * @zh 获取渲染贴图的采样器
                 */

              }, {
                key: "getGFXSampler",
                value: function getGFXSampler() {
                  var root = legacyCC.director.root;
                  return samplerLib.getSampler(root.device, defaultSamplerHash);
                }
              }, {
                key: "onLoaded",
                value: function onLoaded() {
                  this._initWindow();

                  this.loaded = true;
                  this.emit('load');
                }
              }, {
                key: "_initWindow",
                value: function _initWindow(info) {
                  var root = legacyCC.director.root;
                  _windowInfo.title = this._name;
                  _windowInfo.width = this._width;
                  _windowInfo.height = this._height;
                  _windowInfo.renderPassInfo = info && info.passInfo ? info.passInfo : passInfo;

                  if (this._window) {
                    this._window.destroy();

                    this._window.initialize(root.device, _windowInfo);
                  } else {
                    this._window = root.createWindow(_windowInfo);
                  }
                }
              }, {
                key: "width",

                /**
                 * @en The pixel width of the render texture
                 * @zh 渲染贴图的像素宽度
                 */
                get: function get() {
                  return this._width;
                }
                /**
                 * @en The pixel height of the render texture
                 * @zh 渲染贴图的像素高度
                 */

              }, {
                key: "height",
                get: function get() {
                  return this._height;
                }
                /**
                 * @en The render window for the render pipeline, it's created internally and cannot be modified.
                 * @zh 渲染管线所使用的渲染窗口，内部逻辑创建，无法被修改。
                 */

              }, {
                key: "window",
                get: function get() {
                  return this._window;
                }
              }]);

              return RenderTexture;
            }(Asset), _temp$9), (_descriptor$6 = _applyDecoratedDescriptor(_class2$7.prototype, "_width", [serializable, _dec2$1, _dec3], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 1;
              }
            }), _descriptor2$4 = _applyDecoratedDescriptor(_class2$7.prototype, "_height", [serializable, _dec4, _dec5], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 1;
              }
            })), _class2$7)) || _class$9));
            legacyCC.RenderTexture = RenderTexture;

            var _dec$a, _dec2$2, _class$a, _class2$8, _descriptor$7, _descriptor2$5, _descriptor3$4, _descriptor4$2, _descriptor5$2, _temp$a;
            /**
             * @en The basic infos for material initialization.
             * @zh 用来初始化材质的基本信息。
             */

            var Material = exports('b3', (_dec$a = ccclass('cc.Material'), _dec2$2 = type(EffectAsset), _dec$a(_class$a = (_class2$8 = (_temp$a = /*#__PURE__*/function (_Asset) {
              _inherits(Material, _Asset);

              _createClass(Material, [{
                key: "effectAsset",

                /**
                 * @en The current [[EffectAsset]].
                 * @zh 当前使用的 [[EffectAsset]] 资源。
                 */
                get: function get() {
                  return this._effectAsset;
                }
                /**
                 * @en Name of the current [[EffectAsset]].
                 * @zh 当前使用的 [[EffectAsset]] 资源名。
                 */

              }, {
                key: "effectName",
                get: function get() {
                  return this._effectAsset ? this._effectAsset.name : '';
                }
                /**
                 * @en The current technique index.
                 * @zh 当前的 technique 索引。
                 */

              }, {
                key: "technique",
                get: function get() {
                  return this._techIdx;
                }
                /**
                 * @en The passes defined in this material.
                 * @zh 当前正在使用的 pass 数组。
                 */

              }, {
                key: "passes",
                get: function get() {
                  return this._passes;
                }
                /**
                 * @en The hash value of this material.
                 * @zh 材质的 hash。
                 */

              }, {
                key: "hash",
                get: function get() {
                  return this._hash;
                }
                /**
                 * @en The parent material
                 * @zh 父材质
                 */

              }, {
                key: "parent",
                get: function get() {
                  return null;
                }
                /**
                 * @en The owner render component
                 * @zh 该材质所归属的渲染组件
                 */

              }, {
                key: "owner",
                get: function get() {
                  return null;
                }
              }], [{
                key: "getHash",

                /**
                 * @en Get hash for a material
                 * @zh 获取一个材质的哈希值
                 * @param material 
                 */
                value: function getHash(material) {
                  var hash = 0;

                  for (var _iterator = _createForOfIteratorHelperLoose(material.passes), _step; !(_step = _iterator()).done;) {
                    var pass = _step.value;
                    hash ^= pass.hash;
                  }

                  return hash;
                }
              }]);

              function Material() {
                var _this;

                _classCallCheck(this, Material);

                _this = _possibleConstructorReturn(this, _getPrototypeOf(Material).call(this));

                _initializerDefineProperty(_this, "_effectAsset", _descriptor$7, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_techIdx", _descriptor2$5, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_defines", _descriptor3$4, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_states", _descriptor4$2, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_props", _descriptor5$2, _assertThisInitialized(_this));

                _this._passes = [];
                _this._hash = 0;
                _this.loaded = false;
                return _this;
              }
              /**
               * @en Initialize this material with the given information.
               * @zh 根据所给信息初始化这个材质，初始化正常结束后材质即可立即用于渲染。
               * @param info Material description info.
               */


              _createClass(Material, [{
                key: "initialize",
                value: function initialize(info) {
                  if (!this._defines) {
                    this._defines = [];
                  }

                  if (!this._states) {
                    this._states = [];
                  }

                  if (!this._props) {
                    this._props = [];
                  }

                  if (info.technique !== undefined) {
                    this._techIdx = info.technique;
                  }

                  if (info.effectAsset) {
                    this._effectAsset = info.effectAsset;
                  } else if (info.effectName) {
                    this._effectAsset = EffectAsset.get(info.effectName);
                  }

                  if (info.defines) {
                    this._prepareInfo(info.defines, this._defines);
                  }

                  if (info.states) {
                    this._prepareInfo(info.states, this._states);
                  }

                  this._update();
                }
              }, {
                key: "reset",
                value: function reset(info) {
                  // to be consistent with other assets
                  this.initialize(info);
                }
                /**
                 * @en
                 * Destroy the material definitively.<br>
                 * Cannot re-initialize after destroy.<br>
                 * For re-initialize purposes, call [[Material.initialize]] directly.
                 * @zh
                 * 彻底销毁材质，注意销毁后无法重新初始化。<br>
                 * 如需重新初始化材质，不必先调用 destroy。
                 */

              }, {
                key: "destroy",
                value: function destroy() {
                  this._doDestroy();

                  return _get(_getPrototypeOf(Material.prototype), "destroy", this).call(this);
                }
                /**
                 * @en Recompile the shader with the specified macro overrides. Allowed only on material instances.
                 * @zh 使用指定预处理宏重新编译当前 pass（数组）中的 shader。只允许对材质实例执行。
                 * @param overrides The shader macro override values.
                 * @param passIdx The pass to apply to. Will apply to all passes if not specified.
                 */

              }, {
                key: "recompileShaders",
                value: function recompileShaders(overrides, passIdx) {
                  console.warn('Shaders in material asset \'' + this.name + '\' cannot be modified at runtime, please instantiate the material first.');
                }
                /**
                 * @en Override the passes with the specified pipeline states. Allowed only on material instances.
                 * @zh 使用指定管线状态重载当前的 pass（数组）。只允许对材质实例执行。
                 * @param overrides The pipeline state override values.
                 * @param passIdx The pass to apply to. Will apply to all passes if not specified.
                 */

              }, {
                key: "overridePipelineStates",
                value: function overridePipelineStates(overrides, passIdx) {
                  console.warn('Pipeline states in material asset \'' + this.name + '\' cannot be modified at runtime, please instantiate the material first.');
                }
                /**
                 * @en Callback function after material is loaded in [[Loader]]. Initialize the resources automatically.
                 * @zh 通过 [[Loader]] 加载完成时的回调，将自动初始化材质资源。
                 */

              }, {
                key: "onLoaded",
                value: function onLoaded() {
                  this._update();

                  this.loaded = true;
                  this.emit('load');
                }
                /**
                 * @en Reset all the uniforms to the default value specified in [[EffectAsset]].
                 * @zh 重置材质的所有 uniform 参数数据为 [[EffectAsset]] 中的默认初始值。
                 * @param clearPasses Will the rendering data be cleared too?
                 */

              }, {
                key: "resetUniforms",
                value: function resetUniforms() {
                  var clearPasses = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
                  this._props.length = this._passes.length;

                  for (var i = 0; i < this._props.length; i++) {
                    this._props[i] = {};
                  }

                  if (!clearPasses) {
                    return;
                  }

                  for (var _iterator2 = _createForOfIteratorHelperLoose(this._passes), _step2; !(_step2 = _iterator2()).done;) {
                    var pass = _step2.value;
                    pass.resetUBOs();
                    pass.resetTextures();
                  }
                }
                /**
                 * @en
                 * Convenient property setter provided for quick material setup.<br>
                 * [[Pass.setUniform]] should be used instead if you need to do per-frame uniform update.
                 * @zh
                 * 设置材质 uniform 参数的统一入口。<br>
                 * 注意如果需要每帧更新 uniform，建议使用 [[Pass.setUniform]] 以获得更好的性能。
                 * @param name The target uniform name.
                 * @param val The target value.
                 * @param passIdx The pass to apply to. Will apply to all passes if not specified.
                 */

              }, {
                key: "setProperty",
                value: function setProperty(name, val, passIdx) {
                  var success = false;

                  if (passIdx === undefined) {
                    // try set property for all applicable passes
                    var passes = this._passes;
                    var len = passes.length;

                    for (var i = 0; i < len; i++) {
                      var pass = passes[i];

                      if (this._uploadProperty(pass, name, val)) {
                        this._props[pass.propertyIndex][name] = val;
                        success = true;
                      }
                    }
                  } else {
                    if (passIdx >= this._passes.length) {
                      console.warn("illegal pass index: ".concat(passIdx, "."));
                      return;
                    }

                    var _pass = this._passes[passIdx];

                    if (this._uploadProperty(_pass, name, val)) {
                      this._props[_pass.propertyIndex][name] = val;
                      success = true;
                    }
                  }

                  if (!success) {
                    console.warn("illegal property name: ".concat(name, "."));
                    return;
                  }
                }
                /**
                 * @en
                 * Get the specified uniform value for this material.<br>
                 * Note that only uniforms set through [[Material.setProperty]] can be acquired here.<br>
                 * For the complete rendering data, use [[Pass.getUniform]] instead.
                 * @zh
                 * 获取当前材质的指定 uniform 参数的值。<br>
                 * 注意只有通过 [[Material.setProperty]] 函数设置的参数才能从此函数取出，<br>
                 * 如需取出完整的渲染数据，请使用 [[Pass.getUniform]]。
                 * @param name The property or uniform name.
                 * @param passIdx The target pass index. If not specified, return the first found value in all passes.
                 */

              }, {
                key: "getProperty",
                value: function getProperty(name, passIdx) {
                  if (passIdx === undefined) {
                    // try get property in all possible passes
                    var propsArray = this._props;
                    var len = propsArray.length;

                    for (var i = 0; i < len; i++) {
                      var props = propsArray[i];

                      if (name in props) {
                        return props[name];
                      }
                    }
                  } else {
                    if (passIdx >= this._props.length) {
                      console.warn("illegal pass index: ".concat(passIdx, "."));
                      return null;
                    }

                    var _props = this._props[this._passes[passIdx].propertyIndex];

                    if (name in _props) {
                      return _props[name];
                    }
                  }

                  return null;
                }
                /**
                 * @en Copy the target material.
                 * @zh 复制目标材质到当前实例。
                 * @param mat The material to be copied.
                 */

              }, {
                key: "copy",
                value: function copy(mat) {
                  this._techIdx = mat._techIdx;
                  this._props.length = mat._props.length;

                  for (var i = 0; i < mat._props.length; i++) {
                    this._props[i] = Object.assign({}, mat._props[i]);
                  }

                  this._defines.length = mat._defines.length;

                  for (var _i = 0; _i < mat._defines.length; _i++) {
                    this._defines[_i] = Object.assign({}, mat._defines[_i]);
                  }

                  this._states.length = mat._states.length;

                  for (var _i2 = 0; _i2 < mat._states.length; _i2++) {
                    this._states[_i2] = Object.assign({}, mat._states[_i2]);
                  }

                  this._effectAsset = mat._effectAsset;

                  this._update();
                }
              }, {
                key: "_prepareInfo",
                value: function _prepareInfo(patch, cur) {
                  if (!Array.isArray(patch)) {
                    // fill all the passes if not specified
                    var len = this._effectAsset ? this._effectAsset.techniques[this._techIdx].passes.length : 1;
                    patch = Array(len).fill(patch);
                  }

                  for (var i = 0; i < patch.length; ++i) {
                    Object.assign(cur[i] || (cur[i] = {}), patch[i]);
                  }
                }
              }, {
                key: "_createPasses",
                value: function _createPasses() {
                  var tech = this._effectAsset.techniques[this._techIdx || 0];

                  if (!tech) {
                    return [];
                  }

                  var passNum = tech.passes.length;
                  var passes = [];

                  for (var k = 0; k < passNum; ++k) {
                    var passInfo = tech.passes[k];
                    var propIdx = passInfo.passIndex = k;
                    var defines = passInfo.defines = this._defines[propIdx] || (this._defines[propIdx] = {});
                    var states = passInfo.stateOverrides = this._states[propIdx] || (this._states[propIdx] = {});

                    if (passInfo.propertyIndex !== undefined) {
                      Object.assign(defines, this._defines[passInfo.propertyIndex]);
                      Object.assign(states, this._states[passInfo.propertyIndex]);
                    }

                    if (passInfo.embeddedMacros !== undefined) {
                      Object.assign(defines, passInfo.embeddedMacros);
                    }

                    if (passInfo["switch"] && !defines[passInfo["switch"]]) {
                      continue;
                    }

                    var pass = new Pass(legacyCC.director.root);
                    pass.initialize(passInfo);
                    passes.push(pass);
                  }

                  return passes;
                }
              }, {
                key: "_update",
                value: function _update() {
                  var _this2 = this;

                  var keepProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

                  if (this._effectAsset) {
                    if (this._passes && this._passes.length) {
                      for (var _iterator3 = _createForOfIteratorHelperLoose(this._passes), _step3; !(_step3 = _iterator3()).done;) {
                        var pass = _step3.value;
                        pass.destroy();
                      }
                    }

                    this._passes = this._createPasses(); // handle property values

                    var totalPasses = this._effectAsset.techniques[this._techIdx].passes.length;
                    this._props.length = totalPasses;

                    if (keepProps) {
                      this._passes.forEach(function (pass, i) {
                        var props = _this2._props[i];

                        if (!props) {
                          props = _this2._props[i] = {};
                        }

                        props = _this2._props[pass.propertyIndex];

                        for (var p in props) {
                          _this2._uploadProperty(pass, p, props[p]);
                        }
                      });
                    } else {
                      for (var i = 0; i < this._props.length; i++) {
                        this._props[i] = {};
                      }
                    }
                  } else {
                    // ugly yellow indicating missing effect
                    var missing = builtinResMgr.get('missing-effect-material');

                    if (missing) {
                      this._passes = missing._passes.slice();
                    }
                  }

                  this._hash = Material.getHash(this);
                }
              }, {
                key: "_uploadProperty",
                value: function _uploadProperty(pass, name, val) {
                  var handle = pass.getHandle(name);

                  if (!handle) {
                    return false;
                  }

                  var propertyType = Pass.getPropertyTypeFromHandle(handle);

                  if (propertyType === PropertyType.UBO) {
                    if (Array.isArray(val)) {
                      pass.setUniformArray(handle, val);
                    } else if (val !== null) {
                      pass.setUniform(handle, val);
                    } else {
                      pass.resetUniform(name);
                    }
                  } else if (propertyType === PropertyType.SAMPLER) {
                    if (Array.isArray(val)) {
                      for (var i = 0; i < val.length; i++) {
                        this._bindTexture(pass, handle, val[i], i);
                      }
                    } else if (val) {
                      this._bindTexture(pass, handle, val);
                    } else {
                      pass.resetTexture(name);
                    }
                  }

                  return true;
                }
              }, {
                key: "_bindTexture",
                value: function _bindTexture(pass, handle, val, index) {
                  var binding = Pass.getBindingFromHandle(handle);

                  if (val instanceof GFXTexture) {
                    pass.bindTexture(binding, val, index);
                  } else if (val instanceof TextureBase || val instanceof SpriteFrame || val instanceof RenderTexture) {
                    var texture = val.getGFXTexture();

                    if (!texture || !texture.width || !texture.height) {
                      // console.warn(`material '${this._uuid}' received incomplete texture asset '${val._uuid}'`);
                      return false;
                    }

                    pass.bindTexture(binding, texture, index);
                    pass.bindSampler(binding, val.getGFXSampler(), index);
                  }
                }
              }, {
                key: "_doDestroy",
                value: function _doDestroy() {
                  if (this._passes && this._passes.length) {
                    for (var _iterator4 = _createForOfIteratorHelperLoose(this._passes), _step4; !(_step4 = _iterator4()).done;) {
                      var pass = _step4.value;
                      pass.destroy();
                    }
                  }

                  this._effectAsset = null;
                  this._passes.length = 0;
                  this._props.length = 0;
                  this._defines.length = 0;
                  this._states.length = 0;
                }
              }]);

              return Material;
            }(Asset), _temp$a), (_descriptor$7 = _applyDecoratedDescriptor(_class2$8.prototype, "_effectAsset", [_dec2$2], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor2$5 = _applyDecoratedDescriptor(_class2$8.prototype, "_techIdx", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            }), _descriptor3$4 = _applyDecoratedDescriptor(_class2$8.prototype, "_defines", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [];
              }
            }), _descriptor4$2 = _applyDecoratedDescriptor(_class2$8.prototype, "_states", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [];
              }
            }), _descriptor5$2 = _applyDecoratedDescriptor(_class2$8.prototype, "_props", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [];
              }
            })), _class2$8)) || _class$a));
            legacyCC.Material = Material;

            /**
             * @en A pass instance defines an variant version of the [[Pass]]
             * @zh 表示 [[Pass]] 的一种特殊实例
             */

            var PassInstance = exports('ar', /*#__PURE__*/function (_Pass) {
              _inherits(PassInstance, _Pass);

              _createClass(PassInstance, [{
                key: "parent",

                /**
                 * @en The parent pass
                 * @zh 相关联的原始 Pass
                 */
                get: function get() {
                  return this._parent;
                }
              }]);

              function PassInstance(parent, owner) {
                var _this;

                _classCallCheck(this, PassInstance);

                _this = _possibleConstructorReturn(this, _getPrototypeOf(PassInstance).call(this, parent.root));
                _this._parent = void 0;
                _this._owner = void 0;
                _this._dontNotify = false;
                _this._parent = parent;
                _this._owner = owner;

                _this._doInit(_this._parent, true); // defines may change now


                for (var i = 0; i < _this._shaderInfo.blocks.length; i++) {
                  var u = _this._shaderInfo.blocks[i];

                  if (isBuiltinBinding(u.set)) {
                    continue;
                  }

                  var block = _this._blocks[u.binding];
                  var parentBlock = _this._parent.blocks[u.binding];
                  block.set(parentBlock);
                }

                _this._rootBufferDirty = true;
                var paren = _this._parent;

                for (var _i = 0; _i < _this._shaderInfo.samplers.length; _i++) {
                  var _u = _this._shaderInfo.samplers[_i];

                  if (isBuiltinBinding(_u.set)) {
                    continue;
                  }

                  for (var j = 0; j < _u.count; j++) {
                    var sampler = paren._descriptorSet.getSampler(_u.binding, j);

                    var texture = paren._descriptorSet.getTexture(_u.binding, j);

                    _this._descriptorSet.bindSampler(_u.binding, sampler, j);

                    _this._descriptorSet.bindTexture(_u.binding, texture, j);
                  }
                }

                _get(_getPrototypeOf(PassInstance.prototype), "tryCompile", _assertThisInitialized(_this)).call(_assertThisInitialized(_this));

                return _this;
              }
              /**
               * @en Override pipeline states with the given pass override info.
               * This won't affect the original pass
               * @zh 重载当前 Pass 的管线状态。这不会影响原始 Pass
               * @param original The original pass info
               * @param value The override pipeline state info
               */


              _createClass(PassInstance, [{
                key: "overridePipelineStates",
                value: function overridePipelineStates(original, overrides) {
                  BlendStatePool.free(PassPool.get(this._handle, PassView.BLEND_STATE));
                  RasterizerStatePool.free(PassPool.get(this._handle, PassView.RASTERIZER_STATE));
                  DepthStencilStatePool.free(PassPool.get(this._handle, PassView.DEPTH_STENCIL_STATE));
                  PassPool.set(this._handle, PassView.BLEND_STATE, BlendStatePool.alloc());
                  PassPool.set(this._handle, PassView.RASTERIZER_STATE, RasterizerStatePool.alloc());
                  PassPool.set(this._handle, PassView.DEPTH_STENCIL_STATE, DepthStencilStatePool.alloc());
                  Pass.fillPipelineInfo(this._handle, original);
                  Pass.fillPipelineInfo(this._handle, overrides);

                  this._onStateChange();
                }
              }, {
                key: "tryCompile",
                value: function tryCompile(defineOverrides) {
                  if (defineOverrides) {
                    if (!overrideMacros(this._defines, defineOverrides)) {
                      return false;
                    }
                  }

                  var res = _get(_getPrototypeOf(PassInstance.prototype), "tryCompile", this).call(this);

                  this._onStateChange();

                  return res;
                }
                /**
                 * @en Prepare to change states of the pass and do not notify the material to rebuild the pipeline state object
                 * @zh 开始静默修改 Pass 相关状态，不会通知材质去重新构建管线状态对象。
                 */

              }, {
                key: "beginChangeStatesSilently",
                value: function beginChangeStatesSilently() {
                  this._dontNotify = true;
                }
                /**
                 * @en End the silent states changing process, all state changes will be notified.
                 * @zh 结束静默状态修改，所有修改将会开始通知材质。
                 */

              }, {
                key: "endChangeStatesSilently",
                value: function endChangeStatesSilently() {
                  this._dontNotify = false;
                }
              }, {
                key: "_syncBatchingScheme",
                value: function _syncBatchingScheme() {
                  this._defines.USE_BATCHING = this._defines.USE_INSTANCING = false;
                  PassPool.set(this._handle, PassView.BATCHING_SCHEME, 0);
                }
              }, {
                key: "_onStateChange",
                value: function _onStateChange() {
                  PassPool.set(this._handle, PassView.HASH, Pass.getPassHash(this._handle, this._hShaderDefault));

                  this._owner.onPassStateChange(this._dontNotify);
                }
              }]);

              return PassInstance;
            }(Pass));

            /**
             * @zh
             * 材质实例，当有材质修改需求时，根据材质资源创建的，可任意定制的实例。
             */
            var MaterialInstance = exports('aq', /*#__PURE__*/function (_Material) {
              _inherits(MaterialInstance, _Material);

              _createClass(MaterialInstance, [{
                key: "parent",
                get: function get() {
                  return this._parent;
                }
              }, {
                key: "owner",
                get: function get() {
                  return this._owner;
                }
              }]);

              function MaterialInstance(info) {
                var _this;

                _classCallCheck(this, MaterialInstance);

                _this = _possibleConstructorReturn(this, _getPrototypeOf(MaterialInstance).call(this));
                _this._passes = [];
                _this._parent = void 0;
                _this._owner = void 0;
                _this._subModelIdx = 0;
                _this._parent = info.parent;
                _this._owner = info.owner || null;
                _this._subModelIdx = info.subModelIdx || 0;

                _this.copy(_this._parent);

                return _this;
              }

              _createClass(MaterialInstance, [{
                key: "recompileShaders",
                value: function recompileShaders(overrides, passIdx) {
                  if (!this._passes || !this.effectAsset) {
                    return;
                  }

                  if (passIdx === undefined) {
                    for (var _iterator = _createForOfIteratorHelperLoose(this._passes), _step; !(_step = _iterator()).done;) {
                      var pass = _step.value;
                      pass.tryCompile(overrides);
                    }
                  } else {
                    this._passes[passIdx].tryCompile(overrides);
                  }
                }
              }, {
                key: "overridePipelineStates",
                value: function overridePipelineStates(overrides, passIdx) {
                  if (!this._passes || !this.effectAsset) {
                    return;
                  }

                  var passInfos = this.effectAsset.techniques[this.technique].passes;

                  if (passIdx === undefined) {
                    for (var i = 0; i < this._passes.length; i++) {
                      var pass = this._passes[i];
                      var state = this._states[i] || (this._states[i] = {});

                      for (var key in overrides) {
                        state[key] = overrides[key];
                      }

                      pass.overridePipelineStates(passInfos[pass.passIndex], state);
                    }
                  } else {
                    var _state = this._states[passIdx] || (this._states[passIdx] = {});

                    for (var _key in overrides) {
                      _state[_key] = overrides[_key];
                    }

                    this._passes[passIdx].overridePipelineStates(passInfos[passIdx], _state);
                  }
                }
              }, {
                key: "destroy",
                value: function destroy() {
                  this._doDestroy();

                  return true;
                }
              }, {
                key: "onPassStateChange",
                value: function onPassStateChange(dontNotify) {
                  this._hash = Material.getHash(this);

                  if (!dontNotify && this._owner) {
                    // @ts-ignore
                    this._owner._onRebuildPSO(this._subModelIdx, this);
                  }
                }
              }, {
                key: "_createPasses",
                value: function _createPasses() {
                  var passes = [];
                  var parentPasses = this._parent.passes;

                  if (!parentPasses) {
                    return passes;
                  }

                  for (var k = 0; k < parentPasses.length; ++k) {
                    passes.push(new PassInstance(parentPasses[k], this));
                  }

                  return passes;
                }
              }]);

              return MaterialInstance;
            }(Material));

            /**
             * @category event
             */
            /**
             * @en The event type supported by SystemEvent and Node events
             * @zh SystemEvent 支持的事件类型以及节点事件类型
             */

            var SystemEventType;

            (function (SystemEventType) {
              SystemEventType["TOUCH_START"] = "touch-start";
              SystemEventType["TOUCH_MOVE"] = "touch-move";
              SystemEventType["TOUCH_END"] = "touch-end";
              SystemEventType["TOUCH_CANCEL"] = "touch-cancel";
              SystemEventType["MOUSE_DOWN"] = "mouse-down";
              SystemEventType["MOUSE_MOVE"] = "mouse-move";
              SystemEventType["MOUSE_UP"] = "mouse-up";
              SystemEventType["MOUSE_WHEEL"] = "mouse-wheel";
              SystemEventType["MOUSE_ENTER"] = "mouse-enter";
              SystemEventType["MOUSE_LEAVE"] = "mouse-leave";
              SystemEventType["KEY_DOWN"] = "keydown";
              SystemEventType["KEY_UP"] = "keyup";
              SystemEventType["DEVICEMOTION"] = "devicemotion";
              SystemEventType["TRANSFORM_CHANGED"] = "transform-changed";
              SystemEventType["SCENE_CHANGED_FOR_PERSISTS"] = "scene-changed-for-persists";
              SystemEventType["SIZE_CHANGED"] = "size-changed";
              SystemEventType["ANCHOR_CHANGED"] = "anchor-changed";
              SystemEventType["CHILD_ADDED"] = "child-added";
              SystemEventType["CHILD_REMOVED"] = "child-removed";
              SystemEventType["PARENT_CHANGED"] = "parent-changed";
              SystemEventType["NODE_DESTROYED"] = "node-destroyed";
            })(SystemEventType || (SystemEventType = exports('bg', {})));

            ccenum(SystemEventType);
            legacyCC.SystemEventType = SystemEventType;

            var _vec2 = new Vec2();
            /**
             * @en The mouse event
             * @zh 鼠标事件类型
             */


            var EventMouse = exports('bb', /*#__PURE__*/function (_Event) {
              _inherits(EventMouse, _Event);

              // Inner event types of MouseEvent

              /**
               * @en The none event code of mouse event.
               * @zh 无效事件代码
               */

              /**
               * @en The event code of mouse down event.
               * @zh 鼠标按下事件代码。
               */

              /**
               * @en The event code of mouse up event.
               * @zh 鼠标按下后释放事件代码。
               */

              /**
               * @en The event code of mouse move event.
               * @zh 鼠标移动事件。
               */

              /**
               * @en The event code of mouse scroll event.
               * @zh 鼠标滚轮事件。
               */

              /**
               * @en The default tag when no button is pressed
               * @zh 按键默认的缺省状态
               */

              /**
               * @en The tag of mouse's left button.
               * @zh 鼠标左键的标签。
               */

              /**
               * @en The tag of mouse's right button  (The right button number is 2 on browser).
               * @zh 鼠标右键的标签。
               */

              /**
               * @en The tag of mouse's middle button.
               * @zh 鼠标中键的标签。
               */

              /**
               * @en The tag of mouse's button 4.
               * @zh 鼠标按键 4 的标签。
               */

              /**
               * @en The tag of mouse's button 5.
               * @zh 鼠标按键 5 的标签。
               */

              /**
               * @en The tag of mouse's button 6.
               * @zh 鼠标按键 6 的标签。
               */

              /**
               * @en The tag of mouse's button 7.
               * @zh 鼠标按键 7 的标签。
               */

              /**
               * @en The tag of mouse's button 8.
               * @zh 鼠标按键 8 的标签。
               */

              /**
               * @en Mouse movement on x axis of the UI coordinate system.
               * @zh 鼠标在 UI 坐标系下 X 轴上的移动距离
               */

              /**
               * @en Mouse movement on y axis of the UI coordinate system.
               * @zh 鼠标在 UI 坐标系下 Y 轴上的移动距离
               */

              /**
               * @en The type of the event, possible values are UP, DOWN, MOVE, SCROLL
               * @zh 鼠标事件类型，可以是 UP, DOWN, MOVE, CANCELED。
               */

              /**
               * @param eventType - The type of the event, possible values are UP, DOWN, MOVE, SCROLL
               * @param bubbles - Indicate whether the event bubbles up through the hierarchy or not.
               */
              function EventMouse(eventType, bubbles, prevLoc) {
                var _this;

                _classCallCheck(this, EventMouse);

                _this = _possibleConstructorReturn(this, _getPrototypeOf(EventMouse).call(this, Event.MOUSE, bubbles));
                _this.movementX = 0;
                _this.movementY = 0;
                _this.eventType = void 0;
                _this._button = EventMouse.BUTTON_MISSING;
                _this._x = 0;
                _this._y = 0;
                _this._prevX = 0;
                _this._prevY = 0;
                _this._scrollX = 0;
                _this._scrollY = 0;
                _this.eventType = eventType;

                if (prevLoc) {
                  _this._prevX = prevLoc.x;
                  _this._prevY = prevLoc.y;
                }

                return _this;
              }
              /**
               * @en Sets scroll data of the mouse.
               * @zh 设置鼠标滚轮的滚动数据。
               * @param scrollX - The scroll value on x axis
               * @param scrollY - The scroll value on y axis
               */


              _createClass(EventMouse, [{
                key: "setScrollData",
                value: function setScrollData(scrollX, scrollY) {
                  this._scrollX = scrollX;
                  this._scrollY = scrollY;
                }
                /**
                 * @en Returns the scroll value on x axis.
                 * @zh 获取鼠标滚动的 X 轴距离，只有滚动时才有效。
                 */

              }, {
                key: "getScrollX",
                value: function getScrollX() {
                  return this._scrollX;
                }
                /**
                 * @en Returns the scroll value on y axis.
                 * @zh 获取滚轮滚动的 Y 轴距离，只有滚动时才有效。
                 */

              }, {
                key: "getScrollY",
                value: function getScrollY() {
                  return this._scrollY;
                }
                /**
                 * @en Sets cursor location.
                 * @zh 设置当前鼠标位置。
                 * @param x - The location on x axis
                 * @param y - The location on y axis
                 */

              }, {
                key: "setLocation",
                value: function setLocation(x, y) {
                  this._x = x;
                  this._y = y;
                }
                /**
                 * @en Returns cursor location.
                 * @zh 获取鼠标相对于左下角位置对象，对象包含 x 和 y 属性。
                 * @param out - Pass the out object to avoid object creation, very good practice
                 */

              }, {
                key: "getLocation",
                value: function getLocation(out) {
                  if (!out) {
                    out = new Vec2();
                  }

                  Vec2.set(out, this._x, this._y);
                  return out;
                }
                /**
                 * @en Returns the current cursor location in game view coordinates.
                 * @zh 获取当前事件在游戏窗口内的坐标位置对象，对象包含 x 和 y 属性。
                 * @param out - Pass the out object to avoid object creation, very good practice
                 */

              }, {
                key: "getLocationInView",
                value: function getLocationInView(out) {
                  if (!out) {
                    out = new Vec2();
                  }

                  Vec2.set(out, this._x, legacyCC.view._designResolutionSize.height - this._y);
                  return out;
                }
                /**
                 * @en Returns the current cursor location in ui coordinates.
                 * @zh 获取当前事件在 UI 窗口内的坐标位置，对象包含 x 和 y 属性。
                 * @param out - Pass the out object to avoid object creation, very good practice
                 */

              }, {
                key: "getUILocation",
                value: function getUILocation(out) {
                  if (!out) {
                    out = new Vec2();
                  }

                  Vec2.set(out, this._x, this._y);

                  legacyCC.view._convertPointWithScale(out);

                  return out;
                }
                /**
                 * @en Returns the previous touch location.
                 * @zh 获取鼠标点击在上一次事件时的位置对象，对象包含 x 和 y 属性。
                 * @param out - Pass the out object to avoid object creation, very good practice
                 */

              }, {
                key: "getPreviousLocation",
                value: function getPreviousLocation(out) {
                  if (!out) {
                    out = new Vec2();
                  }

                  Vec2.set(out, this._prevX, this._prevY);
                  return out;
                }
                /**
                 * @en Returns the previous touch location.
                 * @zh 获取鼠标点击在上一次事件时的位置对象，对象包含 x 和 y 属性。
                 * @param out - Pass the out object to avoid object creation, very good practice
                 */

              }, {
                key: "getUIPreviousLocation",
                value: function getUIPreviousLocation(out) {
                  if (!out) {
                    out = new Vec2();
                  }

                  Vec2.set(out, this._prevX, this._prevY);

                  legacyCC.view._convertPointWithScale(out);

                  return out;
                }
                /**
                 * @en Returns the delta distance from the previous location to current location.
                 * @zh 获取鼠标距离上一次事件移动的距离对象，对象包含 x 和 y 属性。
                 * @param out - Pass the out object to avoid object creation, very good practice
                 */

              }, {
                key: "getDelta",
                value: function getDelta(out) {
                  if (!out) {
                    out = new Vec2();
                  }

                  Vec2.set(out, this._x - this._prevX, this._y - this._prevY);
                  return out;
                }
                /**
                 * @en Returns the X axis delta distance from the previous location to current location.
                 * @zh 获取鼠标距离上一次事件移动的 X 轴距离。
                 */

              }, {
                key: "getDeltaX",
                value: function getDeltaX() {
                  return this._x - this._prevX;
                }
                /**
                 * @en Returns the Y axis delta distance from the previous location to current location.
                 * @zh 获取鼠标距离上一次事件移动的 Y 轴距离。
                 */

              }, {
                key: "getDeltaY",
                value: function getDeltaY() {
                  return this._y - this._prevY;
                }
                /**
                 * @en Returns the delta distance from the previous location to current location in the UI coordinates.
                 * @zh 获取鼠标距离上一次事件移动在 UI 坐标系下的距离对象，对象包含 x 和 y 属性。
                 * @param out - Pass the out object to avoid object creation, very good practice
                 */

              }, {
                key: "getUIDelta",
                value: function getUIDelta(out) {
                  if (!out) {
                    out = new Vec2();
                  }

                  Vec2.set(out, (this._x - this._prevX) / legacyCC.view.getScaleX(), (this._y - this._prevY) / legacyCC.view.getScaleY());
                  return out;
                }
                /**
                 * @en Returns the X axis delta distance from the previous location to current location in the UI coordinates.
                 * @zh 获取鼠标距离上一次事件移动在 UI 坐标系下的 X 轴距离。
                 */

              }, {
                key: "getUIDeltaX",
                value: function getUIDeltaX() {
                  return (this._x - this._prevX) / legacyCC.view.getScaleX();
                }
                /**
                 * @en Returns the Y axis delta distance from the previous location to current location in the UI coordinates.
                 * @zh 获取鼠标距离上一次事件移动在 UI 坐标系下的 Y 轴距离。
                 */

              }, {
                key: "getUIDeltaY",
                value: function getUIDeltaY() {
                  return (this._y - this._prevY) / legacyCC.view.getScaleY();
                }
                /**
                 * @en Sets mouse button code.
                 * @zh 设置鼠标按键。
                 * @param button - The button code
                 */

              }, {
                key: "setButton",
                value: function setButton(button) {
                  this._button = button;
                }
                /**
                 * @en Returns mouse button code.
                 * @zh 获取鼠标按键。
                 */

              }, {
                key: "getButton",
                value: function getButton() {
                  return this._button;
                }
                /**
                 * @en Returns location data on X axis.
                 * @zh 获取鼠标当前 X 轴位置。
                 */

              }, {
                key: "getLocationX",
                value: function getLocationX() {
                  return this._x;
                }
                /**
                 * @en Returns location data on Y axis.
                 * @zh 获取鼠标当前 Y 轴位置。
                 */

              }, {
                key: "getLocationY",
                value: function getLocationY() {
                  return this._y;
                }
                /**
                 * @en Returns location data on X axis.
                 * @zh 获取鼠标当前 X 轴位置。
                 */

              }, {
                key: "getUILocationX",
                value: function getUILocationX() {
                  var viewport = legacyCC.view.getViewportRect();
                  return (this._x - viewport.x) / legacyCC.view.getScaleX();
                }
                /**
                 * @en Returns location data on Y axis.
                 * @zh 获取鼠标当前 Y 轴位置。
                 */

              }, {
                key: "getUILocationY",
                value: function getUILocationY() {
                  var viewport = legacyCC.view.getViewportRect();
                  return (this._y - viewport.y) / legacyCC.view.getScaleY();
                }
              }]);

              return EventMouse;
            }(Event));
            /**
             * @en
             * The touch event.
             *
             * @zh
             * 触摸事件。
             */

            EventMouse.NONE = 0;
            EventMouse.DOWN = 1;
            EventMouse.UP = 2;
            EventMouse.MOVE = 3;
            EventMouse.SCROLL = 4;
            EventMouse.BUTTON_MISSING = -1;
            EventMouse.BUTTON_LEFT = 0;
            EventMouse.BUTTON_RIGHT = 2;
            EventMouse.BUTTON_MIDDLE = 1;
            EventMouse.BUTTON_4 = 3;
            EventMouse.BUTTON_5 = 4;
            EventMouse.BUTTON_6 = 5;
            EventMouse.BUTTON_7 = 6;
            EventMouse.BUTTON_8 = 7;
            var EventTouch = exports('bc', /*#__PURE__*/function (_Event2) {
              _inherits(EventTouch, _Event2);

              /**
               * @en The maximum touch point numbers simultaneously
               * @zh 同时存在的最大触点数量。
               */

              /**
               * @en The event type code of touch began event.
               * @zh 开始触摸事件。
               */

              /**
               * @en The event type code of touch moved event.
               * @zh 触摸后移动事件。
               */

              /**
               * @en The event type code of touch ended event.
               * @zh 结束触摸事件。
               */

              /**
               * @en The event type code of touch canceled event.
               * @zh 取消触摸事件。
               */

              /**
               * @en The current touch object
               * @zh 当前触点对象
               */

              /**
               * @en Indicate whether the touch event is simulated or real
               * @zh 表示触摸事件是真实触点触发的还是模拟的
               */

              /**
               * @param touches - An array of current touches
               * @param bubbles - Indicate whether the event bubbles up through the hierarchy or not.
               * @param eventCode - The type code of the touch event
               */
              function EventTouch(changedTouches, bubbles, eventCode, touches) {
                var _this2;

                _classCallCheck(this, EventTouch);

                _this2 = _possibleConstructorReturn(this, _getPrototypeOf(EventTouch).call(this, Event.TOUCH, bubbles));
                _this2.touch = null;
                _this2.simulate = false;
                _this2._eventCode = void 0;
                _this2._touches = void 0;
                _this2._allTouches = void 0;
                _this2._eventCode = eventCode || 0;
                _this2._touches = changedTouches || [];
                _this2._allTouches = touches || [];
                return _this2;
              }
              /**
               * @en Returns event type code.
               * @zh 获取触摸事件类型。
               */


              _createClass(EventTouch, [{
                key: "getEventCode",
                value: function getEventCode() {
                  return this._eventCode;
                }
                /**
                 * @en Returns touches of event.
                 * @zh 获取有变动的触摸点的列表。
                 * 注意：第一根手指按下不动，接着按第二根手指，这时候触点信息就只有变动的这根手指（第二根手指）的信息。
                 * 如果需要获取全部手指的信息，请使用 `getAllTouches`。
                 */

              }, {
                key: "getTouches",
                value: function getTouches() {
                  return this._touches;
                }
                /**
                 * @en Returns touches of event.
                 * @zh 获取所有触摸点的列表。
                 * 注意：如果手指行为是 touch end，这个时候列表是没有该手指信息的。如需知道该手指信息，可通过 `getTouches` 获取识别。
                 */

              }, {
                key: "getAllTouches",
                value: function getAllTouches() {
                  return this._allTouches;
                }
                /**
                 * @en Sets touch location.
                 * @zh 设置当前触点位置
                 * @param x - The current touch location on the x axis
                 * @param y - The current touch location on the y axis
                 */

              }, {
                key: "setLocation",
                value: function setLocation(x, y) {
                  if (this.touch) {
                    this.touch.setTouchInfo(this.touch.getID(), x, y);
                  }
                }
                /**
                 * @en Returns the current touch location.
                 * @zh 获取触点位置。
                 * @param out - Pass the out object to avoid object creation, very good practice
                 */

              }, {
                key: "getLocation",
                value: function getLocation(out) {
                  return this.touch ? this.touch.getLocation(out) : new Vec2();
                }
                /**
                 * @en Returns the current touch location in UI coordinates.
                 * @zh 获取 UI 坐标系下的触点位置。
                 * @param out - Pass the out object to avoid object creation, very good practice
                 */

              }, {
                key: "getUILocation",
                value: function getUILocation(out) {
                  return this.touch ? this.touch.getUILocation(out) : new Vec2();
                }
                /**
                 * @en Returns the current touch location in game screen coordinates.
                 * @zh 获取当前触点在游戏窗口中的位置。
                 * @param out - Pass the out object to avoid object creation, very good practice
                 */

              }, {
                key: "getLocationInView",
                value: function getLocationInView(out) {
                  return this.touch ? this.touch.getLocationInView(out) : new Vec2();
                }
                /**
                 * @en Returns the previous touch location.
                 * @zh 获取触点在上一次事件时的位置对象，对象包含 x 和 y 属性。
                 * @param out - Pass the out object to avoid object creation, very good practice
                 */

              }, {
                key: "getPreviousLocation",
                value: function getPreviousLocation(out) {
                  return this.touch ? this.touch.getPreviousLocation(out) : new Vec2();
                }
                /**
                 * @en Returns the start touch location.
                 * @zh 获获取触点落下时的位置对象，对象包含 x 和 y 属性。
                 * @param out - Pass the out object to avoid object creation, very good practice
                 */

              }, {
                key: "getStartLocation",
                value: function getStartLocation(out) {
                  return this.touch ? this.touch.getStartLocation(out) : new Vec2();
                }
                /**
                 * @en Returns the start touch location in UI coordinates.
                 * @zh 获获取触点落下时的 UI 世界下位置对象，对象包含 x 和 y 属性。
                 * @param out - Pass the out object to avoid object creation, very good practice
                 */

              }, {
                key: "getUIStartLocation",
                value: function getUIStartLocation(out) {
                  return this.touch ? this.touch.getUIStartLocation(out) : new Vec2();
                }
                /**
                 * @en Returns the id of the current touch point.
                 * @zh 获取触点的标识 ID，可以用来在多点触摸中跟踪触点。
                 */

              }, {
                key: "getID",
                value: function getID() {
                  return this.touch ? this.touch.getID() : null;
                }
                /**
                 * @en Returns the delta distance from the previous location to current location.
                 * @zh 获取触点距离上一次事件移动的距离对象，对象包含 x 和 y 属性。
                 * @param out - Pass the out object to avoid object creation, very good practice
                 */

              }, {
                key: "getDelta",
                value: function getDelta(out) {
                  return this.touch ? this.touch.getDelta(out) : new Vec2();
                }
                /**
                 * @en Returns the delta distance from the previous location to current location.
                 * @zh 获取触点距离上一次事件 UI 世界下移动的距离对象，对象包含 x 和 y 属性。
                 * @param out - Pass the out object to avoid object creation, very good practice
                */

              }, {
                key: "getUIDelta",
                value: function getUIDelta(out) {
                  return this.touch ? this.touch.getUIDelta(out) : new Vec2();
                }
                /**
                 * @en Returns the X axis delta distance from the previous location to current location.
                 * @zh 获取触点距离上一次事件移动的 x 轴距离。
                 */

              }, {
                key: "getDeltaX",
                value: function getDeltaX() {
                  return this.touch ? this.touch.getDelta(_vec2).x : 0;
                }
                /**
                 * @en Returns the Y axis delta distance from the previous location to current location.
                 * @zh 获取触点距离上一次事件移动的 y 轴距离。
                 */

              }, {
                key: "getDeltaY",
                value: function getDeltaY() {
                  return this.touch ? this.touch.getDelta(_vec2).y : 0;
                }
                /**
                 * @en Returns location X axis data.
                 * @zh 获取当前触点 X 轴位置。
                 */

              }, {
                key: "getLocationX",
                value: function getLocationX() {
                  return this.touch ? this.touch.getLocationX() : 0;
                }
                /**
                 * @en Returns location Y axis data.
                 * @zh 获取当前触点 Y 轴位置。
                 */

              }, {
                key: "getLocationY",
                value: function getLocationY() {
                  return this.touch ? this.touch.getLocationY() : 0;
                }
              }]);

              return EventTouch;
            }(Event));
            /**
             * @en
             * The acceleration event.
             * @zh
             * 加速计事件。
             */

            EventTouch.MAX_TOUCHES = 5;
            EventTouch.BEGAN = 0;
            EventTouch.MOVED = 1;
            EventTouch.ENDED = 2;
            EventTouch.CANCELLED = 3;
            var EventAcceleration = exports('bd', /*#__PURE__*/function (_Event3) {
              _inherits(EventAcceleration, _Event3);

              /**
               * @en The acceleration object
               * @zh 加速度对象
               */

              /**
               * @param acc - The acceleration
               * @param bubbles - Indicate whether the event bubbles up through the hierarchy or not.
               */
              function EventAcceleration(acc, bubbles) {
                var _this3;

                _classCallCheck(this, EventAcceleration);

                _this3 = _possibleConstructorReturn(this, _getPrototypeOf(EventAcceleration).call(this, Event.ACCELERATION, bubbles));
                _this3.acc = void 0;
                _this3.acc = acc;
                return _this3;
              }

              return EventAcceleration;
            }(Event));
            /**
             * @en
             * The keyboard event.
             * @zh
             * 键盘事件。
             */

            var EventKeyboard = exports('be', /*#__PURE__*/function (_Event4) {
              _inherits(EventKeyboard, _Event4);

              /**
               * @en The keyCode read-only property represents a system and implementation dependent numerical code
               * identifying the unmodified value of the pressed key.
               * This is usually the decimal ASCII (RFC 20) or Windows 1252 code corresponding to the key.
               * If the key can't be identified, this value is 0.
               * @zh keyCode 是只读属性它表示一个系统和依赖于实现的数字代码，可以识别按键的未修改值。
               * 这通常是十进制 ASCII (RFC20) 或者 Windows 1252 代码，所对应的密钥。
               * 如果无法识别该键，则该值为 0。
               */

              /**
               * @en Raw DOM KeyboardEvent.
               * @zh 原始 DOM KeyboardEvent 事件对象
               */

              /**
               * @en Indicates whether the current key is being pressed
               * @zh 表示当前按键是否正在被按下
               */

              /**
               * @param keyCode - The key code of the current key or the DOM KeyboardEvent
               * @param isPressed - Indicates whether the current key is being pressed
               * @param bubbles - Indicates whether the event bubbles up through the hierarchy or not.
               */
              function EventKeyboard(keyCode, isPressed, bubbles) {
                var _this4;

                _classCallCheck(this, EventKeyboard);

                _this4 = _possibleConstructorReturn(this, _getPrototypeOf(EventKeyboard).call(this, Event.KEYBOARD, bubbles));
                _this4.keyCode = void 0;
                _this4.rawEvent = void 0;
                _this4.isPressed = void 0;

                if (typeof keyCode === 'number') {
                  _this4.keyCode = keyCode;
                } else {
                  _this4.keyCode = keyCode.keyCode;
                  _this4.rawEvent = keyCode;
                }

                _this4.isPressed = isPressed;
                return _this4;
              }

              return EventKeyboard;
            }(Event)); // TODO
            // @ts-ignore

            Event.EventMouse = EventMouse; // TODO
            // @ts-ignore

            Event.EventTouch = EventTouch; // TODO
            // @ts-ignore

            Event.EventAcceleration = EventAcceleration; // TODO
            // @ts-ignore

            Event.EventKeyboard = EventKeyboard;

            /**
             * @en The base class of event listener.                                                                        <br/>
             * If you need custom listener which with different callback, you need to inherit this class.               <br/>
             * For instance, you could refer to EventListenerAcceleration, EventListenerKeyboard,                       <br/>
             * EventListenerTouchOneByOne, EventListenerCustom.<br/>
             * @zh 封装用户的事件处理逻辑
             * 注意：这是一个抽象类，开发者不应该直接实例化这个类，请参考 [[create]] 。
             */
            var EventListener = exports('d8', /*#__PURE__*/function () {
              _createClass(EventListener, [{
                key: "onEvent",
                // Whether the listener is enabled
                get: function get() {
                  return this._onEvent;
                }
              }], [{
                key: "create",

                /**
                 * @en The type code of unknown event listener.<br/>
                 * @zh 未知的事件监听器类型
                 */

                /**
                 * @en The type code of one by one touch event listener.<br/>
                 * @zh 触摸事件监听器类型，触点会一个一个得分开被派发
                 */

                /**
                 * @en The type code of all at once touch event listener.<br/>
                 * @zh 触摸事件监听器类型，触点会被一次性全部派发
                 */

                /**
                 * @en The type code of keyboard event listener.<br/>
                 * @zh 键盘事件监听器类型
                 */

                /**
                 * @en The type code of mouse event listener.<br/>
                 * @zh 鼠标事件监听器类型
                 */

                /**
                 * @en The type code of acceleration event listener.<br/>
                 * @zh 加速器事件监听器类型
                 */

                /**
                 * @en The type code of custom event listener.<br/>
                 * @zh 自定义事件监听器类型
                 */

                /**
                 * @en Create a EventListener object with configuration including the event type, handlers and other parameters.<br/>
                 * In handlers, this refer to the event listener object itself.<br/>
                 * You can also pass custom parameters in the configuration object,<br/>
                 * all custom parameters will be polyfilled into the event listener object and can be accessed in handlers.<br/>
                 * @zh 通过指定不同的 Event 对象来设置想要创建的事件监听器。
                 * @param argObj a json object
                 */
                value: function create(argObj) {
                  assertID(argObj && argObj.event, 1900);
                  var listenerType = argObj.event;
                  delete argObj.event;
                  var listener = null;

                  if (listenerType === legacyCC.EventListener.TOUCH_ONE_BY_ONE) {
                    listener = new TouchOneByOne();
                  } else if (listenerType === legacyCC.EventListener.TOUCH_ALL_AT_ONCE) {
                    listener = new TouchAllAtOnce();
                  } else if (listenerType === legacyCC.EventListener.MOUSE) {
                    listener = new Mouse();
                  } else if (listenerType === legacyCC.EventListener.KEYBOARD) {
                    listener = new Keyboard();
                  } else if (listenerType === legacyCC.EventListener.ACCELERATION) {
                    listener = new Acceleration(argObj.callback);
                    delete argObj.callback;
                  }

                  if (listener) {
                    for (var _i = 0, _Object$keys = Object.keys(argObj); _i < _Object$keys.length; _i++) {
                      var key = _Object$keys[_i];
                      listener[key] = argObj[key];
                    }
                  }

                  return listener;
                } // hack: How to solve the problem of uncertain attribute
                // callback's this object

              }]);

              function EventListener(type, listenerID, callback) {
                _classCallCheck(this, EventListener);

                this.owner = null;
                this.mask = null;
                this._previousIn = false;
                this._target = null;
                this._onEvent = void 0;
                this._type = void 0;
                this._listenerID = void 0;
                this._registered = false;
                this._fixedPriority = 0;
                this._node = null;
                this._paused = true;
                this._isEnabled = true;
                this._onEvent = callback;
                this._type = type || 0;
                this._listenerID = listenerID || '';
              }
              /**
               * @en
               * <p><br/>
               *     Sets paused state for the listener<br/>
               *     The paused state is only used for scene graph priority listeners.<br/>
               *     `EventDispatcher.resumeAllEventListenersForTarget(node)` will set the paused state to `true`,<br/>
               *     while `EventDispatcher.pauseAllEventListenersForTarget(node)` will set it to `false`.<br/>
               *     @note 1) Fixed priority listeners will never get paused. If a fixed priority doesn't want to receive events,<br/>
               *              call `setEnabled(false)` instead.<br/>
               *            2) In `Node`'s onEnter and onExit, the `paused state` of the listeners<br/>
               *              which associated with that node will be automatically updated.<br/>
               * </p><br/>
               * @zh
               * *为侦听器设置暂停状态<br/>
               * 暂停状态仅用于场景图优先级侦听器。<br/>
               * `EventDispatcher :: resumeAllEventListenersForTarget（node）`将暂停状态设置为`true`，<br/>
               * 而`EventDispatcher :: pauseAllEventListenersForTarget（node）`将它设置为`false`。<br/>
               * 注意：<br/>
               * - 固定优先级侦听器永远不会被暂停。 如果固定优先级不想接收事件，改为调用`setEnabled（false）`。<br/>
               * - 在“Node”的onEnter和onExit中，监听器的“暂停状态”与该节点关联的*将自动更新。
               */


              _createClass(EventListener, [{
                key: "_setPaused",
                value: function _setPaused(paused) {
                  this._paused = paused;
                }
                /**
                 * @en Checks whether the listener is paused.<br/>
                 * @zh 检查侦听器是否已暂停。
                 */

              }, {
                key: "_isPaused",
                value: function _isPaused() {
                  return this._paused;
                }
                /**
                 * @en Marks the listener was registered by EventDispatcher.<br/>
                 * @zh 标记监听器已由 EventDispatcher 注册。
                 */

              }, {
                key: "_setRegistered",
                value: function _setRegistered(registered) {
                  this._registered = registered;
                }
                /**
                 * @en Checks whether the listener was registered by EventDispatcher<br/>
                 * @zh 检查监听器是否已由 EventDispatcher 注册。
                 * @private
                 */

              }, {
                key: "_isRegistered",
                value: function _isRegistered() {
                  return this._registered;
                }
                /**
                 * @en Gets the type of this listener<br/>
                 * note： It's different from `EventType`, e.g.<br/>
                 * TouchEvent has two kinds of event listeners - EventListenerOneByOne, EventListenerAllAtOnce<br/>
                 * @zh 获取此侦听器的类型<br/>
                 * 注意：它与`EventType`不同，例如<br/>
                 * TouchEvent 有两种事件监听器 -  EventListenerOneByOne，EventListenerAllAtOnce
                 */

              }, {
                key: "_getType",
                value: function _getType() {
                  return this._type;
                }
                /**
                 * @en Gets the listener ID of this listener<br/>
                 * When event is being dispatched, listener ID is used as key for searching listeners according to event type.<br/>
                 * @zh 获取此侦听器的侦听器 ID。<br/>
                 * 调度事件时，侦听器 ID 用作根据事件类型搜索侦听器的键。
                 */

              }, {
                key: "_getListenerID",
                value: function _getListenerID() {
                  return this._listenerID;
                }
                /**
                 * @en Sets the fixed priority for this listener<br/>
                 * note: This method is only used for `fixed priority listeners`,<br/>
                 *   it needs to access a non-zero value. 0 is reserved for scene graph priority listeners<br/>
                 * @zh 设置此侦听器的固定优先级。<br/>
                 * 注意：此方法仅用于“固定优先级侦听器”，<br/>
                 * 它需要访问非零值。 0保留给场景图优先级侦听器。
                 */

              }, {
                key: "_setFixedPriority",
                value: function _setFixedPriority(fixedPriority) {
                  this._fixedPriority = fixedPriority;
                }
                /**
                 * @en Gets the fixed priority of this listener<br/>
                 * @zh 获取此侦听器的固定优先级。
                 * @return 如果它是场景图优先级侦听器则返回 0 ，则对于固定优先级侦听器则不为零
                 */

              }, {
                key: "_getFixedPriority",
                value: function _getFixedPriority() {
                  return this._fixedPriority;
                }
                /**
                 * @en Sets scene graph priority for this listener<br/>
                 * @zh 设置此侦听器的场景图优先级。
                 * @param {Node} node
                 */

              }, {
                key: "_setSceneGraphPriority",
                value: function _setSceneGraphPriority(node) {
                  this._target = node;
                  this._node = node;
                }
                /**
                 * @en Gets scene graph priority of this listener<br/>
                 * @zh 获取此侦听器的场景图优先级。
                 * @return 如果它是固定优先级侦听器，则为场景图优先级侦听器非 null 。
                 */

              }, {
                key: "_getSceneGraphPriority",
                value: function _getSceneGraphPriority() {
                  return this._node;
                }
                /**
                 * @en Checks whether the listener is available.<br/>
                 * @zh 检测监听器是否有效
                 */

              }, {
                key: "checkAvailable",
                value: function checkAvailable() {
                  return this._onEvent !== null;
                }
                /**
                 * @en Clones the listener, its subclasses have to override this method.<br/>
                 * @zh 克隆监听器,它的子类必须重写此方法。
                 */

              }, {
                key: "clone",
                value: function clone() {
                  return null;
                }
                /**
                 * @en
                 * Enables or disables the listener<br/>
                 * note: Only listeners with `enabled` state will be able to receive events.<br/>
                 * When an listener was initialized, it's enabled by default.<br/>
                 * An event listener can receive events when it is enabled and is not paused.<br/>
                 * paused state is always false when it is a fixed priority listener.<br/>
                 * @zh
                 * 启用或禁用监听器。<br/>
                 * 注意：只有处于“启用”状态的侦听器才能接收事件。<br/>
                 * 初始化侦听器时，默认情况下启用它。<br/>
                 * 事件侦听器可以在启用且未暂停时接收事件。<br/>
                 * 当固定优先级侦听器时，暂停状态始终为false。<br/>
                 */

              }, {
                key: "setEnabled",
                value: function setEnabled(enabled) {
                  this._isEnabled = enabled;
                }
                /**
                 * @en Checks whether the listener is enabled<br/>
                 * @zh 检查监听器是否可用。
                 */

              }, {
                key: "isEnabled",
                value: function isEnabled() {
                  return this._isEnabled;
                }
              }]);

              return EventListener;
            }());
            EventListener.UNKNOWN = 0;
            EventListener.TOUCH_ONE_BY_ONE = 1;
            EventListener.TOUCH_ALL_AT_ONCE = 2;
            EventListener.KEYBOARD = 3;
            EventListener.MOUSE = 4;
            EventListener.ACCELERATION = 6;
            EventListener.CUSTOM = 8;
            EventListener.ListenerID = {
              MOUSE: '__cc_mouse',
              TOUCH_ONE_BY_ONE: '__cc_touch_one_by_one',
              TOUCH_ALL_AT_ONCE: '__cc_touch_all_at_once',
              KEYBOARD: '__cc_keyboard',
              ACCELERATION: '__cc_acceleration'
            };
            var ListenerID = EventListener.ListenerID;
            var Mouse = /*#__PURE__*/function (_EventListener) {
              _inherits(Mouse, _EventListener);

              function Mouse() {
                var _this;

                _classCallCheck(this, Mouse);

                _this = _possibleConstructorReturn(this, _getPrototypeOf(Mouse).call(this, EventListener.MOUSE, ListenerID.MOUSE, null));
                _this.onMouseDown = null;
                _this.onMouseUp = null;
                _this.onMouseMove = null;
                _this.onMouseScroll = null;

                _this._onEvent = function (event) {
                  return _this._callback(event);
                };

                return _this;
              }

              _createClass(Mouse, [{
                key: "_callback",
                value: function _callback(event) {
                  var eventType = legacyCC.Event.EventMouse;

                  switch (event.eventType) {
                    case eventType.DOWN:
                      if (this.onMouseDown) {
                        this.onMouseDown(event);
                      }

                      break;

                    case eventType.UP:
                      if (this.onMouseUp) {
                        this.onMouseUp(event);
                      }

                      break;

                    case eventType.MOVE:
                      if (this.onMouseMove) {
                        this.onMouseMove(event);
                      }

                      break;

                    case eventType.SCROLL:
                      if (this.onMouseScroll) {
                        this.onMouseScroll(event);
                      }

                      break;
                  }
                }
              }, {
                key: "clone",
                value: function clone() {
                  var eventListener = new Mouse();
                  eventListener.onMouseDown = this.onMouseDown;
                  eventListener.onMouseUp = this.onMouseUp;
                  eventListener.onMouseMove = this.onMouseMove;
                  eventListener.onMouseScroll = this.onMouseScroll;
                  return eventListener;
                }
              }, {
                key: "checkAvailable",
                value: function checkAvailable() {
                  return true;
                }
              }]);

              return Mouse;
            }(EventListener);
            var TouchOneByOne = /*#__PURE__*/function (_EventListener2) {
              _inherits(TouchOneByOne, _EventListener2);

              function TouchOneByOne() {
                var _this2;

                _classCallCheck(this, TouchOneByOne);

                _this2 = _possibleConstructorReturn(this, _getPrototypeOf(TouchOneByOne).call(this, EventListener.TOUCH_ONE_BY_ONE, ListenerID.TOUCH_ONE_BY_ONE, null));
                _this2.swallowTouches = false;
                _this2.onTouchBegan = null;
                _this2.onTouchMoved = null;
                _this2.onTouchEnded = null;
                _this2.onTouchCancelled = null;
                _this2._claimedTouches = [];
                return _this2;
              }

              _createClass(TouchOneByOne, [{
                key: "setSwallowTouches",
                value: function setSwallowTouches(needSwallow) {
                  this.swallowTouches = needSwallow;
                }
              }, {
                key: "isSwallowTouches",
                value: function isSwallowTouches() {
                  return this.swallowTouches;
                }
              }, {
                key: "clone",
                value: function clone() {
                  var eventListener = new TouchOneByOne();
                  eventListener.onTouchBegan = this.onTouchBegan;
                  eventListener.onTouchMoved = this.onTouchMoved;
                  eventListener.onTouchEnded = this.onTouchEnded;
                  eventListener.onTouchCancelled = this.onTouchCancelled;
                  eventListener.swallowTouches = this.swallowTouches;
                  return eventListener;
                }
              }, {
                key: "checkAvailable",
                value: function checkAvailable() {
                  if (!this.onTouchBegan) {
                    logID(1801);
                    return false;
                  }

                  return true;
                }
              }]);

              return TouchOneByOne;
            }(EventListener);
            var TouchAllAtOnce = /*#__PURE__*/function (_EventListener3) {
              _inherits(TouchAllAtOnce, _EventListener3);

              function TouchAllAtOnce() {
                var _this3;

                _classCallCheck(this, TouchAllAtOnce);

                _this3 = _possibleConstructorReturn(this, _getPrototypeOf(TouchAllAtOnce).call(this, EventListener.TOUCH_ALL_AT_ONCE, ListenerID.TOUCH_ALL_AT_ONCE, null));
                _this3.onTouchesBegan = null;
                _this3.onTouchesMoved = null;
                _this3.onTouchesEnded = null;
                _this3.onTouchesCancelled = null;
                return _this3;
              }

              _createClass(TouchAllAtOnce, [{
                key: "clone",
                value: function clone() {
                  var eventListener = new TouchAllAtOnce();
                  eventListener.onTouchesBegan = this.onTouchesBegan;
                  eventListener.onTouchesMoved = this.onTouchesMoved;
                  eventListener.onTouchesEnded = this.onTouchesEnded;
                  eventListener.onTouchesCancelled = this.onTouchesCancelled;
                  return eventListener;
                }
              }, {
                key: "checkAvailable",
                value: function checkAvailable() {
                  if (this.onTouchesBegan === null && this.onTouchesMoved === null && this.onTouchesEnded === null && this.onTouchesCancelled === null) {
                    logID(1802);
                    return false;
                  }

                  return true;
                }
              }]);

              return TouchAllAtOnce;
            }(EventListener); // Acceleration

            var Acceleration = /*#__PURE__*/function (_EventListener4) {
              _inherits(Acceleration, _EventListener4);

              function Acceleration(callback) {
                var _this4;

                _classCallCheck(this, Acceleration);

                _this4 = _possibleConstructorReturn(this, _getPrototypeOf(Acceleration).call(this, EventListener.ACCELERATION, ListenerID.ACCELERATION, null));
                _this4._onAccelerationEvent = null;

                _this4._onEvent = function (event) {
                  return _this4._callback(event);
                };

                _this4._onAccelerationEvent = callback;
                return _this4;
              }

              _createClass(Acceleration, [{
                key: "_callback",
                value: function _callback(event) {
                  if (this._onAccelerationEvent) {
                    this._onAccelerationEvent(event.acc, event);
                  }
                }
              }, {
                key: "checkAvailable",
                value: function checkAvailable() {
                  assertID(this._onAccelerationEvent, 1803);
                  return true;
                }
              }, {
                key: "clone",
                value: function clone() {
                  return new Acceleration(this._onAccelerationEvent);
                }
              }]);

              return Acceleration;
            }(EventListener); // Keyboard

            var Keyboard = /*#__PURE__*/function (_EventListener5) {
              _inherits(Keyboard, _EventListener5);

              function Keyboard() {
                var _this5;

                _classCallCheck(this, Keyboard);

                _this5 = _possibleConstructorReturn(this, _getPrototypeOf(Keyboard).call(this, EventListener.KEYBOARD, ListenerID.KEYBOARD, null));
                _this5.onKeyPressed = null;
                _this5.onKeyReleased = null;

                _this5._onEvent = function (event) {
                  return _this5._callback(event);
                };

                return _this5;
              }

              _createClass(Keyboard, [{
                key: "_callback",
                value: function _callback(event) {
                  if (event.isPressed) {
                    if (this.onKeyPressed) {
                      this.onKeyPressed(event.keyCode, event);
                    }
                  } else {
                    if (this.onKeyReleased) {
                      this.onKeyReleased(event.keyCode, event);
                    }
                  }
                }
              }, {
                key: "clone",
                value: function clone() {
                  var eventListener = new Keyboard();
                  eventListener.onKeyPressed = this.onKeyPressed;
                  eventListener.onKeyReleased = this.onKeyReleased;
                  return eventListener;
                }
              }, {
                key: "checkAvailable",
                value: function checkAvailable() {
                  if (this.onKeyPressed === null && this.onKeyReleased === null) {
                    logID(1800);
                    return false;
                  }

                  return true;
                }
              }]);

              return Keyboard;
            }(EventListener);
            legacyCC.EventListener = EventListener;

            var ListenerID$1 = EventListener.ListenerID;

            function checkUINode(node) {
              if (node && node.getComponent('cc.UITransform')) {
                return true;
              }

              return false;
            } // tslint:disable-next-line: class-name


            var _EventListenerVector = /*#__PURE__*/function () {
              function _EventListenerVector() {
                _classCallCheck(this, _EventListenerVector);

                this.gt0Index = 0;
                this._fixedListeners = [];
                this._sceneGraphListeners = [];
              }

              _createClass(_EventListenerVector, [{
                key: "size",
                value: function size() {
                  return this._fixedListeners.length + this._sceneGraphListeners.length;
                }
              }, {
                key: "empty",
                value: function empty() {
                  return this._fixedListeners.length === 0 && this._sceneGraphListeners.length === 0;
                }
              }, {
                key: "push",
                value: function push(listener) {
                  if (listener._getFixedPriority() === 0) {
                    this._sceneGraphListeners.push(listener);
                  } else {
                    this._fixedListeners.push(listener);
                  }
                }
              }, {
                key: "clearSceneGraphListeners",
                value: function clearSceneGraphListeners() {
                  this._sceneGraphListeners.length = 0;
                }
              }, {
                key: "clearFixedListeners",
                value: function clearFixedListeners() {
                  this._fixedListeners.length = 0;
                }
              }, {
                key: "clear",
                value: function clear() {
                  this._sceneGraphListeners.length = 0;
                  this._fixedListeners.length = 0;
                }
              }, {
                key: "getFixedPriorityListeners",
                value: function getFixedPriorityListeners() {
                  return this._fixedListeners;
                }
              }, {
                key: "getSceneGraphPriorityListeners",
                value: function getSceneGraphPriorityListeners() {
                  return this._sceneGraphListeners;
                }
              }]);

              return _EventListenerVector;
            }();

            function __getListenerID(event) {
              var eventType = Event;
              var type = event.type;

              if (type === eventType.ACCELERATION) {
                return ListenerID$1.ACCELERATION;
              }

              if (type === eventType.KEYBOARD) {
                return ListenerID$1.KEYBOARD;
              }

              if (type.startsWith(eventType.MOUSE)) {
                return ListenerID$1.MOUSE;
              }

              if (type.startsWith(eventType.TOUCH)) {
                // Touch listener is very special, it contains two kinds of listeners:
                // EventListenerTouchOneByOne and EventListenerTouchAllAtOnce.
                // return UNKNOWN instead.
                logID(2000);
              }

              return '';
            } // Priority dirty flag


            var DIRTY_NONE = 0;
            var DIRTY_FIXED_PRIORITY = 1 << 0;
            var DIRTY_SCENE_GRAPH_PRIORITY = 1 << 1;

            var EventManager = /*#__PURE__*/function () {
              function EventManager() {
                _classCallCheck(this, EventManager);

                this._listenersMap = {};
                this._priorityDirtyFlagMap = {};
                this._nodeListenersMap = {};
                this._toAddedListeners = [];
                this._toRemovedListeners = [];
                this._dirtyListeners = [];
                this._inDispatch = 0;
                this._isEnabled = false;
                this._internalCustomListenerIDs = [];
                this._currentTouch = null;
                this._currentTouchListener = null;
              }

              _createClass(EventManager, [{
                key: "pauseTarget",

                /**
                 * @en Pauses all listeners which are associated the specified target.
                 * @zh 暂停传入的 node 相关的所有监听器的事件响应。
                 * @param node - 暂停目标节点
                 * @param recursive - 是否往子节点递归暂停。默认为 false。
                 */
                value: function pauseTarget(node) {
                  var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

                  if (!(node instanceof legacyCC._BaseNode)) {
                    warnID(3506);
                    return;
                  }

                  var listeners = this._nodeListenersMap[node.uuid];

                  if (listeners) {
                    for (var i = 0; i < listeners.length; ++i) {
                      var listener = listeners[i];

                      listener._setPaused(true);
                    }
                  }

                  if (recursive === true) {
                    var locChildren = node.children;

                    if (locChildren) {
                      for (var _i = 0; _i < locChildren.length; ++_i) {
                        var locChild = locChildren[_i];
                        this.pauseTarget(locChild, true);
                      }
                    }
                  }
                }
                /**
                 * @en
                 * Resumes all listeners which are associated the specified target.
                 *
                 * @zh
                 * 恢复传入的 node 相关的所有监听器的事件响应。
                 *
                 * @param node - 监听器节点。
                 * @param recursive - 是否往子节点递归。默认为 false。
                 */

              }, {
                key: "resumeTarget",
                value: function resumeTarget(node) {
                  var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

                  if (!(node instanceof legacyCC._BaseNode)) {
                    warnID(3506);
                    return;
                  }

                  var listeners = this._nodeListenersMap[node.uuid];

                  if (listeners) {
                    for (var i = 0; i < listeners.length; ++i) {
                      var listener = listeners[i];

                      listener._setPaused(false);
                    }
                  }

                  this._setDirtyForNode(node);

                  if (recursive === true && node.children.length > 0) {
                    var locChildren = node.children;

                    if (locChildren) {
                      for (var _i2 = 0; _i2 < locChildren.length; ++_i2) {
                        var locChild = locChildren[_i2];
                        this.resumeTarget(locChild, true);
                      }
                    }
                  }
                }
              }, {
                key: "frameUpdateListeners",
                value: function frameUpdateListeners() {
                  var locListenersMap = this._listenersMap;
                  var locPriorityDirtyFlagMap = this._priorityDirtyFlagMap;

                  for (var selKey in locListenersMap) {
                    if (locListenersMap[selKey].empty()) {
                      delete locPriorityDirtyFlagMap[selKey];
                      delete locListenersMap[selKey];
                    }
                  }

                  var locToAddedListeners = this._toAddedListeners;

                  if (locToAddedListeners.length !== 0) {
                    for (var i = 0, len = locToAddedListeners.length; i < len; i++) {
                      this._forceAddEventListener(locToAddedListeners[i]);
                    }

                    locToAddedListeners.length = 0;
                  }

                  if (this._toRemovedListeners.length !== 0) {
                    this._cleanToRemovedListeners();
                  }
                }
                /**
                 * @en
                 * Query whether the specified event listener id has been added.
                 *
                 * @zh
                 * 查询指定的事件 ID 是否存在。
                 *
                 * @param listenerID - 查找监听器 ID。
                 * @returns 是否已查找到。
                 */

              }, {
                key: "hasEventListener",
                value: function hasEventListener(listenerID) {
                  return !!this._getListeners(listenerID);
                }
                /**
                 * @en
                 * <p>
                 * Adds a event listener for a specified event.<br/>
                 * if the parameter "nodeOrPriority" is a node,
                 * it means to add a event listener for a specified event with the priority of scene graph.<br/>
                 * if the parameter "nodeOrPriority" is a Number,
                 * it means to add a event listener for a specified event with the fixed priority.<br/>
                 * </p>
                 *
                 * @zh
                 * 将事件监听器添加到事件管理器中。<br/>
                 * 如果参数 “nodeOrPriority” 是节点，优先级由 node 的渲染顺序决定，显示在上层的节点将优先收到事件。<br/>
                 * 如果参数 “nodeOrPriority” 是数字，优先级则固定为该参数的数值，数字越小，优先级越高。<br/>
                 *
                 * @param listener - 指定事件监听器。
                 * @param nodeOrPriority - 监听程序的优先级。
                 * @returns
                 */

              }, {
                key: "addListener",
                value: function addListener(listener, nodeOrPriority) {
                  assertID(listener && nodeOrPriority, 3503);

                  if (!(legacyCC.js.isNumber(nodeOrPriority) || nodeOrPriority instanceof legacyCC._BaseNode)) {
                    warnID(3506);
                    return;
                  }

                  if (!(listener instanceof legacyCC.EventListener)) {
                    assertID(!legacyCC.js.isNumber(nodeOrPriority), 3504);
                    listener = legacyCC.EventListener.create(listener);
                  } else {
                    if (listener._isRegistered()) {
                      logID(3505);
                      return;
                    }
                  }

                  if (!listener.checkAvailable()) {
                    return;
                  }

                  if (legacyCC.js.isNumber(nodeOrPriority)) {
                    if (nodeOrPriority === 0) {
                      logID(3500);
                      return;
                    }

                    listener._setSceneGraphPriority(null);

                    listener._setFixedPriority(nodeOrPriority);

                    listener._setRegistered(true);

                    listener._setPaused(false);

                    this._addListener(listener);
                  } else {
                    if (!checkUINode(nodeOrPriority)) {
                      logID(3512);
                      return;
                    }

                    listener._setSceneGraphPriority(nodeOrPriority);

                    listener._setFixedPriority(0);

                    listener._setRegistered(true);

                    this._addListener(listener);
                  }

                  return listener;
                }
                /**
                 * @en
                 * Adds a Custom event listener. It will use a fixed priority of 1.
                 *
                 * @zh
                 * 向事件管理器添加一个自定义事件监听器。
                 *
                 * @param eventName - 自定义事件名。
                 * @param callback - 事件回调。
                 * @returns 返回自定义监听器。
                 */

              }, {
                key: "addCustomListener",
                value: function addCustomListener(eventName, callback) {
                  var listener = EventListener.create({
                    event: legacyCC.EventListener.CUSTOM,
                    eventName: eventName,
                    callback: callback
                  });
                  this.addListener(listener, 1);
                  return listener;
                }
                /**
                 * @en
                 * Remove a listener.
                 *
                 * @zh
                 * 移除一个已添加的监听器。
                 *
                 * @param listener - 需要移除的监听器。
                 */

              }, {
                key: "removeListener",
                value: function removeListener(listener) {
                  if (listener == null) {
                    return;
                  }

                  var isFound = false;
                  var locListener = this._listenersMap;

                  for (var selKey in locListener) {
                    var listeners = locListener[selKey];
                    var fixedPriorityListeners = listeners.getFixedPriorityListeners();
                    var sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
                    isFound = this._removeListenerInVector(sceneGraphPriorityListeners, listener);

                    if (isFound) {
                      // fixed #4160: Dirty flag need to be updated after listeners were removed.
                      this._setDirty(listener._getListenerID(), DIRTY_SCENE_GRAPH_PRIORITY);
                    } else {
                      isFound = this._removeListenerInVector(fixedPriorityListeners, listener);

                      if (isFound) {
                        this._setDirty(listener._getListenerID(), DIRTY_FIXED_PRIORITY);
                      }
                    }

                    if (listeners.empty()) {
                      delete this._priorityDirtyFlagMap[listener._getListenerID()];
                      delete locListener[selKey];
                    }

                    if (isFound) {
                      break;
                    }
                  }

                  if (!isFound) {
                    var locToAddedListeners = this._toAddedListeners;

                    for (var i = locToAddedListeners.length - 1; i >= 0; i--) {
                      var selListener = locToAddedListeners[i];

                      if (selListener === listener) {
                        legacyCC.js.array.removeAt(locToAddedListeners, i);

                        selListener._setRegistered(false);

                        break;
                      }
                    }
                  }
                }
                /**
                 * @en
                 * Removes all listeners with the same event listener type or removes all listeners of a node.
                 *
                 * @zh
                 * 移除注册到 eventManager 中指定类型的所有事件监听器。<br/>
                 * 1. 如果传入的第一个参数类型是 Node，那么事件管理器将移除与该对象相关的所有事件监听器。
                 * （如果第二参数 recursive 是 true 的话，就会连同该对象的子控件上所有的事件监听器也一并移除）<br/>
                 * 2. 如果传入的第一个参数类型是 Number（该类型 EventListener 中定义的事件类型），
                 * 那么事件管理器将移除该类型的所有事件监听器。<br/>
                 *
                 * 下列是目前存在监听器类型：       <br/>
                 * `EventListener.UNKNOWN`       <br/>
                 * `EventListener.KEYBOARD`      <br/>
                 * `EventListener.ACCELERATION`，<br/>
                 *
                 * @param listenerType - 监听器类型。
                 * @param recursive - 递归子节点的同类型监听器一并移除。默认为 false。
                 */

              }, {
                key: "removeListeners",
                value: function removeListeners(listenerType) {
                  var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

                  if (!(legacyCC.js.isNumber(listenerType) || listenerType instanceof legacyCC._BaseNode)) {
                    warnID(3506);
                    return;
                  }

                  if (listenerType._id !== undefined) {
                    // Ensure the node is removed from these immediately also.
                    // Don't want any dangling pointers or the possibility of dealing with deleted objects..
                    var listeners = this._nodeListenersMap[listenerType._id];

                    if (listeners) {
                      var listenersCopy = legacyCC.js.array.copy(listeners);

                      for (var i = 0; i < listenersCopy.length; ++i) {
                        var listenerCopy = listenersCopy[i];
                        this.removeListener(listenerCopy);
                      }

                      delete this._nodeListenersMap[listenerType._id];
                    } // Bug fix: ensure there are no references to the node in the list of listeners to be added.
                    // If we find any listeners associated with the destroyed node in this list then remove them.
                    // This is to catch the scenario where the node gets destroyed before it's listener
                    // is added into the event dispatcher fully. This could happen if a node registers a listener
                    // and gets destroyed while we are dispatching an event (touch etc.)


                    var locToAddedListeners = this._toAddedListeners;

                    for (var _i3 = 0; _i3 < locToAddedListeners.length;) {
                      var listener = locToAddedListeners[_i3];

                      if (listener._getSceneGraphPriority() === listenerType) {
                        // Ensure no dangling ptr to the target node.
                        listener._setSceneGraphPriority(null);

                        listener._setRegistered(false);

                        locToAddedListeners.splice(_i3, 1);
                      } else {
                        ++_i3;
                      }
                    }

                    if (recursive === true) {
                      var locChildren = listenerType.getChildren();

                      for (var _i4 = 0; _i4 < locChildren.length; ++_i4) {
                        var locChild = locChildren[_i4];
                        this.removeListeners(locChild, true);
                      }
                    }
                  } else {
                    if (listenerType === legacyCC.EventListener.TOUCH_ONE_BY_ONE) {
                      this._removeListenersForListenerID(ListenerID$1.TOUCH_ONE_BY_ONE);
                    } else if (listenerType === legacyCC.EventListener.TOUCH_ALL_AT_ONCE) {
                      this._removeListenersForListenerID(ListenerID$1.TOUCH_ALL_AT_ONCE);
                    } else if (listenerType === legacyCC.EventListener.MOUSE) {
                      this._removeListenersForListenerID(ListenerID$1.MOUSE);
                    } else if (listenerType === legacyCC.EventListener.ACCELERATION) {
                      this._removeListenersForListenerID(ListenerID$1.ACCELERATION);
                    } else if (listenerType === legacyCC.EventListener.KEYBOARD) {
                      this._removeListenersForListenerID(ListenerID$1.KEYBOARD);
                    } else {
                      logID(3501);
                    }
                  }
                }
                /**
                 * @en
                 * Removes all custom listeners with the same event name.
                 *
                 * @zh
                 * 移除同一事件名的自定义事件监听器。
                 *
                 * @param customEventName - 自定义事件监听器名。
                 */

              }, {
                key: "removeCustomListeners",
                value: function removeCustomListeners(customEventName) {
                  this._removeListenersForListenerID(customEventName);
                }
                /**
                 * @en
                 * Removes all listeners.
                 *
                 * @zh
                 * 移除所有事件监听器。
                 */

              }, {
                key: "removeAllListeners",
                value: function removeAllListeners() {
                  var locListeners = this._listenersMap;
                  var locInternalCustomEventIDs = this._internalCustomListenerIDs;

                  for (var selKey in locListeners) {
                    if (locInternalCustomEventIDs.indexOf(selKey) === -1) {
                      this._removeListenersForListenerID(selKey);
                    }
                  }
                }
                /**
                 * @en
                 * Sets listener's priority with fixed value.
                 *
                 * @zh
                 * 设置 FixedPriority 类型监听器的优先级。
                 *
                 * @param listener - 监听器。
                 * @param fixedPriority - 优先级。
                 */

              }, {
                key: "setPriority",
                value: function setPriority(listener, fixedPriority) {
                  if (listener == null) {
                    return;
                  }

                  var locListeners = this._listenersMap;

                  for (var selKey in locListeners) {
                    var selListeners = locListeners[selKey];
                    var fixedPriorityListeners = selListeners.getFixedPriorityListeners();

                    if (fixedPriorityListeners) {
                      var found = fixedPriorityListeners.indexOf(listener);

                      if (found !== -1) {
                        if (listener._getSceneGraphPriority() != null) {
                          logID(3502);
                        }

                        if (listener._getFixedPriority() !== fixedPriority) {
                          listener._setFixedPriority(fixedPriority);

                          this._setDirty(listener._getListenerID(), DIRTY_FIXED_PRIORITY);
                        }

                        return;
                      }
                    }
                  }
                }
                /**
                 * @en
                 * Whether to enable dispatching events.
                 *
                 * @zh
                 * 启用或禁用事件管理器，禁用后不会分发任何事件。
                 *
                 * @param enabled - 是否启用事件管理器。
                 */

              }, {
                key: "setEnabled",
                value: function setEnabled(enabled) {
                  this._isEnabled = enabled;
                }
                /**
                 * @en
                 * Checks whether dispatching events is enabled.
                 *
                 * @zh 检测事件管理器是否启用。
                 *
                 * @returns
                 */

              }, {
                key: "isEnabled",
                value: function isEnabled() {
                  return this._isEnabled;
                }
                /**
                 * @en
                 * Dispatches the event, also removes all EventListeners marked for deletion from the event dispatcher list.
                 *
                 * @zh
                 * 分发事件。
                 *
                 * @param event - 分发事件。
                 */

              }, {
                key: "dispatchEvent",
                value: function dispatchEvent(event) {
                  if (!this._isEnabled) {
                    return;
                  }

                  this._updateDirtyFlagForSceneGraph();

                  this._inDispatch++;

                  if (!event || !event.getType) {
                    errorID(3511);
                    return;
                  }

                  if (event.getType().startsWith(legacyCC.Event.TOUCH)) {
                    this._dispatchTouchEvent(event);

                    this._inDispatch--;
                    return;
                  }

                  var listenerID = __getListenerID(event);

                  this._sortEventListeners(listenerID);

                  var selListeners = this._listenersMap[listenerID];

                  if (selListeners != null) {
                    this._dispatchEventToListeners(selListeners, this._onListenerCallback, event);

                    this._onUpdateListeners(selListeners);
                  }

                  this._inDispatch--;
                }
              }, {
                key: "_onListenerCallback",
                value: function _onListenerCallback(listener, event) {
                  event.currentTarget = listener._target;
                  var onEvent = listener.onEvent;

                  if (onEvent) {
                    onEvent(event);
                  }

                  return event.isStopped();
                }
                /**
                 * @en
                 * Dispatches a Custom Event with a event name an optional user data.
                 *
                 * @zh
                 * 分发自定义事件。
                 *
                 * @param eventName - 自定义事件名。
                 * @param optionalUserData
                 */

              }, {
                key: "dispatchCustomEvent",
                value: function dispatchCustomEvent(eventName, optionalUserData) {
                  var ev = new legacyCC.Event.EventCustom(eventName);
                  ev.setUserData(optionalUserData);
                  this.dispatchEvent(ev);
                }
              }, {
                key: "_setDirtyForNode",
                value: function _setDirtyForNode(node) {
                  // Mark the node dirty only when there is an event listener associated with it.
                  // @ts-ignore
                  var selListeners = this._nodeListenersMap[node._id];

                  if (selListeners !== undefined) {
                    for (var j = 0, len = selListeners.length; j < len; j++) {
                      var selListener = selListeners[j];

                      var listenerID = selListener._getListenerID();

                      if (this._dirtyListeners[listenerID] == null) {
                        this._dirtyListeners[listenerID] = true;
                      }
                    }
                  }

                  if (node.children.length > 0) {
                    var _children = node.children;

                    for (var i = 0, _len = _children ? _children.length : 0; i < _len; i++) {
                      this._setDirtyForNode(_children[i]);
                    }
                  }
                }
              }, {
                key: "_addListener",
                value: function _addListener(listener) {
                  if (this._inDispatch === 0) {
                    this._forceAddEventListener(listener);
                  } else {
                    this._toAddedListeners.push(listener);
                  }
                }
              }, {
                key: "_forceAddEventListener",
                value: function _forceAddEventListener(listener) {
                  var listenerID = listener._getListenerID();

                  var listeners = this._listenersMap[listenerID];

                  if (!listeners) {
                    listeners = new _EventListenerVector();
                    this._listenersMap[listenerID] = listeners;
                  }

                  listeners.push(listener);

                  if (listener._getFixedPriority() === 0) {
                    this._setDirty(listenerID, DIRTY_SCENE_GRAPH_PRIORITY);

                    var node = listener._getSceneGraphPriority();

                    if (node === null) {
                      logID(3507);
                    }

                    this._associateNodeAndEventListener(node, listener);

                    if (node.activeInHierarchy) {
                      this.resumeTarget(node);
                    }
                  } else {
                    this._setDirty(listenerID, DIRTY_FIXED_PRIORITY);
                  }
                }
              }, {
                key: "_getListeners",
                value: function _getListeners(listenerID) {
                  return this._listenersMap[listenerID];
                }
              }, {
                key: "_updateDirtyFlagForSceneGraph",
                value: function _updateDirtyFlagForSceneGraph() {
                  var locDirtyListeners = this._dirtyListeners; // tslint:disable-next-line: forin

                  for (var selKey in locDirtyListeners) {
                    this._setDirty(selKey, DIRTY_SCENE_GRAPH_PRIORITY);
                  }

                  this._dirtyListeners.length = 0;
                }
              }, {
                key: "_removeAllListenersInVector",
                value: function _removeAllListenersInVector(listenerVector) {
                  if (!listenerVector) {
                    return;
                  }

                  var selListener;

                  for (var i = listenerVector.length - 1; i >= 0; i--) {
                    selListener = listenerVector[i];

                    selListener._setRegistered(false);

                    if (selListener._getSceneGraphPriority() != null) {
                      this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener);

                      selListener._setSceneGraphPriority(null); // NULL out the node pointer so we don't have any dangling pointers to destroyed nodes.

                    }

                    if (this._inDispatch === 0) {
                      legacyCC.js.array.removeAt(listenerVector, i);
                    }
                  }
                }
              }, {
                key: "_removeListenersForListenerID",
                value: function _removeListenersForListenerID(listenerID) {
                  var listeners = this._listenersMap[listenerID];

                  if (listeners) {
                    var fixedPriorityListeners = listeners.getFixedPriorityListeners();
                    var sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();

                    this._removeAllListenersInVector(sceneGraphPriorityListeners);

                    this._removeAllListenersInVector(fixedPriorityListeners); // Remove the dirty flag according the 'listenerID'.
                    // No need to check whether the dispatcher is dispatching event.


                    delete this._priorityDirtyFlagMap[listenerID];

                    if (!this._inDispatch) {
                      listeners.clear();
                      delete this._listenersMap[listenerID];
                    }
                  }

                  var locToAddedListeners = this._toAddedListeners;

                  for (var i = locToAddedListeners.length - 1; i >= 0; i--) {
                    var listener = locToAddedListeners[i];

                    if (listener && listener._getListenerID() === listenerID) {
                      legacyCC.js.array.removeAt(locToAddedListeners, i);
                    }
                  }
                }
              }, {
                key: "_sortEventListeners",
                value: function _sortEventListeners(listenerID) {
                  var dirtyFlag = DIRTY_NONE;
                  var locFlagMap = this._priorityDirtyFlagMap;

                  if (locFlagMap[listenerID]) {
                    dirtyFlag = locFlagMap[listenerID];
                  }

                  if (dirtyFlag !== DIRTY_NONE) {
                    // Clear the dirty flag first, if `rootNode` is null, then set its dirty flag of scene graph priority
                    locFlagMap[listenerID] = DIRTY_NONE;

                    if (dirtyFlag & DIRTY_FIXED_PRIORITY) {
                      this._sortListenersOfFixedPriority(listenerID);
                    }

                    if (dirtyFlag & DIRTY_SCENE_GRAPH_PRIORITY) {
                      var rootEntity = legacyCC.director.getScene();

                      if (rootEntity) {
                        this._sortListenersOfSceneGraphPriority(listenerID);
                      }
                    }
                  }
                }
              }, {
                key: "_sortListenersOfSceneGraphPriority",
                value: function _sortListenersOfSceneGraphPriority(listenerID) {
                  var listeners = this._getListeners(listenerID);

                  if (!listeners) {
                    return;
                  }

                  var sceneGraphListener = listeners.getSceneGraphPriorityListeners();

                  if (!sceneGraphListener || sceneGraphListener.length === 0) {
                    return;
                  } // After sort: priority < 0, > 0


                  listeners.getSceneGraphPriorityListeners().sort(this._sortEventListenersOfSceneGraphPriorityDes);
                }
              }, {
                key: "_sortEventListenersOfSceneGraphPriorityDes",
                value: function _sortEventListenersOfSceneGraphPriorityDes(l1, l2) {
                  var node1 = l1._getSceneGraphPriority();

                  var node2 = l2._getSceneGraphPriority(); // Event manager should only care about ui node in the current scene hierarchy


                  if (!l2 || !node2 || !node2._activeInHierarchy || !node2._uiProps.uiTransformComp) {
                    return -1;
                  } else if (!l1 || !node1 || !node1._activeInHierarchy || !node1._uiProps.uiTransformComp) {
                    return 1;
                  }

                  var p1 = node1,
                      p2 = node2,
                      ex = false;
                  var trans1 = node1._uiProps.uiTransformComp;
                  var trans2 = node2._uiProps.uiTransformComp;

                  if (trans1.visibility !== trans2.visibility) {
                    return trans2.visibility - trans1.visibility;
                  }

                  while (p1.parent._id !== p2.parent._id) {
                    p1 = p1.parent.parent === null ? (ex = true) && node2 : p1.parent;
                    p2 = p2.parent.parent === null ? (ex = true) && node1 : p2.parent;
                  }

                  if (p1._id === p2._id) {
                    if (p1._id === node2._id) {
                      return -1;
                    }

                    if (p1._id === node1._id) {
                      return 1;
                    }
                  }

                  var priority1 = p1.getSiblingIndex();
                  var priority2 = p2.getSiblingIndex();
                  return ex ? priority1 - priority2 : priority2 - priority1;
                }
              }, {
                key: "_sortListenersOfFixedPriority",
                value: function _sortListenersOfFixedPriority(listenerID) {
                  var listeners = this._listenersMap[listenerID];

                  if (!listeners) {
                    return;
                  }

                  var fixedListeners = listeners.getFixedPriorityListeners();

                  if (!fixedListeners || fixedListeners.length === 0) {
                    return;
                  } // After sort: priority < 0, > 0


                  fixedListeners.sort(this._sortListenersOfFixedPriorityAsc); // FIXME: Should use binary search

                  var index = 0;

                  for (var len = fixedListeners.length; index < len;) {
                    if (fixedListeners[index]._getFixedPriority() >= 0) {
                      break;
                    }

                    ++index;
                  }

                  listeners.gt0Index = index;
                }
              }, {
                key: "_sortListenersOfFixedPriorityAsc",
                value: function _sortListenersOfFixedPriorityAsc(l1, l2) {
                  return l1._getFixedPriority() - l2._getFixedPriority();
                }
              }, {
                key: "_onUpdateListeners",
                value: function _onUpdateListeners(listeners) {
                  var fixedPriorityListeners = listeners.getFixedPriorityListeners();
                  var sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
                  var toRemovedListeners = this._toRemovedListeners;

                  if (sceneGraphPriorityListeners) {
                    for (var i = sceneGraphPriorityListeners.length - 1; i >= 0; i--) {
                      var selListener = sceneGraphPriorityListeners[i];

                      if (!selListener._isRegistered()) {
                        legacyCC.js.array.removeAt(sceneGraphPriorityListeners, i); // if item in toRemove list, remove it from the list

                        var idx = toRemovedListeners.indexOf(selListener);

                        if (idx !== -1) {
                          toRemovedListeners.splice(idx, 1);
                        }
                      }
                    }
                  }

                  if (fixedPriorityListeners) {
                    for (var _i5 = fixedPriorityListeners.length - 1; _i5 >= 0; _i5--) {
                      var _selListener = fixedPriorityListeners[_i5];

                      if (!_selListener._isRegistered()) {
                        legacyCC.js.array.removeAt(fixedPriorityListeners, _i5); // if item in toRemove list, remove it from the list

                        var _idx = toRemovedListeners.indexOf(_selListener);

                        if (_idx !== -1) {
                          toRemovedListeners.splice(_idx, 1);
                        }
                      }
                    }
                  }

                  if (sceneGraphPriorityListeners && sceneGraphPriorityListeners.length === 0) {
                    listeners.clearSceneGraphListeners();
                  }

                  if (fixedPriorityListeners && fixedPriorityListeners.length === 0) {
                    listeners.clearFixedListeners();
                  }
                }
              }, {
                key: "_updateTouchListeners",
                value: function _updateTouchListeners(event) {
                  var locInDispatch = this._inDispatch;
                  assertID(locInDispatch > 0, 3508);

                  if (locInDispatch > 1) {
                    return;
                  }

                  var listeners;
                  listeners = this._listenersMap[ListenerID$1.TOUCH_ONE_BY_ONE];

                  if (listeners) {
                    this._onUpdateListeners(listeners);
                  }

                  listeners = this._listenersMap[ListenerID$1.TOUCH_ALL_AT_ONCE];

                  if (listeners) {
                    this._onUpdateListeners(listeners);
                  }

                  assertID(locInDispatch === 1, 3509);
                  var locToAddedListeners = this._toAddedListeners;

                  if (locToAddedListeners.length !== 0) {
                    for (var i = 0, len = locToAddedListeners.length; i < len; i++) {
                      this._forceAddEventListener(locToAddedListeners[i]);
                    }

                    this._toAddedListeners.length = 0;
                  }

                  if (this._toRemovedListeners.length !== 0) {
                    this._cleanToRemovedListeners();
                  }
                } // Remove all listeners in _toRemoveListeners list and cleanup

              }, {
                key: "_cleanToRemovedListeners",
                value: function _cleanToRemovedListeners() {
                  var toRemovedListeners = this._toRemovedListeners;

                  for (var i = 0; i < toRemovedListeners.length; ++i) {
                    var selListener = toRemovedListeners[i];

                    var listeners = this._listenersMap[selListener._getListenerID()];

                    if (!listeners) {
                      continue;
                    }

                    var fixedPriorityListeners = listeners.getFixedPriorityListeners();
                    var sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();

                    if (sceneGraphPriorityListeners) {
                      var idx = sceneGraphPriorityListeners.indexOf(selListener);

                      if (idx !== -1) {
                        sceneGraphPriorityListeners.splice(idx, 1);
                      }
                    }

                    if (fixedPriorityListeners) {
                      var _idx2 = fixedPriorityListeners.indexOf(selListener);

                      if (_idx2 !== -1) {
                        fixedPriorityListeners.splice(_idx2, 1);
                      }
                    }
                  }

                  toRemovedListeners.length = 0;
                }
              }, {
                key: "_onTouchEventCallback",
                value: function _onTouchEventCallback(listener, argsObj) {
                  // Skip if the listener was removed.
                  if (!listener._isRegistered()) {
                    return false;
                  }

                  var event = argsObj.event;
                  var selTouch = event.touch;
                  event.currentTarget = listener._getSceneGraphPriority();
                  var isClaimed = false;
                  var removedIdx = -1;
                  var getCode = event.getEventCode(); // const EventTouch = cc.Event.EventTouch;

                  if (getCode === EventTouch.BEGAN) {
                    if (!macro.ENABLE_MULTI_TOUCH && eventManager._currentTouch) {
                      var node = eventManager._currentTouchListener._node;

                      if (!node || node.activeInHierarchy) {
                        return false;
                      }
                    }

                    if (listener.onTouchBegan) {
                      isClaimed = listener.onTouchBegan(selTouch, event);

                      if (isClaimed && listener._isRegistered()) {
                        listener._claimedTouches.push(selTouch);

                        if (macro.ENABLE_MULTI_TOUCH || !eventManager._currentTouch) {
                          eventManager._currentTouch = selTouch;
                        }

                        eventManager._currentTouchListener = listener;
                      }
                    }
                  } else if (listener._claimedTouches.length > 0) {
                    removedIdx = listener._claimedTouches.indexOf(selTouch);

                    if (removedIdx !== -1) {
                      isClaimed = true;

                      if (!macro.ENABLE_MULTI_TOUCH && eventManager._currentTouch && eventManager._currentTouch !== selTouch) {
                        return false;
                      }

                      if (getCode === EventTouch.MOVED && listener.onTouchMoved) {
                        listener.onTouchMoved(selTouch, event);
                      } else if (getCode === EventTouch.ENDED) {
                        if (listener.onTouchEnded) {
                          listener.onTouchEnded(selTouch, event);
                        }

                        if (listener._isRegistered()) {
                          listener._claimedTouches.splice(removedIdx, 1);
                        }

                        if (macro.ENABLE_MULTI_TOUCH || eventManager._currentTouch === selTouch) {
                          eventManager._currentTouch = null;
                        }

                        eventManager._currentTouchListener = null;
                      } else if (getCode === EventTouch.CANCELLED) {
                        if (listener.onTouchCancelled) {
                          listener.onTouchCancelled(selTouch, event);
                        }

                        if (listener._isRegistered()) {
                          listener._claimedTouches.splice(removedIdx, 1);
                        }

                        if (macro.ENABLE_MULTI_TOUCH || eventManager._currentTouch === selTouch) {
                          eventManager._currentTouch = null;
                        }

                        eventManager._currentTouchListener = null;
                      }
                    }
                  } // If the event was stopped, return directly.


                  if (event.isStopped()) {
                    eventManager._updateTouchListeners(event);

                    return true;
                  }

                  if (isClaimed && listener._isRegistered() && listener.swallowTouches) {
                    if (argsObj.needsMutableSet) {
                      argsObj.touches.splice(selTouch, 1);
                    }

                    return true;
                  }

                  return false;
                }
              }, {
                key: "_dispatchTouchEvent",
                value: function _dispatchTouchEvent(event) {
                  this._sortEventListeners(ListenerID$1.TOUCH_ONE_BY_ONE);

                  this._sortEventListeners(ListenerID$1.TOUCH_ALL_AT_ONCE);

                  var oneByOneListeners = this._getListeners(ListenerID$1.TOUCH_ONE_BY_ONE);

                  var allAtOnceListeners = this._getListeners(ListenerID$1.TOUCH_ALL_AT_ONCE); // If there aren't any touch listeners, return directly.


                  if (null === oneByOneListeners && null === allAtOnceListeners) {
                    return;
                  }

                  var originalTouches = event.getTouches();
                  var mutableTouches = legacyCC.js.array.copy(originalTouches);
                  var oneByOneArgsObj = {
                    event: event,
                    needsMutableSet: oneByOneListeners && allAtOnceListeners,
                    touches: mutableTouches,
                    selTouch: null
                  }; //
                  // process the target handlers 1st
                  //

                  if (oneByOneListeners) {
                    for (var i = 0; i < originalTouches.length; ++i) {
                      var originalTouch = originalTouches[i];
                      event.touch = originalTouch;
                      event.propagationStopped = event.propagationImmediateStopped = false;

                      this._dispatchEventToListeners(oneByOneListeners, this._onTouchEventCallback, oneByOneArgsObj);
                    }
                  } //
                  // process standard handlers 2nd
                  //


                  if (allAtOnceListeners && mutableTouches.length > 0) {
                    this._dispatchEventToListeners(allAtOnceListeners, this._onTouchesEventCallback, {
                      event: event,
                      touches: mutableTouches
                    });

                    if (event.isStopped()) {
                      return;
                    }
                  }

                  this._updateTouchListeners(event);
                }
              }, {
                key: "_onTouchesEventCallback",
                value: function _onTouchesEventCallback(listener, callbackParams) {
                  // Skip if the listener was removed.
                  if (!listener._isRegistered()) {
                    return false;
                  } // const EventTouch = cc.Event.EventTouch;


                  var event = callbackParams.event;
                  var touches = callbackParams.touches;
                  var getCode = event.getEventCode();
                  event.currentTarget = listener._getSceneGraphPriority();

                  if (getCode === EventTouch.BEGAN && listener.onTouchesBegan) {
                    listener.onTouchesBegan(touches, event);
                  } else if (getCode === EventTouch.MOVED && listener.onTouchesMoved) {
                    listener.onTouchesMoved(touches, event);
                  } else if (getCode === EventTouch.ENDED && listener.onTouchesEnded) {
                    listener.onTouchesEnded(touches, event);
                  } else if (getCode === EventTouch.CANCELLED && listener.onTouchesCancelled) {
                    listener.onTouchesCancelled(touches, event);
                  } // If the event was stopped, return directly.


                  if (event.isStopped()) {
                    eventManager._updateTouchListeners(event);

                    return true;
                  }

                  return false;
                }
              }, {
                key: "_associateNodeAndEventListener",
                value: function _associateNodeAndEventListener(node, listener) {
                  var listeners = this._nodeListenersMap[node.uuid];

                  if (!listeners) {
                    listeners = [];
                    this._nodeListenersMap[node.uuid] = listeners;
                  }

                  listeners.push(listener);
                }
              }, {
                key: "_dissociateNodeAndEventListener",
                value: function _dissociateNodeAndEventListener(node, listener) {
                  var listeners = this._nodeListenersMap[node.uuid];

                  if (listeners) {
                    legacyCC.js.array.remove(listeners, listener);

                    if (listeners.length === 0) {
                      delete this._nodeListenersMap[node.uuid];
                    }
                  }
                }
              }, {
                key: "_dispatchEventToListeners",
                value: function _dispatchEventToListeners(listeners, onEvent, eventOrArgs) {
                  var shouldStopPropagation = false;
                  var fixedPriorityListeners = listeners.getFixedPriorityListeners();
                  var sceneGraphPriorityListeners = listeners.getSceneGraphPriorityListeners();
                  var i = 0;

                  if (fixedPriorityListeners) {
                    // priority < 0
                    if (fixedPriorityListeners.length !== 0) {
                      for (; i < listeners.gt0Index; ++i) {
                        var selListener = fixedPriorityListeners[i];

                        if (selListener.isEnabled() && !selListener._isPaused() && selListener._isRegistered() && onEvent(selListener, eventOrArgs)) {
                          shouldStopPropagation = true;
                          break;
                        }
                      }
                    }
                  }

                  if (sceneGraphPriorityListeners && !shouldStopPropagation) {
                    // priority == 0, scene graph priority
                    for (var _i6 = 0; _i6 < sceneGraphPriorityListeners.length; ++_i6) {
                      var _selListener2 = sceneGraphPriorityListeners[_i6];

                      if (_selListener2.isEnabled() && !_selListener2._isPaused() && _selListener2._isRegistered() && onEvent(_selListener2, eventOrArgs)) {
                        shouldStopPropagation = true;
                        break;
                      }
                    }
                  }

                  if (fixedPriorityListeners && !shouldStopPropagation) {
                    // priority > 0
                    for (; i < fixedPriorityListeners.length; ++i) {
                      var _selListener3 = fixedPriorityListeners[i];

                      if (_selListener3.isEnabled() && !_selListener3._isPaused() && _selListener3._isRegistered() && onEvent(_selListener3, eventOrArgs)) {
                        shouldStopPropagation = true;
                        break;
                      }
                    }
                  }
                }
              }, {
                key: "_setDirty",
                value: function _setDirty(listenerID, flag) {
                  var locDirtyFlagMap = this._priorityDirtyFlagMap;

                  if (locDirtyFlagMap[listenerID] == null) {
                    locDirtyFlagMap[listenerID] = flag;
                  } else {
                    locDirtyFlagMap[listenerID] = flag | locDirtyFlagMap[listenerID];
                  }
                }
              }, {
                key: "_sortNumberAsc",
                value: function _sortNumberAsc(a, b) {
                  return a - b;
                }
              }, {
                key: "_removeListenerInCallback",
                value: function _removeListenerInCallback(listeners, callback) {
                  if (listeners == null) {
                    return false;
                  }

                  for (var i = listeners.length - 1; i >= 0; i--) {
                    var selListener = listeners[i]; // @ts-ignore

                    if (selListener._onCustomEvent === callback || selListener.onEvent === callback) {
                      selListener._setRegistered(false);

                      if (selListener._getSceneGraphPriority() != null) {
                        this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener); // NULL out the node pointer so we don't have any dangling pointers to destroyed nodes.


                        selListener._setSceneGraphPriority(null);
                      }

                      if (this._inDispatch === 0) {
                        legacyCC.js.array.removeAt(listeners, i);
                      } else {
                        this._toRemovedListeners.push(selListener);
                      }

                      return true;
                    }
                  }

                  return false;
                }
              }, {
                key: "_removeListenerInVector",
                value: function _removeListenerInVector(listeners, listener) {
                  if (listeners == null) {
                    return false;
                  }

                  for (var i = listeners.length - 1; i >= 0; i--) {
                    var selListener = listeners[i];

                    if (selListener === listener) {
                      selListener._setRegistered(false);

                      if (selListener._getSceneGraphPriority() != null) {
                        this._dissociateNodeAndEventListener(selListener._getSceneGraphPriority(), selListener); // NULL out the node pointer so we don't have any dangling pointers to destroyed nodes.


                        selListener._setSceneGraphPriority(null);
                      }

                      if (this._inDispatch === 0) {
                        legacyCC.js.array.removeAt(listeners, i);
                      } else {
                        this._toRemovedListeners.push(selListener);
                      }

                      return true;
                    }
                  }

                  return false;
                }
              }]);

              return EventManager;
            }();
            /**
             * @en
             * This class has been deprecated, please use `systemEvent` or `EventTarget` instead.
             * See [Listen to and launch events](../../../manual/en/scripting/events.md) for details.<br>
             * <br>
             * `eventManager` is a singleton object which manages event listener subscriptions and event dispatching.
             * The EventListener list is managed in such way so that event listeners can be added and removed
             * while events are being dispatched.
             *
             * @zh
             * 该类已废弃，请使用 `systemEvent` 或 `EventTarget` 代替，详见 [监听和发射事件](../../../manual/zh/scripting/events.md)。<br>
             * <br>
             * 事件管理器，它主要管理事件监听器注册和派发系统事件。
             *
             * @class eventManager
             * @static
             * @example {@link cocos/core/event-manager/CCEventManager/addListener.js}
             * @deprecated
             */


            var eventManager = exports('b9', new EventManager());
            legacyCC.eventManager = eventManager;

            var Destroying = CCObject.Flags.Destroying;

            var _cachedArray = new Array(16);

            var _currentHovered = null;
            var pos = new Vec2();
            var _touchEvents = [SystemEventType.TOUCH_START.toString(), SystemEventType.TOUCH_MOVE.toString(), SystemEventType.TOUCH_END.toString(), SystemEventType.TOUCH_CANCEL.toString()];
            var _mouseEvents = [SystemEventType.MOUSE_DOWN.toString(), SystemEventType.MOUSE_ENTER.toString(), SystemEventType.MOUSE_MOVE.toString(), SystemEventType.MOUSE_LEAVE.toString(), SystemEventType.MOUSE_UP.toString(), SystemEventType.MOUSE_WHEEL.toString()]; // TODO: rearrange event

            function _touchStartHandler(touch, event) {
              var node = this.owner;

              if (!node || !node._uiProps.uiTransformComp) {
                return false;
              }

              touch.getUILocation(pos);

              if (node._uiProps.uiTransformComp.isHit(pos, this)) {
                event.type = SystemEventType.TOUCH_START.toString();
                event.touch = touch;
                event.bubbles = true;
                node.dispatchEvent(event);
                return true;
              }

              return false;
            }

            function _touchMoveHandler(touch, event) {
              var node = this.owner;

              if (!node || !node._uiProps.uiTransformComp) {
                return false;
              }

              event.type = SystemEventType.TOUCH_MOVE.toString();
              event.touch = touch;
              event.bubbles = true;
              node.dispatchEvent(event);
            }

            function _touchEndHandler(touch, event) {
              var node = this.owner;

              if (!node || !node._uiProps.uiTransformComp) {
                return;
              }

              touch.getUILocation(pos);

              if (node._uiProps.uiTransformComp.isHit(pos, this)) {
                event.type = SystemEventType.TOUCH_END.toString();
              } else {
                event.type = SystemEventType.TOUCH_CANCEL.toString();
              }

              event.touch = touch;
              event.bubbles = true;
              node.dispatchEvent(event);
            }

            function _touchCancelHandler(touch, event) {
              var node = this.owner;

              if (!node || !node._uiProps.uiTransformComp) {
                return;
              }

              event.type = SystemEventType.TOUCH_CANCEL.toString();
              event.touch = touch;
              event.bubbles = true;
              node.dispatchEvent(event);
            }

            function _mouseDownHandler(event) {
              var node = this.owner;

              if (!node || !node._uiProps.uiTransformComp) {
                return;
              }

              pos = event.getUILocation();

              if (node._uiProps.uiTransformComp.isHit(pos, this)) {
                event.type = SystemEventType.MOUSE_DOWN.toString();
                event.bubbles = true;
                node.dispatchEvent(event);
              }
            }

            function _mouseMoveHandler(event) {
              var node = this.owner;

              if (!node || !node._uiProps.uiTransformComp) {
                return;
              }

              pos = event.getUILocation();

              var hit = node._uiProps.uiTransformComp.isHit(pos, this);

              if (hit) {
                if (!this._previousIn) {
                  // Fix issue when hover node switched, previous hovered node won't get MOUSE_LEAVE notification
                  if (_currentHovered && _currentHovered.eventProcessor.mouseListener) {
                    event.type = SystemEventType.MOUSE_LEAVE;

                    _currentHovered.dispatchEvent(event);

                    if (_currentHovered.eventProcessor.mouseListener) {
                      _currentHovered.eventProcessor.mouseListener._previousIn = false;
                    }
                  }

                  _currentHovered = node;
                  event.type = SystemEventType.MOUSE_ENTER.toString();
                  node.dispatchEvent(event);
                  this._previousIn = true;
                }

                event.type = SystemEventType.MOUSE_MOVE.toString();
                event.bubbles = true;
                node.dispatchEvent(event);
              } else if (this._previousIn) {
                event.type = SystemEventType.MOUSE_LEAVE.toString();
                node.dispatchEvent(event);
                this._previousIn = false;
                _currentHovered = null;
              } else {
                // continue dispatching
                return;
              } // Event processed, cleanup
              // event.propagationStopped = true;


              event.propagationStopped = true;
            }

            function _mouseUpHandler(event) {
              var node = this.owner;

              if (!node || !node._uiProps.uiTransformComp) {
                return;
              }

              pos = event.getUILocation();

              if (node._uiProps.uiTransformComp.isHit(pos, this)) {
                event.type = SystemEventType.MOUSE_UP.toString();
                event.bubbles = true;
                node.dispatchEvent(event); // event.propagationStopped = true;

                event.propagationStopped = true;
              }
            }

            function _mouseWheelHandler(event) {
              var node = this.owner;

              if (!node || !node._uiProps.uiTransformComp) {
                return;
              }

              pos = event.getUILocation();

              if (node._uiProps.uiTransformComp.isHit(pos, this)) {
                event.type = SystemEventType.MOUSE_WHEEL.toString();
                event.bubbles = true;
                node.dispatchEvent(event); // event.propagationStopped = true;

                event.propagationStopped = true;
              }
            }

            function _doDispatchEvent(owner, event) {
              var target;
              var i = 0;
              event.target = owner; // Event.CAPTURING_PHASE

              _cachedArray.length = 0;
              owner.eventProcessor.getCapturingTargets(event.type, _cachedArray); // capturing

              event.eventPhase = 1;

              for (i = _cachedArray.length - 1; i >= 0; --i) {
                target = _cachedArray[i];

                if (target.eventProcessor.capturingTargets) {
                  event.currentTarget = target; // fire event

                  target.eventProcessor.capturingTargets.emit(event.type, event, _cachedArray); // check if propagation stopped

                  if (event.propagationStopped) {
                    _cachedArray.length = 0;
                    return;
                  }
                }
              }

              _cachedArray.length = 0; // Event.AT_TARGET
              // checks if destroyed in capturing callbacks

              event.eventPhase = 2;
              event.currentTarget = owner;

              if (owner.eventProcessor.capturingTargets) {
                owner.eventProcessor.capturingTargets.emit(event.type, event);
              }

              if (!event.propagationImmediateStopped && owner.eventProcessor.bubblingTargets) {
                owner.eventProcessor.bubblingTargets.emit(event.type, event);
              }

              if (!event.propagationStopped && event.bubbles) {
                // Event.BUBBLING_PHASE
                owner.eventProcessor.getBubblingTargets(event.type, _cachedArray); // propagate

                event.eventPhase = 3;

                for (i = 0; i < _cachedArray.length; ++i) {
                  target = _cachedArray[i];

                  if (target.eventProcessor.bubblingTargets) {
                    event.currentTarget = target; // fire event

                    target.eventProcessor.bubblingTargets.emit(event.type, event); // check if propagation stopped

                    if (event.propagationStopped) {
                      _cachedArray.length = 0;
                      return;
                    }
                  }
                }
              }

              _cachedArray.length = 0;
            }

            function _searchMaskInParent(node) {
              var Mask = legacyCC.Mask;

              if (Mask) {
                var index = 0;

                for (var curr = node; curr && legacyCC.Node.isNode(curr); curr = curr.parent, ++index) {
                  if (curr.getComponent(Mask)) {
                    return {
                      index: index,
                      node: curr
                    };
                  }
                }
              }

              return null;
            }

            function _checkListeners(node, events) {
              if (!node._persistNode) {
                if (node.eventProcessor.bubblingTargets) {
                  for (var i = 0; i < events.length; ++i) {
                    if (node.eventProcessor.bubblingTargets.hasEventListener(events[i])) {
                      return true;
                    }
                  }
                }

                if (node.eventProcessor.capturingTargets) {
                  for (var _i = 0; _i < events.length; ++_i) {
                    if (node.eventProcessor.capturingTargets.hasEventListener(events[_i])) {
                      return true;
                    }
                  }
                }

                return false;
              }

              return true;
            }
            /**
             * @zh
             * 节点事件类。
             */


            var NodeEventProcessor = /*#__PURE__*/function () {
              _createClass(NodeEventProcessor, [{
                key: "node",
                get: function get() {
                  return this._node;
                }
                /**
                 * @zh
                 * 节点冒泡事件监听器
                 */

              }]);

              function NodeEventProcessor(node) {
                _classCallCheck(this, NodeEventProcessor);

                this.bubblingTargets = null;
                this.capturingTargets = null;
                this.touchListener = null;
                this.mouseListener = null;
                this._node = void 0;
                this._node = node;
              }

              _createClass(NodeEventProcessor, [{
                key: "reattach",
                value: function reattach() {
                  if (this.touchListener) {
                    var mask = this.touchListener.mask = _searchMaskInParent(this._node);

                    if (this.mouseListener) {
                      this.mouseListener.mask = mask;
                    }
                  } else if (this.mouseListener) {
                    this.mouseListener.mask = _searchMaskInParent(this._node);
                  }
                }
              }, {
                key: "destroy",
                value: function destroy() {
                  if (_currentHovered === this._node) {
                    _currentHovered = null;
                  } // Remove all event listeners if necessary


                  if (this.touchListener || this.mouseListener) {
                    eventManager.removeListeners(this._node);

                    if (this.touchListener) {
                      this.touchListener.owner = null;
                      this.touchListener.mask = null;
                      this.touchListener = null;
                    }

                    if (this.mouseListener) {
                      this.mouseListener.owner = null;
                      this.mouseListener.mask = null;
                      this.mouseListener = null;
                    }
                  }

                  this.capturingTargets && this.capturingTargets.clear();
                  this.bubblingTargets && this.bubblingTargets.clear();
                }
                /**
                 * @zh
                 * 在节点上注册指定类型的回调函数，也可以设置 target 用于绑定响应函数的 this 对象。<br/>
                 * 鼠标或触摸事件会被系统调用 dispatchEvent 方法触发，触发的过程包含三个阶段：<br/>
                 * 1. 捕获阶段：派发事件给捕获目标（通过 `getCapturingTargets` 获取），比如，节点树中注册了捕获阶段的父节点，从根节点开始派发直到目标节点。<br/>
                 * 2. 目标阶段：派发给目标节点的监听器。<br/>
                 * 3. 冒泡阶段：派发事件给冒泡目标（通过 `getBubblingTargets` 获取），比如，节点树中注册了冒泡阶段的父节点，从目标节点开始派发直到根节点。<br/>
                 * 同时您可以将事件派发到父节点或者通过调用 stopPropagation 拦截它。<br/>
                 * 推荐使用这种方式来监听节点上的触摸或鼠标事件，请不要在节点上直接使用 `eventManager`。<br/>
                 * 你也可以注册自定义事件到节点上，并通过 emit 方法触发此类事件，对于这类事件，不会发生捕获冒泡阶段，只会直接派发给注册在该节点上的监听器。<br/>
                 * 你可以通过在 emit 方法调用时在 type 之后传递额外的参数作为事件回调的参数列表。<br/>
                 *
                 * @param type - 一个监听事件类型的字符串。参见：[[EventType]]
                 * @param callback - 事件分派时将被调用的回调函数。如果该回调存在则不会重复添加。
                 * @param callback.event - 事件派发的时候回调的第一个参数。
                 * @param callback.arg2 - 第二个参数。
                 * @param callback.arg3 - 第三个参数。
                 * @param callback.arg4 - 第四个参数。
                 * @param callback.arg5 - 第五个参数。
                 * @param target - 调用回调的目标。可以为空。
                 * @param useCapture - 当设置为 true，监听器将在捕获阶段触发，否则将在冒泡阶段触发。默认为 false。
                 * @return - 返回监听回调函数自身。
                 *
                 * @example
                 * ```ts
                 * import { Node } from 'cc';
                 * this.node.on(Node.EventType.TOUCH_START, this.memberFunction, this);  // if "this" is component and the "memberFunction" declared in CCClass.
                 * this.node.on(Node.EventType.TOUCH_START, callback, this);
                 * this.node.on(Node.EventType.ANCHOR_CHANGED, callback);
                 * ```
                 */

              }, {
                key: "on",
                value: function on(type, callback, target, useCapture) {
                  var forDispatch = this._checknSetupSysEvent(type);

                  if (forDispatch) {
                    return this._onDispatch(type, callback, target, useCapture);
                  } else {
                    // switch (type) {
                    //     case EventType.POSITION_CHANGED:
                    //         this._eventMask |= POSITION_ON;
                    //         break;
                    //     case EventType.SCALE_CHANGED:
                    //         this._eventMask |= SCALE_ON;
                    //         break;
                    //     case EventType.ROTATION_CHANGED:
                    //         this._eventMask |= ROTATION_ON;
                    //         break;
                    //     case EventType.SIZE_CHANGED:
                    //         this._eventMask |= SIZE_ON;
                    //         break;
                    //     case EventType.ANCHOR_CHANGED:
                    //         this._eventMask |= ANCHOR_ON;
                    //         break;
                    // }
                    if (!this.bubblingTargets) {
                      this.bubblingTargets = new CallbacksInvoker();
                    }

                    return this.bubblingTargets.on(type, callback, target);
                  }
                }
                /**
                 * @zh
                 * 注册节点的特定事件类型回调，回调会在第一时间被触发后删除自身。
                 *
                 * @param type - 一个监听事件类型的字符串。参见：[[EventType]]。
                 * @param callback - 事件分派时将被调用的回调函数。如果该回调存在则不会重复添加。
                 * @param callback.event - 事件派发的时候回调的第一个参数。
                 * @param callback.arg2 - 第二个参数。
                 * @param callback.arg3 - 第三个参数。
                 * @param callback.arg4 - 第四个参数。
                 * @param callback.arg5 - 第五个参数。
                 * @param target - 调用回调的目标。可以为空。
                 * @param useCapture - 当设置为 true，监听器将在捕获阶段触发，否则将在冒泡阶段触发。默认为 false。
                 *
                 * @example
                 * ```ts
                 * import { Node } from 'cc';
                 * node.once(Node.EventType.ANCHOR_CHANGED, callback);
                 * ```
                 */

              }, {
                key: "once",
                value: function once(type, callback, target, useCapture) {
                  var _this = this;

                  var forDispatch = this._checknSetupSysEvent(type);

                  var listeners;

                  if (forDispatch && useCapture) {
                    listeners = this.capturingTargets = this.capturingTargets || new CallbacksInvoker();
                  } else {
                    listeners = this.bubblingTargets = this.bubblingTargets || new CallbacksInvoker();
                  }

                  listeners.on(type, callback, target, true);
                  listeners.on(type, function () {
                    _this.off(type, callback, target);
                  }, undefined, true);
                }
                /**
                 * @zh
                 * 删除之前与同类型，回调，目标或 useCapture 注册的回调。
                 *
                 * @param type - 一个监听事件类型的字符串。参见：[[EventType]]。
                 * @param callback - 移除指定注册回调。如果没有给，则删除全部同事件类型的监听。
                 * @param target - 调用回调的目标。配合 callback 一起使用。
                 * @param useCapture - 当设置为 true，监听器将在捕获阶段触发，否则将在冒泡阶段触发。默认为 false。
                 *
                 * @example
                 * ```ts
                 * import { Node } from 'cc';
                 * this.node.off(Node.EventType.TOUCH_START, this.memberFunction, this);
                 * node.off(Node.EventType.TOUCH_START, callback, this.node);
                 * node.off(Node.EventType.ANCHOR_CHANGED, callback, this);
                 * ```
                 */

              }, {
                key: "off",
                value: function off(type, callback, target, useCapture) {
                  var touchEvent = _touchEvents.indexOf(type) !== -1;
                  var mouseEvent = !touchEvent && _mouseEvents.indexOf(type) !== -1;

                  if (touchEvent || mouseEvent) {
                    this._offDispatch(type, callback, target, useCapture);

                    if (touchEvent) {
                      if (this.touchListener && !_checkListeners(this._node, _touchEvents)) {
                        eventManager.removeListener(this.touchListener);
                        this.touchListener = null;
                      }
                    } else if (mouseEvent) {
                      if (this.mouseListener && !_checkListeners(this._node, _mouseEvents)) {
                        eventManager.removeListener(this.mouseListener);
                        this.mouseListener = null;
                      }
                    }
                  } else if (this.bubblingTargets) {
                    this.bubblingTargets.off(type, callback, target); // const hasListeners = this.bubblingTargets.hasEventListener(type);
                    // All listener removed
                    // if (!hasListeners) {
                    //     switch (type) {
                    //         case EventType.POSITION_CHANGED:
                    //             this._eventMask &= ~POSITION_ON;
                    //             break;
                    //         case EventType.SCALE_CHANGED:
                    //             this._eventMask &= ~SCALE_ON;
                    //             break;
                    //         case EventType.ROTATION_CHANGED:
                    //             this._eventMask &= ~ROTATION_ON;
                    //             break;
                    //         case EventType.SIZE_CHANGED:
                    //             this._eventMask &= ~SIZE_ON;
                    //             break;
                    //         case EventType.ANCHOR_CHANGED:
                    //             this._eventMask &= ~ANCHOR_ON;
                    //             break;
                    //     }
                    // }
                  }
                }
                /**
                 * @zh
                 * 通过事件名发送自定义事件
                 *
                 * @param type - 一个监听事件类型的字符串。
                 * @param arg0 - 回调第一个参数。
                 * @param arg1 - 回调第二个参数。
                 * @param arg2 - 回调第三个参数。
                 * @param arg3 - 回调第四个参数。
                 * @param arg4 - 回调第五个参数。
                 * @example
                 * ```ts
                 * eventTarget.emit('fire', event);
                 * eventTarget.emit('fire', message, emitter);
                 * ```
                 */

              }, {
                key: "emit",
                value: function emit(type, arg0, arg1, arg2, arg3, arg4) {
                  if (this.bubblingTargets) {
                    this.bubblingTargets.emit(type, arg0, arg1, arg2, arg3, arg4);
                  }
                }
                /**
                 * @zh
                 * 分发事件到事件流中。
                 *
                 * @param event - 分派到事件流中的事件对象。
                 */

              }, {
                key: "dispatchEvent",
                value: function dispatchEvent(event) {
                  _doDispatchEvent(this._node, event);

                  _cachedArray.length = 0;
                }
                /**
                 * @zh
                 * 是否监听过某事件。
                 *
                 * @param type - 一个监听事件类型的字符串。
                 * @param callback - The callback function of the event listener, if absent all event listeners for the given type will be removed
                 * @param target - The callback callee of the event listener
                 * @return - 返回是否当前节点已监听该事件类型。
                 */

              }, {
                key: "hasEventListener",
                value: function hasEventListener(type, callback, target) {
                  var has = false;

                  if (this.bubblingTargets) {
                    has = this.bubblingTargets.hasEventListener(type, callback, target);
                  }

                  if (!has && this.capturingTargets) {
                    has = this.capturingTargets.hasEventListener(type, callback, target);
                  }

                  return has;
                }
                /**
                 * @zh
                 * 移除在特定事件类型中注册的所有回调或在某个目标中注册的所有回调。
                 *
                 * @param target - 要删除的事件键或要删除的目标。
                 */

              }, {
                key: "targetOff",
                value: function targetOff(target) {
                  if (this.capturingTargets) {
                    this.capturingTargets.removeAll(target);
                  }

                  if (this.bubblingTargets) {
                    this.bubblingTargets.removeAll(target);
                  }

                  if (this.touchListener && !_checkListeners(this.node, _touchEvents)) {
                    eventManager.removeListener(this.touchListener);
                    this.touchListener = null;
                  }

                  if (this.mouseListener && !_checkListeners(this.node, _mouseEvents)) {
                    eventManager.removeListener(this.mouseListener);
                    this.mouseListener = null;
                  }
                }
                /**
                 * @zh
                 * 获得所提供的事件类型在目标捕获阶段监听的所有目标。
                 * 捕获阶段包括从根节点到目标节点的过程。
                 * 结果保存在数组参数中，并且必须从子节点排序到父节点。
                 *
                 * @param type - 一个监听事件类型的字符串。
                 * @param array - 接收目标的数组。
                 */

              }, {
                key: "getCapturingTargets",
                value: function getCapturingTargets(type, targets) {
                  var parent = this._node.parent;

                  while (parent) {
                    if (parent.eventProcessor.capturingTargets && parent.eventProcessor.capturingTargets.hasEventListener(type)) {
                      targets.push(parent);
                    }

                    parent = parent.parent;
                  }
                }
                /**
                 * @zh
                 * 获得所提供的事件类型在目标冒泡阶段监听的所有目标。
                 * 冒泡阶段目标节点到根节点的过程。
                 * 结果保存在数组参数中，并且必须从子节点排序到父节点。
                 *
                 * @param type - 一个监听事件类型的字符串。
                 * @param array - 接收目标的数组。
                 */

              }, {
                key: "getBubblingTargets",
                value: function getBubblingTargets(type, targets) {
                  var parent = this._node.parent;

                  while (parent) {
                    if (parent.eventProcessor.bubblingTargets && parent.eventProcessor.bubblingTargets.hasEventListener(type)) {
                      targets.push(parent);
                    }

                    parent = parent.parent;
                  }
                } // EVENT TARGET

              }, {
                key: "_checknSetupSysEvent",
                value: function _checknSetupSysEvent(type) {
                  var _this2 = this;

                  var newAdded = false;
                  var forDispatch = false; // just for ui

                  if (_touchEvents.indexOf(type) !== -1) {
                    if (!this.touchListener) {
                      this.touchListener = legacyCC.EventListener.create({
                        event: legacyCC.EventListener.TOUCH_ONE_BY_ONE,
                        swallowTouches: true,
                        owner: this._node,
                        mask: _searchMaskInParent(this._node),
                        onTouchBegan: _touchStartHandler,
                        onTouchMoved: _touchMoveHandler,
                        onTouchEnded: _touchEndHandler,
                        onTouchCancelled: _touchCancelHandler
                      });
                      eventManager.addListener(this.touchListener, this._node);
                      newAdded = true;
                    }

                    forDispatch = true;
                  } else if (_mouseEvents.indexOf(type) !== -1) {
                    if (!this.mouseListener) {
                      this.mouseListener = legacyCC.EventListener.create({
                        event: legacyCC.EventListener.MOUSE,
                        _previousIn: false,
                        owner: this._node,
                        mask: _searchMaskInParent(this._node),
                        onMouseDown: _mouseDownHandler,
                        onMouseMove: _mouseMoveHandler,
                        onMouseUp: _mouseUpHandler,
                        onMouseScroll: _mouseWheelHandler
                      });
                      eventManager.addListener(this.mouseListener, this._node);
                      newAdded = true;
                    }

                    forDispatch = true;
                  }

                  if (newAdded && !this._node.activeInHierarchy) {
                    legacyCC.director.getScheduler().schedule(function () {
                      if (!_this2._node.activeInHierarchy) {
                        eventManager.pauseTarget(_this2._node);
                      }
                    }, this._node, 0, 0, 0, false);
                  }

                  return forDispatch;
                }
              }, {
                key: "_onDispatch",
                value: function _onDispatch(type, callback, target, useCapture) {
                  // Accept also patameters like: (type, callback, useCapture)
                  if (typeof target === 'boolean') {
                    useCapture = target;
                    target = undefined;
                  } else {
                    useCapture = !!useCapture;
                  }

                  if (!callback) {
                    errorID(6800);
                    return;
                  }

                  var listeners = null;

                  if (useCapture) {
                    listeners = this.capturingTargets = this.capturingTargets || new CallbacksInvoker();
                  } else {
                    listeners = this.bubblingTargets = this.bubblingTargets || new CallbacksInvoker();
                  }

                  if (!listeners.hasEventListener(type, callback, target)) {
                    listeners.on(type, callback, target);
                  }

                  return callback;
                }
              }, {
                key: "_offDispatch",
                value: function _offDispatch(type, callback, target, useCapture) {
                  // Accept also patameters like: (type, callback, useCapture)
                  if (typeof target === 'boolean') {
                    useCapture = target;
                    target = undefined;
                  } else {
                    useCapture = !!useCapture;
                  }

                  if (!callback) {
                    if (this.capturingTargets) {
                      this.capturingTargets.removeAll(type);
                    }

                    if (this.bubblingTargets) {
                      this.bubblingTargets.removeAll(type);
                    }
                  } else {
                    var listeners = useCapture ? this.capturingTargets : this.bubblingTargets;

                    if (listeners) {
                      listeners.off(type, callback, target);
                    }
                  }
                }
              }]);

              return NodeEventProcessor;
            }();
            legacyCC.NodeEventProcessor = NodeEventProcessor;

            var _dec$b, _class$b, _class2$9, _descriptor$8, _descriptor2$6, _descriptor3$5, _descriptor4$3, _descriptor5$3, _class3$4, _temp$b;
            // @ts-ignore
            var Destroying$1 = CCObject.Flags.Destroying; // @ts-ignore

            var DontDestroy = CCObject.Flags.DontDestroy; // @ts-ignore

            var Deactivating = CCObject.Flags.Deactivating; // @ts-ignore

            var Activating = CCObject.Flags.Activating;
            var ChangingState = Activating | Deactivating;
            var TRANSFORM_ON = 1 << 0; // const CHILD_ADDED = 'child-added';
            // const CHILD_REMOVED = 'child-removed';

            var idGenerator$1 = new IDGenerator("Node");
            var NullScene = null;

            function getConstructor(typeOrClassName) {
              if (!typeOrClassName) {
                errorID(3804);
                return null;
              }

              if (typeof typeOrClassName === "string") {
                return getClassByName(typeOrClassName);
              }

              return typeOrClassName;
            }
            /**
             * @en The base class for [[Node]], it:
             * - maintains scene hierarchy and life cycle logic
             * - provides EventTarget ability
             * - emits events if some properties changed, ref: [[SystemEventType]]
             * - manages components
             * @zh [[Node]] 的基类，他会负责：
             * - 维护场景树以及节点生命周期管理
             * - 提供 EventTarget 的事件管理和注册能力
             * - 派发节点状态相关的事件，参考：[[SystemEventType]]
             * - 管理组件
             */


            var BaseNode = exports('cV', (_dec$b = ccclass("cc.BaseNode"), _dec$b(_class$b = (_class2$9 = (_temp$b = _class3$4 = /*#__PURE__*/function (_CCObject) {
              _inherits(BaseNode, _CCObject);

              _createClass(BaseNode, [{
                key: "components",

                /**
                 * @en Gets all components attached to this node.
                 * @zh 获取附加到此节点的所有组件。
                 */
                get: function get() {
                  return this._components;
                }
                /**
                 * @en If true, the node is an persist node which won't be destroyed during scene transition.
                 * If false, the node will be destroyed automatically when loading a new scene. Default is false.
                 * @zh 如果为true，则该节点是一个常驻节点，不会在场景转换期间被销毁。
                 * 如果为false，节点将在加载新场景时自动销毁。默认为 false。
                 * @default false
                 * @protected
                 */

              }, {
                key: "_persistNode",
                get: function get() {
                  return (this._objFlags & DontDestroy) > 0;
                },
                set: function set(value) {
                  if (value) {
                    this._objFlags |= DontDestroy;
                  } else {
                    this._objFlags &= ~DontDestroy;
                  }
                } // API

                /**
                 * @en Name of node.
                 * @zh 该节点名称。
                 */

              }, {
                key: "name",
                get: function get() {
                  return this._name;
                },
                set: function set(value) {

                  this._name = value;
                }
                /**
                 * @en The uuid for editor, will be stripped after building project.
                 * @zh 主要用于编辑器的 uuid，在编辑器下可用于持久化存储，在项目构建之后将变成自增的 id。
                 * @readOnly
                 */

              }, {
                key: "uuid",
                get: function get() {
                  return this._id;
                }
                /**
                 * @en All children nodes.
                 * @zh 节点的所有子节点。
                 * @readOnly
                 */

              }, {
                key: "children",
                get: function get() {
                  return this._children;
                }
                /**
                 * @en
                 * The local active state of this node.
                 * Note that a Node may be inactive because a parent is not active, even if this returns true.
                 * Use [[activeInHierarchy]]
                 * if you want to check if the Node is actually treated as active in the scene.
                 * @zh
                 * 当前节点的自身激活状态。
                 * 值得注意的是，一个节点的父节点如果不被激活，那么即使它自身设为激活，它仍然无法激活。
                 * 如果你想检查节点在场景中实际的激活状态可以使用 [[activeInHierarchy]]
                 * @default true
                 */

              }, {
                key: "active",
                get: function get() {
                  return this._active;
                },
                set: function set(isActive) {
                  if (this._active !== isActive) {
                    this._active = isActive;
                    var parent = this._parent;

                    if (parent) {
                      var couldActiveInScene = parent._activeInHierarchy;

                      if (couldActiveInScene) {
                        legacyCC.director._nodeActivator.activateNode(this, isActive);
                      }
                    }
                  }
                }
                /**
                 * @en Indicates whether this node is active in the scene.
                 * @zh 表示此节点是否在场景中激活。
                 */

              }, {
                key: "activeInHierarchy",
                get: function get() {
                  return this._activeInHierarchy;
                }
                /**
                 * @en The parent node
                 * @zh 父节点
                 */

              }, {
                key: "parent",
                get: function get() {
                  return this._parent;
                },
                set: function set(value) {
                  this.setParent(value);
                }
                /**
                 * @en Which scene this node belongs to.
                 * @zh 此节点属于哪个场景。
                 * @readonly
                 */

              }, {
                key: "scene",
                get: function get() {
                  return this._scene;
                }
                /**
                 * @en The event processor of the current node, it provides EventTarget ability.
                 * @zh 当前节点的事件处理器，提供 EventTarget 能力。
                 * @readonly
                 */

              }, {
                key: "eventProcessor",
                get: function get() {
                  return this._eventProcessor;
                }
              }], [{
                key: "_setScene",
                value: function _setScene(node) {
                  if (node instanceof legacyCC.Scene) {
                    node._scene = node;
                  } else {
                    if (node._parent == null) {
                      error$1("Node %s(%s) has not attached to a scene.", node.name, node.uuid);
                    } else {
                      node._scene = node._parent._scene;
                    }
                  }
                }
              }, {
                key: "_findComponent",
                value: function _findComponent(node, constructor) {
                  var cls = constructor;
                  var comps = node._components;

                  if (cls._sealed) {
                    for (var i = 0; i < comps.length; ++i) {
                      var comp = comps[i];

                      if (comp.constructor === constructor) {
                        return comp;
                      }
                    }
                  } else {
                    for (var _i = 0; _i < comps.length; ++_i) {
                      var _comp = comps[_i];

                      if (_comp instanceof constructor) {
                        return _comp;
                      }
                    }
                  }

                  return null;
                }
              }, {
                key: "_findComponents",
                value: function _findComponents(node, constructor, components) {
                  var cls = constructor;
                  var comps = node._components;

                  if (cls._sealed) {
                    for (var i = 0; i < comps.length; ++i) {
                      var comp = comps[i];

                      if (comp.constructor === constructor) {
                        components.push(comp);
                      }
                    }
                  } else {
                    for (var _i2 = 0; _i2 < comps.length; ++_i2) {
                      var _comp2 = comps[_i2];

                      if (_comp2 instanceof constructor) {
                        components.push(_comp2);
                      }
                    }
                  }
                }
              }, {
                key: "_findChildComponent",
                value: function _findChildComponent(children, constructor) {
                  for (var i = 0; i < children.length; ++i) {
                    var node = children[i];

                    var comp = BaseNode._findComponent(node, constructor);

                    if (comp) {
                      return comp;
                    } else if (node._children.length > 0) {
                      comp = BaseNode._findChildComponent(node._children, constructor);

                      if (comp) {
                        return comp;
                      }
                    }
                  }

                  return null;
                }
              }, {
                key: "_findChildComponents",
                value: function _findChildComponents(children, constructor, components) {
                  for (var i = 0; i < children.length; ++i) {
                    var node = children[i];

                    BaseNode._findComponents(node, constructor, components);

                    if (node._children.length > 0) {
                      BaseNode._findChildComponents(node._children, constructor, components);
                    }
                  }
                }
              }]);

              function BaseNode(name) {
                var _this;

                _classCallCheck(this, BaseNode);

                _this = _possibleConstructorReturn(this, _getPrototypeOf(BaseNode).call(this, name));

                _initializerDefineProperty(_this, "_parent", _descriptor$8, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_children", _descriptor2$6, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_active", _descriptor3$5, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_components", _descriptor4$3, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_prefab", _descriptor5$3, _assertThisInitialized(_this));

                _this._scene = NullScene;
                _this._activeInHierarchy = false;
                _this._id = idGenerator$1.getNewId();
                _this._name = void 0;
                _this._eventProcessor = new NodeEventProcessor(_assertThisInitialized(_this));
                _this._eventMask = 0;
                _this._siblingIndex = 0;
                _this._registerIfAttached =  undefined ;
                _this._name = name !== undefined ? name : "New Node";
                return _this;
              }
              /**
               * @en
               * Properties configuration function.
               * All properties in attrs will be set to the node,
               * when the setter of the node is available,
               * the property will be set via setter function.
               * @zh 属性配置函数。在 attrs 的所有属性将被设置为节点属性。
               * @param attrs - Properties to be set to node
               * @example
               * ```
               * var attrs = { name: 'New Name', active: false };
               * node.attr(attrs);
               * ```
               */


              _createClass(BaseNode, [{
                key: "attr",
                value: function attr(attrs) {
                  mixin(this, attrs);
                } // HIERARCHY METHODS

                /**
                 * @en Get parent of the node.
                 * @zh 获取该节点的父节点。
                 */

              }, {
                key: "getParent",
                value: function getParent() {
                  return this._parent;
                }
              }, {
                key: "onSetParent",
                value: function onSetParent(newParent, oldParent) {}
                /**
                 * @en Set parent of the node.
                 * @zh 设置该节点的父节点。
                 */

              }, {
                key: "setParent",
                value: function setParent(value) {
                  var keepWorldTransform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

                  if (this._parent === value) {
                    return;
                  }

                  var oldParent = this._parent;
                  var newParent = value;

                  if ( oldParent && // Change parent when old parent desactivating or activating
                  oldParent._objFlags & ChangingState) {
                    errorID(3821);
                  }

                  this._parent = newParent; // Reset sibling index

                  this._siblingIndex = 0;

                  this._onSetParent(oldParent, keepWorldTransform);

                  this.onSetParent(newParent, oldParent);

                  if (this.emit) {
                    this.emit(SystemEventType.PARENT_CHANGED, oldParent);
                  }

                  if (oldParent) {
                    if (!(oldParent._objFlags & Destroying$1)) {
                      var removeAt = oldParent._children.indexOf(this);

                      oldParent._children.splice(removeAt, 1);

                      oldParent._updateSiblingIndex();

                      if (oldParent.emit) {
                        oldParent.emit(SystemEventType.CHILD_REMOVED, this);
                      }
                    }
                  }

                  if (newParent) {
                    if ( newParent._objFlags & Deactivating) {
                      errorID(3821);
                    }

                    newParent._children.push(this);

                    this._siblingIndex = newParent._children.length - 1;

                    if (newParent.emit) {
                      newParent.emit(SystemEventType.CHILD_ADDED, this);
                    }
                  }

                  this._onHierarchyChanged(oldParent);
                }
                /**
                 * @en Returns a child with the same uuid.
                 * @zh 通过 uuid 获取节点的子节点。
                 * @param uuid - The uuid to find the child node.
                 * @return a Node whose uuid equals to the input parameter
                 */

              }, {
                key: "getChildByUuid",
                value: function getChildByUuid(uuid) {
                  if (!uuid) {
                    log("Invalid uuid");
                    return null;
                  }

                  var locChildren = this._children;

                  for (var i = 0, len = locChildren.length; i < len; i++) {
                    if (locChildren[i]._id === uuid) {
                      return locChildren[i];
                    }
                  }

                  return null;
                }
                /**
                 * @en Returns a child with the same name.
                 * @zh 通过名称获取节点的子节点。
                 * @param name - A name to find the child node.
                 * @return a CCNode object whose name equals to the input parameter
                 * @example
                 * ```
                 * var child = node.getChildByName("Test Node");
                 * ```
                 */

              }, {
                key: "getChildByName",
                value: function getChildByName(name) {
                  if (!name) {
                    log("Invalid name");
                    return null;
                  }

                  var locChildren = this._children;

                  for (var i = 0, len = locChildren.length; i < len; i++) {
                    if (locChildren[i]._name === name) {
                      return locChildren[i];
                    }
                  }

                  return null;
                }
                /**
                 * @en Returns a child with the given path.
                 * @zh 通过路径获取节点的子节点。
                 * @param path - A path to find the child node.
                 * @return a Node object whose path equals to the input parameter
                 * @example
                 * ```
                 * var child = node.getChildByPath("subNode/Test Node");
                 * ```
                 */

              }, {
                key: "getChildByPath",
                value: function getChildByPath(path) {
                  var segments = path.split("/");
                  var lastNode = this;

                  var _loop = function _loop(i) {
                    var segment = segments[i];

                    if (segment.length === 0) {
                      return "continue";
                    }

                    var next = lastNode.children.find(function (childNode) {
                      return childNode.name === segment;
                    });

                    if (!next) {
                      return {
                        v: null
                      };
                    }

                    lastNode = next;
                  };

                  for (var i = 0; i < segments.length; ++i) {
                    var _ret = _loop(i);

                    switch (_ret) {
                      case "continue":
                        continue;

                      default:
                        if (_typeof(_ret) === "object") return _ret.v;
                    }
                  }

                  return lastNode;
                }
                /**
                 * @en Add a child to the current node, it will be pushed to the end of [[children]] array.
                 * @zh 添加一个子节点，它会被添加到 [[children]] 数组的末尾。
                 * @param child - the child node to be added
                 */

              }, {
                key: "addChild",
                value: function addChild(child) {

                  assertID(child, 1606);
                  assertID(child._parent === null, 1605); // invokes the parent setter

                  child.setParent(this);
                }
                /**
                 * @en Inserts a child to the node at a specified index.
                 * @zh 插入子节点到指定位置
                 * @param child - the child node to be inserted
                 * @param siblingIndex - the sibling index to place the child in
                 * @example
                 * ```
                 * node.insertChild(child, 2);
                 * ```
                 */

              }, {
                key: "insertChild",
                value: function insertChild(child, siblingIndex) {
                  child.parent = this;
                  child.setSiblingIndex(siblingIndex);
                }
                /**
                 * @en Get the sibling index of the current node in its parent's children array.
                 * @zh 获取当前节点在父节点的 children 数组中的位置。
                 */

              }, {
                key: "getSiblingIndex",
                value: function getSiblingIndex() {
                  return this._siblingIndex;
                }
                /**
                 * @en Set the sibling index of the current node in its parent's children array.
                 * @zh 设置当前节点在父节点的 children 数组中的位置。
                 */

              }, {
                key: "setSiblingIndex",
                value: function setSiblingIndex(index) {
                  if (!this._parent) {
                    return;
                  }

                  if (this._parent._objFlags & Deactivating) {
                    errorID(3821);
                    return;
                  }

                  var siblings = this._parent._children;
                  index = index !== -1 ? index : siblings.length - 1;
                  var oldIndex = siblings.indexOf(this);

                  if (index !== oldIndex) {
                    siblings.splice(oldIndex, 1);

                    if (index < siblings.length) {
                      siblings.splice(index, 0, this);
                    } else {
                      siblings.push(this);
                    }

                    this._parent._updateSiblingIndex();

                    if (this._onSiblingIndexChanged) {
                      this._onSiblingIndexChanged(index);
                    }
                  }
                }
                /**
                 * @en Walk though the sub children tree of the current node.
                 * Each node, including the current node, in the sub tree will be visited two times,
                 * before all children and after all children.
                 * This function call is not recursive, it's based on stack.
                 * Please don't walk any other node inside the walk process.
                 * @zh 遍历该节点的子树里的所有节点并按规则执行回调函数。
                 * 对子树中的所有节点，包含当前节点，会执行两次回调，preFunc 会在访问它的子节点之前调用，postFunc 会在访问所有子节点之后调用。
                 * 这个函数的实现不是基于递归的，而是基于栈展开递归的方式。
                 * 请不要在 walk 过程中对任何其他的节点嵌套执行 walk。
                 * @param preFunc The callback to process node when reach the node for the first time
                 * @param postFunc The callback to process node when re-visit the node after walked all children in its sub tree
                 * @example
                 * ```
                 * node.walk(function (target) {
                 *     console.log('Walked through node ' + target.name + ' for the first time');
                 * }, function (target) {
                 *     console.log('Walked through node ' + target.name + ' after walked all children in its sub tree');
                 * });
                 * ```
                 */

              }, {
                key: "walk",
                value: function walk(preFunc, postFunc) {
                  // const BaseNode = cc._BaseNode;
                  var index = 1;
                  var children = null;
                  var curr = null;
                  var i = 0;
                  var stack = BaseNode._stacks[BaseNode._stackId];

                  if (!stack) {
                    stack = [];

                    BaseNode._stacks.push(stack);
                  }

                  BaseNode._stackId++;
                  stack.length = 0;
                  stack[0] = this;
                  var parent = null;
                  var afterChildren = false;

                  while (index) {
                    index--;
                    curr = stack[index];

                    if (!curr) {
                      continue;
                    }

                    if (!afterChildren && preFunc) {
                      // pre call
                      preFunc(curr);
                    } else if (afterChildren && postFunc) {
                      // post call
                      postFunc(curr);
                    } // Avoid memory leak


                    stack[index] = null; // Do not repeatly visit child tree, just do post call and continue walk

                    if (afterChildren) {
                      afterChildren = false;
                    } else {
                      // Children not proceeded and has children, proceed to child tree
                      if (curr._children.length > 0) {
                        parent = curr;
                        children = curr._children;
                        i = 0;
                        stack[index] = children[i];
                        index++;
                      } else {
                        stack[index] = curr;
                        index++;
                        afterChildren = true;
                      }

                      continue;
                    } // curr has no sub tree, so look into the siblings in parent children


                    if (children) {
                      i++; // Proceed to next sibling in parent children

                      if (children[i]) {
                        stack[index] = children[i];
                        index++;
                      } else if (parent) {
                        stack[index] = parent;
                        index++; // Setup parent walk env

                        afterChildren = true;

                        if (parent._parent) {
                          children = parent._parent._children;
                          i = children.indexOf(parent);
                          parent = parent._parent;
                        } else {
                          // At root
                          parent = null;
                          children = null;
                        } // ERROR


                        if (i < 0) {
                          break;
                        }
                      }
                    }
                  }

                  stack.length = 0;
                  BaseNode._stackId--;
                }
                /**
                 * @en
                 * Remove itself from its parent node.
                 * If the node have no parent, then nothing happens.
                 * @zh
                 * 从父节点中删除该节点。
                 * 如果这个节点是一个孤立节点，那么什么都不会发生。
                 */

              }, {
                key: "removeFromParent",
                value: function removeFromParent() {
                  if (this._parent) {
                    this._parent.removeChild(this);
                  }
                }
                /**
                 * @en Removes a child from the container.
                 * @zh 移除节点中指定的子节点。
                 * @param child - The child node which will be removed.
                 */

              }, {
                key: "removeChild",
                value: function removeChild(child) {
                  if (this._children.indexOf(child) > -1) {
                    // invoke the parent setter
                    child.parent = null;
                  }
                }
                /**
                 * @en Removes all children from the container.
                 * @zh 移除节点所有的子节点。
                 */

              }, {
                key: "removeAllChildren",
                value: function removeAllChildren() {
                  // not using detachChild improves speed here
                  var children = this._children;

                  for (var i = children.length - 1; i >= 0; i--) {
                    var node = children[i];

                    if (node) {
                      node.parent = null;
                    }
                  }

                  this._children.length = 0;
                }
                /**
                 * @en Is this node a child of the given node?
                 * @zh 是否是指定节点的子节点？
                 * @return True if this node is a child, deep child or identical to the given node.
                 */

              }, {
                key: "isChildOf",
                value: function isChildOf(parent) {
                  var child = this;

                  do {
                    if (child === parent) {
                      return true;
                    }

                    child = child._parent;
                  } while (child);

                  return false;
                } // COMPONENT

                /**
                 * @en
                 * Returns the component of supplied type if the node has one attached, null if it doesn't.
                 * You can also get component in the node by passing in the name of the script.
                 * @zh
                 * 获取节点上指定类型的组件，如果节点有附加指定类型的组件，则返回，如果没有则为空。
                 * 传入参数也可以是脚本的名称。
                 * @param classConstructor The class of the target component
                 * @example
                 * ```
                 * // get sprite component.
                 * var sprite = node.getComponent(Sprite);
                 * ```
                 */

              }, {
                key: "getComponent",
                value: function getComponent(typeOrClassName) {
                  var constructor = getConstructor(typeOrClassName);

                  if (constructor) {
                    return BaseNode._findComponent(this, constructor);
                  }

                  return null;
                }
                /**
                 * @en Returns all components of given type in the node.
                 * @zh 返回节点上指定类型的所有组件。
                 * @param classConstructor The class of the target component
                 */

              }, {
                key: "getComponents",
                value: function getComponents(typeOrClassName) {
                  var constructor = getConstructor(typeOrClassName);
                  var components = [];

                  if (constructor) {
                    BaseNode._findComponents(this, constructor, components);
                  }

                  return components;
                }
                /**
                 * @en Returns the component of given type in any of its children using depth first search.
                 * @zh 递归查找所有子节点中第一个匹配指定类型的组件。
                 * @param classConstructor The class of the target component
                 * @example
                 * ```
                 * var sprite = node.getComponentInChildren(Sprite);
                 * ```
                 */

              }, {
                key: "getComponentInChildren",
                value: function getComponentInChildren(typeOrClassName) {
                  var constructor = getConstructor(typeOrClassName);

                  if (constructor) {
                    return BaseNode._findChildComponent(this._children, constructor);
                  }

                  return null;
                }
                /**
                 * @en Returns all components of given type in self or any of its children.
                 * @zh 递归查找自身或所有子节点中指定类型的组件
                 * @param classConstructor The class of the target component
                 * @example
                 * ```
                 * var sprites = node.getComponentsInChildren(Sprite);
                 * ```
                 */

              }, {
                key: "getComponentsInChildren",
                value: function getComponentsInChildren(typeOrClassName) {
                  var constructor = getConstructor(typeOrClassName);
                  var components = [];

                  if (constructor) {
                    BaseNode._findComponents(this, constructor, components);

                    BaseNode._findChildComponents(this._children, constructor, components);
                  }

                  return components;
                }
                /**
                 * @en Adds a component class to the node. You can also add component to node by passing in the name of the script.
                 * @zh 向节点添加一个指定类型的组件类，你还可以通过传入脚本的名称来添加组件。
                 * @param classConstructor The class of the component to add
                 * @throws `TypeError` if the `classConstructor` does not specify a cc-class constructor extending the `Component`.
                 * @example
                 * ```
                 * var sprite = node.addComponent(Sprite);
                 * ```
                 */

              }, {
                key: "addComponent",
                value: function addComponent(typeOrClassName) {


                  var constructor;

                  if (typeof typeOrClassName === "string") {
                    constructor = getClassByName(typeOrClassName);

                    if (!constructor) {
                      if (legacyCC._RF.peek()) {
                        errorID(3808, typeOrClassName);
                      }

                      throw TypeError(getError(3807, typeOrClassName));
                    }
                  } else {
                    if (!typeOrClassName) {
                      throw TypeError(getError(3804));
                    }

                    constructor = typeOrClassName;
                  } // check component


                  if (typeof constructor !== "function") {
                    throw TypeError(getError(3809));
                  }

                  if (!isChildClassOf(constructor, legacyCC.Component)) {
                    throw TypeError(getError(3810));
                  }


                  var ReqComp = constructor._requireComponent;

                  if (ReqComp && !this.getComponent(ReqComp)) {
                    this.addComponent(ReqComp);
                  } //// check conflict
                  //
                  // if (EDITOR && !_Scene.DetectConflict.beforeAddComponent(this, constructor)) {
                  //    return null;
                  // }
                  //


                  var component = new constructor();
                  component.node = this;

                  this._components.push(component);

                  if (this._activeInHierarchy) {
                    legacyCC.director._nodeActivator.activateComp(component);
                  }

                  return component;
                }
                /**
                 * @en
                 * Removes a component identified by the given name or removes the component object given.
                 * You can also use component.destroy() if you already have the reference.
                 * @zh
                 * 删除节点上的指定组件，传入参数可以是一个组件构造函数或组件名，也可以是已经获得的组件引用。
                 * 如果你已经获得组件引用，你也可以直接调用 component.destroy()
                 * @param classConstructor The class of the component to remove
                 * @deprecated please destroy the component to remove it.
                 * @example
                 * ```
                 * node.removeComponent(Sprite);
                 * ```
                 */

              }, {
                key: "removeComponent",
                value: function removeComponent(component) {
                  if (!component) {
                    errorID(3813);
                    return;
                  }

                  var componentInstance = null;

                  if (component instanceof Component) {
                    componentInstance = component;
                  } else {
                    componentInstance = this.getComponent(component);
                  }

                  if (componentInstance) {
                    componentInstance.destroy();
                  }
                } // EVENT PROCESSING

                /**
                 * @en
                 * Register a callback of a specific event type on Node.
                 * Use this method to register touch or mouse event permit propagation based on scene graph,
                 * These kinds of event are triggered with dispatchEvent, the dispatch process has three steps:
                 * 1. Capturing phase: dispatch in capture targets (`_getCapturingTargets`), e.g. parents in node tree, from root to the real target
                 * 2. At target phase: dispatch to the listeners of the real target
                 * 3. Bubbling phase: dispatch in bubble targets (`_getBubblingTargets`), e.g. parents in node tree, from the real target to root
                 * In any moment of the dispatching process, it can be stopped via `event.stopPropagation()` or `event.stopPropagationImmidiate()`.
                 * It's the recommended way to register touch/mouse event for Node,
                 * please do not use `eventManager` directly for Node.
                 * You can also register custom event and use `emit` to trigger custom event on Node.
                 * For such events, there won't be capturing and bubbling phase, your event will be dispatched directly to its listeners registered on the same node.
                 * You can also pass event callback parameters with `emit` by passing parameters after `type`.
                 * @zh
                 * 在节点上注册指定类型的回调函数，也可以设置 target 用于绑定响应函数的 this 对象。
                 * 鼠标或触摸事件会被系统调用 dispatchEvent 方法触发，触发的过程包含三个阶段：
                 * 1. 捕获阶段：派发事件给捕获目标（通过 `_getCapturingTargets` 获取），比如，节点树中注册了捕获阶段的父节点，从根节点开始派发直到目标节点。
                 * 2. 目标阶段：派发给目标节点的监听器。
                 * 3. 冒泡阶段：派发事件给冒泡目标（通过 `_getBubblingTargets` 获取），比如，节点树中注册了冒泡阶段的父节点，从目标节点开始派发直到根节点。
                 * 同时您可以将事件派发到父节点或者通过调用 stopPropagation 拦截它。
                 * 推荐使用这种方式来监听节点上的触摸或鼠标事件，请不要在节点上直接使用 `eventManager`。
                 * 你也可以注册自定义事件到节点上，并通过 emit 方法触发此类事件，对于这类事件，不会发生捕获冒泡阶段，只会直接派发给注册在该节点上的监听器
                 * 你可以通过在 emit 方法调用时在 type 之后传递额外的参数作为事件回调的参数列表
                 * @param type - A string representing the event type to listen for.<br>See {{#crossLink "Node/EventTyupe/POSITION_CHANGED"}}Node Events{{/crossLink}} for all builtin events.
                 * @param callback - The callback that will be invoked when the event is dispatched. The callback is ignored if it is a duplicate (the callbacks are unique).
                 * @param target - The target (this object) to invoke the callback, can be null
                 * @param useCapture - When set to true, the listener will be triggered at capturing phase which is ahead of the final target emit, otherwise it will be triggered during bubbling phase.
                 * @return - Just returns the incoming callback so you can save the anonymous function easier.
                 * @example
                 * ```ts
                 * this.node.on(SystemEventType.TOUCH_START, this.memberFunction, this);  // if "this" is component and the "memberFunction" declared in CCClass.
                 * node.on(SystemEventType.TOUCH_START, callback, this);
                 * node.on(SystemEventType.TOUCH_MOVE, callback, this);
                 * node.on(SystemEventType.TOUCH_END, callback, this);
                 * ```
                 */

              }, {
                key: "on",
                value: function on(type, callback, target) {
                  var useCapture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

                  switch (type) {
                    case SystemEventType.TRANSFORM_CHANGED:
                      this._eventMask |= TRANSFORM_ON;
                      break;
                  }

                  this._eventProcessor.on(type, callback, target, useCapture);
                }
                /**
                 * @en
                 * Removes the callback previously registered with the same type, callback, target and or useCapture.
                 * This method is merely an alias to removeEventListener.
                 * @zh 删除之前与同类型，回调，目标或 useCapture 注册的回调。
                 * @param type - A string representing the event type being removed.
                 * @param callback - The callback to remove.
                 * @param target - The target (this object) to invoke the callback, if it's not given, only callback without target will be removed
                 * @param useCapture - When set to true, the listener will be triggered at capturing phase which is ahead of the final target emit, otherwise it will be triggered during bubbling phase.
                 * @example
                 * ```ts
                 * this.node.off(SystemEventType.TOUCH_START, this.memberFunction, this);
                 * node.off(SystemEventType.TOUCH_START, callback, this.node);
                 * ```
                 */

              }, {
                key: "off",
                value: function off(type, callback, target) {
                  var useCapture = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

                  this._eventProcessor.off(type, callback, target, useCapture);

                  var hasListeners = this._eventProcessor.hasEventListener(type); // All listener removed


                  if (!hasListeners) {
                    switch (type) {
                      case SystemEventType.TRANSFORM_CHANGED:
                        this._eventMask &= ~TRANSFORM_ON;
                        break;
                    }
                  }
                }
                /**
                 * @en
                 * Register an callback of a specific event type on the Node,
                 * the callback will remove itself after the first time it is triggered.
                 * @zh
                 * 注册节点的特定事件类型回调，回调会在第一时间被触发后删除自身。
                 *
                 * @param type - A string representing the event type to listen for.
                 * @param callback - The callback that will be invoked when the event is dispatched.
                 *                              The callback is ignored if it is a duplicate (the callbacks are unique).
                 * @param target - The target (this object) to invoke the callback, can be null
                 */

              }, {
                key: "once",
                value: function once(type, callback, target, useCapture) {
                  this._eventProcessor.once(type, callback, target, useCapture);
                }
                /**
                 * @en
                 * Trigger an event directly with the event name and necessary arguments.
                 * @zh
                 * 通过事件名发送自定义事件
                 * @param type - event type
                 * @param arg1 - First argument in callback
                 * @param arg2 - Second argument in callback
                 * @param arg3 - Third argument in callback
                 * @param arg4 - Fourth argument in callback
                 * @param arg5 - Fifth argument in callback
                 * @example
                 * ```ts
                 * eventTarget.emit('fire', event);
                 * eventTarget.emit('fire', message, emitter);
                 * ```
                 */

              }, {
                key: "emit",
                value: function emit(type, arg0, arg1, arg2, arg3, arg4) {
                  this._eventProcessor.emit(type, arg0, arg1, arg2, arg3, arg4);
                }
                /**
                 * @en
                 * Dispatches an event into the event flow.
                 * The event target is the EventTarget object upon which the dispatchEvent() method is called.
                 * @zh 分发事件到事件流中。
                 * @param event - The Event object that is dispatched into the event flow
                 */

              }, {
                key: "dispatchEvent",
                value: function dispatchEvent(event) {
                  this._eventProcessor.dispatchEvent(event);
                }
                /**
                 * @en Checks whether the EventTarget object has any callback registered for a specific type of event.
                 * @zh 检查事件目标对象是否有为特定类型的事件注册的回调。
                 * @param type - The type of event.
                 * @param callback - The callback function of the event listener, if absent all event listeners for the given type will be removed
                 * @param target - The callback callee of the event listener
                 * @return True if a callback of the specified type is registered; false otherwise.
                 */

              }, {
                key: "hasEventListener",
                value: function hasEventListener(type, callback, target) {
                  return this._eventProcessor.hasEventListener(type, callback, target);
                }
                /**
                 * @en Removes all callbacks previously registered with the same target.
                 * @zh 移除目标上的所有注册事件。
                 * @param target - The target to be searched for all related callbacks
                 */

              }, {
                key: "targetOff",
                value: function targetOff(target) {
                  this._eventProcessor.targetOff(target); // Check for event mask reset


                  if (this._eventMask & TRANSFORM_ON && !this._eventProcessor.hasEventListener(SystemEventType.TRANSFORM_CHANGED)) {
                    this._eventMask &= ~TRANSFORM_ON;
                  }
                }
              }, {
                key: "destroy",
                value: function destroy() {
                  if (_get(_getPrototypeOf(BaseNode.prototype), "destroy", this).call(this)) {
                    // disable hierarchy
                    if (this._activeInHierarchy) {
                      this._disableChildComps();
                    }

                    return true;
                  }

                  return false;
                }
                /**
                 * @en
                 * Destroy all children from the node, and release all their own references to other objects.
                 * Actual destruct operation will delayed until before rendering.
                 * @zh
                 * 销毁所有子节点，并释放所有它们对其它对象的引用。
                 * 实际销毁操作会延迟到当前帧渲染前执行。
                 */

              }, {
                key: "destroyAllChildren",
                value: function destroyAllChildren() {
                  var children = this._children;

                  for (var i = 0; i < children.length; ++i) {
                    children[i].destroy();
                  }
                } // Do remove component, only used internally.

              }, {
                key: "_removeComponent",
                value: function _removeComponent(component) {
                  if (!component) {
                    errorID(3814);
                    return;
                  }

                  if (!(this._objFlags & Destroying$1)) {
                    var i = this._components.indexOf(component);

                    if (i !== -1) {
                      this._components.splice(i, 1);
                    } // @ts-ignore
                    else if (component.node !== this) {
                        errorID(3815);
                      }
                  }
                }
              }, {
                key: "_updateSiblingIndex",
                value: function _updateSiblingIndex() {
                  for (var i = 0; i < this._children.length; ++i) {
                    this._children[i]._siblingIndex = i;
                  }
                }
              }, {
                key: "_onSetParent",
                value: function _onSetParent(oldParent) {

                  if (this._parent) {
                    if ((oldParent == null || oldParent._scene !== this._parent._scene) && this._parent._scene != null) {
                      this.walk(function (node) {
                        BaseNode._setScene(node);
                      });
                    }
                  }
                } // PRIVATE

              }, {
                key: "_onPostActivated",
                value: function _onPostActivated(active) {
                  return;
                }
              }, {
                key: "_onBatchRestored",
                value: function _onBatchRestored() {
                  return;
                }
              }, {
                key: "_onBatchCreated",
                value: function _onBatchCreated() {
                  if (this._parent) {
                    this._siblingIndex = this._parent.children.indexOf(this);
                  }

                  return;
                }
              }, {
                key: "_onPreDestroy",
                value: function _onPreDestroy() {
                  this._onPreDestroyBase();
                }
              }, {
                key: "_onHierarchyChanged",
                value: function _onHierarchyChanged(oldParent) {
                  return this._onHierarchyChangedBase(oldParent);
                }
              }, {
                key: "_instantiate",
                value: function _instantiate(cloned) {
                  if (!cloned) {
                    cloned = legacyCC.instantiate._clone(this, this);
                  }

                  var thisPrefabInfo = this._prefab;

                  var syncing = thisPrefabInfo && this === thisPrefabInfo.root && thisPrefabInfo.sync;


                  cloned._parent = null;

                  cloned._onBatchRestored();

                  return cloned;
                }
              }, {
                key: "_onHierarchyChangedBase",
                value: function _onHierarchyChangedBase(oldParent) {
                  var newParent = this._parent;

                  if (this._persistNode && !(newParent instanceof legacyCC.Scene)) {
                    legacyCC.game.removePersistRootNode(this);
                  }

                  var shouldActiveNow = this._active && !!(newParent && newParent._activeInHierarchy);

                  if (this._activeInHierarchy !== shouldActiveNow) {
                    legacyCC.director._nodeActivator.activateNode(this, shouldActiveNow);
                  }
                }
              }, {
                key: "_onPreDestroyBase",
                value: function _onPreDestroyBase() {
                  // marked as destroying
                  this._objFlags |= Destroying$1; // detach self and children from editor

                  var parent = this._parent;
                  var destroyByParent = !!parent && (parent._objFlags & Destroying$1) !== 0;

                  if (!destroyByParent && EDITOR) {
                    this._registerIfAttached(false);
                  } // remove from persist


                  if (this._persistNode) {
                    legacyCC.game.removePersistRootNode(this);
                  }

                  if (!destroyByParent) {
                    // remove from parent
                    if (parent) {
                      this.emit(SystemEventType.PARENT_CHANGED, this); // During destroy process, siblingIndex is not relyable

                      var childIndex = parent._children.indexOf(this);

                      parent._children.splice(childIndex, 1);

                      this._siblingIndex = 0;

                      if (parent.emit) {
                        parent.emit(SystemEventType.CHILD_REMOVED, this);
                      }
                    }
                  } // emit node destroy event (this should before event processor destroy)


                  this.emit(SystemEventType.NODE_DESTROYED, this); // Destroy node event processor

                  this._eventProcessor.destroy(); // destroy children


                  var children = this._children;

                  for (var i = 0; i < children.length; ++i) {
                    // destroy immediate so its _onPreDestroy can be called
                    children[i]._destroyImmediate();
                  } // destroy self components


                  var comps = this._components;

                  for (var _i5 = 0; _i5 < comps.length; ++_i5) {
                    // destroy immediate so its _onPreDestroy can be called
                    // TO DO
                    comps[_i5]._destroyImmediate();
                  }

                  return destroyByParent;
                }
              }, {
                key: "_disableChildComps",
                value: function _disableChildComps() {
                  // leave this._activeInHierarchy unmodified
                  var comps = this._components;

                  for (var i = 0; i < comps.length; ++i) {
                    var component = comps[i];

                    if (component._enabled) {
                      legacyCC.director._compScheduler.disableComp(component);
                    }
                  } // deactivate recursively


                  var children = this._children;

                  for (var _i6 = 0; _i6 < children.length; ++_i6) {
                    var node = children[_i6];

                    if (node._active) {
                      node._disableChildComps();
                    }
                  }
                }
              }]);

              return BaseNode;
            }(CCObject), _class3$4.idGenerator = idGenerator$1, _class3$4._stacks = [[]], _class3$4._stackId = 0, _temp$b), (_applyDecoratedDescriptor(_class2$9.prototype, "_persistNode", [property], Object.getOwnPropertyDescriptor(_class2$9.prototype, "_persistNode"), _class2$9.prototype), _applyDecoratedDescriptor(_class2$9.prototype, "name", [editable], Object.getOwnPropertyDescriptor(_class2$9.prototype, "name"), _class2$9.prototype), _applyDecoratedDescriptor(_class2$9.prototype, "children", [editable], Object.getOwnPropertyDescriptor(_class2$9.prototype, "children"), _class2$9.prototype), _applyDecoratedDescriptor(_class2$9.prototype, "active", [editable], Object.getOwnPropertyDescriptor(_class2$9.prototype, "active"), _class2$9.prototype), _applyDecoratedDescriptor(_class2$9.prototype, "activeInHierarchy", [editable], Object.getOwnPropertyDescriptor(_class2$9.prototype, "activeInHierarchy"), _class2$9.prototype), _applyDecoratedDescriptor(_class2$9.prototype, "parent", [editable], Object.getOwnPropertyDescriptor(_class2$9.prototype, "parent"), _class2$9.prototype), _descriptor$8 = _applyDecoratedDescriptor(_class2$9.prototype, "_parent", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor2$6 = _applyDecoratedDescriptor(_class2$9.prototype, "_children", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [];
              }
            }), _descriptor3$5 = _applyDecoratedDescriptor(_class2$9.prototype, "_active", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return true;
              }
            }), _descriptor4$3 = _applyDecoratedDescriptor(_class2$9.prototype, "_components", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [];
              }
            }), _descriptor5$3 = _applyDecoratedDescriptor(_class2$9.prototype, "_prefab", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            })), _class2$9)) || _class$b));
            /**
             * @en
             * Note: This event is only emitted from the top most node whose active value did changed,
             * not including its child nodes.
             * @zh
             * 注意：此节点激活时，此事件仅从最顶部的节点发出。
             * @event active-in-hierarchy-changed
             * @param {Event.EventCustom} event
             */

            legacyCC._BaseNode = BaseNode;

            /*
             Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

             http://www.cocos.com

             Permission is hereby granted, free of charge, to any person obtaining a copy
             of this software and associated engine source code (the "Software"), a limited,
              worldwide, royalty-free, non-assignable, revocable and non-exclusive license
             to use Cocos Creator solely to develop games on your target platforms. You shall
              not use Cocos Creator software for developing other software or tools that's
              used for developing games. You are not granted to publish, distribute,
              sublicense, and/or sell copies of Cocos Creator.

             The software or tools in this License Agreement are licensed, not sold.
             Xiamen Yaji Software Co., Ltd. reserves all rights not expressly granted to you.

             THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
             THE SOFTWARE.
            */
            /**
             * @category scene-graph
             */

            /**
             * @en Node's coordinate space
             * @zh 节点的坐标空间
             */

            var NodeSpace;
            /**
             * @en Bit masks for node's transformation
             * @zh 节点的空间变换位标记
             */

            (function (NodeSpace) {
              NodeSpace[NodeSpace["LOCAL"] = 0] = "LOCAL";
              NodeSpace[NodeSpace["WORLD"] = 1] = "WORLD";
            })(NodeSpace || (NodeSpace = {}));

            var TransformBit;

            (function (TransformBit) {
              TransformBit[TransformBit["NONE"] = 0] = "NONE";
              TransformBit[TransformBit["POSITION"] = 1] = "POSITION";
              TransformBit[TransformBit["ROTATION"] = 2] = "ROTATION";
              TransformBit[TransformBit["SCALE"] = 4] = "SCALE";
              TransformBit[TransformBit["RS"] = TransformBit.ROTATION | TransformBit.SCALE] = "RS";
              TransformBit[TransformBit["TRS"] = TransformBit.POSITION | TransformBit.ROTATION | TransformBit.SCALE] = "TRS";
              TransformBit[TransformBit["TRS_MASK"] = ~TransformBit.TRS] = "TRS_MASK";
            })(TransformBit || (TransformBit = exports('dR', {})));

            legacyCC.internal.TransformBit = TransformBit;

            var _dec$c, _dec2$3, _dec3$1, _dec4$1, _dec5$1, _dec6, _dec7, _dec8, _dec9, _class$c, _class2$a, _descriptor$9, _descriptor2$7, _descriptor3$6, _class3$5, _temp$c;

            var _vec2a = new Vec2();

            var _vec2b = new Vec2();

            var _mat4_temp = new Mat4();

            var _matrix = new Mat4();

            var _worldMatrix = new Mat4();

            var _zeroMatrix = new Mat4(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

            var _rect = new Rect();
            /**
             * @en
             * The component of transform in UI.
             *
             * @zh
             * UI 变换组件。
             */


            var UITransform = exports('db', (_dec$c = ccclass('cc.UITransform'), _dec2$3 = help(), _dec3$1 = executionOrder(110), _dec4$1 = menu(), _dec5$1 = displayOrder(), _dec6 = tooltip(), _dec7 = displayOrder(), _dec8 = tooltip(), _dec9 = tooltip(), _dec$c(_class$c = _dec2$3(_class$c = _dec3$1(_class$c = _dec4$1(_class$c = executeInEditMode(_class$c = (_class2$a = (_temp$c = _class3$5 = /*#__PURE__*/function (_Component) {
              _inherits(UITransform, _Component);

              function UITransform() {
                var _getPrototypeOf2;

                var _this;

                _classCallCheck(this, UITransform);

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(UITransform)).call.apply(_getPrototypeOf2, [this].concat(args)));

                _initializerDefineProperty(_this, "_priority", _descriptor$9, _assertThisInitialized(_this));

                _this._canvas = null;

                _initializerDefineProperty(_this, "_contentSize", _descriptor2$7, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_anchorPoint", _descriptor3$6, _assertThisInitialized(_this));

                return _this;
              }

              _createClass(UITransform, [{
                key: "__preload",
                value: function __preload() {
                  this.node._uiProps.uiTransformComp = this;
                }
              }, {
                key: "onEnable",
                value: function onEnable() {
                  this._updateVisibility();

                  this.node.on(SystemEventType.PARENT_CHANGED, this._parentChanged, this);

                  this._sortSiblings();
                }
              }, {
                key: "onDisable",
                value: function onDisable() {
                  this.node.off(SystemEventType.PARENT_CHANGED, this._parentChanged, this);
                  this._canvas = null;
                }
              }, {
                key: "onDestroy",
                value: function onDestroy() {
                  this.node._uiProps.uiTransformComp = null;
                }
                /**
                 * @en
                 * Sets the untransformed size of the node.<br/>
                 * The contentSize remains the same no matter if the node is scaled or rotated.<br/>
                 * All nodes have a size. Layer and Scene have the same size of the screen.
                 *
                 * @zh
                 * 设置节点原始大小，不受该节点是否被缩放或者旋转的影响。
                 *
                 * @param size - 节点内容变换的尺寸或者宽度。
                 * @param height - 节点内容未变换的高度。
                 * @example
                 * ```ts
                 * import { Size } from 'cc';
                 * node.setContentSize(new Size(100, 100));
                 * node.setContentSize(100, 100);
                 * ```
                 */

              }, {
                key: "setContentSize",
                value: function setContentSize(size, height) {
                  var locContentSize = this._contentSize;

                  if (height === undefined) {
                    size = size;

                    if (size.width === locContentSize.width && size.height === locContentSize.height) {
                      return;
                    }

                    locContentSize.width = size.width;
                    locContentSize.height = size.height;
                  } else {
                    if (size === locContentSize.width && height === locContentSize.height) {
                      return;
                    }

                    locContentSize.width = size;
                    locContentSize.height = height;
                  }

                  {
                    this.node.emit(SystemEventType.SIZE_CHANGED);
                  }
                }
                /**
                 * @en
                 * Sets the anchor point in percent. <br/>
                 * anchor point is the point around which all transformations and positioning manipulations take place. <br/>
                 * It's like a pin in the node where it is "attached" to its parent. <br/>
                 * The anchorPoint is normalized, like a percentage. (0,0) means the bottom-left corner and (1,1) means the top-right corner.<br/>
                 * But you can use values higher than (1,1) and lower than (0,0) too.<br/>
                 * The default anchor point is (0.5,0.5), so it starts at the center of the node.
                 *
                 * @zh
                 * 设置锚点的百分比。<br>
                 * 锚点应用于所有变换和坐标点的操作，它就像在节点上连接其父节点的大头针。<br>
                 * 锚点是标准化的，就像百分比一样。(0，0) 表示左下角，(1，1) 表示右上角。<br>
                 * 但是你可以使用比（1，1）更高的值或者比（0，0）更低的值。<br>
                 * 默认的锚点是（0.5，0.5），因此它开始于节点的中心位置。<br>
                 * 注意：Creator 中的锚点仅用于定位所在的节点，子节点的定位不受影响。
                 *
                 * @param point - 节点锚点或节点 x 轴锚。
                 * @param y - 节点 y 轴锚。
                 * @example
                 * ```ts
                 * import { Vec2 } from 'cc';
                 * node.setAnchorPoint(new Vec2(1, 1));
                 * node.setAnchorPoint(1, 1);
                 * ```
                 */

              }, {
                key: "setAnchorPoint",
                value: function setAnchorPoint(point, y) {
                  var locAnchorPoint = this._anchorPoint;

                  if (y === undefined) {
                    point = point;

                    if (point.x === locAnchorPoint.x && point.y === locAnchorPoint.y) {
                      return;
                    }

                    locAnchorPoint.x = point.x;
                    locAnchorPoint.y = point.y;
                  } else {
                    if (point === locAnchorPoint.x && y === locAnchorPoint.y) {
                      return;
                    }

                    locAnchorPoint.x = point;
                    locAnchorPoint.y = y;
                  } // this.setLocalDirty(LocalDirtyFlag.POSITION);
                  // if (this._eventMask & ANCHOR_ON) {


                  this.node.emit(SystemEventType.ANCHOR_CHANGED, this._anchorPoint); // }
                }
                /**
                 * @zh
                 * 当前节点的点击计算。
                 *
                 * @param point - 屏幕点。
                 * @param listener - 事件监听器。
                 */

              }, {
                key: "isHit",
                value: function isHit(point, listener) {
                  var w = this._contentSize.width;
                  var h = this._contentSize.height;
                  var cameraPt = _vec2a;
                  var testPt = _vec2b;
                  var canvas = this._canvas;

                  if (!canvas) {
                    return;
                  } // 将一个摄像机坐标系下的点转换到世界坐标系下


                  canvas.node.getWorldRT(_mat4_temp);
                  var m12 = _mat4_temp.m12;
                  var m13 = _mat4_temp.m13;
                  var center = legacyCC.visibleRect.center;
                  _mat4_temp.m12 = center.x - (_mat4_temp.m00 * m12 + _mat4_temp.m04 * m13);
                  _mat4_temp.m13 = center.y - (_mat4_temp.m01 * m12 + _mat4_temp.m05 * m13);
                  Mat4.invert(_mat4_temp, _mat4_temp);
                  Vec2.transformMat4(cameraPt, point, _mat4_temp);
                  this.node.getWorldMatrix(_worldMatrix);
                  Mat4.invert(_mat4_temp, _worldMatrix);

                  if (Mat4.strictEquals(_mat4_temp, _zeroMatrix)) {
                    return false;
                  }

                  Vec2.transformMat4(testPt, cameraPt, _mat4_temp);
                  testPt.x += this._anchorPoint.x * w;
                  testPt.y += this._anchorPoint.y * h;

                  if (testPt.x >= 0 && testPt.y >= 0 && testPt.x <= w && testPt.y <= h) {
                    if (listener && listener.mask) {
                      var mask = listener.mask;
                      var parent = this.node; // find mask parent, should hit test it

                      for (var i = 0; parent && i < mask.index; ++i, parent = parent.parent) {}

                      if (parent === mask.node) {
                        var comp = parent.getComponent(legacyCC.Mask);
                        return comp && comp.enabledInHierarchy ? comp.isHit(cameraPt) : true;
                      } else {
                        listener.mask = null;
                        return true;
                      }
                    } else {
                      return true;
                    }
                  } else {
                    return false;
                  }
                }
                /**
                 * @en
                 * Converts a Point to node (local) space coordinates.
                 *
                 * @zh
                 * 将一个 UI 节点世界坐标系下点转换到另一个 UI 节点 (局部) 空间坐标系，这个坐标系以锚点为原点。
                 * 非 UI 节点转换到 UI 节点(局部) 空间坐标系，请走 Camera 的 `convertToUINode`。
                 *
                 * @param worldPoint - 世界坐标点。
                 * @param out - 转换后坐标。
                 * @returns - 返回与目标节点的相对位置。
                 * @example
                 * ```ts
                 * const newVec3 = uiTransform.convertToNodeSpaceAR(cc.v3(100, 100, 0));
                 * ```
                 */

              }, {
                key: "convertToNodeSpaceAR",
                value: function convertToNodeSpaceAR(worldPoint, out) {
                  this.node.getWorldMatrix(_worldMatrix);
                  Mat4.invert(_mat4_temp, _worldMatrix);

                  if (!out) {
                    out = new Vec3();
                  }

                  return Vec3.transformMat4(out, worldPoint, _mat4_temp);
                }
                /**
                 * @en
                 * Converts a Point in node coordinates to world space coordinates.
                 *
                 * @zh
                 * 将距当前节点坐标系下的一个点转换到世界坐标系。
                 *
                 * @param nodePoint - 节点坐标。
                 * @param out - 转换后坐标。
                 * @returns - 返回 UI 世界坐标系。
                 * @example
                 * ```ts
                 * const newVec3 = uiTransform.convertToWorldSpaceAR(3(100, 100, 0));
                 * ```
                 */

              }, {
                key: "convertToWorldSpaceAR",
                value: function convertToWorldSpaceAR(nodePoint, out) {
                  this.node.getWorldMatrix(_worldMatrix);

                  if (!out) {
                    out = new Vec3();
                  }

                  return Vec3.transformMat4(out, nodePoint, _worldMatrix);
                }
                /**
                 * @en
                 * Returns a "local" axis aligned bounding box of the node. <br/>
                 * The returned box is relative only to its parent.
                 *
                 * @zh
                 * 返回父节坐标系下的轴向对齐的包围盒。
                 *
                 * @return - 节点大小的包围盒
                 * @example
                 * ```ts
                 * const boundingBox = uiTransform.getBoundingBox();
                 * ```
                 */

              }, {
                key: "getBoundingBox",
                value: function getBoundingBox() {
                  Mat4.fromRTS(_matrix, this.node.getRotation(), this.node.getPosition(), this.node.getScale());
                  var width = this._contentSize.width;
                  var height = this._contentSize.height;
                  var rect = new Rect(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);
                  rect.transformMat4(_matrix);
                  return rect;
                }
                /**
                 * @en
                 * Returns a "world" axis aligned bounding box of the node.<br/>
                 * The bounding box contains self and active children's world bounding box.
                 *
                 * @zh
                 * 返回节点在世界坐标系下的对齐轴向的包围盒（AABB）。
                 * 该边框包含自身和已激活的子节点的世界边框。
                 *
                 * @returns - 返回世界坐标系下包围盒。
                 * @example
                 * ```ts
                 * const newRect = uiTransform.getBoundingBoxToWorld();
                 * ```
                 */

              }, {
                key: "getBoundingBoxToWorld",
                value: function getBoundingBoxToWorld() {
                  if (this.node.parent) {
                    this.node.parent.getWorldMatrix(_worldMatrix);
                    return this.getBoundingBoxTo(_worldMatrix);
                  } else {
                    return this.getBoundingBox();
                  }
                }
                /**
                 * @en
                 * Returns the minimum bounding box containing the current bounding box and its child nodes.
                 *
                 * @zh
                 * 返回包含当前包围盒及其子节点包围盒的最小包围盒。
                 *
                 * @param parentMat - 父节点矩阵。
                 * @returns
                 */

              }, {
                key: "getBoundingBoxTo",
                value: function getBoundingBoxTo(parentMat) {
                  Mat4.fromRTS(_matrix, this.node.getRotation(), this.node.getPosition(), this.node.getScale());
                  var width = this._contentSize.width;
                  var height = this._contentSize.height;
                  var rect = new Rect(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);
                  Mat4.multiply(_worldMatrix, parentMat, _matrix);
                  rect.transformMat4(_worldMatrix); // query child's BoundingBox

                  if (!this.node.children) {
                    return rect;
                  }

                  var locChildren = this.node.children;

                  for (var _iterator = _createForOfIteratorHelperLoose(locChildren), _step; !(_step = _iterator()).done;) {
                    var child = _step.value;

                    if (child && child.active) {
                      var uiTransform = child.getComponent(UITransform);

                      if (uiTransform) {
                        var childRect = uiTransform.getBoundingBoxTo(parentMat);

                        if (childRect) {
                          Rect.union(rect, rect, childRect);
                        }
                      }
                    }
                  }

                  return rect;
                }
                /**
                 * @en
                 * Compute the corresponding aabb in world space for raycast.
                 *
                 * @zh
                 * 计算出此 UI_2D 节点在世界空间下的 aabb 包围盒
                 */

              }, {
                key: "getComputeAABB",
                value: function getComputeAABB(out) {
                  var width = this._contentSize.width;
                  var height = this._contentSize.height;

                  _rect.set(-this._anchorPoint.x * width, -this._anchorPoint.y * height, width, height);

                  _rect.transformMat4(this.node.worldMatrix);

                  var px = _rect.x + _rect.width * 0.5;
                  var py = _rect.y + _rect.height * 0.5;
                  var pz = this.node.worldPosition.z;
                  var w = _rect.width / 2;
                  var h = _rect.height / 2;
                  var l = 0.001;

                  if (out != null) {
                    aabb.set(out, px, py, pz, w, h, l);
                  } else {
                    return new aabb(px, py, pz, w, h, l);
                  }
                }
              }, {
                key: "_updateVisibility",
                value: function _updateVisibility() {
                  var parent = this.node; // 获取被渲染相机的 visibility

                  while (parent) {
                    if (parent) {
                      var canvasComp = parent.getComponent('cc.Canvas');

                      if (canvasComp) {
                        this._canvas = canvasComp;
                        break;
                      }
                    } // @ts-ignore


                    parent = parent.parent;
                  }
                }
              }, {
                key: "_parentChanged",
                value: function _parentChanged(node) {
                  if (this._canvas && this._canvas.node === this.node) {
                    return;
                  }

                  this._sortSiblings();
                }
              }, {
                key: "_sortSiblings",
                value: function _sortSiblings() {
                  var siblings = this.node.parent && this.node.parent.children;

                  if (siblings) {
                    siblings.sort(function (a, b) {
                      var aComp = a._uiProps.uiTransformComp;
                      var bComp = b._uiProps.uiTransformComp;
                      var ca = aComp ? aComp.priority : 0;
                      var cb = bComp ? bComp.priority : 0;
                      var diff = ca - cb;

                      if (diff === 0) {
                        return a.getSiblingIndex() - b.getSiblingIndex();
                      }

                      return diff;
                    });

                    this.node.parent._updateSiblingIndex();
                  }
                }
              }, {
                key: "contentSize",

                /**
                 * @en
                 * Size of the UI node.
                 *
                 * @zh
                 * 内容尺寸。
                 */
                get: function get() {
                  return this._contentSize;
                },
                set: function set(value) {
                  if (this._contentSize.equals(value)) {
                    return;
                  }

                  this._contentSize.set(value);

                  {
                    this.node.emit(SystemEventType.SIZE_CHANGED);
                  }
                }
              }, {
                key: "width",
                get: function get() {
                  return this._contentSize.width;
                },
                set: function set(value) {
                  if (this._contentSize.width === value) {
                    return;
                  }

                  this._contentSize.width = value;

                  {
                    this.node.emit(SystemEventType.SIZE_CHANGED);
                  }
                }
              }, {
                key: "height",
                get: function get() {
                  return this._contentSize.height;
                },
                set: function set(value) {
                  if (this.contentSize.height === value) {
                    return;
                  }

                  this._contentSize.height = value;

                  {
                    this.node.emit(SystemEventType.SIZE_CHANGED);
                  }
                }
                /**
                 * @en
                 * Anchor point of the UI node.
                 *
                 * @zh
                 * 锚点位置。
                 */

              }, {
                key: "anchorPoint",
                get: function get() {
                  return this._anchorPoint;
                },
                set: function set(value) {
                  if (this._anchorPoint.equals(value)) {
                    return;
                  }

                  this._anchorPoint.set(value);

                  this.node.emit(SystemEventType.ANCHOR_CHANGED, this._anchorPoint);
                }
              }, {
                key: "anchorX",
                get: function get() {
                  return this._anchorPoint.x;
                },
                set: function set(value) {
                  if (this._anchorPoint.x === value) {
                    return;
                  }

                  this._anchorPoint.x = value;
                  this.node.emit(SystemEventType.ANCHOR_CHANGED, this._anchorPoint);
                }
              }, {
                key: "anchorY",
                get: function get() {
                  return this._anchorPoint.y;
                },
                set: function set(value) {
                  if (this._anchorPoint.y === value) {
                    return;
                  }

                  this._anchorPoint.y = value;
                  this.node.emit(SystemEventType.ANCHOR_CHANGED, this._anchorPoint);
                }
                /**
                 * @en
                 * Render sequence.
                 * Note: UI rendering is only about priority.
                 *
                 * @zh
                 * 渲染先后顺序，按照广度渲染排列，按同级节点下进行一次排列。
                 */

              }, {
                key: "priority",
                get: function get() {
                  return this._priority;
                },
                set: function set(value) {
                  if (this._priority === value) {
                    return;
                  }

                  if (this._canvas && this._canvas.node === this.node) {
                    warnID(9200);
                    return;
                  }

                  this._priority = value;

                  this._sortSiblings();
                }
              }, {
                key: "visibility",

                /**
                 * @zh
                 * 查找被渲染相机。
                 */
                get: function get() {
                  if (!this._canvas) {
                    return -1;
                  }

                  return this._canvas.visibility;
                }
              }]);

              return UITransform;
            }(Component), _class3$5.EventType = SystemEventType, _temp$c), (_applyDecoratedDescriptor(_class2$a.prototype, "contentSize", [_dec5$1, _dec6], Object.getOwnPropertyDescriptor(_class2$a.prototype, "contentSize"), _class2$a.prototype), _applyDecoratedDescriptor(_class2$a.prototype, "anchorPoint", [_dec7, _dec8], Object.getOwnPropertyDescriptor(_class2$a.prototype, "anchorPoint"), _class2$a.prototype), _applyDecoratedDescriptor(_class2$a.prototype, "priority", [_dec9], Object.getOwnPropertyDescriptor(_class2$a.prototype, "priority"), _class2$a.prototype), _descriptor$9 = _applyDecoratedDescriptor(_class2$a.prototype, "_priority", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            }), _descriptor2$7 = _applyDecoratedDescriptor(_class2$a.prototype, "_contentSize", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Size(100, 100);
              }
            }), _descriptor3$6 = _applyDecoratedDescriptor(_class2$a.prototype, "_anchorPoint", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Vec2(0.5, 0.5);
              }
            })), _class2$a)) || _class$c) || _class$c) || _class$c) || _class$c) || _class$c));

            /**
             * @en Node's UI properties abstraction
             * @zh 节点上 UI 相关的属性抽象类
             */
            var NodeUIProperties = /*#__PURE__*/function () {
              _createClass(NodeUIProperties, [{
                key: "uiTransformComp",

                /**
                 * @en The UI transform component
                 * @zh UI 变换组件
                 */
                get: function get() {
                  if (!this._uiTransformComp) {
                    this._uiTransformComp = this._node.getComponent(UITransform);
                  }

                  return this._uiTransformComp;
                },
                set: function set(value) {
                  this._uiTransformComp = value;
                }
                /**
                 * @en The base UI component
                 * @zh UI 基类组件
                 */

              }]);

              function NodeUIProperties(node) {
                _classCallCheck(this, NodeUIProperties);

                this.uiComp = null;
                this.opacity = 1;
                this._uiTransformComp = null;
                this._node = void 0;
                this._node = node;
              }

              return NodeUIProperties;
            }();

            var _dec$d, _dec2$4, _class$d, _class2$b, _descriptor$a, _descriptor2$8, _descriptor3$7, _descriptor4$4, _descriptor5$4, _class3$6, _temp$d;
            var v3_a = new Vec3();
            var q_a = new Quat();
            var q_b = new Quat();
            var array_a = new Array(10);
            var qt_1 = new Quat();
            var m3_1 = new Mat3();
            var m3_scaling = new Mat3();
            var m4_1 = new Mat4();
            var bookOfChange = new Map();
            /**
             * @zh
             * 场景树中的基本节点，基本特性有：
             * * 具有层级关系
             * * 持有各类组件
             * * 维护空间变换（坐标、旋转、缩放）信息
             */

            /**
             * !#en
             * Class of all entities in Cocos Creator scenes.
             * Basic functionalities include:
             * * Hierarchy management with parent and children
             * * Components management
             * * Coordinate system with position, scale, rotation in 3d space
             * !#zh
             * Cocos Creator 场景中的所有节点类。
             * 基本特性有：
             * * 具有层级关系
             * * 持有各类组件
             * * 维护 3D 空间左边变换（坐标、旋转、缩放）信息
             */

            var Node = exports('cW', (_dec$d = ccclass("cc.Node"), _dec2$4 = type(Vec3), _dec$d(_class$d = (_class2$b = (_temp$d = _class3$6 = /*#__PURE__*/function (_BaseNode) {
              _inherits(Node, _BaseNode);

              function Node() {
                var _getPrototypeOf2;

                var _this;

                _classCallCheck(this, Node);

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Node)).call.apply(_getPrototypeOf2, [this].concat(args)));
                _this._uiProps = new NodeUIProperties(_assertThisInitialized(_this));
                _this._static = false;
                _this._pos = new Vec3();
                _this._rot = new Quat();
                _this._scale = new Vec3(1, 1, 1);
                _this._mat = new Mat4();

                _initializerDefineProperty(_this, "_lpos", _descriptor$a, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_lrot", _descriptor2$8, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_lscale", _descriptor3$7, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_layer", _descriptor4$4, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_euler", _descriptor5$4, _assertThisInitialized(_this));

                _this._dirtyFlags = TransformBit.NONE;
                _this._eulerDirty = false;
                return _this;
              }

              _createClass(Node, [{
                key: "setParent",
                // ===============================
                // hierarchy
                // ===============================

                /**
                 * @en Set parent of the node.
                 * @zh 设置该节点的父节点。
                 * @param value Parent node
                 * @param keepWorldTransform Whether keep node's current world transform unchanged after this operation
                 */
                value: function setParent(value) {
                  var keepWorldTransform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

                  if (keepWorldTransform) {
                    this.updateWorldTransform();
                  }

                  _get(_getPrototypeOf(Node.prototype), "setParent", this).call(this, value, keepWorldTransform);
                }
              }, {
                key: "_onSetParent",
                value: function _onSetParent(oldParent, keepWorldTransform) {
                  _get(_getPrototypeOf(Node.prototype), "_onSetParent", this).call(this, oldParent, keepWorldTransform);

                  if (keepWorldTransform) {
                    var parent = this._parent;

                    if (parent) {
                      parent.updateWorldTransform();
                      Mat4.multiply(m4_1, Mat4.invert(m4_1, parent._mat), this._mat);
                      Mat4.toRTS(m4_1, this._lrot, this._lpos, this._lscale);
                    } else {
                      Vec3.copy(this._lpos, this._pos);
                      Quat.copy(this._lrot, this._rot);
                      Vec3.copy(this._lscale, this._scale);
                    }

                    this._eulerDirty = true;
                  }

                  this.invalidateChildren(TransformBit.TRS);
                }
              }, {
                key: "_onBatchCreated",
                value: function _onBatchCreated() {
                  _get(_getPrototypeOf(Node.prototype), "_onBatchCreated", this).call(this);

                  bookOfChange.set(this._id, TransformBit.TRS);
                  this._dirtyFlags = TransformBit.TRS;
                  var len = this._children.length;

                  for (var i = 0; i < len; ++i) {
                    this._children[i]._onBatchCreated();
                  }
                }
              }, {
                key: "_onBatchRestored",
                value: function _onBatchRestored() {
                  this._onBatchCreated();
                }
              }, {
                key: "_onBeforeSerialize",
                value: function _onBeforeSerialize() {
                  // tslint:disable-next-line: no-unused-expression
                  this.eulerAngles; // make sure we save the correct eulerAngles
                }
              }, {
                key: "_onPostActivated",
                value: function _onPostActivated(active) {
                  if (active) {
                    // activated
                    eventManager.resumeTarget(this);
                    this.eventProcessor.reattach(); // in case transform updated during deactivated period

                    this.invalidateChildren(TransformBit.TRS);
                  } else {
                    // deactivated
                    eventManager.pauseTarget(this);
                  }
                } // ===============================
                // transform helper, convenient but not the most efficient
                // ===============================

                /**
                 * @en Perform a translation on the node
                 * @zh 移动节点
                 * @param trans The increment on position
                 * @param ns The operation coordinate space
                 */

              }, {
                key: "translate",
                value: function translate(trans, ns) {
                  var space = ns || NodeSpace.LOCAL;

                  if (space === NodeSpace.LOCAL) {
                    Vec3.transformQuat(v3_a, trans, this._lrot);
                    this._lpos.x += v3_a.x;
                    this._lpos.y += v3_a.y;
                    this._lpos.z += v3_a.z;
                  } else if (space === NodeSpace.WORLD) {
                    if (this._parent) {
                      Quat.invert(q_a, this._parent.worldRotation);
                      Vec3.transformQuat(v3_a, trans, q_a);
                      var _scale = this.worldScale;
                      this._lpos.x += v3_a.x / _scale.x;
                      this._lpos.y += v3_a.y / _scale.y;
                      this._lpos.z += v3_a.z / _scale.z;
                    } else {
                      this._lpos.x += trans.x;
                      this._lpos.y += trans.y;
                      this._lpos.z += trans.z;
                    }
                  }

                  this.invalidateChildren(TransformBit.POSITION);

                  if (this._eventMask & TRANSFORM_ON) {
                    this.emit(SystemEventType.TRANSFORM_CHANGED, TransformBit.POSITION);
                  }
                }
                /**
                 * @en Perform a rotation on the node
                 * @zh 旋转节点
                 * @param trans The increment on position
                 * @param ns The operation coordinate space
                 */

              }, {
                key: "rotate",
                value: function rotate(rot, ns) {
                  var space = ns || NodeSpace.LOCAL;
                  Quat.normalize(q_a, rot);

                  if (space === NodeSpace.LOCAL) {
                    Quat.multiply(this._lrot, this._lrot, q_a);
                  } else if (space === NodeSpace.WORLD) {
                    var worldRot = this.worldRotation;
                    Quat.multiply(q_b, q_a, worldRot);
                    Quat.invert(q_a, worldRot);
                    Quat.multiply(q_b, q_a, q_b);
                    Quat.multiply(this._lrot, this._lrot, q_b);
                  }

                  this._eulerDirty = true;
                  this.invalidateChildren(TransformBit.ROTATION);

                  if (this._eventMask & TRANSFORM_ON) {
                    this.emit(SystemEventType.TRANSFORM_CHANGED, TransformBit.ROTATION);
                  }
                }
                /**
                 * @en Set the orientation of the node to face the target position, the node is facing minus z direction by default
                 * @zh 设置当前节点旋转为面向目标位置，默认前方为 -z 方向
                 * @param pos Target position
                 * @param up Up direction
                 */

              }, {
                key: "lookAt",
                value: function lookAt(pos, up) {
                  this.getWorldPosition(v3_a);
                  Vec3.subtract(v3_a, v3_a, pos);
                  Vec3.normalize(v3_a, v3_a);
                  Quat.fromViewUp(q_a, v3_a, up);
                  this.setWorldRotation(q_a);
                } // ===============================
                // transform maintainer
                // ===============================

                /**
                 * @en Invalidate the world transform information
                 * for this node and all its children recursively
                 * @zh 递归标记节点世界变换为 dirty
                 * @param dirtyBit The dirty bits to setup to children, can be composed with multiple dirty bits
                 */

              }, {
                key: "invalidateChildren",
                value: function invalidateChildren(dirtyBit) {
                  if ((this._dirtyFlags & this.hasChangedFlags & dirtyBit) === dirtyBit) {
                    return;
                  }

                  this._dirtyFlags |= dirtyBit;
                  bookOfChange.set(this._id, this.hasChangedFlags | dirtyBit);
                  dirtyBit |= TransformBit.POSITION;
                  var len = this._children.length;

                  for (var i = 0; i < len; ++i) {
                    var child = this._children[i];

                    if (child.isValid) {
                      child.invalidateChildren(dirtyBit);
                    }
                  }
                }
                /**
                 * @en Update the world transform information if outdated
                 * @zh 更新节点的世界变换信息
                 */

              }, {
                key: "updateWorldTransform",
                value: function updateWorldTransform() {
                  if (!this._dirtyFlags) {
                    return;
                  }

                  var cur = this;
                  var i = 0;

                  while (cur && cur._dirtyFlags) {
                    // top level node
                    array_a[i++] = cur;
                    cur = cur._parent;
                  }

                  var child;
                  var dirtyBits = 0;

                  while (i) {
                    child = array_a[--i];
                    dirtyBits |= child._dirtyFlags;

                    if (cur) {
                      if (dirtyBits & TransformBit.POSITION) {
                        Vec3.transformMat4(child._pos, child._lpos, cur._mat);
                        child._mat.m12 = child._pos.x;
                        child._mat.m13 = child._pos.y;
                        child._mat.m14 = child._pos.z;
                      }

                      if (dirtyBits & TransformBit.RS) {
                        Mat4.fromRTS(child._mat, child._lrot, child._lpos, child._lscale);
                        Mat4.multiply(child._mat, cur._mat, child._mat);

                        if (dirtyBits & TransformBit.ROTATION) {
                          Quat.multiply(child._rot, cur._rot, child._lrot);
                        }

                        Mat3.fromQuat(m3_1, Quat.conjugate(qt_1, child._rot));
                        Mat3.multiplyMat4(m3_1, m3_1, child._mat);
                        child._scale.x = m3_1.m00;
                        child._scale.y = m3_1.m04;
                        child._scale.z = m3_1.m08;
                      }
                    } else {
                      if (dirtyBits & TransformBit.POSITION) {
                        Vec3.copy(child._pos, child._lpos);
                        child._mat.m12 = child._pos.x;
                        child._mat.m13 = child._pos.y;
                        child._mat.m14 = child._pos.z;
                      }

                      if (dirtyBits & TransformBit.RS) {
                        if (dirtyBits & TransformBit.ROTATION) {
                          Quat.copy(child._rot, child._lrot);
                        }

                        if (dirtyBits & TransformBit.SCALE) {
                          Vec3.copy(child._scale, child._lscale);
                        }

                        Mat4.fromRTS(child._mat, child._rot, child._pos, child._scale);
                      }
                    }

                    child._dirtyFlags = TransformBit.NONE;
                    cur = child;
                  }
                } // ===============================
                // transform
                // ===============================

                /**
                 * @en Set position in local coordinate system
                 * @zh 设置本地坐标
                 * @param position Target position
                 */

              }, {
                key: "setPosition",
                value: function setPosition(val, y, z) {
                  if (y === undefined || z === undefined) {
                    Vec3.copy(this._lpos, val);
                  } else {
                    Vec3.set(this._lpos, val, y, z);
                  }

                  this.invalidateChildren(TransformBit.POSITION);

                  if (this._eventMask & TRANSFORM_ON) {
                    this.emit(SystemEventType.TRANSFORM_CHANGED, TransformBit.POSITION);
                  }
                }
                /**
                 * @en Get position in local coordinate system, please try to pass `out` vector and reuse it to avoid garbage.
                 * @zh 获取本地坐标，注意，尽可能传递复用的 [[Vec3]] 以避免产生垃圾。
                 * @param out Set the result to out vector
                 * @return If `out` given, the return value equals to `out`, otherwise a new vector will be generated and return
                 */

              }, {
                key: "getPosition",
                value: function getPosition(out) {
                  if (out) {
                    return Vec3.set(out, this._lpos.x, this._lpos.y, this._lpos.z);
                  } else {
                    return Vec3.copy(new Vec3(), this._lpos);
                  }
                }
                /**
                 * @en Set rotation in local coordinate system with a quaternion representing the rotation
                 * @zh 用四元数设置本地旋转
                 * @param rotation Rotation in quaternion
                 */

              }, {
                key: "setRotation",
                value: function setRotation(val, y, z, w) {
                  if (y === undefined || z === undefined || w === undefined) {
                    Quat.copy(this._lrot, val);
                  } else {
                    Quat.set(this._lrot, val, y, z, w);
                  }

                  this._eulerDirty = true;
                  this.invalidateChildren(TransformBit.ROTATION);

                  if (this._eventMask & TRANSFORM_ON) {
                    this.emit(SystemEventType.TRANSFORM_CHANGED, TransformBit.ROTATION);
                  }
                }
                /**
                 * @en Set rotation in local coordinate system with euler angles
                 * @zh 用欧拉角设置本地旋转
                 * @param x X axis rotation
                 * @param y Y axis rotation
                 * @param z Z axis rotation
                 */

              }, {
                key: "setRotationFromEuler",
                value: function setRotationFromEuler(x, y, z) {
                  Vec3.set(this._euler, x, y, z);
                  Quat.fromEuler(this._lrot, x, y, z);
                  this._eulerDirty = false;
                  this.invalidateChildren(TransformBit.ROTATION);

                  if (this._eventMask & TRANSFORM_ON) {
                    this.emit(SystemEventType.TRANSFORM_CHANGED, TransformBit.ROTATION);
                  }
                }
                /**
                 * @en Get rotation as quaternion in local coordinate system, please try to pass `out` quaternion and reuse it to avoid garbage.
                 * @zh 获取本地旋转，注意，尽可能传递复用的 [[Quat]] 以避免产生垃圾。
                 * @param out Set the result to out quaternion
                 * @return If `out` given, the return value equals to `out`, otherwise a new quaternion will be generated and return
                 */

              }, {
                key: "getRotation",
                value: function getRotation(out) {
                  if (out) {
                    return Quat.set(out, this._lrot.x, this._lrot.y, this._lrot.z, this._lrot.w);
                  } else {
                    return Quat.copy(new Quat(), this._lrot);
                  }
                }
                /**
                 * @en Set scale in local coordinate system
                 * @zh 设置本地缩放
                 * @param scale Target scale
                 */

              }, {
                key: "setScale",
                value: function setScale(val, y, z) {
                  if (y === undefined || z === undefined) {
                    Vec3.copy(this._lscale, val);
                  } else {
                    Vec3.set(this._lscale, val, y, z);
                  }

                  this.invalidateChildren(TransformBit.SCALE);

                  if (this._eventMask & TRANSFORM_ON) {
                    this.emit(SystemEventType.TRANSFORM_CHANGED, TransformBit.SCALE);
                  }
                }
                /**
                 * @en Get scale in local coordinate system, please try to pass `out` vector and reuse it to avoid garbage.
                 * @zh 获取本地缩放，注意，尽可能传递复用的 [[Vec3]] 以避免产生垃圾。
                 * @param out Set the result to out vector
                 * @return If `out` given, the return value equals to `out`, otherwise a new vector will be generated and return
                 */

              }, {
                key: "getScale",
                value: function getScale(out) {
                  if (out) {
                    return Vec3.set(out, this._lscale.x, this._lscale.y, this._lscale.z);
                  } else {
                    return Vec3.copy(new Vec3(), this._lscale);
                  }
                }
                /**
                 * @en Inversely transform a point from world coordinate system to local coordinate system.
                 * @zh 逆向变换一个空间点，一般用于将世界坐标转换到本地坐标系中。
                 * @param out The result point in local coordinate system will be stored in this vector
                 * @param p A position in world coordinate system
                 */

              }, {
                key: "inverseTransformPoint",
                value: function inverseTransformPoint(out, p) {
                  Vec3.copy(out, p);
                  var cur = this;
                  var i = 0;

                  while (cur._parent) {
                    array_a[i++] = cur;
                    cur = cur._parent; // if (cur._parent instanceof Scene) break;
                  }

                  while (i >= 0) {
                    Vec3.transformInverseRTS(out, out, cur._lrot, cur._lpos, cur._lscale);
                    cur = array_a[--i];
                  }

                  return out;
                }
                /**
                 * @en Set position in world coordinate system
                 * @zh 设置世界坐标
                 * @param position Target position
                 */

              }, {
                key: "setWorldPosition",
                value: function setWorldPosition(val, y, z) {
                  if (y === undefined || z === undefined) {
                    Vec3.copy(this._pos, val);
                  } else {
                    Vec3.set(this._pos, val, y, z);
                  }

                  var parent = this._parent;
                  var local = this._lpos;

                  if (parent) {
                    // TODO: benchmark these approaches

                    /* */
                    parent.updateWorldTransform();
                    Vec3.transformMat4(local, this._pos, Mat4.invert(m4_1, parent._mat));
                    /* *
                          parent.inverseTransformPoint(local, this._pos);
                          /* */
                  } else {
                    Vec3.copy(local, this._pos);
                  }

                  this.invalidateChildren(TransformBit.POSITION);

                  if (this._eventMask & TRANSFORM_ON) {
                    this.emit(SystemEventType.TRANSFORM_CHANGED, TransformBit.POSITION);
                  }
                }
                /**
                 * @en Get position in world coordinate system, please try to pass `out` vector and reuse it to avoid garbage.
                 * @zh 获取世界坐标，注意，尽可能传递复用的 [[Vec3]] 以避免产生垃圾。
                 * @param out Set the result to out vector
                 * @return If `out` given, the return value equals to `out`, otherwise a new vector will be generated and return
                 */

              }, {
                key: "getWorldPosition",
                value: function getWorldPosition(out) {
                  this.updateWorldTransform();

                  if (out) {
                    return Vec3.copy(out, this._pos);
                  } else {
                    return Vec3.copy(new Vec3(), this._pos);
                  }
                }
                /**
                 * @en Set rotation in world coordinate system with a quaternion representing the rotation
                 * @zh 用四元数设置世界坐标系下的旋转
                 * @param rotation Rotation in quaternion
                 */

              }, {
                key: "setWorldRotation",
                value: function setWorldRotation(val, y, z, w) {
                  if (y === undefined || z === undefined || w === undefined) {
                    Quat.copy(this._rot, val);
                  } else {
                    Quat.set(this._rot, val, y, z, w);
                  }

                  if (this._parent) {
                    this._parent.updateWorldTransform();

                    Quat.multiply(this._lrot, Quat.conjugate(this._lrot, this._parent._rot), this._rot);
                  } else {
                    Quat.copy(this._lrot, this._rot);
                  }

                  this._eulerDirty = true;
                  this.invalidateChildren(TransformBit.ROTATION);

                  if (this._eventMask & TRANSFORM_ON) {
                    this.emit(SystemEventType.TRANSFORM_CHANGED, TransformBit.ROTATION);
                  }
                }
                /**
                 * @en Set rotation in world coordinate system with euler angles
                 * @zh 用欧拉角设置世界坐标系下的旋转
                 * @param x X axis rotation
                 * @param y Y axis rotation
                 * @param z Z axis rotation
                 */

              }, {
                key: "setWorldRotationFromEuler",
                value: function setWorldRotationFromEuler(x, y, z) {
                  Quat.fromEuler(this._rot, x, y, z);

                  if (this._parent) {
                    this._parent.updateWorldTransform();

                    Quat.multiply(this._lrot, Quat.conjugate(this._lrot, this._parent._rot), this._rot);
                  } else {
                    Quat.copy(this._lrot, this._rot);
                  }

                  this._eulerDirty = true;
                  this.invalidateChildren(TransformBit.ROTATION);

                  if (this._eventMask & TRANSFORM_ON) {
                    this.emit(SystemEventType.TRANSFORM_CHANGED, TransformBit.ROTATION);
                  }
                }
                /**
                 * @en Get rotation as quaternion in world coordinate system, please try to pass `out` quaternion and reuse it to avoid garbage.
                 * @zh 获取世界坐标系下的旋转，注意，尽可能传递复用的 [[Quat]] 以避免产生垃圾。
                 * @param out Set the result to out quaternion
                 * @return If `out` given, the return value equals to `out`, otherwise a new quaternion will be generated and return
                 */

              }, {
                key: "getWorldRotation",
                value: function getWorldRotation(out) {
                  this.updateWorldTransform();

                  if (out) {
                    return Quat.copy(out, this._rot);
                  } else {
                    return Quat.copy(new Quat(), this._rot);
                  }
                }
                /**
                 * @en Set scale in world coordinate system
                 * @zh 设置世界坐标系下的缩放
                 * @param scale Target scale
                 */

              }, {
                key: "setWorldScale",
                value: function setWorldScale(val, y, z) {
                  if (y === undefined || z === undefined) {
                    Vec3.copy(this._scale, val);
                  } else {
                    Vec3.set(this._scale, val, y, z);
                  }

                  var parent = this._parent;

                  if (parent) {
                    parent.updateWorldTransform();
                    Mat3.fromQuat(m3_1, Quat.conjugate(qt_1, parent._rot));
                    Mat3.multiplyMat4(m3_1, m3_1, parent._mat);
                    m3_scaling.m00 = this._scale.x;
                    m3_scaling.m04 = this._scale.y;
                    m3_scaling.m08 = this._scale.z;
                    Mat3.multiply(m3_1, m3_scaling, Mat3.invert(m3_1, m3_1));
                    this._lscale.x = Vec3.set(v3_a, m3_1.m00, m3_1.m01, m3_1.m02).length();
                    this._lscale.y = Vec3.set(v3_a, m3_1.m03, m3_1.m04, m3_1.m05).length();
                    this._lscale.z = Vec3.set(v3_a, m3_1.m06, m3_1.m07, m3_1.m08).length();
                  } else {
                    Vec3.copy(this._lscale, this._scale);
                  }

                  this.invalidateChildren(TransformBit.SCALE);

                  if (this._eventMask & TRANSFORM_ON) {
                    this.emit(SystemEventType.TRANSFORM_CHANGED, TransformBit.SCALE);
                  }
                }
                /**
                 * @en Get scale in world coordinate system, please try to pass `out` vector and reuse it to avoid garbage.
                 * @zh 获取世界缩放，注意，尽可能传递复用的 [[Vec3]] 以避免产生垃圾。
                 * @param out Set the result to out vector
                 * @return If `out` given, the return value equals to `out`, otherwise a new vector will be generated and return
                 */

              }, {
                key: "getWorldScale",
                value: function getWorldScale(out) {
                  this.updateWorldTransform();

                  if (out) {
                    return Vec3.copy(out, this._scale);
                  } else {
                    return Vec3.copy(new Vec3(), this._scale);
                  }
                }
                /**
                 * @en Get a world transform matrix
                 * @zh 获取世界变换矩阵
                 * @param out Set the result to out matrix
                 * @return If `out` given, the return value equals to `out`, otherwise a new matrix will be generated and return
                 */

              }, {
                key: "getWorldMatrix",
                value: function getWorldMatrix(out) {
                  this.updateWorldTransform();

                  if (!out) {
                    out = new Mat4();
                  }

                  return Mat4.copy(out, this._mat);
                }
                /**
                 * @en Get a world transform matrix with only rotation and scale
                 * @zh 获取只包含旋转和缩放的世界变换矩阵
                 * @param out Set the result to out matrix
                 * @return If `out` given, the return value equals to `out`, otherwise a new matrix will be generated and return
                 */

              }, {
                key: "getWorldRS",
                value: function getWorldRS(out) {
                  this.updateWorldTransform();

                  if (!out) {
                    out = new Mat4();
                  }

                  Mat4.copy(out, this._mat);
                  out.m12 = 0;
                  out.m13 = 0;
                  out.m14 = 0;
                  return out;
                }
                /**
                 * @en Get a world transform matrix with only rotation and translation
                 * @zh 获取只包含旋转和位移的世界变换矩阵
                 * @param out Set the result to out matrix
                 * @return If `out` given, the return value equals to `out`, otherwise a new matrix will be generated and return
                 */

              }, {
                key: "getWorldRT",
                value: function getWorldRT(out) {
                  this.updateWorldTransform();

                  if (!out) {
                    out = new Mat4();
                  }

                  return Mat4.fromRT(out, this._rot, this._pos);
                }
                /**
                 * @en Set local transformation with rotation, position and scale separately.
                 * @zh 一次性设置所有局部变换（平移、旋转、缩放）信息
                 * @param rot The rotation
                 * @param pos The position
                 * @param scale The scale
                 */

              }, {
                key: "setRTS",
                value: function setRTS(rot, pos, scale) {
                  var dirtyBit = 0;

                  if (rot) {
                    dirtyBit |= TransformBit.ROTATION;

                    if (rot.w !== undefined) {
                      Quat.copy(this._lrot, rot);
                      this._eulerDirty = true;
                    } else {
                      Vec3.copy(this._euler, rot);
                      Quat.fromEuler(this._lrot, rot.x, rot.y, rot.z);
                      this._eulerDirty = false;
                    }
                  }

                  if (pos) {
                    Vec3.copy(this._lpos, pos);
                    dirtyBit |= TransformBit.POSITION;
                  }

                  if (scale) {
                    Vec3.copy(this._lscale, scale);
                    dirtyBit |= TransformBit.SCALE;
                  }

                  if (dirtyBit) {
                    this.invalidateChildren(dirtyBit);

                    if (this._eventMask & TRANSFORM_ON) {
                      this.emit(SystemEventType.TRANSFORM_CHANGED, dirtyBit);
                    }
                  }
                }
                /**
                 * @en Pause all system events which is dispatched by [[SystemEvent]]
                 * @zh 暂停所有 [[SystemEvent]] 派发的系统事件
                 * @param recursive Whether pause system events recursively for the child node tree
                 */

              }, {
                key: "pauseSystemEvents",
                value: function pauseSystemEvents(recursive) {
                  // @ts-ignore
                  eventManager.pauseTarget(this, recursive);
                }
                /**
                 * @en Resume all paused system events which is dispatched by [[SystemEvent]]
                 * @zh 恢复所有 [[SystemEvent]] 派发的系统事件
                 * @param recursive Whether resume system events recursively for the child node tree
                 */

              }, {
                key: "resumeSystemEvents",
                value: function resumeSystemEvents(recursive) {
                  // @ts-ignore
                  eventManager.resumeTarget(this, recursive);
                }
              }, {
                key: "position",

                /**
                 * @en Position in local coordinate system
                 * @zh 本地坐标系下的坐标
                 */
                // @constget
                get: function get() {
                  return this._lpos;
                },
                set: function set(val) {
                  this.setPosition(val);
                }
                /**
                 * @en Position in world coordinate system
                 * @zh 世界坐标系下的坐标
                 */
                // @constget

              }, {
                key: "worldPosition",
                get: function get() {
                  this.updateWorldTransform();
                  return this._pos;
                },
                set: function set(val) {
                  this.setWorldPosition(val);
                }
                /**
                 * @en Rotation in local coordinate system, represented by a quaternion
                 * @zh 本地坐标系下的旋转，用四元数表示
                 */
                // @constget

              }, {
                key: "rotation",
                get: function get() {
                  return this._lrot;
                },
                set: function set(val) {
                  this.setRotation(val);
                }
                /**
                 * @en Rotation in local coordinate system, represented by euler angles
                 * @zh 本地坐标系下的旋转，用欧拉角表示
                 */

              }, {
                key: "eulerAngles",
                set: function set(val) {
                  this.setRotationFromEuler(val.x, val.y, val.z);
                },
                get: function get() {
                  if (this._eulerDirty) {
                    Quat.toEuler(this._euler, this._lrot);
                    this._eulerDirty = false;
                  }

                  return this._euler;
                }
                /**
                 * @en Rotation in world coordinate system, represented by a quaternion
                 * @zh 世界坐标系下的旋转，用四元数表示
                 */
                // @constget

              }, {
                key: "worldRotation",
                get: function get() {
                  this.updateWorldTransform();
                  return this._rot;
                },
                set: function set(val) {
                  this.setWorldRotation(val);
                }
                /**
                 * @en Scale in local coordinate system
                 * @zh 本地坐标系下的缩放
                 */
                // @constget

              }, {
                key: "scale",
                get: function get() {
                  return this._lscale;
                },
                set: function set(val) {
                  this.setScale(val);
                }
                /**
                 * @en Scale in world coordinate system
                 * @zh 世界坐标系下的缩放
                 */
                // @constget

              }, {
                key: "worldScale",
                get: function get() {
                  this.updateWorldTransform();
                  return this._scale;
                },
                set: function set(val) {
                  this.setWorldScale(val);
                }
                /**
                 * @en Local transformation matrix
                 * @zh 本地坐标系变换矩阵
                 */

              }, {
                key: "matrix",
                set: function set(val) {
                  Mat4.toRTS(val, this._lrot, this._lpos, this._lscale);
                  this.invalidateChildren(TransformBit.TRS);
                  this._eulerDirty = true;

                  if (this._eventMask & TRANSFORM_ON) {
                    this.emit(SystemEventType.TRANSFORM_CHANGED, TransformBit.TRS);
                  }
                }
                /**
                 * @en World transformation matrix
                 * @zh 世界坐标系变换矩阵
                 */
                // @constget

              }, {
                key: "worldMatrix",
                get: function get() {
                  this.updateWorldTransform();
                  return this._mat;
                }
                /**
                 * @en The vector representing forward direction in local coordinate system, it's the minus z direction by default
                 * @zh 当前节点面向的前方方向，默认前方为 -z 方向
                 */

              }, {
                key: "forward",
                get: function get() {
                  return Vec3.transformQuat(new Vec3(), Vec3.FORWARD, this.worldRotation);
                },
                set: function set(dir) {
                  var len = dir.length();
                  Vec3.multiplyScalar(v3_a, dir, -1 / len);
                  Quat.fromViewUp(q_a, v3_a);
                  this.setWorldRotation(q_a);
                }
                /**
                 * @en Layer of the current Node, it affects raycast, physics etc, refer to [[Layers]]
                 * @zh 节点所属层，主要影响射线检测、物理碰撞等，参考 [[Layers]]
                 */

              }, {
                key: "layer",
                set: function set(l) {
                  this._layer = l;
                },
                get: function get() {
                  return this._layer;
                }
                /**
                 * @en Whether the node's transformation have changed during the current frame.
                 * @zh 这个节点的空间变换信息在当前帧内是否有变过？
                 */

              }, {
                key: "hasChangedFlags",
                get: function get() {
                  return bookOfChange.get(this._id) || 0;
                },
                set: function set(val) {
                  bookOfChange.set(this._id, val);
                }
              }], [{
                key: "isNode",

                /**
                 * @en Determine whether the given object is a normal Node. Will return false if [[Scene]] given.
                 * @zh 指定对象是否是普通的节点？如果传入 [[Scene]] 会返回 false。
                 */
                value: function isNode(obj) {
                  return obj instanceof Node && (obj.constructor === Node || !(obj instanceof legacyCC.Scene));
                } // UI 部分的脏数据

              }]);

              return Node;
            }(BaseNode), _class3$6.bookOfChange = bookOfChange, _class3$6.EventType = SystemEventType, _class3$6.NodeSpace = NodeSpace, _class3$6.TransformDirtyBit = TransformBit, _class3$6.TransformBit = TransformBit, _temp$d), (_descriptor$a = _applyDecoratedDescriptor(_class2$b.prototype, "_lpos", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Vec3();
              }
            }), _descriptor2$8 = _applyDecoratedDescriptor(_class2$b.prototype, "_lrot", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Quat();
              }
            }), _descriptor3$7 = _applyDecoratedDescriptor(_class2$b.prototype, "_lscale", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Vec3(1, 1, 1);
              }
            }), _descriptor4$4 = _applyDecoratedDescriptor(_class2$b.prototype, "_layer", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return Layers.Enum.DEFAULT;
              }
            }), _descriptor5$4 = _applyDecoratedDescriptor(_class2$b.prototype, "_euler", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Vec3();
              }
            }), _applyDecoratedDescriptor(_class2$b.prototype, "eulerAngles", [_dec2$4], Object.getOwnPropertyDescriptor(_class2$b.prototype, "eulerAngles"), _class2$b.prototype), _applyDecoratedDescriptor(_class2$b.prototype, "layer", [editable], Object.getOwnPropertyDescriptor(_class2$b.prototype, "layer"), _class2$b.prototype)), _class2$b)) || _class$d));
            legacyCC.Node = Node;

            var _dec$e, _class$e, _class2$c, _descriptor$b, _temp$e, _dec2$5, _class4, _class5, _descriptor2$9, _temp2;
            function isPropertyPath(path) {
              return typeof path === 'string' || typeof path === 'number';
            }
            function isCustomPath(path, constructor) {
              return path instanceof constructor;
            }
            var HierarchyPath = exports('ax', (_dec$e = ccclass('cc.animation.HierarchyPath'), _dec$e(_class$e = (_class2$c = (_temp$e = /*#__PURE__*/function () {
              function HierarchyPath(path) {
                _classCallCheck(this, HierarchyPath);

                _initializerDefineProperty(this, "path", _descriptor$b, this);

                this.path = path || '';
              }

              _createClass(HierarchyPath, [{
                key: "get",
                value: function get(target) {
                  if (!(target instanceof Node)) {
                    warn("Target of hierarchy path should be of type Node.");
                    return null;
                  }

                  var result = target.getChildByPath(this.path);

                  if (!result) {
                    warn("Node \"".concat(target.name, "\" has no path \"").concat(this.path, "\""));
                    return null;
                  }

                  return result;
                }
              }]);

              return HierarchyPath;
            }(), _temp$e), (_descriptor$b = _applyDecoratedDescriptor(_class2$c.prototype, "path", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return '';
              }
            })), _class2$c)) || _class$e));
            var ComponentPath = exports('ay', (_dec2$5 = ccclass('cc.animation.ComponentPath'), _dec2$5(_class4 = (_class5 = (_temp2 = /*#__PURE__*/function () {
              function ComponentPath(component) {
                _classCallCheck(this, ComponentPath);

                _initializerDefineProperty(this, "component", _descriptor2$9, this);

                this.component = component || '';
              }

              _createClass(ComponentPath, [{
                key: "get",
                value: function get(target) {
                  if (!(target instanceof Node)) {
                    warn("Target of component path should be of type Node.");
                    return null;
                  }

                  var result = target.getComponent(this.component);

                  if (!result) {
                    warn("Node \"".concat(target.name, "\" has no component \"").concat(this.component, "\""));
                    return null;
                  }

                  return result;
                }
              }]);

              return ComponentPath;
            }(), _temp2), (_descriptor2$9 = _applyDecoratedDescriptor(_class5.prototype, "component", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return '';
              }
            })), _class5)) || _class4));
            /**
             * Evaluate a sequence of paths, in order, from specified root.
             * @param root The root object.
             * @param path The path sequence.
             */

            function evaluatePath(root) {
              var result = root;

              for (var iPath = 0; iPath < (arguments.length <= 1 ? 0 : arguments.length - 1); ++iPath) {
                var path = iPath + 1 < 1 || arguments.length <= iPath + 1 ? undefined : arguments[iPath + 1];

                if (isPropertyPath(path)) {
                  if (!(path in result)) {
                    warn("Target object has no property \"".concat(path, "\""));
                    return null;
                  } else {
                    result = result[path];
                  }
                } else {
                  result = path.get(result);
                }

                if (result === null) {
                  break;
                }
              }

              return result;
            }

            /**
             * 骨骼动画数据转换中心。
             */
            var SkelAnimDataHub = exports('d4', /*#__PURE__*/function () {
              function SkelAnimDataHub() {
                _classCallCheck(this, SkelAnimDataHub);
              }

              _createClass(SkelAnimDataHub, null, [{
                key: "getOrExtract",
                value: function getOrExtract(clip) {
                  var data = SkelAnimDataHub.pool.get(clip);

                  if (!data || data.info.sample !== clip.sample) {
                    // release outdated render data
                    if (data) {
                      legacyCC.director.root.dataPoolManager.releaseAnimationClip(clip);
                    }

                    data = convertToSkeletalCurves(clip);
                    SkelAnimDataHub.pool.set(clip, data);
                  }

                  return data;
                }
              }, {
                key: "destroy",
                value: function destroy(clip) {
                  SkelAnimDataHub.pool["delete"](clip);
                }
              }]);

              return SkelAnimDataHub;
            }());
            SkelAnimDataHub.pool = new Map();

            function convertToSkeletalCurves(clip) {
              var data = {};
              clip.curves.forEach(function (curve) {
                if (!curve.valueAdapter && isCustomPath(curve.modifiers[0], HierarchyPath) && isPropertyPath(curve.modifiers[1])) {
                  var path = curve.modifiers[0].path;
                  var cs = data[path];

                  if (!cs) {
                    cs = data[path] = {};
                  }

                  var property = curve.modifiers[1];
                  cs[property] = {
                    values: curve.data.values,
                    keys: curve.data.keys
                  }; // don't use curve.data directly
                }
              });
              var frames = Math.ceil(clip.sample * clip.duration) + 1; // lazy eval the conversion due to memory-heavy ops
              // many animation paths may not be actually in-use

              var _loop = function _loop() {
                var path = _Object$keys[_i];
                var props = data[path];

                if (!props) {
                  return "continue";
                }

                Object.defineProperty(props, 'worldMatrix', {
                  get: function get() {
                    if (!props._worldMatrix) {
                      var position = props.position,
                          rotation = props.rotation,
                          scale = props.scale; // fixed step pre-sample

                      convertToUniformSample(clip, position, frames);
                      convertToUniformSample(clip, rotation, frames);
                      convertToUniformSample(clip, scale, frames); // transform to world space

                      convertToWorldSpace(data, path, props);
                    }

                    return props._worldMatrix;
                  }
                });
              };

              for (var _i = 0, _Object$keys = Object.keys(data); _i < _Object$keys.length; _i++) {
                var _ret = _loop();

                if (_ret === "continue") continue;
              }

              var info = {
                frames: frames,
                sample: clip.sample
              };
              return {
                info: info,
                data: data
              };
            }

            function convertToUniformSample(clip, curve, frames) {
              var keys = clip.keys[curve.keys];
              var values = [];

              if (!keys || keys.length === 1) {
                for (var i = 0; i < frames; i++) {
                  values[i] = curve.values[0].clone(); // never forget to clone
                }
              } else {
                var isQuat = curve.values[0] instanceof Quat;

                for (var _i2 = 0, idx = 0; _i2 < frames; _i2++) {
                  var time = _i2 / clip.sample;

                  while (keys[idx] <= time) {
                    idx++;
                  }

                  if (idx > keys.length - 1) {
                    idx = keys.length - 1;
                    time = keys[idx];
                  } else if (idx === 0) {
                    idx = 1;
                  }

                  var from = curve.values[idx - 1].clone();
                  var denom = keys[idx] - keys[idx - 1];
                  var ratio = denom ? clamp01((time - keys[idx - 1]) / denom) : 1;

                  if (isQuat) {
                    from.slerp(curve.values[idx], ratio);
                  } else {
                    from.lerp(curve.values[idx], ratio);
                  }

                  values[_i2] = from;
                }
              }

              curve.values = values;
            }

            function convertToWorldSpace(convertedProps, path, props) {
              var oPos = props.position.values;
              var oRot = props.rotation.values;
              var oScale = props.scale.values;
              var matrix = oPos.map(function () {
                return new Mat4();
              });
              var idx = path.lastIndexOf('/');
              var pMatrix = null;

              if (idx > 0) {
                var name = path.substring(0, idx);
                var data = convertedProps[name];

                if (!data) {
                  console.warn('no data for parent bone?');
                  return;
                }

                pMatrix = data.worldMatrix.values;
              } // all props should have the same length now


              for (var i = 0; i < oPos.length; i++) {
                var oT = oPos[i];
                var oR = oRot[i];
                var oS = oScale[i];
                var m = matrix[i];
                Mat4.fromRTS(m, oR, oT, oS);

                if (pMatrix) {
                  Mat4.multiply(m, pMatrix[i], m);
                }
              }

              Object.keys(props).forEach(function (k) {
                return delete props[k];
              });
              props._worldMatrix = {
                keys: 0,
                interpolate: false,
                values: matrix
              };
            }

            /*
             Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

             http://www.cocos.com

             Permission is hereby granted, free of charge, to any person obtaining a copy
             of this software and associated engine source code (the "Software"), a limited,
              worldwide, royalty-free, non-assignable, revocable and non-exclusive license
             to use Cocos Creator solely to develop games on your target platforms. You shall
              not use Cocos Creator software for developing other software or tools that's
              used for developing games. You are not granted to publish, distribute,
              sublicense, and/or sell copies of Cocos Creator.

             The software or tools in this License Agreement are licensed, not sold.
             Xiamen Yaji Software Co., Ltd. reserves all rights not expressly granted to you.

             THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
             THE SOFTWARE.
            */
            var m4_1$1 = new Mat4();
            function getPathFromRoot(target, root) {
              var node = target;
              var path = '';

              while (node !== null && node !== root) {
                path = "".concat(node.name, "/").concat(path);
                node = node.parent;
              }

              return path.slice(0, -1);
            }
            function getWorldTransformUntilRoot(target, root, outMatrix) {
              Mat4.identity(outMatrix);

              while (target !== root) {
                Mat4.fromRTS(m4_1$1, target.rotation, target.position, target.scale);
                Mat4.multiply(outMatrix, m4_1$1, outMatrix);
                target = target.parent;
              }

              return outMatrix;
            }

            var uploadJointData = exports('u', uploadJointDataLBS);
            var MINIMUM_JOINT_TEXTURE_SIZE = exports('M',  480); // have to be multiples of 12

            function selectJointsMediumFormat(device) {
              if (device.hasFeature(GFXFeature.TEXTURE_FLOAT)) {
                return GFXFormat.RGBA32F;
              } else {
                return GFXFormat.RGBA8;
              }
            } // Linear Blending Skinning

            function uploadJointDataLBS(out, base, mat, firstBone) {
              out[base + 0] = mat.m00;
              out[base + 1] = mat.m01;
              out[base + 2] = mat.m02;
              out[base + 3] = mat.m12;
              out[base + 4] = mat.m04;
              out[base + 5] = mat.m05;
              out[base + 6] = mat.m06;
              out[base + 7] = mat.m13;
              out[base + 8] = mat.m08;
              out[base + 9] = mat.m09;
              out[base + 10] = mat.m10;
              out[base + 11] = mat.m14;
            }

            var dq_0 = new Quat();
            var dq_1 = new Quat();
            var v3_1$1 = new Vec3();
            var qt_1$1 = new Quat();
            var v3_2$1 = new Vec3(); // Dual Quaternion Skinning

            function roundUpTextureSize(targetLength, formatSize) {
              var formatScale = 4 / Math.sqrt(formatSize);
              return Math.ceil(Math.max(MINIMUM_JOINT_TEXTURE_SIZE * formatScale, targetLength) / 12) * 12;
            }

            var jointTextureSamplerHash = exports('l', genSamplerHash([GFXFilter.POINT, GFXFilter.POINT, GFXFilter.NONE, GFXAddress.CLAMP, GFXAddress.CLAMP, GFXAddress.CLAMP]));
            var v3_3 = new Vec3();
            var v3_4 = new Vec3();
            var v3_min = new Vec3();
            var v3_max = new Vec3();
            var m4_1$2 = new Mat4();
            var m4_2 = new Mat4();
            var ab_1 = new aabb();
            // Have to use some big number to replace the actual 'Infinity'.
            // For (Infinity - Infinity) evaluates to NaN
            var Inf = Number.MAX_SAFE_INTEGER;
            var JointTexturePool = exports('J', /*#__PURE__*/function () {
              _createClass(JointTexturePool, [{
                key: "pixelsPerJoint",
                // per skeleton per clip
                // hash -> chunkIdx
                get: function get() {
                  return this._pixelsPerJoint;
                }
              }]);

              function JointTexturePool(device) {
                _classCallCheck(this, JointTexturePool);

                this._device = void 0;
                this._pool = void 0;
                this._textureBuffers = new Map();
                this._formatSize = void 0;
                this._pixelsPerJoint = void 0;
                this._customPool = void 0;
                this._chunkIdxMap = new Map();
                this._device = device;
                var format = selectJointsMediumFormat(this._device);
                this._formatSize = GFXFormatInfos[format].size;
                this._pixelsPerJoint = 48 / this._formatSize;
                this._pool = new TextureBufferPool(device);

                this._pool.initialize({
                  format: format,
                  roundUpFn: roundUpTextureSize
                });

                this._customPool = new TextureBufferPool(device);

                this._customPool.initialize({
                  format: format,
                  roundUpFn: roundUpTextureSize
                });
              }

              _createClass(JointTexturePool, [{
                key: "clear",
                value: function clear() {
                  this._pool.destroy();

                  this._textureBuffers.clear();
                }
              }, {
                key: "registerCustomTextureLayouts",
                value: function registerCustomTextureLayouts(layouts) {
                  for (var i = 0; i < layouts.length; i++) {
                    var layout = layouts[i];

                    var chunkIdx = this._customPool.createChunk(layout.textureLength);

                    for (var j = 0; j < layout.contents.length; j++) {
                      var content = layout.contents[j];
                      var skeleton = content.skeleton;

                      this._chunkIdxMap.set(skeleton, chunkIdx); // include default pose too


                      for (var k = 0; k < content.clips.length; k++) {
                        var clip = content.clips[k];

                        this._chunkIdxMap.set(skeleton ^ clip, chunkIdx);
                      }
                    }
                  }
                }
                /**
                 * @en
                 * Get joint texture for the default pose.
                 * @zh
                 * 获取默认姿势的骨骼贴图。
                 */

              }, {
                key: "getDefaultPoseTexture",
                value: function getDefaultPoseTexture(skeleton, mesh, skinningRoot) {
                  var hash = skeleton.hash ^ 0; // may not equal to skeleton.hash

                  var texture = this._textureBuffers.get(hash) || null;

                  if (texture && texture.bounds.has(mesh.hash)) {
                    texture.refCount++;
                    return texture;
                  }

                  var joints = skeleton.joints,
                      bindposes = skeleton.bindposes;
                  var textureBuffer = null;
                  var buildTexture = false;
                  var jointCount = joints.length;

                  if (!texture) {
                    var bufSize = jointCount * 12;

                    var customChunkIdx = this._chunkIdxMap.get(hash);

                    var handle = customChunkIdx !== undefined ? this._customPool.alloc(bufSize * Float32Array.BYTES_PER_ELEMENT, customChunkIdx) : this._pool.alloc(bufSize * Float32Array.BYTES_PER_ELEMENT);

                    if (!handle) {
                      return texture;
                    }

                    texture = {
                      pixelOffset: handle.start / this._formatSize,
                      refCount: 1,
                      bounds: new Map(),
                      skeletonHash: skeleton.hash,
                      clipHash: 0,
                      readyToBeDeleted: false,
                      handle: handle
                    };
                    textureBuffer = new Float32Array(bufSize);
                    buildTexture = true;
                  } else {
                    texture.refCount++;
                  }

                  Vec3.set(v3_min, Inf, Inf, Inf);
                  Vec3.set(v3_max, -Inf, -Inf, -Inf);
                  var boneSpaceBounds = mesh.getBoneSpaceBounds(skeleton);

                  for (var j = 0, offset = 0; j < jointCount; j++, offset += 12) {
                    var node = skinningRoot.getChildByPath(joints[j]);
                    var mat = node ? getWorldTransformUntilRoot(node, skinningRoot, m4_1$2) : skeleton.inverseBindposes[j];
                    var bound = boneSpaceBounds[j];

                    if (bound) {
                      aabb.transform(ab_1, bound, mat);
                      ab_1.getBoundary(v3_3, v3_4);
                      Vec3.min(v3_min, v3_min, v3_3);
                      Vec3.max(v3_max, v3_max, v3_4);
                    }

                    if (buildTexture) {
                      if (node) {
                        Mat4.multiply(mat, mat, bindposes[j]);
                      }

                      uploadJointData(textureBuffer, offset, node ? mat : Mat4.IDENTITY);
                    }
                  }

                  var bounds = [new aabb()];
                  texture.bounds.set(mesh.hash, bounds);
                  aabb.fromPoints(bounds[0], v3_min, v3_max);

                  if (buildTexture) {
                    this._pool.update(texture.handle, textureBuffer.buffer);

                    this._textureBuffers.set(hash, texture);
                  }

                  return texture;
                }
                /**
                 * @en
                 * Get joint texture for the specified animation clip.
                 * @zh
                 * 获取指定动画片段的骨骼贴图。
                 */

              }, {
                key: "getSequencePoseTexture",
                value: function getSequencePoseTexture(skeleton, clip, mesh, skinningRoot) {
                  var hash = skeleton.hash ^ clip.hash;
                  var texture = this._textureBuffers.get(hash) || null;

                  if (texture && texture.bounds.has(mesh.hash)) {
                    texture.refCount++;
                    return texture;
                  }

                  var joints = skeleton.joints,
                      bindposes = skeleton.bindposes;
                  var clipData = SkelAnimDataHub.getOrExtract(clip);
                  var frames = clipData.info.frames;
                  var textureBuffer = null;
                  var buildTexture = false;
                  var jointCount = joints.length;

                  if (!texture) {
                    var bufSize = jointCount * 12 * frames;

                    var customChunkIdx = this._chunkIdxMap.get(hash);

                    var handle = customChunkIdx !== undefined ? this._customPool.alloc(bufSize * Float32Array.BYTES_PER_ELEMENT, customChunkIdx) : this._pool.alloc(bufSize * Float32Array.BYTES_PER_ELEMENT);

                    if (!handle) {
                      return null;
                    }

                    var animInfos = this._createAnimInfos(skeleton, clip, skinningRoot);

                    texture = {
                      pixelOffset: handle.start / this._formatSize,
                      refCount: 1,
                      bounds: new Map(),
                      skeletonHash: skeleton.hash,
                      clipHash: clip.hash,
                      readyToBeDeleted: false,
                      handle: handle,
                      animInfos: animInfos
                    };
                    textureBuffer = new Float32Array(bufSize);
                    buildTexture = true;
                  } else {
                    texture.refCount++;
                  }

                  var boneSpaceBounds = mesh.getBoneSpaceBounds(skeleton);
                  var bounds = [];
                  texture.bounds.set(mesh.hash, bounds);

                  for (var f = 0; f < frames; f++) {
                    bounds.push(new aabb(Inf, Inf, Inf, -Inf, -Inf, -Inf));
                  }

                  for (var _f = 0, offset = 0; _f < frames; _f++) {
                    var bound = bounds[_f];

                    for (var j = 0; j < jointCount; j++, offset += 12) {
                      var _j = texture.animInfos[j],
                          curveData = _j.curveData,
                          downstream = _j.downstream,
                          bindposeIdx = _j.bindposeIdx,
                          bindposeCorrection = _j.bindposeCorrection;
                      var mat = void 0;
                      var transformValid = true;

                      if (curveData && downstream) {
                        // curve & static two-way combination
                        mat = Mat4.multiply(m4_1$2, curveData[_f], downstream);
                      } else if (curveData) {
                        // there is a curve directly controlling the joint
                        mat = curveData[_f];
                      } else if (downstream) {
                        // fallback to default pose if no animation curve can be found upstream
                        mat = downstream;
                      } else {
                        // bottom line: render the original mesh as-is
                        mat = skeleton.inverseBindposes[bindposeIdx];
                        transformValid = false;
                      }

                      var boneSpaceBound = boneSpaceBounds[j];

                      if (boneSpaceBound) {
                        var transform = bindposeCorrection ? Mat4.multiply(m4_2, mat, bindposeCorrection) : mat;
                        aabb.transform(ab_1, boneSpaceBound, transform);
                        ab_1.getBoundary(v3_3, v3_4);
                        Vec3.min(bound.center, bound.center, v3_3);
                        Vec3.max(bound.halfExtents, bound.halfExtents, v3_4);
                      }

                      if (buildTexture) {
                        if (transformValid) {
                          Mat4.multiply(m4_1$2, mat, bindposes[bindposeIdx]);
                        }

                        uploadJointData(textureBuffer, offset, transformValid ? m4_1$2 : Mat4.IDENTITY);
                      }
                    }

                    aabb.fromPoints(bound, bound.center, bound.halfExtents);
                  }

                  if (buildTexture) {
                    this._pool.update(texture.handle, textureBuffer.buffer);

                    this._textureBuffers.set(hash, texture);
                  }

                  return texture;
                }
              }, {
                key: "releaseHandle",
                value: function releaseHandle(handle) {
                  if (handle.refCount > 0) {
                    handle.refCount--;
                  }

                  if (!handle.refCount && handle.readyToBeDeleted) {
                    var hash = handle.skeletonHash ^ handle.clipHash;

                    var customChunkIdx = this._chunkIdxMap.get(hash);

                    (customChunkIdx !== undefined ? this._customPool : this._pool).free(handle.handle);

                    if (this._textureBuffers.get(hash) === handle) {
                      this._textureBuffers["delete"](hash);
                    }
                  }
                }
              }, {
                key: "releaseSkeleton",
                value: function releaseSkeleton(skeleton) {
                  var it = this._textureBuffers.values();

                  var res = it.next();

                  while (!res.done) {
                    var handle = res.value;

                    if (handle.skeletonHash === skeleton.hash) {
                      handle.readyToBeDeleted = true;

                      if (handle.refCount) {
                        // delete handle record immediately so new allocations with the same asset could work
                        this._textureBuffers["delete"](handle.skeletonHash ^ handle.clipHash);
                      } else {
                        this.releaseHandle(handle);
                      }
                    }

                    res = it.next();
                  }
                }
              }, {
                key: "releaseAnimationClip",
                value: function releaseAnimationClip(clip) {
                  var it = this._textureBuffers.values();

                  var res = it.next();

                  while (!res.done) {
                    var handle = res.value;

                    if (handle.clipHash === clip.hash) {
                      handle.readyToBeDeleted = true;

                      if (handle.refCount) {
                        // delete handle record immediately so new allocations with the same asset could work
                        this._textureBuffers["delete"](handle.skeletonHash ^ handle.clipHash);
                      } else {
                        this.releaseHandle(handle);
                      }
                    }

                    res = it.next();
                  }
                }
              }, {
                key: "_createAnimInfos",
                value: function _createAnimInfos(skeleton, clip, skinningRoot) {
                  var animInfos = [];
                  var joints = skeleton.joints,
                      bindposes = skeleton.bindposes;
                  var jointCount = joints.length;
                  var clipData = SkelAnimDataHub.getOrExtract(clip);

                  for (var j = 0; j < jointCount; j++) {
                    var animPath = joints[j];
                    var source = clipData.data[animPath];
                    var animNode = skinningRoot.getChildByPath(animPath);
                    var downstream = void 0;
                    var correctionPath = void 0;

                    while (!source) {
                      var idx = animPath.lastIndexOf('/');
                      animPath = animPath.substring(0, idx);
                      source = clipData.data[animPath];

                      if (animNode) {
                        if (!downstream) {
                          downstream = new Mat4();
                        }

                        Mat4.fromRTS(m4_1$2, animNode.rotation, animNode.position, animNode.scale);
                        Mat4.multiply(downstream, m4_1$2, downstream);
                        animNode = animNode.parent;
                      } else {
                        // record the nearest curve path if no downstream pose is present
                        correctionPath = animPath;
                      }

                      if (idx < 0) {
                        break;
                      }
                    } // the default behavior, just use the bindpose for current joint directly


                    var bindposeIdx = j;
                    var bindposeCorrection = void 0;
                    /**
                     * It is regularly observed that developers may choose to delete the whole
                     * skeleton node tree for skinning models that only use baked animations,
                     * to reduce prefab file size.
                     *
                     * This becomes troublesome in some cases during baking though, e.g. when a
                     * skeleton joint node is not directly controlled by any animation curve,
                     * but its parent nodes are. Due to lack of proper downstream default pose,
                     * the joint transform can not be calculated accurately.
                     *
                     * We address this issue by employing some pragmatic approximation.
                     * Specifically, by multiplying the bindpose of the joint corresponding to
                     * the nearest curve, instead of the actual target joint. This effectively
                     * merges the skinning influence of the 'incomplete' joint into its nearest
                     * parent with accurate transform data.
                     * It gives more visually-plausible results compared to the naive approach
                     * for most cases we've covered.
                     */

                    if (correctionPath !== undefined && source) {
                      // just use the previous joint if the exact path is not found
                      bindposeIdx = j - 1;

                      for (var t = 0; t < jointCount; t++) {
                        if (joints[t] === correctionPath) {
                          bindposeIdx = t;
                          bindposeCorrection = new Mat4();
                          Mat4.multiply(bindposeCorrection, bindposes[t], skeleton.inverseBindposes[j]);
                          break;
                        }
                      }
                    }

                    animInfos.push({
                      curveData: source && source.worldMatrix.values,
                      downstream: downstream,
                      bindposeIdx: bindposeIdx,
                      bindposeCorrection: bindposeCorrection
                    });
                  }

                  return animInfos;
                }
              }]);

              return JointTexturePool;
            }());
            var JointAnimationInfo = exports('n', /*#__PURE__*/function () {
              // per node
              function JointAnimationInfo(device) {
                _classCallCheck(this, JointAnimationInfo);

                this._pool = new Map();
                this._device = void 0;
                this._device = device;
              }

              _createClass(JointAnimationInfo, [{
                key: "getData",
                value: function getData() {
                  var nodeID = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '-1';

                  var res = this._pool.get(nodeID);

                  if (res) {
                    return res;
                  }

                  var buffer = this._device.createBuffer({
                    usage: GFXBufferUsageBit.UNIFORM | GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                    size: UBOSkinningAnimation.SIZE,
                    stride: UBOSkinningAnimation.SIZE
                  });

                  var data = new Float32Array([0, 0, 0, 0]);
                  buffer.update(data);
                  var info = {
                    buffer: buffer,
                    data: data,
                    dirty: false
                  };

                  this._pool.set(nodeID, info);

                  return info;
                }
              }, {
                key: "destroy",
                value: function destroy(nodeID) {
                  var info = this._pool.get(nodeID);

                  if (!info) {
                    return;
                  }

                  info.buffer.destroy();

                  this._pool["delete"](nodeID);
                }
              }, {
                key: "switchClip",
                value: function switchClip(info, clip) {
                  info.data[0] = 0;
                  info.buffer.update(info.data);
                  info.dirty = false;
                  return info;
                }
              }, {
                key: "clear",
                value: function clear() {
                  for (var _iterator = _createForOfIteratorHelperLoose(this._pool.values()), _step; !(_step = _iterator()).done;) {
                    var info = _step.value;
                    info.buffer.destroy();
                  }

                  this._pool.clear();
                }
              }]);

              return JointAnimationInfo;
            }());

            var _dsInfo$1 = {
              layout: null
            };
            var SubModel = exports('a2', /*#__PURE__*/function () {
              function SubModel() {
                _classCallCheck(this, SubModel);

                this._device = null;
                this._passes = null;
                this._subMesh = null;
                this._patches = null;
                this._handle = NULL_HANDLE;
                this._priority = RenderPriority.DEFAULT;
                this._inputAssembler = null;
                this._descriptorSet = null;
              }

              _createClass(SubModel, [{
                key: "initialize",
                value: function initialize(subMesh, passes) {
                  var patches = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
                  this._device = legacyCC.director.root.device;
                  this._subMesh = subMesh;
                  this._patches = patches;
                  this._passes = passes;
                  this._handle = SubModelPool.alloc();

                  this._flushPassInfo();

                  _dsInfo$1.layout = passes[0].setLayouts[SetIndex.LOCAL];
                  var dsHandle = DSPool.alloc(this._device, _dsInfo$1);
                  var iaHandle = IAPool.alloc(this._device, subMesh);
                  SubModelPool.set(this._handle, SubModelView.PRIORITY, RenderPriority.DEFAULT);
                  SubModelPool.set(this._handle, SubModelView.INPUT_ASSEMBLER, iaHandle);
                  SubModelPool.set(this._handle, SubModelView.DESCRIPTOR_SET, dsHandle);
                  this._inputAssembler = IAPool.get(iaHandle);
                  this._descriptorSet = DSPool.get(dsHandle);
                }
              }, {
                key: "destroy",
                value: function destroy() {
                  DSPool.free(SubModelPool.get(this._handle, SubModelView.DESCRIPTOR_SET));
                  IAPool.free(SubModelPool.get(this._handle, SubModelView.INPUT_ASSEMBLER));
                  SubModelPool.free(this._handle);
                  this._descriptorSet = null;
                  this._inputAssembler = null;
                  this._priority = RenderPriority.DEFAULT;
                  this._handle = NULL_HANDLE;
                  this._patches = null;
                  this._subMesh = null;
                  this._passes = null;
                }
              }, {
                key: "update",
                value: function update() {
                  for (var i = 0; i < this._passes.length; ++i) {
                    var pass = this._passes[i];
                    pass.update();
                  }

                  this._descriptorSet.update();
                }
              }, {
                key: "onPipelineStateChanged",
                value: function onPipelineStateChanged() {
                  var passes = this._passes;

                  if (!passes) {
                    return;
                  }

                  for (var i = 0; i < passes.length; i++) {
                    var pass = passes[i];
                    pass.beginChangeStatesSilently();
                    pass.tryCompile(); // force update shaders

                    pass.endChangeStatesSilently();
                  }

                  this._flushPassInfo();
                }
              }, {
                key: "onMacroPatchesStateChanged",
                value: function onMacroPatchesStateChanged(patches) {
                  this._patches = patches;
                  var passes = this._passes;

                  if (!passes) {
                    return;
                  }

                  for (var i = 0; i < passes.length; i++) {
                    var pass = passes[i];
                    pass.beginChangeStatesSilently();
                    pass.tryCompile(); // force update shaders

                    pass.endChangeStatesSilently();
                  }

                  this._flushPassInfo();
                }
              }, {
                key: "_flushPassInfo",
                value: function _flushPassInfo() {
                  var passes = this._passes;

                  if (!passes) {
                    return;
                  }

                  SubModelPool.set(this._handle, SubModelView.PASS_COUNT, passes.length);

                  for (var i = 0; i < passes.length; i++) {
                    SubModelPool.set(this._handle, SubModelView.PASS_0 + i, passes[i].handle);
                    SubModelPool.set(this._handle, SubModelView.SHADER_0 + i, passes[i].getShaderVariant(this._patches));
                  }
                }
              }, {
                key: "passes",
                set: function set(passes) {
                  this._passes = passes;

                  this._flushPassInfo();
                },
                get: function get() {
                  return this._passes;
                }
              }, {
                key: "subMesh",
                set: function set(subMesh) {
                  this._subMesh = subMesh;

                  this._inputAssembler.destroy();

                  this._inputAssembler.initialize(subMesh);
                },
                get: function get() {
                  return this._subMesh;
                }
              }, {
                key: "priority",
                set: function set(val) {
                  this._priority = val;
                  SubModelPool.set(this._handle, SubModelView.PRIORITY, val);
                },
                get: function get() {
                  return this._priority;
                }
              }, {
                key: "handle",
                get: function get() {
                  return this._handle;
                }
              }, {
                key: "inputAssembler",
                get: function get() {
                  return this._inputAssembler;
                }
              }, {
                key: "descriptorSet",
                get: function get() {
                  return this._descriptorSet;
                }
              }]);

              return SubModel;
            }());

            var INITIAL_CAPACITY = 32;
            var MAX_CAPACITY = 1024;
            var InstancedBuffer = /*#__PURE__*/function () {
              _createClass(InstancedBuffer, null, [{
                key: "get",
                value: function get(pass) {
                  var extraKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                  var buffers = InstancedBuffer._buffers;
                  if (!buffers.has(pass)) buffers.set(pass, {});
                  var record = buffers.get(pass);
                  return record[extraKey] || (record[extraKey] = new InstancedBuffer(pass));
                }
              }]);

              function InstancedBuffer(pass) {
                _classCallCheck(this, InstancedBuffer);

                this.instances = [];
                this.hPass = NULL_HANDLE;
                this.hasPendingModels = false;
                this.dynamicOffsets = [];
                this._device = void 0;
                this._device = pass.device;
                this.hPass = pass.handle;
              }

              _createClass(InstancedBuffer, [{
                key: "destroy",
                value: function destroy() {
                  for (var i = 0; i < this.instances.length; ++i) {
                    var instance = this.instances[i];
                    instance.vb.destroy();
                    instance.ia.destroy();
                  }

                  this.instances.length = 0;
                }
              }, {
                key: "merge",
                value: function merge(subModel, attrs, passIdx) {
                  var hShaderImplant = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
                  var stride = attrs.buffer.length;

                  if (!stride) {
                    return;
                  } // we assume per-instance attributes are always present


                  var sourceIA = subModel.inputAssembler;
                  var lightingMap = subModel.descriptorSet.getTexture(UniformLightingMapSampler.binding);
                  var hShader = hShaderImplant || SubModelPool.get(subModel.handle, SubModelView.SHADER_0 + passIdx);
                  var hDescriptorSet = SubModelPool.get(subModel.handle, SubModelView.DESCRIPTOR_SET);

                  for (var i = 0; i < this.instances.length; ++i) {
                    var instance = this.instances[i];

                    if (instance.ia.indexBuffer !== sourceIA.indexBuffer || instance.count >= MAX_CAPACITY) {
                      continue;
                    } // check same binding


                    if (instance.lightingMap !== lightingMap) {
                      continue;
                    }

                    if (instance.stride !== stride) {
                      // console.error(`instanced buffer stride mismatch! ${stride}/${instance.stride}`);
                      return;
                    }

                    if (instance.count >= instance.capacity) {
                      // resize buffers
                      instance.capacity <<= 1;
                      var newSize = instance.stride * instance.capacity;
                      var oldData = instance.data;
                      instance.data = new Uint8Array(newSize);
                      instance.data.set(oldData);
                      instance.vb.resize(newSize);
                    }

                    if (instance.hShader !== hShader) {
                      instance.hShader = hShader;
                    }

                    if (instance.hDescriptorSet !== hDescriptorSet) {
                      instance.hDescriptorSet = hDescriptorSet;
                    }

                    instance.data.set(attrs.buffer, instance.stride * instance.count++);
                    this.hasPendingModels = true;
                    return;
                  } // Create a new instance


                  var vb = this._device.createBuffer({
                    usage: GFXBufferUsageBit.VERTEX | GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                    size: stride * INITIAL_CAPACITY,
                    stride: stride
                  });

                  var data = new Uint8Array(stride * INITIAL_CAPACITY);
                  var vertexBuffers = sourceIA.vertexBuffers.slice();
                  var attributes = sourceIA.attributes.slice();
                  var indexBuffer = sourceIA.indexBuffer || undefined;

                  for (var _i = 0; _i < attrs.list.length; _i++) {
                    var attr = attrs.list[_i];
                    var newAttr = {
                      name: attr.name,
                      format: attr.format,
                      stream: vertexBuffers.length,
                      isInstanced: true
                    };

                    if (attr.isNormalized !== undefined) {
                      newAttr.isNormalized = attr.isNormalized;
                    }

                    attributes.push(newAttr);
                  }

                  data.set(attrs.buffer);
                  vertexBuffers.push(vb);

                  var ia = this._device.createInputAssembler({
                    attributes: attributes,
                    vertexBuffers: vertexBuffers,
                    indexBuffer: indexBuffer
                  });

                  this.instances.push({
                    count: 1,
                    capacity: INITIAL_CAPACITY,
                    vb: vb,
                    data: data,
                    ia: ia,
                    stride: stride,
                    hShader: hShader,
                    hDescriptorSet: hDescriptorSet,
                    lightingMap: lightingMap
                  });
                  this.hasPendingModels = true;
                }
              }, {
                key: "uploadBuffers",
                value: function uploadBuffers() {
                  for (var i = 0; i < this.instances.length; ++i) {
                    var instance = this.instances[i];

                    if (!instance.count) {
                      continue;
                    }

                    instance.ia.instanceCount = instance.count;
                    instance.vb.update(instance.data);
                  }
                }
              }, {
                key: "clear",
                value: function clear() {
                  for (var i = 0; i < this.instances.length; ++i) {
                    var instance = this.instances[i];
                    instance.count = 0;
                  }

                  this.hasPendingModels = false;
                }
              }]);

              return InstancedBuffer;
            }();
            InstancedBuffer._buffers = new Map();

            var m4_1$3 = new Mat4();

            var _subModelPool = new Pool(function () {
              return new SubModel();
            }, 32);

            var shadowMapPatches = [{
              name: 'CC_RECEIVE_SHADOW',
              value: true
            }];
            var ModelType;

            (function (ModelType) {
              ModelType[ModelType["DEFAULT"] = 0] = "DEFAULT";
              ModelType[ModelType["SKINNING"] = 1] = "SKINNING";
              ModelType[ModelType["BAKED_SKINNING"] = 2] = "BAKED_SKINNING";
              ModelType[ModelType["UI_BATCH"] = 3] = "UI_BATCH";
              ModelType[ModelType["PARTICLE_BATCH"] = 4] = "PARTICLE_BATCH";
              ModelType[ModelType["LINE"] = 5] = "LINE";
            })(ModelType || (ModelType = exports('U', {})));

            function uploadMat4AsVec4x3(mat, v1, v2, v3) {
              v1[0] = mat.m00;
              v1[1] = mat.m01;
              v1[2] = mat.m02;
              v1[3] = mat.m12;
              v2[0] = mat.m04;
              v2[1] = mat.m05;
              v2[2] = mat.m06;
              v2[3] = mat.m13;
              v3[0] = mat.m08;
              v3[1] = mat.m09;
              v3[2] = mat.m10;
              v3[3] = mat.m14;
            }

            var lightmapSamplerHash = genSamplerHash([GFXFilter.LINEAR, GFXFilter.LINEAR, GFXFilter.NONE, GFXAddress.CLAMP, GFXAddress.CLAMP, GFXAddress.CLAMP]);
            var lightmapSamplerWithMipHash = genSamplerHash([GFXFilter.LINEAR, GFXFilter.LINEAR, GFXFilter.LINEAR, GFXAddress.CLAMP, GFXAddress.CLAMP, GFXAddress.CLAMP]);
            /**
             * A representation of a model
             */

            var Model = exports('W', /*#__PURE__*/function () {
              _createClass(Model, [{
                key: "subModels",
                get: function get() {
                  return this._subModels;
                }
              }, {
                key: "inited",
                get: function get() {
                  return this._inited;
                }
              }, {
                key: "worldBounds",
                get: function get() {
                  return this._worldBounds;
                }
              }, {
                key: "modelBounds",
                get: function get() {
                  return this._modelBounds;
                }
              }, {
                key: "localBuffer",
                get: function get() {
                  return this._localBuffer;
                }
              }, {
                key: "updateStamp",
                get: function get() {
                  return this._updateStamp;
                }
              }, {
                key: "isInstancingEnabled",
                get: function get() {
                  return this._instMatWorldIdx >= 0;
                }
              }, {
                key: "receiveShadow",
                get: function get() {
                  return this._receiveShadow;
                },
                set: function set(val) {
                  this._receiveShadow = val;
                  this.onMacroPatchesStateChanged();
                }
              }]);

              /**
               * Setup a default empty model
               */
              function Model() {
                _classCallCheck(this, Model);

                this.type = ModelType.DEFAULT;
                this.scene = null;
                this.node = null;
                this.transform = null;
                this.enabled = true;
                this.visFlags = Layers.Enum.NONE;
                this.castShadow = false;
                this.isDynamicBatching = false;
                this.instancedAttributes = {
                  buffer: null,
                  list: []
                };
                this._worldBounds = null;
                this._modelBounds = null;
                this._subModels = [];
                this._device = void 0;
                this._inited = false;
                this._descriptorSetCount = 1;
                this._updateStamp = -1;
                this._transformUpdated = true;
                this._localData = new Float32Array(UBOLocal.COUNT);
                this._localBuffer = null;
                this._instMatWorldIdx = -1;
                this._lightmap = null;
                this._lightmapUVParam = new Vec4();
                this._receiveShadow = true;
                this._device = legacyCC.director.root.device;
              }

              _createClass(Model, [{
                key: "initialize",
                value: function initialize(node) {
                  this.transform = this.node = node;
                  this._receiveShadow = true;
                  this.castShadow = false;
                }
              }, {
                key: "destroy",
                value: function destroy() {
                  var subModels = this._subModels;

                  for (var i = 0; i < subModels.length; i++) {
                    var subModel = this._subModels[i];
                    subModel.destroy();

                    _subModelPool.free(subModel);
                  }

                  if (this._localBuffer) {
                    this._localBuffer.destroy();

                    this._localBuffer = null;
                  }

                  this._worldBounds = null;
                  this._modelBounds = null;
                  this._subModels.length = 0;
                  this._inited = false;
                  this._transformUpdated = true;
                  this.isDynamicBatching = false;
                }
              }, {
                key: "attachToScene",
                value: function attachToScene(scene) {
                  this.scene = scene;
                }
              }, {
                key: "detachFromScene",
                value: function detachFromScene() {
                  this.scene = null;
                }
              }, {
                key: "updateTransform",
                value: function updateTransform(stamp) {
                  var node = this.transform; // @ts-ignore TS2445

                  if (node.hasChangedFlags || node._dirtyFlags) {
                    node.updateWorldTransform();
                    this._transformUpdated = true;

                    if (this._modelBounds && this._worldBounds) {
                      // @ts-ignore TS2445
                      this._modelBounds.transform(node._mat, node._pos, node._rot, node._scale, this._worldBounds);
                    }
                  }
                }
              }, {
                key: "updateUBOs",
                value: function updateUBOs(stamp) {
                  var subModels = this._subModels;

                  for (var i = 0; i < subModels.length; i++) {
                    subModels[i].update();
                  }

                  this._updateStamp = stamp;

                  if (!this._transformUpdated) {
                    return;
                  }

                  this._transformUpdated = false; // @ts-ignore

                  var worldMatrix = this.transform._mat;
                  var idx = this._instMatWorldIdx;

                  if (idx >= 0) {
                    var attrs = this.instancedAttributes.list;
                    uploadMat4AsVec4x3(worldMatrix, attrs[idx].view, attrs[idx + 1].view, attrs[idx + 2].view);
                  } else {
                    Mat4.toArray(this._localData, worldMatrix, UBOLocal.MAT_WORLD_OFFSET);
                    Mat4.inverseTranspose(m4_1$3, worldMatrix);
                    Mat4.toArray(this._localData, m4_1$3, UBOLocal.MAT_WORLD_IT_OFFSET);

                    this._localBuffer.update(this._localData);
                  }
                }
                /**
                 * Create the bounding shape of this model
                 * @param minPos the min position of the model
                 * @param maxPos the max position of the model
                 */

              }, {
                key: "createBoundingShape",
                value: function createBoundingShape(minPos, maxPos) {
                  if (!minPos || !maxPos) {
                    return;
                  }

                  this._modelBounds = aabb.fromPoints(aabb.create(), minPos, maxPos);
                  this._worldBounds = aabb.clone(this._modelBounds);
                }
              }, {
                key: "initSubModel",
                value: function initSubModel(idx, subMeshData, mat) {
                  if (this._subModels[idx] == null) {
                    this._subModels[idx] = _subModelPool.alloc();
                  } else {
                    this._subModels[idx].destroy();
                  }

                  this._subModels[idx].initialize(subMeshData, mat.passes, this.getMacroPatches(idx));

                  this._updateAttributesAndBinding(idx);

                  this._inited = true;
                }
              }, {
                key: "setSubModelMesh",
                value: function setSubModelMesh(idx, subMesh) {
                  if (!this._subModels[idx]) {
                    return;
                  }

                  this._subModels[idx].subMesh = subMesh;
                }
              }, {
                key: "setSubModelMaterial",
                value: function setSubModelMaterial(idx, mat) {
                  if (!this._subModels[idx]) {
                    return;
                  }

                  this._subModels[idx].passes = mat.passes;

                  this._updateAttributesAndBinding(idx);
                }
              }, {
                key: "onGlobalPipelineStateChanged",
                value: function onGlobalPipelineStateChanged() {
                  var subModels = this._subModels;

                  for (var i = 0; i < subModels.length; i++) {
                    subModels[i].onPipelineStateChanged();
                  }
                }
              }, {
                key: "onMacroPatchesStateChanged",
                value: function onMacroPatchesStateChanged() {
                  var subModels = this._subModels;

                  for (var i = 0; i < subModels.length; i++) {
                    subModels[i].onMacroPatchesStateChanged(this.getMacroPatches(i));
                  }
                }
              }, {
                key: "updateLightingmap",
                value: function updateLightingmap(texture, uvParam) {
                  Vec4.toArray(this._localData, uvParam, UBOLocal.LIGHTINGMAP_UVPARAM);
                  this._lightmap = texture;
                  this._lightmapUVParam = uvParam;

                  if (texture === null) {
                    texture = builtinResMgr.get('empty-texture');
                  }

                  var gfxTexture = texture.getGFXTexture();

                  if (gfxTexture !== null) {
                    var sampler = samplerLib.getSampler(this._device, texture.mipmaps.length > 1 ? lightmapSamplerWithMipHash : lightmapSamplerHash);
                    var subModels = this._subModels;

                    for (var i = 0; i < subModels.length; i++) {
                      var descriptorSet = subModels[i].descriptorSet;
                      descriptorSet.bindTexture(UniformLightingMapSampler.binding, gfxTexture);
                      descriptorSet.bindSampler(UniformLightingMapSampler.binding, sampler);
                      descriptorSet.update();
                    }
                  }
                }
              }, {
                key: "getMacroPatches",
                value: function getMacroPatches(subModelIndex) {
                  return this.receiveShadow ? shadowMapPatches : null;
                }
              }, {
                key: "_updateAttributesAndBinding",
                value: function _updateAttributesAndBinding(subModelIndex) {
                  var subModel = this._subModels[subModelIndex];

                  if (!subModel) {
                    return;
                  }

                  this._initLocalDescriptors(subModelIndex);

                  this._updateLocalDescriptors(subModelIndex, subModel.descriptorSet);

                  var shader = ShaderPool.get(SubModelPool.get(subModel.handle, SubModelView.SHADER_0));

                  this._updateInstancedAttributes(shader.attributes, subModel.passes[0]);
                }
              }, {
                key: "_getInstancedAttributeIndex",
                value: function _getInstancedAttributeIndex(name) {
                  var list = this.instancedAttributes.list;

                  for (var i = 0; i < list.length; i++) {
                    if (list[i].name === name) {
                      return i;
                    }
                  }

                  return -1;
                } // sub-classes can override the following functions if needed
                // for now no submodel level instancing attributes

              }, {
                key: "_updateInstancedAttributes",
                value: function _updateInstancedAttributes(attributes, pass) {
                  if (!pass.device.hasFeature(GFXFeature.INSTANCED_ARRAYS)) {
                    return;
                  }

                  var size = 0;

                  for (var j = 0; j < attributes.length; j++) {
                    var attribute = attributes[j];

                    if (!attribute.isInstanced) {
                      continue;
                    }

                    size += GFXFormatInfos[attribute.format].size;
                  }

                  var attrs = this.instancedAttributes;
                  attrs.buffer = new Uint8Array(size);
                  attrs.list.length = 0;
                  var offset = 0;
                  var buffer = attrs.buffer.buffer;

                  for (var _j = 0; _j < attributes.length; _j++) {
                    var _attribute = attributes[_j];

                    if (!_attribute.isInstanced) {
                      continue;
                    }

                    var format = _attribute.format;
                    var info = GFXFormatInfos[format];
                    var view = new (getTypedArrayConstructor(info))(buffer, offset, info.count);
                    var isNormalized = _attribute.isNormalized;
                    offset += info.size;
                    attrs.list.push({
                      name: _attribute.name,
                      format: format,
                      isNormalized: isNormalized,
                      view: view
                    });
                  }

                  if (pass.batchingScheme === BatchingSchemes.INSTANCING) {
                    InstancedBuffer.get(pass).destroy();
                  } // instancing IA changed


                  this._instMatWorldIdx = this._getInstancedAttributeIndex(INST_MAT_WORLD);
                  this._transformUpdated = true;
                }
              }, {
                key: "_initLocalDescriptors",
                value: function _initLocalDescriptors(subModelIndex) {
                  if (!this._localBuffer) {
                    this._localBuffer = this._device.createBuffer({
                      usage: GFXBufferUsageBit.UNIFORM | GFXBufferUsageBit.TRANSFER_DST,
                      memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                      size: UBOLocal.SIZE,
                      stride: UBOLocal.SIZE
                    });
                  }
                }
              }, {
                key: "_updateLocalDescriptors",
                value: function _updateLocalDescriptors(submodelIdx, descriptorSet) {
                  descriptorSet.bindBuffer(UBOLocal.BLOCK.binding, this._localBuffer);
                }
              }]);

              return Model;
            }());

            var MorphModel = exports('r', /*#__PURE__*/function (_Model) {
              _inherits(MorphModel, _Model);

              function MorphModel() {
                var _getPrototypeOf2;

                var _this;

                _classCallCheck(this, MorphModel);

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(MorphModel)).call.apply(_getPrototypeOf2, [this].concat(args)));
                _this._morphRenderingInstance = null;
                _this._usedMaterials = new Set();
                return _this;
              }

              _createClass(MorphModel, [{
                key: "getMacroPatches",
                value: function getMacroPatches(subModelIndex) {
                  if (this._morphRenderingInstance) {
                    return this._morphRenderingInstance.requiredPatches(subModelIndex);
                  } else {
                    return undefined;
                  }
                }
              }, {
                key: "initSubModel",
                value: function initSubModel(subModelIndex, subMeshData, material) {
                  return _get(_getPrototypeOf(MorphModel.prototype), "initSubModel", this).call(this, subModelIndex, subMeshData, this._launderMaterial(material));
                }
              }, {
                key: "setSubModelMaterial",
                value: function setSubModelMaterial(subModelIndex, material) {
                  return _get(_getPrototypeOf(MorphModel.prototype), "setSubModelMaterial", this).call(this, subModelIndex, this._launderMaterial(material));
                }
              }, {
                key: "_updateLocalDescriptors",
                value: function _updateLocalDescriptors(submodelIdx, descriptorSet) {
                  _get(_getPrototypeOf(MorphModel.prototype), "_updateLocalDescriptors", this).call(this, submodelIdx, descriptorSet);

                  if (this._morphRenderingInstance) {
                    this._morphRenderingInstance.adaptPipelineState(submodelIdx, descriptorSet);
                  }
                }
              }, {
                key: "_launderMaterial",
                value: function _launderMaterial(material) {
                  return material; // if (this._usedMaterials.has(material)) {
                  //     return new MaterialInstance({
                  //         parent: material,
                  //     });
                  // } else {
                  //     this._usedMaterials.add(material);
                  //     return material;
                  // }
                }
              }, {
                key: "setMorphRendering",
                value: function setMorphRendering(morphRendering) {
                  this._morphRenderingInstance = morphRendering;
                }
              }]);

              return MorphModel;
            }(Model));

            var stack = [];
            var pool = new Map();
            var myPatches = [{
              name: 'CC_USE_SKINNING',
              value: true
            }];
            function getWorldMatrix(transform, stamp) {
              var i = 0;
              var res = Mat4.IDENTITY;

              while (transform) {
                if (transform.stamp === stamp || transform.stamp + 1 === stamp && !transform.node.hasChangedFlags) {
                  res = transform.world;
                  transform.stamp = stamp;
                  break;
                }

                transform.stamp = stamp;
                stack[i++] = transform;
                transform = transform.parent;
              }

              while (i > 0) {
                transform = stack[--i];
                var node = transform.node;
                Mat4.fromRTS(transform.local, node.rotation, node.position, node.scale);
                res = Mat4.multiply(transform.world, res, transform.local);
              }

              return res;
            }
            function getTransform(node, root) {
              var joint = null;
              var i = 0;

              while (node !== root) {
                var id = node.uuid;

                if (pool.has(id)) {
                  joint = pool.get(id);
                  break;
                } else {
                  // TODO: object reuse
                  joint = {
                    node: node,
                    local: new Mat4(),
                    world: new Mat4(),
                    stamp: -1,
                    parent: null
                  };
                  pool.set(id, joint);
                }

                stack[i++] = joint;
                node = node.parent;
                joint = null;
              }

              var child;

              while (i > 0) {
                child = stack[--i];
                child.parent = joint;
                joint = child;
              }

              return joint;
            }
            function deleteTransform(node) {
              var transform = pool.get(node.uuid) || null;

              while (transform) {
                pool["delete"](transform.node.uuid);
                transform = transform.parent;
              }
            }

            function getRelevantBuffers(outIndices, outBuffers, jointMaps, targetJoint) {
              for (var i = 0; i < jointMaps.length; i++) {
                var idxMap = jointMaps[i];
                var index = -1;

                for (var j = 0; j < idxMap.length; j++) {
                  if (idxMap[j] === targetJoint) {
                    index = j;
                    break;
                  }
                }

                if (index >= 0) {
                  outBuffers.push(i);
                  outIndices.push(index);
                }
              }
            }

            var v3_min$1 = new Vec3();
            var v3_max$1 = new Vec3();
            var v3_1$2 = new Vec3();
            var v3_2$2 = new Vec3();
            var m4_1$4 = new Mat4();
            var ab_1$1 = new aabb();
            /**
             * @en
             * The skinning model that is using real-time pose calculation.
             * @zh
             * 实时计算动画的蒙皮模型。
             */

            var SkinningModel = exports('S', /*#__PURE__*/function (_MorphModel) {
              _inherits(SkinningModel, _MorphModel);

              function SkinningModel() {
                var _this;

                _classCallCheck(this, SkinningModel);

                _this = _possibleConstructorReturn(this, _getPrototypeOf(SkinningModel).call(this));
                _this.uploadAnimation = null;
                _this._buffers = [];
                _this._dataArray = [];
                _this._joints = [];
                _this._bufferIndices = null;
                _this.type = ModelType.SKINNING;
                return _this;
              }

              _createClass(SkinningModel, [{
                key: "destroy",
                value: function destroy() {
                  this.bindSkeleton();

                  if (this._buffers.length) {
                    for (var i = 0; i < this._buffers.length; i++) {
                      this._buffers[i].destroy();
                    }

                    this._buffers.length = 0;
                  }

                  _get(_getPrototypeOf(SkinningModel.prototype), "destroy", this).call(this);
                }
              }, {
                key: "bindSkeleton",
                value: function bindSkeleton() {
                  var skeleton = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
                  var skinningRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
                  var mesh = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

                  for (var i = 0; i < this._joints.length; i++) {
                    deleteTransform(this._joints[i].target);
                  }

                  this._bufferIndices = null;
                  this._joints.length = 0;

                  if (!skeleton || !skinningRoot || !mesh) {
                    return;
                  }

                  this.transform = skinningRoot;
                  var boneSpaceBounds = mesh.getBoneSpaceBounds(skeleton);
                  var jointMaps = mesh.struct.jointMaps;

                  this._ensureEnoughBuffers(jointMaps && jointMaps.length || 1);

                  this._bufferIndices = mesh.jointBufferIndices;

                  for (var index = 0; index < skeleton.joints.length; index++) {
                    var bound = boneSpaceBounds[index];
                    var target = skinningRoot.getChildByPath(skeleton.joints[index]);

                    if (!bound || !target) {
                      continue;
                    }

                    var transform = getTransform(target, skinningRoot);
                    var bindpose = skeleton.bindposes[index];
                    var indices = [];
                    var buffers = [];

                    if (!jointMaps) {
                      indices.push(index);
                      buffers.push(0);
                    } else {
                      getRelevantBuffers(indices, buffers, jointMaps, index);
                    }

                    this._joints.push({
                      indices: indices,
                      buffers: buffers,
                      bound: bound,
                      target: target,
                      bindpose: bindpose,
                      transform: transform
                    });
                  }
                }
              }, {
                key: "updateTransform",
                value: function updateTransform(stamp) {
                  var root = this.transform; // @ts-ignore TS2445

                  if (root.hasChangedFlags || root._dirtyFlags) {
                    root.updateWorldTransform();
                    this._transformUpdated = true;
                  } // update bounds


                  Vec3.set(v3_min$1, Infinity, Infinity, Infinity);
                  Vec3.set(v3_max$1, -Infinity, -Infinity, -Infinity);

                  for (var i = 0; i < this._joints.length; i++) {
                    var _this$_joints$i = this._joints[i],
                        bound = _this$_joints$i.bound,
                        transform = _this$_joints$i.transform;
                    var worldMatrix = getWorldMatrix(transform, stamp);
                    aabb.transform(ab_1$1, bound, worldMatrix);
                    ab_1$1.getBoundary(v3_1$2, v3_2$2);
                    Vec3.min(v3_min$1, v3_min$1, v3_1$2);
                    Vec3.max(v3_max$1, v3_max$1, v3_2$2);
                  }

                  if (this._modelBounds && this._worldBounds) {
                    aabb.fromPoints(this._modelBounds, v3_min$1, v3_max$1); // @ts-ignore TS2445

                    this._modelBounds.transform(root._mat, root._pos, root._rot, root._scale, this._worldBounds);
                  }
                }
              }, {
                key: "updateUBOs",
                value: function updateUBOs(stamp) {
                  _get(_getPrototypeOf(SkinningModel.prototype), "updateUBOs", this).call(this, stamp);

                  for (var i = 0; i < this._joints.length; i++) {
                    var _this$_joints$i2 = this._joints[i],
                        indices = _this$_joints$i2.indices,
                        buffers = _this$_joints$i2.buffers,
                        transform = _this$_joints$i2.transform,
                        bindpose = _this$_joints$i2.bindpose;
                    Mat4.multiply(m4_1$4, transform.world, bindpose);

                    for (var b = 0; b < buffers.length; b++) {
                      uploadJointData(this._dataArray[buffers[b]], indices[b] * 12, m4_1$4);
                    }
                  }

                  for (var _b = 0; _b < this._buffers.length; _b++) {
                    this._buffers[_b].update(this._dataArray[_b]);
                  }

                  return true;
                }
              }, {
                key: "initSubModel",
                value: function initSubModel(idx, subMeshData, mat) {
                  var original = subMeshData.vertexBuffers;
                  subMeshData.vertexBuffers = subMeshData.jointMappedBuffers;

                  _get(_getPrototypeOf(SkinningModel.prototype), "initSubModel", this).call(this, idx, subMeshData, mat);

                  subMeshData.vertexBuffers = original;
                }
              }, {
                key: "getMacroPatches",
                value: function getMacroPatches(subModelIndex) {
                  var superMacroPatches = _get(_getPrototypeOf(SkinningModel.prototype), "getMacroPatches", this).call(this, subModelIndex);

                  if (superMacroPatches) {
                    return myPatches.concat(superMacroPatches);
                  } else {
                    return myPatches;
                  }
                }
              }, {
                key: "_updateLocalDescriptors",
                value: function _updateLocalDescriptors(submodelIdx, descriptorSet) {
                  _get(_getPrototypeOf(SkinningModel.prototype), "_updateLocalDescriptors", this).call(this, submodelIdx, descriptorSet);

                  var buffer = this._buffers[this._bufferIndices[submodelIdx]];

                  if (buffer) {
                    descriptorSet.bindBuffer(UBOSkinning.BLOCK.binding, buffer);
                  }
                }
              }, {
                key: "_ensureEnoughBuffers",
                value: function _ensureEnoughBuffers(count) {
                  for (var i = 0; i < count; i++) {
                    if (!this._buffers[i]) {
                      this._buffers[i] = this._device.createBuffer({
                        usage: GFXBufferUsageBit.UNIFORM | GFXBufferUsageBit.TRANSFER_DST,
                        memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                        size: UBOSkinning.SIZE,
                        stride: UBOSkinning.SIZE
                      });
                    }

                    if (!this._dataArray[i]) {
                      this._dataArray[i] = new Float32Array(UBOSkinning.COUNT);
                    }
                  }
                }
              }]);

              return SkinningModel;
            }(MorphModel));

            var Ambient = exports('A', /*#__PURE__*/function () {
              function Ambient() {
                _classCallCheck(this, Ambient);

                this._enabled = true;
                this._skyColor = new Color(51, 128, 204, 1.0);
                this._skyIllum = Ambient.SKY_ILLUM;
                this._groundAlbedo = new Color(51, 51, 51, 255);
                this._albedoArray = Float32Array.from([0.2, 0.2, 0.2, 1.0]);
                this._colorArray = Float32Array.from([0.2, 0.5, 0.8, 1.0]);
              }

              _createClass(Ambient, [{
                key: "activate",
                value: function activate() {
                  Color.toArray(this._colorArray, this._skyColor);
                  Vec3.toArray(this._albedoArray, this._groundAlbedo);
                }
              }, {
                key: "colorArray",
                get: function get() {
                  return this._colorArray;
                }
              }, {
                key: "albedoArray",
                get: function get() {
                  return this._albedoArray;
                }
                /**
                 * @en Enable ambient
                 * @zh 是否开启环境光
                 */

              }, {
                key: "enabled",
                set: function set(val) {
                  if (this._enabled === val) {
                    return;
                  }

                  this._enabled = val;
                  this.activate();
                },
                get: function get() {
                  return this._enabled;
                }
                /**
                 * @en Sky color
                 * @zh 天空颜色
                 */

              }, {
                key: "skyColor",
                get: function get() {
                  return this._skyColor;
                },
                set: function set(color) {
                  this._skyColor = color;
                  Color.toArray(this._colorArray, this._skyColor);
                }
                /**
                 * @en Sky illuminance
                 * @zh 天空亮度
                 */

              }, {
                key: "skyIllum",
                get: function get() {
                  return this._skyIllum;
                },
                set: function set(illum) {
                  this._skyIllum = illum;
                }
                /**
                 * @en Ground color
                 * @zh 地面颜色
                 */

              }, {
                key: "groundAlbedo",
                get: function get() {
                  return this._groundAlbedo;
                },
                set: function set(color) {
                  this._groundAlbedo = color;
                  Vec3.toArray(this._albedoArray, this._groundAlbedo);
                }
              }]);

              return Ambient;
            }());
            Ambient.SUN_ILLUM = 65000.0;
            Ambient.SKY_ILLUM = 20000.0;

            var CameraFOVAxis;

            (function (CameraFOVAxis) {
              CameraFOVAxis[CameraFOVAxis["VERTICAL"] = 0] = "VERTICAL";
              CameraFOVAxis[CameraFOVAxis["HORIZONTAL"] = 1] = "HORIZONTAL";
            })(CameraFOVAxis || (CameraFOVAxis = exports('B', {})));

            var CameraProjection;

            (function (CameraProjection) {
              CameraProjection[CameraProjection["ORTHO"] = 0] = "ORTHO";
              CameraProjection[CameraProjection["PERSPECTIVE"] = 1] = "PERSPECTIVE";
            })(CameraProjection || (CameraProjection = exports('D', {})));

            var CameraAperture;

            (function (CameraAperture) {
              CameraAperture[CameraAperture["F1_8"] = 0] = "F1_8";
              CameraAperture[CameraAperture["F2_0"] = 1] = "F2_0";
              CameraAperture[CameraAperture["F2_2"] = 2] = "F2_2";
              CameraAperture[CameraAperture["F2_5"] = 3] = "F2_5";
              CameraAperture[CameraAperture["F2_8"] = 4] = "F2_8";
              CameraAperture[CameraAperture["F3_2"] = 5] = "F3_2";
              CameraAperture[CameraAperture["F3_5"] = 6] = "F3_5";
              CameraAperture[CameraAperture["F4_0"] = 7] = "F4_0";
              CameraAperture[CameraAperture["F4_5"] = 8] = "F4_5";
              CameraAperture[CameraAperture["F5_0"] = 9] = "F5_0";
              CameraAperture[CameraAperture["F5_6"] = 10] = "F5_6";
              CameraAperture[CameraAperture["F6_3"] = 11] = "F6_3";
              CameraAperture[CameraAperture["F7_1"] = 12] = "F7_1";
              CameraAperture[CameraAperture["F8_0"] = 13] = "F8_0";
              CameraAperture[CameraAperture["F9_0"] = 14] = "F9_0";
              CameraAperture[CameraAperture["F10_0"] = 15] = "F10_0";
              CameraAperture[CameraAperture["F11_0"] = 16] = "F11_0";
              CameraAperture[CameraAperture["F13_0"] = 17] = "F13_0";
              CameraAperture[CameraAperture["F14_0"] = 18] = "F14_0";
              CameraAperture[CameraAperture["F16_0"] = 19] = "F16_0";
              CameraAperture[CameraAperture["F18_0"] = 20] = "F18_0";
              CameraAperture[CameraAperture["F20_0"] = 21] = "F20_0";
              CameraAperture[CameraAperture["F22_0"] = 22] = "F22_0";
            })(CameraAperture || (CameraAperture = exports('E', {})));

            var CameraISO;

            (function (CameraISO) {
              CameraISO[CameraISO["ISO100"] = 0] = "ISO100";
              CameraISO[CameraISO["ISO200"] = 1] = "ISO200";
              CameraISO[CameraISO["ISO400"] = 2] = "ISO400";
              CameraISO[CameraISO["ISO800"] = 3] = "ISO800";
            })(CameraISO || (CameraISO = exports('F', {})));

            var CameraShutter;

            (function (CameraShutter) {
              CameraShutter[CameraShutter["D1"] = 0] = "D1";
              CameraShutter[CameraShutter["D2"] = 1] = "D2";
              CameraShutter[CameraShutter["D4"] = 2] = "D4";
              CameraShutter[CameraShutter["D8"] = 3] = "D8";
              CameraShutter[CameraShutter["D15"] = 4] = "D15";
              CameraShutter[CameraShutter["D30"] = 5] = "D30";
              CameraShutter[CameraShutter["D60"] = 6] = "D60";
              CameraShutter[CameraShutter["D125"] = 7] = "D125";
              CameraShutter[CameraShutter["D250"] = 8] = "D250";
              CameraShutter[CameraShutter["D500"] = 9] = "D500";
              CameraShutter[CameraShutter["D1000"] = 10] = "D1000";
              CameraShutter[CameraShutter["D2000"] = 11] = "D2000";
              CameraShutter[CameraShutter["D4000"] = 12] = "D4000";
            })(CameraShutter || (CameraShutter = exports('H', {})));

            var FSTOPS = [1.8, 2.0, 2.2, 2.5, 2.8, 3.2, 3.5, 4.0, 4.5, 5.0, 5.6, 6.3, 7.1, 8.0, 9.0, 10.0, 11.0, 13.0, 14.0, 16.0, 18.0, 20.0, 22.0];
            var SHUTTERS = [1.0, 1.0 / 2.0, 1.0 / 4.0, 1.0 / 8.0, 1.0 / 15.0, 1.0 / 30.0, 1.0 / 60.0, 1.0 / 125.0, 1.0 / 250.0, 1.0 / 500.0, 1.0 / 1000.0, 1.0 / 2000.0, 1.0 / 4000.0];
            var ISOS = [100.0, 200.0, 400.0, 800.0];
            var v_a = new Vec3();
            var v_b = new Vec3();

            var _tempMat1 = new Mat4();

            var _tempMat2 = new Mat4();

            var SKYBOX_FLAG = exports('I', GFXClearFlag.STENCIL << 1);
            var Camera = exports('K', /*#__PURE__*/function () {
              function Camera(device) {
                _classCallCheck(this, Camera);

                this.isWindowSize = true;
                this.screenScale = void 0;
                this.clearStencil = 0;
                this.clearDepth = 1.0;
                this.clearFlag = GFXClearFlag.NONE;
                this._device = void 0;
                this._scene = null;
                this._node = null;
                this._name = null;
                this._enabled = false;
                this._proj = -1;
                this._width = void 0;
                this._height = void 0;
                this._aspect = void 0;
                this._orthoHeight = 10.0;
                this._fovAxis = CameraFOVAxis.VERTICAL;
                this._fov = toRadian(45);
                this._nearClip = 1.0;
                this._farClip = 1000.0;
                this._clearColor = {
                  r: 0.2,
                  g: 0.2,
                  b: 0.2,
                  a: 1
                };
                this._viewport = new Rect(0, 0, 1, 1);
                this._isProjDirty = true;
                this._matView = new Mat4();
                this._matViewInv = null;
                this._matProj = new Mat4();
                this._matProjInv = new Mat4();
                this._matViewProj = new Mat4();
                this._matViewProjInv = new Mat4();
                this._frustum = new frustum();
                this._forward = new Vec3();
                this._position = new Vec3();
                this._view = null;
                this._visibility = CAMERA_DEFAULT_MASK;
                this._priority = 0;
                this._aperture = CameraAperture.F16_0;
                this._apertureValue = void 0;
                this._shutter = CameraShutter.D125;
                this._shutterValue = 0.0;
                this._iso = CameraISO.ISO100;
                this._isoValue = 0.0;
                this._ec = 0.0;
                this._exposure = 0.0;
                this._device = device;
                this._apertureValue = FSTOPS[this._aperture];
                this._shutterValue = SHUTTERS[this._shutter];
                this._isoValue = ISOS[this._iso];
                this.updateExposure();
                this._aspect = this._width = this._height = this.screenScale = 1;
              }

              _createClass(Camera, [{
                key: "initialize",
                value: function initialize(info) {
                  this._name = info.name;
                  this._node = info.node;
                  this._proj = info.projection;
                  this._priority = info.priority || 0;
                  this._view = legacyCC.director.root.createView({
                    camera: this,
                    name: this._name,
                    priority: this._priority,
                    flows: info.flows
                  });
                  legacyCC.director.root.attachCamera(this);
                  this.changeTargetWindow(info.window);
                  console.log('Created Camera: ' + this._name + ' ' + this._width + 'x' + this._height);
                }
              }, {
                key: "destroy",
                value: function destroy() {
                  legacyCC.director.root.detachCamera(this);

                  if (this._view) {
                    this._view.destroy();

                    this._view = null;
                  }

                  this._name = null;
                }
              }, {
                key: "attachToScene",
                value: function attachToScene(scene) {
                  this._scene = scene;

                  if (this._view) {
                    this._view.enable(true);
                  }
                }
              }, {
                key: "detachFromScene",
                value: function detachFromScene() {
                  this._scene = null;

                  if (this._view) {
                    this._view.enable(false);
                  }
                }
              }, {
                key: "resize",
                value: function resize(width, height) {
                  this._width = width;
                  this._height = height;
                  this._aspect = this._width * this._viewport.width / (this._height * this._viewport.height);
                  this._isProjDirty = true;
                }
              }, {
                key: "setFixedSize",
                value: function setFixedSize(width, height) {
                  this._width = width;
                  this._height = height;
                  this._aspect = this._width * this._viewport.width / (this._height * this._viewport.height);
                  this.isWindowSize = false;
                }
              }, {
                key: "update",
                value: function update() {
                  var forceUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
                  // for lazy eval situations like the in-editor preview
                  if (!this._node) return; // view matrix

                  if (this._node.hasChangedFlags || forceUpdate) {
                    Mat4.invert(this._matView, this._node.worldMatrix);
                    this._forward.x = -this._matView.m02;
                    this._forward.y = -this._matView.m06;
                    this._forward.z = -this._matView.m10;

                    this._node.getWorldPosition(this._position);
                  } // projection matrix


                  if (this._isProjDirty) {
                    var projectionSignY = this._device.screenSpaceSignY;

                    if (this._view && this._view.window.hasOffScreenAttachments) {
                      projectionSignY *= this._device.UVSpaceSignY; // need flipping if drawing on render targets
                    }

                    if (this._proj === CameraProjection.PERSPECTIVE) {
                      Mat4.perspective(this._matProj, this._fov, this._aspect, this._nearClip, this._farClip, this._fovAxis === CameraFOVAxis.VERTICAL, this._device.clipSpaceMinZ, projectionSignY);
                    } else {
                      var x = this._orthoHeight * this._aspect;
                      var y = this._orthoHeight;
                      Mat4.ortho(this._matProj, -x, x, -y, y, this._nearClip, this._farClip, this._device.clipSpaceMinZ, projectionSignY);
                    }

                    Mat4.invert(this._matProjInv, this._matProj);
                  } // view-projection


                  if (this._node.hasChangedFlags || this._isProjDirty || forceUpdate) {
                    Mat4.multiply(this._matViewProj, this._matProj, this._matView);
                    Mat4.invert(this._matViewProjInv, this._matViewProj);

                    this._frustum.update(this._matViewProj, this._matViewProjInv);
                  }

                  this._isProjDirty = false;
                }
              }, {
                key: "getSplitFrustum",
                value: function getSplitFrustum(out, nearClip, farClip) {
                  if (!this._node) return;
                  nearClip = Math.max(nearClip, this._nearClip);
                  farClip = Math.min(farClip, this._farClip); // view matrix

                  Mat4.invert(this._matView, this._node.worldMatrix); // projection matrix

                  if (this._proj === CameraProjection.PERSPECTIVE) {
                    Mat4.perspective(_tempMat1, this._fov, this._aspect, nearClip, farClip, this._fovAxis === CameraFOVAxis.VERTICAL, this._device.clipSpaceMinZ, this._device.screenSpaceSignY);
                  } else {
                    var x = this._orthoHeight * this._aspect;
                    var y = this._orthoHeight;
                    Mat4.ortho(_tempMat1, -x, x, -y, y, nearClip, farClip, this._device.clipSpaceMinZ, this._device.screenSpaceSignY);
                  } // view-projection


                  Mat4.multiply(_tempMat2, _tempMat1, this._matView);
                  Mat4.invert(_tempMat1, _tempMat2);
                  out.update(_tempMat2, _tempMat1);
                }
              }, {
                key: "changeTargetWindow",
                value: function changeTargetWindow() {
                  var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
                  var win = window || legacyCC.director.root.mainWindow;

                  if (win && this._view) {
                    this._view.window = win;
                    this.resize(win.width, win.height);
                  }
                }
                /**
                 * transform a screen position to a world space ray
                 */

              }, {
                key: "screenPointToRay",
                value: function screenPointToRay(out, x, y) {
                  var cx = this._viewport.x * this._width;
                  var cy = this._viewport.y * this._height;
                  var cw = this._viewport.width * this._width;
                  var ch = this._viewport.height * this._height; // far plane intersection

                  Vec3.set(v_a, (x - cx) / cw * 2 - 1, (y - cy) / ch * 2 - 1, 1);
                  v_a.y *= this._device.screenSpaceSignY;
                  Vec3.transformMat4(v_a, v_a, this._matViewProjInv);

                  if (this._proj === CameraProjection.PERSPECTIVE) {
                    // camera origin
                    if (this._node) {
                      this._node.getWorldPosition(v_b);
                    }
                  } else {
                    // near plane intersection
                    Vec3.set(v_b, (x - cx) / cw * 2 - 1, (y - cy) / ch * 2 - 1, -1);
                    v_b.y *= this._device.screenSpaceSignY;
                    Vec3.transformMat4(v_b, v_b, this._matViewProjInv);
                  }

                  return ray.fromPoints(out, v_b, v_a);
                }
                /**
                 * transform a screen position to world space
                 */

              }, {
                key: "screenToWorld",
                value: function screenToWorld(out, screenPos) {
                  var cx = this._viewport.x * this._width;
                  var cy = this._viewport.y * this._height;
                  var cw = this._viewport.width * this._width;
                  var ch = this._viewport.height * this._height;

                  if (this._proj === CameraProjection.PERSPECTIVE) {
                    // calculate screen pos in far clip plane
                    Vec3.set(out, (screenPos.x - cx) / cw * 2 - 1, (screenPos.y - cy) / ch * 2 - 1, 1.0); // transform to world

                    Vec3.transformMat4(out, out, this._matViewProjInv); // lerp to depth z

                    if (this._node) {
                      this._node.getWorldPosition(v_a);
                    }

                    Vec3.lerp(out, v_a, out, lerp(this._nearClip / this._farClip, 1, screenPos.z));
                  } else {
                    Vec3.set(out, (screenPos.x - cx) / cw * 2 - 1, (screenPos.y - cy) / ch * 2 - 1, screenPos.z * 2 - 1); // transform to world

                    Vec3.transformMat4(out, out, this.matViewProjInv);
                  }

                  return out;
                }
                /**
                 * transform a world space position to screen space
                 */

              }, {
                key: "worldToScreen",
                value: function worldToScreen(out, worldPos) {
                  var cx = this._viewport.x * this._width;
                  var cy = this._viewport.y * this._height;
                  var cw = this._viewport.width * this._width;
                  var ch = this._viewport.height * this._height;
                  Vec3.transformMat4(out, worldPos, this.matViewProj);
                  out.x = cx + (out.x + 1) * 0.5 * cw;
                  out.y = cy + (out.y + 1) * 0.5 * ch;
                  out.z = out.z * 0.5 + 0.5;
                  return out;
                }
              }, {
                key: "updateExposure",
                value: function updateExposure() {
                  var ev100 = Math.log2(this._apertureValue * this._apertureValue / this._shutterValue * 100.0 / this._isoValue);
                  this._exposure = 0.833333 / Math.pow(2.0, ev100);
                }
              }, {
                key: "node",
                set: function set(val) {
                  this._node = val;
                },
                get: function get() {
                  return this._node;
                }
              }, {
                key: "enabled",
                set: function set(val) {
                  this._enabled = val;

                  if (this._view) {
                    this._view.enable(val);
                  }
                },
                get: function get() {
                  return this._enabled;
                }
              }, {
                key: "view",
                get: function get() {
                  return this._view;
                }
              }, {
                key: "orthoHeight",
                set: function set(val) {
                  this._orthoHeight = val;
                  this._isProjDirty = true;
                },
                get: function get() {
                  return this._orthoHeight;
                }
              }, {
                key: "projectionType",
                set: function set(val) {
                  this._proj = val;
                  this._isProjDirty = true;
                },
                get: function get() {
                  return this._proj;
                }
              }, {
                key: "fovAxis",
                set: function set(axis) {
                  this._fovAxis = axis;
                  this._isProjDirty = true;
                },
                get: function get() {
                  return this._fovAxis;
                }
              }, {
                key: "fov",
                set: function set(fov) {
                  this._fov = fov;
                  this._isProjDirty = true;
                },
                get: function get() {
                  return this._fov;
                }
              }, {
                key: "nearClip",
                set: function set(nearClip) {
                  this._nearClip = nearClip;
                  this._isProjDirty = true;
                },
                get: function get() {
                  return this._nearClip;
                }
              }, {
                key: "farClip",
                set: function set(farClip) {
                  this._farClip = farClip;
                  this._isProjDirty = true;
                },
                get: function get() {
                  return this._farClip;
                }
              }, {
                key: "clearColor",
                set: function set(val) {
                  this._clearColor.r = val.r;
                  this._clearColor.g = val.g;
                  this._clearColor.b = val.b;
                  this._clearColor.a = val.a;
                },
                get: function get() {
                  return this._clearColor;
                }
              }, {
                key: "viewport",
                get: function get() {
                  return this._viewport;
                },
                set: function set(val) {
                  var signY = this._device.screenSpaceSignY;
                  this._viewport.x = val.x;

                  if (signY > 0) {
                    this._viewport.y = val.y;
                  } else {
                    this._viewport.y = 1 - val.y - val.height;
                  }

                  this._viewport.width = val.width;
                  this._viewport.height = val.height;
                  this.resize(this._width, this._height);
                }
              }, {
                key: "scene",
                get: function get() {
                  return this._scene;
                }
              }, {
                key: "name",
                get: function get() {
                  return this._name;
                }
              }, {
                key: "width",
                get: function get() {
                  return this._width;
                }
              }, {
                key: "height",
                get: function get() {
                  return this._height;
                }
              }, {
                key: "aspect",
                get: function get() {
                  return this._aspect;
                }
              }, {
                key: "matView",
                set: function set(val) {
                  this._matView = val;
                },
                get: function get() {
                  return this._matView;
                }
              }, {
                key: "matViewInv",
                set: function set(val) {
                  this._matViewInv = val;
                },
                get: function get() {
                  return this._matViewInv || this._node.worldMatrix;
                }
              }, {
                key: "matProj",
                set: function set(val) {
                  this._matProj = val;
                },
                get: function get() {
                  return this._matProj;
                }
              }, {
                key: "matProjInv",
                set: function set(val) {
                  this._matProjInv = val;
                },
                get: function get() {
                  return this._matProjInv;
                }
              }, {
                key: "matViewProj",
                set: function set(val) {
                  this._matViewProj = val;
                },
                get: function get() {
                  return this._matViewProj;
                }
              }, {
                key: "matViewProjInv",
                set: function set(val) {
                  this._matViewProjInv = val;
                },
                get: function get() {
                  return this._matViewProjInv;
                }
              }, {
                key: "frustum",
                set: function set(val) {
                  this._frustum = val;
                },
                get: function get() {
                  return this._frustum;
                }
              }, {
                key: "forward",
                set: function set(val) {
                  this._forward = val;
                },
                get: function get() {
                  return this._forward;
                }
              }, {
                key: "position",
                set: function set(val) {
                  this._position = val;
                },
                get: function get() {
                  return this._position;
                }
              }, {
                key: "visibility",
                set: function set(vis) {
                  this._visibility = vis;

                  if (this._view) {
                    this._view.visibility = vis;
                  }
                },
                get: function get() {
                  return this._visibility;
                }
              }, {
                key: "priority",
                get: function get() {
                  return this._view ? this._view.priority : -1;
                },
                set: function set(val) {
                  this._priority = val;

                  if (this._view) {
                    this._view.priority = this._priority;
                  }
                }
              }, {
                key: "aperture",
                set: function set(val) {
                  this._aperture = val;
                  this._apertureValue = FSTOPS[this._aperture];
                  this.updateExposure();
                },
                get: function get() {
                  return this._aperture;
                }
              }, {
                key: "apertureValue",
                get: function get() {
                  return this._apertureValue;
                }
              }, {
                key: "shutter",
                set: function set(val) {
                  this._shutter = val;
                  this._shutterValue = SHUTTERS[this._shutter];
                  this.updateExposure();
                },
                get: function get() {
                  return this._shutter;
                }
              }, {
                key: "shutterValue",
                get: function get() {
                  return this._shutterValue;
                }
              }, {
                key: "iso",
                set: function set(val) {
                  this._iso = val;
                  this._isoValue = ISOS[this._iso];
                  this.updateExposure();
                },
                get: function get() {
                  return this._iso;
                }
              }, {
                key: "isoValue",
                get: function get() {
                  return this._isoValue;
                }
              }, {
                key: "ec",
                set: function set(val) {
                  this._ec = val;
                },
                get: function get() {
                  return this._ec;
                }
              }, {
                key: "exposure",
                get: function get() {
                  return this._exposure;
                }
              }, {
                key: "flows",
                set: function set(val) {
                  if (this._view) {
                    this._view.setExecuteFlows(val);
                  }
                }
              }]);

              return Camera;
            }());

            var RenderScene = exports('$', /*#__PURE__*/function () {
              _createClass(RenderScene, [{
                key: "root",
                get: function get() {
                  return this._root;
                }
              }, {
                key: "name",
                get: function get() {
                  return this._name;
                }
              }, {
                key: "cameras",
                get: function get() {
                  return this._cameras;
                }
              }, {
                key: "mainLight",
                get: function get() {
                  return this._mainLight;
                }
              }, {
                key: "sphereLights",
                get: function get() {
                  return this._sphereLights;
                }
              }, {
                key: "spotLights",
                get: function get() {
                  return this._spotLights;
                }
              }, {
                key: "models",
                get: function get() {
                  return this._models;
                }
                /**
                 * @zh
                 * 获取 raycastAllCanvas 后的检测结果
                 */

              }, {
                key: "rayResultCanvas",
                get: function get() {
                  return resultCanvas;
                }
                /**
                 * @zh
                 * 获取 raycastAllModels 后的检测结果
                 */

              }, {
                key: "rayResultModels",
                get: function get() {
                  return resultModels;
                }
                /**
                 * @zh
                 * 获取 raycastAll 后的检测结果
                 */

              }, {
                key: "rayResultAll",
                get: function get() {
                  return resultAll;
                }
                /**
                 * @zh
                 * 获取 raycastSingleModel 后的检测结果
                 */

              }, {
                key: "rayResultSingleModel",
                get: function get() {
                  return resultSingleModel;
                }
              }], [{
                key: "registerCreateFunc",
                value: function registerCreateFunc(root) {
                  root._createSceneFun = function (_root) {
                    return new RenderScene(_root);
                  };
                }
              }]);

              function RenderScene(root) {
                _classCallCheck(this, RenderScene);

                this._root = void 0;
                this._name = '';
                this._cameras = [];
                this._models = [];
                this._directionalLights = [];
                this._sphereLights = [];
                this._spotLights = [];
                this._mainLight = null;
                this._modelId = 0;
                this._root = root;
              }

              _createClass(RenderScene, [{
                key: "initialize",
                value: function initialize(info) {
                  this._name = info.name;
                  return true;
                }
              }, {
                key: "update",
                value: function update(stamp) {
                  var mainLight = this._mainLight;

                  if (mainLight) {
                    mainLight.update();
                  }

                  var sphereLights = this._sphereLights;

                  for (var i = 0; i < sphereLights.length; i++) {
                    var light = sphereLights[i];
                    light.update();
                  }

                  var spotLights = this._spotLights;

                  for (var _i = 0; _i < spotLights.length; _i++) {
                    var _light = spotLights[_i];

                    _light.update();
                  }

                  var models = this._models;

                  for (var _i2 = 0; _i2 < models.length; _i2++) {
                    var model = models[_i2];

                    if (model.enabled) {
                      model.updateTransform(stamp);
                      model.updateUBOs(stamp);
                    }
                  }
                }
              }, {
                key: "destroy",
                value: function destroy() {
                  this.removeCameras();
                  this.removeSphereLights();
                  this.removeSpotLights();
                  this.removeModels();
                }
              }, {
                key: "addCamera",
                value: function addCamera(cam) {
                  cam.attachToScene(this);

                  this._cameras.push(cam);
                }
              }, {
                key: "removeCamera",
                value: function removeCamera(camera) {
                  for (var i = 0; i < this._cameras.length; ++i) {
                    if (this._cameras[i] === camera) {
                      this._cameras.splice(i, 1);

                      camera.detachFromScene();
                      return;
                    }
                  }
                }
              }, {
                key: "removeCameras",
                value: function removeCameras() {
                  for (var _iterator = _createForOfIteratorHelperLoose(this._cameras), _step; !(_step = _iterator()).done;) {
                    var camera = _step.value;
                    camera.detachFromScene();
                  }

                  this._cameras.splice(0);
                }
              }, {
                key: "setMainLight",
                value: function setMainLight(dl) {
                  this._mainLight = dl;
                }
              }, {
                key: "unsetMainLight",
                value: function unsetMainLight(dl) {
                  if (this._mainLight === dl) {
                    var dlList = this._directionalLights;

                    if (dlList.length) {
                      this._mainLight = dlList[dlList.length - 1];

                      if (this._mainLight.node) {
                        // trigger update
                        this._mainLight.node.hasChangedFlags |= TransformBit.ROTATION;
                      }
                    } else {
                      this._mainLight = null;
                    }
                  }
                }
              }, {
                key: "addDirectionalLight",
                value: function addDirectionalLight(dl) {
                  dl.attachToScene(this);

                  this._directionalLights.push(dl);
                }
              }, {
                key: "removeDirectionalLight",
                value: function removeDirectionalLight(dl) {
                  for (var i = 0; i < this._directionalLights.length; ++i) {
                    if (this._directionalLights[i] === dl) {
                      dl.detachFromScene();

                      this._directionalLights.splice(i, 1);

                      return;
                    }
                  }
                }
              }, {
                key: "addSphereLight",
                value: function addSphereLight(pl) {
                  pl.attachToScene(this);

                  this._sphereLights.push(pl);
                }
              }, {
                key: "removeSphereLight",
                value: function removeSphereLight(pl) {
                  for (var i = 0; i < this._sphereLights.length; ++i) {
                    if (this._sphereLights[i] === pl) {
                      pl.detachFromScene();

                      this._sphereLights.splice(i, 1);

                      return;
                    }
                  }
                }
              }, {
                key: "addSpotLight",
                value: function addSpotLight(sl) {
                  sl.attachToScene(this);

                  this._spotLights.push(sl);
                }
              }, {
                key: "removeSpotLight",
                value: function removeSpotLight(sl) {
                  for (var i = 0; i < this._spotLights.length; ++i) {
                    if (this._spotLights[i] === sl) {
                      sl.detachFromScene();

                      this._spotLights.splice(i, 1);

                      return;
                    }
                  }
                }
              }, {
                key: "removeSphereLights",
                value: function removeSphereLights() {
                  for (var i = 0; i < this._sphereLights.length; ++i) {
                    this._sphereLights[i].detachFromScene();
                  }

                  this._sphereLights.length = 0;
                }
              }, {
                key: "removeSpotLights",
                value: function removeSpotLights() {
                  for (var i = 0; i < this._spotLights.length; ++i) {
                    this._spotLights[i].detachFromScene();
                  }

                  this._spotLights = [];
                }
              }, {
                key: "addModel",
                value: function addModel(m) {
                  m.attachToScene(this);

                  this._models.push(m);
                }
              }, {
                key: "removeModel",
                value: function removeModel(model) {
                  var pipeline = legacyCC.director.root.pipeline;

                  for (var i = 0; i < this._models.length; ++i) {
                    if (this._models[i] === model) {
                      pipeline.shadows.destroyShadowData(model);
                      model.detachFromScene();

                      this._models.splice(i, 1);

                      return;
                    }
                  }
                }
              }, {
                key: "removeModels",
                value: function removeModels() {
                  var pipeline = legacyCC.director.root.pipeline;

                  for (var _iterator2 = _createForOfIteratorHelperLoose(this._models), _step2; !(_step2 = _iterator2()).done;) {
                    var m = _step2.value;
                    pipeline.shadows.destroyShadowData(m);
                    m.detachFromScene();
                    m.destroy();
                  }

                  this._models.length = 0;
                }
              }, {
                key: "onGlobalPipelineStateChanged",
                value: function onGlobalPipelineStateChanged() {
                  for (var _iterator3 = _createForOfIteratorHelperLoose(this._models), _step3; !(_step3 = _iterator3()).done;) {
                    var m = _step3.value;
                    m.onGlobalPipelineStateChanged();
                  }
                }
              }, {
                key: "generateModelId",
                value: function generateModelId() {
                  return this._modelId++;
                }
                /**
                 * @en
                 * Cast a ray into the scene, record all the intersected models and ui2d nodes in the result array
                 * @param worldRay the testing ray
                 * @param mask the layer mask to filter the models
                 * @param distance the max distance , Infinity by default
                 * @returns boolean , ray is hit or not
                 * @note getter of this.rayResultAll can get recently result
                 * @zh
                 * 传入一条射线检测场景中所有的 3D 模型和 UI2D Node
                 * @param worldRay 世界射线
                 * @param mask mask 用于标记所有要检测的层，默认为 Default | UI2D
                 * @param distance 射线检测的最大距离, 默认为 Infinity
                 * @returns boolean , 射线是否有击中
                 * @note 通过 this.rayResultAll 可以获取到最近的结果
                 */

              }, {
                key: "raycastAll",
                value: function raycastAll(worldRay) {
                  var mask = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Layers.Enum.DEFAULT | Layers.Enum.UI_2D;
                  var distance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;
                  var r_3d = this.raycastAllModels(worldRay, mask, distance);
                  var r_ui2d = this.raycastAllCanvas(worldRay, mask, distance);
                  var isHit = r_3d || r_ui2d;
                  resultAll.length = 0;

                  if (isHit) {
                    Array.prototype.push.apply(resultAll, resultModels);
                    Array.prototype.push.apply(resultAll, resultCanvas);
                  }

                  return isHit;
                }
                /**
                 * @en
                 * Cast a ray into the scene, record all the intersected models in the result array
                 * @param worldRay the testing ray
                 * @param mask the layer mask to filter the models
                 * @param distance the max distance , Infinity by default
                 * @returns boolean , ray is hit or not
                 * @note getter of this.rayResultModels can get recently result
                 * @zh
                 * 传入一条射线检测场景中所有的 3D 模型。
                 * @param worldRay 世界射线
                 * @param mask 用于标记所有要检测的层，默认为 Default
                 * @param distance 射线检测的最大距离, 默认为 Infinity
                 * @returns boolean , 射线是否有击中
                 * @note 通过 this.rayResultModels 可以获取到最近的结果
                 */

              }, {
                key: "raycastAllModels",
                value: function raycastAllModels(worldRay) {
                  var mask = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Layers.Enum.DEFAULT;
                  var distance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;
                  pool$1.reset();

                  for (var _iterator4 = _createForOfIteratorHelperLoose(this._models), _step4; !(_step4 = _iterator4()).done;) {
                    var m = _step4.value;
                    var transform = m.transform;

                    if (!transform || !m.enabled || !(m.node.layer & (mask & ~Layers.Enum.IGNORE_RAYCAST)) || !m.worldBounds) {
                      continue;
                    } // broadphase


                    var d = intersect.ray_aabb(worldRay, m.worldBounds);

                    if (d <= 0 || d >= distance) {
                      continue;
                    }

                    if (m.type === ModelType.DEFAULT) {
                      // transform ray back to model space
                      Mat4.invert(m4, transform.getWorldMatrix(m4));
                      Vec3.transformMat4(modelRay.o, worldRay.o, m4);
                      Vec3.normalize(modelRay.d, Vec3.transformMat4Normal(modelRay.d, worldRay.d, m4));
                      d = Infinity;
                      var subModels = m.subModels;

                      for (var i = 0; i < subModels.length; ++i) {
                        var subMesh = subModels[i].subMesh;

                        if (subMesh && subMesh.geometricInfo) {
                          var _subMesh$geometricInf = subMesh.geometricInfo,
                              vb = _subMesh$geometricInf.positions,
                              ib = _subMesh$geometricInf.indices,
                              sides = _subMesh$geometricInf.doubleSided;
                          narrowphase(vb, ib, subMesh.primitiveMode, sides, distance);
                          d = Math.min(d, narrowDis * Vec3.multiply(v3, modelRay.d, transform.worldScale).length());
                        }
                      }
                    }

                    if (d < distance) {
                      var r = pool$1.add();
                      r.node = m.node;
                      r.distance = d;
                      resultModels[pool$1.length - 1] = r;
                    }
                  }

                  resultModels.length = pool$1.length;
                  return resultModels.length > 0;
                }
                /**
                 * @en
                 * Before you raycast the model, make sure the model is not null
                 * @param worldRay the testing ray
                 * @param model the testing model
                 * @param mask the layer mask to filter the models
                 * @param distance the max distance , Infinity by default
                 * @returns boolean , ray is hit or not
                 * @zh
                 * 传入一条射线和一个 3D 模型进行射线检测。
                 * @param worldRay 世界射线
                 * @param model 进行检测的模型
                 * @param mask 用于标记所有要检测的层，默认为 Default
                 * @param distance 射线检测的最大距离, 默认为 Infinity
                 * @returns boolean , 射线是否有击中
                 */

              }, {
                key: "raycastSingleModel",
                value: function raycastSingleModel(worldRay, model) {
                  var mask = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Layers.Enum.DEFAULT;
                  var distance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;

                  pool$1.reset();
                  var m = model;
                  var transform = m.transform;

                  if (!transform || !m.enabled || !(m.node.layer & (mask & ~Layers.Enum.IGNORE_RAYCAST)) || !m.worldBounds) {
                    return false;
                  } // broadphase


                  var d = intersect.ray_aabb(worldRay, m.worldBounds);

                  if (d <= 0 || d >= distance) {
                    return false;
                  }

                  if (m.type === ModelType.DEFAULT) {
                    // transform ray back to model space
                    Mat4.invert(m4, transform.getWorldMatrix(m4));
                    Vec3.transformMat4(modelRay.o, worldRay.o, m4);
                    Vec3.normalize(modelRay.d, Vec3.transformMat4Normal(modelRay.d, worldRay.d, m4));
                    d = Infinity;
                    var subModels = m.subModels;

                    for (var i = 0; i < subModels.length; ++i) {
                      var subMesh = subModels[i].subMesh;

                      if (subMesh && subMesh.geometricInfo) {
                        var _subMesh$geometricInf2 = subMesh.geometricInfo,
                            vb = _subMesh$geometricInf2.positions,
                            ib = _subMesh$geometricInf2.indices,
                            sides = _subMesh$geometricInf2.doubleSided;
                        narrowphase(vb, ib, subMesh.primitiveMode, sides, distance);
                        d = Math.min(d, narrowDis * Vec3.multiply(v3, modelRay.d, transform.worldScale).length());
                      }
                    }
                  }

                  if (d < distance) {
                    var r = pool$1.add();
                    r.node = m.node;
                    r.distance = d;
                    resultSingleModel[pool$1.length - 1] = r;
                  }

                  resultSingleModel.length = pool$1.length;
                  return resultSingleModel.length > 0;
                }
                /**
                 * @en
                 * Cast a ray into the scene, detect all canvas and its children
                 * @param worldRay the testing ray
                 * @param mask the layer mask to filter all ui2d aabb
                 * @param distance the max distance , Infinity by default
                 * @returns boolean , ray is hit or not
                 * @note getter of this.rayResultCanvas can get recently result
                 * @zh
                 * 传入一条射线检测场景中所有的 Canvas 以及 Canvas 下的 Node
                 * @param worldRay 世界射线
                 * @param mask 用于标记所有要检测的层，默认为 UI_2D
                 * @param distance 射线检测的最大距离, 默认为 Infinity
                 * @returns boolean , 射线是否有击中
                 * @note 通过 this.rayResultCanvas 可以获取到最近的结果
                 */

              }, {
                key: "raycastAllCanvas",
                value: function raycastAllCanvas(worldRay) {
                  var mask = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Layers.Enum.UI_2D;
                  var distance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;
                  poolUI.reset();
                  var canvasComs = legacyCC.director.getScene().getComponentsInChildren(legacyCC.Canvas);

                  if (canvasComs != null && canvasComs.length > 0) {
                    for (var i = 0; i < canvasComs.length; i++) {
                      var canvasNode = canvasComs[i].node;

                      if (canvasNode != null && canvasNode.active) {
                        this._raycastUI2DNodeRecursiveChildren(worldRay, canvasNode, mask, distance);
                      }
                    }
                  }

                  resultCanvas.length = poolUI.length;
                  return resultCanvas.length > 0;
                }
              }, {
                key: "_raycastUI2DNode",
                value: function _raycastUI2DNode(worldRay, ui2dNode) {
                  var mask = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Layers.Enum.UI_2D;
                  var distance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;

                  var uiTransform = ui2dNode._uiProps.uiTransformComp;

                  if (uiTransform == null || ui2dNode.layer & Layers.Enum.IGNORE_RAYCAST || !(ui2dNode.layer & mask)) {
                    return;
                  }

                  uiTransform.getComputeAABB(aabbUI);
                  var d = intersect.ray_aabb(worldRay, aabbUI);

                  if (d <= 0) {
                    return;
                  } else if (d < distance) {
                    var r = poolUI.add();
                    r.node = ui2dNode;
                    r.distance = d;
                    return r;
                  }
                }
              }, {
                key: "_raycastUI2DNodeRecursiveChildren",
                value: function _raycastUI2DNodeRecursiveChildren(worldRay, parent) {
                  var mask = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Layers.Enum.UI_2D;
                  var distance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;

                  var result = this._raycastUI2DNode(worldRay, parent, mask, distance);

                  if (result != null) {
                    resultCanvas[poolUI.length - 1] = result;
                  }

                  for (var _iterator5 = _createForOfIteratorHelperLoose(parent.children), _step5; !(_step5 = _iterator5()).done;) {
                    var node = _step5.value;

                    if (node != null && node.active) {
                      this._raycastUI2DNodeRecursiveChildren(worldRay, node, mask, distance);
                    }
                  }
                }
              }]);

              return RenderScene;
            }());
            var modelRay = ray.create();
            var v3 = new Vec3();
            var m4 = new Mat4();
            var narrowDis = Infinity;
            var tri = triangle.create();
            var pool$1 = new RecyclePool(function () {
              return {
                node: null,
                distance: Infinity
              };
            }, 8);
            var resultModels = [];
            /** Canvas raycast result pool */

            var aabbUI = new aabb();
            var poolUI = new RecyclePool(function () {
              return {
                node: null,
                distance: Infinity
              };
            }, 8);
            var resultCanvas = [];
            /** raycast all */

            var resultAll = [];
            /** raycast single model */

            var resultSingleModel = [];

            var narrowphase = function narrowphase(vb, ib, pm, sides) {
              var distance = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Infinity;
              narrowDis = distance;

              if (pm === GFXPrimitiveMode.TRIANGLE_LIST) {
                var cnt = ib.length;

                for (var j = 0; j < cnt; j += 3) {
                  var i0 = ib[j] * 3;
                  var i1 = ib[j + 1] * 3;
                  var i2 = ib[j + 2] * 3;
                  Vec3.set(tri.a, vb[i0], vb[i0 + 1], vb[i0 + 2]);
                  Vec3.set(tri.b, vb[i1], vb[i1 + 1], vb[i1 + 2]);
                  Vec3.set(tri.c, vb[i2], vb[i2 + 1], vb[i2 + 2]);
                  var dist = intersect.ray_triangle(modelRay, tri, sides);

                  if (dist <= 0 || dist >= narrowDis) {
                    continue;
                  }

                  narrowDis = dist;
                }
              } else if (pm === GFXPrimitiveMode.TRIANGLE_STRIP) {
                var _cnt = ib.length - 2;

                var rev = 0;

                for (var _j = 0; _j < _cnt; _j += 1) {
                  var _i3 = ib[_j - rev] * 3;

                  var _i4 = ib[_j + rev + 1] * 3;

                  var _i5 = ib[_j + 2] * 3;

                  Vec3.set(tri.a, vb[_i3], vb[_i3 + 1], vb[_i3 + 2]);
                  Vec3.set(tri.b, vb[_i4], vb[_i4 + 1], vb[_i4 + 2]);
                  Vec3.set(tri.c, vb[_i5], vb[_i5 + 1], vb[_i5 + 2]);
                  rev = ~rev;

                  var _dist = intersect.ray_triangle(modelRay, tri, sides);

                  if (_dist <= 0 || _dist >= narrowDis) {
                    continue;
                  }

                  narrowDis = _dist;
                }
              } else if (pm === GFXPrimitiveMode.TRIANGLE_FAN) {
                var _cnt2 = ib.length - 1;

                var _i6 = ib[0] * 3;

                Vec3.set(tri.a, vb[_i6], vb[_i6 + 1], vb[_i6 + 2]);

                for (var _j2 = 1; _j2 < _cnt2; _j2 += 1) {
                  var _i7 = ib[_j2] * 3;

                  var _i8 = ib[_j2 + 1] * 3;

                  Vec3.set(tri.b, vb[_i7], vb[_i7 + 1], vb[_i7 + 2]);
                  Vec3.set(tri.c, vb[_i8], vb[_i8 + 1], vb[_i8 + 2]);

                  var _dist2 = intersect.ray_triangle(modelRay, tri, sides);

                  if (_dist2 <= 0 || _dist2 >= narrowDis) {
                    continue;
                  }

                  narrowDis = _dist2;
                }
              }
            };

            replaceProperty(RenderScene.prototype, 'RenderScene.prototype', [{
              'name': 'raycastUI',
              'newName': 'raycastAllCanvas'
            }, {
              'name': 'raycastUI2D',
              'newName': 'raycastAllCanvas'
            }, {
              'name': 'raycast',
              'newName': 'raycastAllModels'
            }, {
              'name': 'raycastModels',
              'newName': 'raycastAllModels'
            }, {
              'name': 'raycastModel',
              'newName': 'raycastSingleModel'
            }]);
            removeProperty(RenderScene.prototype, 'RenderScene.prototype', [{
              'name': 'raycastUI2DNode'
            }, {
              'name': 'raycastUINode'
            }]);
            markAsWarning(RenderScene.prototype, 'RenderScene.prototype', [{
              'name': 'raycastAll',
              'suggest': 'using intersect in geometry'
            }, {
              'name': 'raycastAllModels',
              'suggest': 'using intersect in geometry'
            }, {
              'name': 'raycastSingleModel',
              'suggest': 'using intersect in geometry'
            }, {
              'name': 'raycastAllCanvas',
              'suggest': 'using intersect in geometry'
            }, {
              'name': 'rayResultCanvas'
            }, {
              'name': 'rayResultModels'
            }, {
              'name': 'rayResultAll'
            }, {
              'name': 'rayResultSingleModel'
            }]);
            var CameraVisFlags = exports('L', {});
            removeProperty(CameraVisFlags, 'CameraVisFlags', [{
              name: 'GENERAL'
            }]);
            replaceProperty(CameraVisFlags, 'CameraVisFlags', [{
              name: 'PROFILER',
              newName: 'PROFILER',
              target: Layers.BitMask,
              targetName: 'PROFILER'
            }, {
              name: 'GIZMOS',
              newName: 'GIZMOS',
              target: Layers.BitMask,
              targetName: 'GIZMOS'
            }, {
              name: 'EDITOR',
              newName: 'EDITOR',
              target: Layers.BitMask,
              targetName: 'EDITOR'
            }, {
              name: 'UI',
              newName: 'UI',
              target: Layers.BitMask,
              targetName: 'UI_3D'
            }, {
              name: 'UI2D',
              newName: 'UI2D',
              target: Layers.BitMask,
              targetName: 'UI_2D'
            }]);
            legacyCC.CameraVisFlags = CameraVisFlags;
            var VisibilityFlags = exports('V', {});
            removeProperty(VisibilityFlags, 'VisibilityFlags', [{
              name: 'GENERAL'
            }]);
            replaceProperty(VisibilityFlags, 'VisibilityFlags', [{
              name: 'ALWALS',
              newName: 'ALWALS',
              target: Layers.Enum,
              targetName: 'ALWALS'
            }, {
              name: 'PROFILER',
              newName: 'PROFILER',
              target: Layers.Enum,
              targetName: 'PROFILER'
            }, {
              name: 'GIZMOS',
              newName: 'GIZMOS',
              target: Layers.Enum,
              targetName: 'GIZMOS'
            }, {
              name: 'EDITOR',
              newName: 'EDITOR',
              target: Layers.Enum,
              targetName: 'EDITOR'
            }, {
              name: 'UI',
              newName: 'UI',
              target: Layers.Enum,
              targetName: 'UI_3D'
            }, {
              name: 'UI2D',
              newName: 'UI2D',
              target: Layers.Enum,
              targetName: 'UI_2D'
            }]);
            legacyCC.VisibilityFlags = VisibilityFlags;
            replaceProperty(Pass.prototype, 'Pass.prototype', [{
              name: 'getBindingTypeFromHandle',
              newName: 'getDescriptorTypeFromHandle'
            }]);

            // Color temperature (in Kelvin) to RGB
            function ColorTemperatureToRGB(rgb, kelvin) {
              if (kelvin < 1000.0) {
                kelvin = 1000.0;
              } else if (kelvin > 15000.0) {
                kelvin = 15000.0;
              } // Approximate Planckian locus in CIE 1960 UCS


              var kSqr = kelvin * kelvin;
              var u = (0.860117757 + 1.54118254e-4 * kelvin + 1.28641212e-7 * kSqr) / (1.0 + 8.42420235e-4 * kelvin + 7.08145163e-7 * kSqr);
              var v = (0.317398726 + 4.22806245e-5 * kelvin + 4.20481691e-8 * kSqr) / (1.0 - 2.89741816e-5 * kelvin + 1.61456053e-7 * kSqr);
              var d = 2.0 * u - 8.0 * v + 4.0;
              var x = 3.0 * u / d;
              var y = 2.0 * v / d;
              var z = 1.0 - x - y;
              var X = 1.0 / y * x;
              var Z = 1.0 / y * z; // XYZ to RGB with BT.709 primaries

              rgb.x = 3.2404542 * X + -1.5371385 + -0.4985314 * Z;
              rgb.y = -0.9692660 * X + 1.8760108 + 0.0415560 * Z;
              rgb.z = 0.0556434 * X + -0.2040259 + 1.0572252 * Z;
            }
            var LightType;

            (function (LightType) {
              LightType[LightType["DIRECTIONAL"] = 0] = "DIRECTIONAL";
              LightType[LightType["SPHERE"] = 1] = "SPHERE";
              LightType[LightType["SPOT"] = 2] = "SPOT";
              LightType[LightType["UNKNOWN"] = 3] = "UNKNOWN";
            })(LightType || (LightType = exports('P', {})));

            var nt2lm = exports('Q', function nt2lm(size) {
              return 4 * Math.PI * Math.PI * size * size;
            });
            var Light = exports('T', /*#__PURE__*/function () {
              _createClass(Light, [{
                key: "color",
                set: function set(color) {
                  this._color.set(color);
                },
                get: function get() {
                  return this._color;
                }
              }, {
                key: "useColorTemperature",
                set: function set(enable) {
                  this._useColorTemp = enable;
                },
                get: function get() {
                  return this._useColorTemp;
                }
              }, {
                key: "colorTemperature",
                set: function set(val) {
                  this._colorTemp = val;
                  ColorTemperatureToRGB(this._colorTempRGB, this._colorTemp);
                },
                get: function get() {
                  return this._colorTemp;
                }
              }, {
                key: "colorTemperatureRGB",
                get: function get() {
                  return this._colorTempRGB;
                }
              }, {
                key: "node",
                set: function set(n) {
                  this._node = n;

                  if (this._node) {
                    this._node.hasChangedFlags |= TransformBit.ROTATION;
                  }
                },
                get: function get() {
                  return this._node;
                }
              }, {
                key: "type",
                get: function get() {
                  return this._type;
                }
              }, {
                key: "name",
                get: function get() {
                  return this._name;
                }
              }, {
                key: "scene",
                get: function get() {
                  return this._scene;
                }
              }]);

              function Light() {
                _classCallCheck(this, Light);

                this._color = new Vec3(1, 1, 1);
                this._useColorTemp = false;
                this._colorTemp = 6550.0;
                this._colorTempRGB = new Vec3(1, 1, 1);
                this._scene = null;
                this._node = null;
                this._type = void 0;
                this._name = null;
                this._type = LightType.UNKNOWN;
              }

              _createClass(Light, [{
                key: "initialize",
                value: function initialize(name, node) {
                  this._name = name;
                  this._type = LightType.UNKNOWN;
                  this._node = node;
                }
              }, {
                key: "attachToScene",
                value: function attachToScene(scene) {
                  this._scene = scene;
                }
              }, {
                key: "detachFromScene",
                value: function detachFromScene() {
                  this._scene = null;
                }
              }, {
                key: "destroy",
                value: function destroy() {
                  this._name = null;
                  this._type = LightType.UNKNOWN;
                  this._node = null;
                }
              }, {
                key: "update",
                value: function update() {}
              }]);

              return Light;
            }());

            var _forward = new Vec3(0, 0, -1);

            var _v3 = new Vec3();

            var _qt = new Quat();

            var DirectionalLight = exports('N', /*#__PURE__*/function (_Light) {
              _inherits(DirectionalLight, _Light);

              _createClass(DirectionalLight, [{
                key: "shadowRange",
                set: function set(shadowRange) {
                  this._shadowRange = shadowRange;
                },
                get: function get() {
                  return this._shadowRange;
                }
              }, {
                key: "shadowIntensitywRange",
                set: function set(shadowIntensity) {
                  this._shadowIntensity = shadowIntensity;
                }
              }, {
                key: "shadowIntensity",
                get: function get() {
                  return this._shadowIntensity;
                }
              }, {
                key: "shadowFadeDistance",
                set: function set(shadowFadeDistance) {
                  this._shadowFadeDistance = shadowFadeDistance;
                },
                get: function get() {
                  return this._shadowFadeDistance;
                }
              }, {
                key: "shadowDistance",
                set: function set(shadowDistance) {
                  this._shadowDistance = shadowDistance;
                },
                get: function get() {
                  return this._shadowDistance;
                }
              }, {
                key: "fadeStart",
                set: function set(fadeStart) {
                  this._fadeStart = fadeStart;
                },
                get: function get() {
                  return this._fadeStart;
                }
              }, {
                key: "splits",
                set: function set(splits) {
                  this._splits = splits;
                },
                get: function get() {
                  return this._splits;
                }
              }, {
                key: "biasAutoAdjust",
                set: function set(biasAutoAdjust) {
                  this._biasAutoAdjust = biasAutoAdjust;
                },
                get: function get() {
                  return this._biasAutoAdjust;
                }
              }, {
                key: "direction",
                set: function set(dir) {
                  this._dir = dir;
                  Vec3.normalize(this._dir, this._dir);
                },
                get: function get() {
                  return this._dir;
                } // in Lux(lx)

              }, {
                key: "illuminance",
                set: function set(illum) {
                  this._illum = illum;
                },
                get: function get() {
                  return this._illum;
                }
              }]);

              function DirectionalLight() {
                var _this;

                _classCallCheck(this, DirectionalLight);

                _this = _possibleConstructorReturn(this, _getPrototypeOf(DirectionalLight).call(this));
                _this._dir = new Vec3(1.0, -1.0, -1.0);
                _this._illum = Ambient.SUN_ILLUM;
                _this._shadowRange = 1000.0;
                _this._shadowIntensity = 0.0;
                _this._shadowFadeDistance = 0.0;
                _this._shadowDistance = 0.0;
                _this._fadeStart = 0.8;
                _this._splits = new Vec4(1.0, 0.0, 0.0, 0.0);
                _this._biasAutoAdjust = 1.0;
                _this._type = LightType.DIRECTIONAL;
                return _this;
              }

              _createClass(DirectionalLight, [{
                key: "update",
                value: function update() {
                  if (this._node && this._node.hasChangedFlags) {
                    this._dir = Vec3.transformQuat(_v3, _forward, this._node.getWorldRotation(_qt));
                    Vec3.normalize(this._dir, this._dir);
                  }
                }
              }]);

              return DirectionalLight;
            }(Light));

            var PipelineStateManager = exports('dX', /*#__PURE__*/function () {
              function PipelineStateManager() {
                _classCallCheck(this, PipelineStateManager);
              }

              _createClass(PipelineStateManager, null, [{
                key: "getOrCreatePipelineState",
                value: function getOrCreatePipelineState(device, hPass, shader, renderPass, ia) {
                  var hash1 = PassPool.get(hPass, PassView.HASH);
                  var hash2 = renderPass.hash;
                  var hash3 = ia.attributesHash;
                  var hash4 = shader.id;
                  var newHash = hash1 ^ hash2 ^ hash3 ^ hash4;

                  var pso = this._PSOHashMap.get(newHash);

                  if (!pso) {
                    var pipelineLayout = PipelineLayoutPool.get(PassPool.get(hPass, PassView.PIPELINE_LAYOUT));
                    var inputState = new GFXInputState();
                    inputState.attributes = ia.attributes;
                    pso = device.createPipelineState({
                      primitive: PassPool.get(hPass, PassView.PRIMITIVE),
                      rasterizerState: RasterizerStatePool.get(PassPool.get(hPass, PassView.RASTERIZER_STATE)),
                      depthStencilState: DepthStencilStatePool.get(PassPool.get(hPass, PassView.DEPTH_STENCIL_STATE)),
                      blendState: BlendStatePool.get(PassPool.get(hPass, PassView.BLEND_STATE)),
                      dynamicStates: PassPool.get(hPass, PassView.DYNAMIC_STATES),
                      inputState: inputState,
                      renderPass: renderPass,
                      shader: shader,
                      pipelineLayout: pipelineLayout
                    });

                    this._PSOHashMap.set(newHash, pso);
                  }

                  return pso;
                }
              }]);

              return PipelineStateManager;
            }());
            PipelineStateManager._PSOHashMap = new Map();

            var _forward$1 = new Vec3(0, 0, -1);

            var _v3$1 = new Vec3();

            var _ab = new aabb();

            var _qt$1 = new Quat();

            var _up = new Vec3(0, 1, 0);

            var _dir_negate = new Vec3();

            var _vec3_p = new Vec3();

            var _mat4_trans = new Mat4();
            /**
             * @zh 阴影类型。
             * @en The shadow type
             * @enum Shadows.ShadowType
             */


            var ShadowType = exports('X', Enum({
              /**
               * @zh 平面阴影。
               * @en Planar shadow
               * @property Planar
               * @readonly
               */
              Planar: 0,

              /**
               * @zh 阴影贴图。
               * @en Shadow type
               * @property ShadowMap
               * @readonly
               */
              ShadowMap: 1
            }));
            /**
             * @zh pcf阴影等级。
             * @en The pcf type
             * @static
             * @enum Shadows.ShadowType
             */

            var PCFType = exports('Y', Enum({
              /**
               * @zh x1 次采样
               * @en x1 times
               * @readonly
               */
              HARD: 0,

              /**
               * @zh x5 次采样
               * @en x5 times
               * @readonly
               */
              FILTER_X5: 1,

              /**
               * @zh x9 次采样
               * @en x9 times
               * @readonly
               */
              FILTER_X9: 2,

              /**
               * @zh x25 次采样
               * @en x25 times
               * @readonly
               */
              FILTER_X25: 3
            }));
            var Shadows = exports('Z', /*#__PURE__*/function () {
              function Shadows() {
                _classCallCheck(this, Shadows);

                this._enabled = false;
                this._type = ShadowType.Planar;
                this._normal = new Vec3(0, 1, 0);
                this._distance = 0;
                this._shadowColor = new Color(0, 0, 0, 76);
                this._matLight = new Mat4();
                this._data = Float32Array.from([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, // matLightPlaneProj
                0.0, 0.0, 0.0, 0.3 // shadowColor
                ]);
                this._record = new Map();
                this._pendingModels = [];
                this._material = null;
                this._instancingMaterial = null;
                this._device = null;
                this._globalDescriptorSet = null;
                this._dirty = true;
                this._sphere = new sphere(0.0, 0.0, 0.0, 0.01);
                this.near = 1;
                this.far = 30;
                this.aspect = 1;
                this.orthoSize = 1;
                this.size = new Vec2(512, 512);
                this.pcf = PCFType.HARD;
              }

              _createClass(Shadows, [{
                key: "activate",
                value: function activate() {
                  var pipeline = legacyCC.director.root.pipeline;
                  this._globalDescriptorSet = pipeline.descriptorSet;
                  this._data = pipeline.shadowUBO;
                  Color.toArray(this._data, this._shadowColor, UBOShadow.SHADOW_COLOR_OFFSET);

                  this._globalDescriptorSet.getBuffer(UBOShadow.BLOCK.binding).update(this._data);

                  if (this._type === ShadowType.ShadowMap) {
                    this._updatePipeline();
                  } else {
                    this._updatePlanarInfo();
                  }
                } // used to auto adapt

              }, {
                key: "getWorldMatrix",
                value: function getWorldMatrix(rotation, dir) {
                  Vec3.negate(_dir_negate, dir);

                  var distance = Math.sqrt(2) * this._sphere.radius;

                  Vec3.multiplyScalar(_vec3_p, _dir_negate, distance);
                  Vec3.add(_vec3_p, _vec3_p, this._sphere.center);
                  Mat4.fromRT(_mat4_trans, rotation, _vec3_p);
                  return _mat4_trans;
                }
              }, {
                key: "_updatePlanarInfo",
                value: function _updatePlanarInfo() {
                  this._dirty = true;

                  if (!this._material) {
                    this._material = new Material();

                    this._material.initialize({
                      effectName: 'pipeline/planar-shadow'
                    });
                  }

                  if (!this._instancingMaterial) {
                    this._instancingMaterial = new Material();

                    this._instancingMaterial.initialize({
                      effectName: 'pipeline/planar-shadow',
                      defines: {
                        USE_INSTANCING: true
                      }
                    });
                  }
                }
              }, {
                key: "_updatePipeline",
                value: function _updatePipeline() {
                  var root = legacyCC.director.root;
                  var pipeline = root.pipeline;
                  var enable = this._enabled && this._type === ShadowType.ShadowMap;

                  if (enable) {
                    delete pipeline.macros.CC_RECEIVE_SHADOW;
                  } else {
                    pipeline.macros.CC_RECEIVE_SHADOW = false;
                  }

                  root.onGlobalPipelineStateChanged();
                }
              }, {
                key: "updateSphereLight",
                value: function updateSphereLight(light) {
                  if (!light.node.hasChangedFlags && !this._dirty) {
                    return;
                  }

                  this._dirty = false;
                  light.node.getWorldPosition(_v3$1);
                  var n = this._normal;
                  var d = this._distance + 0.001; // avoid z-fighting

                  var NdL = Vec3.dot(n, _v3$1);
                  var lx = _v3$1.x;
                  var ly = _v3$1.y;
                  var lz = _v3$1.z;
                  var nx = n.x;
                  var ny = n.y;
                  var nz = n.z;
                  var m = this._matLight;
                  m.m00 = NdL - d - lx * nx;
                  m.m01 = -ly * nx;
                  m.m02 = -lz * nx;
                  m.m03 = -nx;
                  m.m04 = -lx * ny;
                  m.m05 = NdL - d - ly * ny;
                  m.m06 = -lz * ny;
                  m.m07 = -ny;
                  m.m08 = -lx * nz;
                  m.m09 = -ly * nz;
                  m.m10 = NdL - d - lz * nz;
                  m.m11 = -nz;
                  m.m12 = lx * d;
                  m.m13 = ly * d;
                  m.m14 = lz * d;
                  m.m15 = NdL;
                  Mat4.toArray(this._data, this._matLight, UBOShadow.MAT_LIGHT_PLANE_PROJ_OFFSET);

                  this._globalDescriptorSet.getBuffer(UBOShadow.BLOCK.binding).update(this.data);
                }
              }, {
                key: "updateDirLight",
                value: function updateDirLight(light) {
                  if (!light.node.hasChangedFlags && !this._dirty) {
                    return;
                  }

                  this._dirty = false;
                  light.node.getWorldRotation(_qt$1);
                  Vec3.transformQuat(_v3$1, _forward$1, _qt$1);
                  var n = this._normal;
                  var d = this._distance + 0.001; // avoid z-fighting

                  var NdL = Vec3.dot(n, _v3$1);
                  var scale = 1 / NdL;
                  var lx = _v3$1.x * scale;
                  var ly = _v3$1.y * scale;
                  var lz = _v3$1.z * scale;
                  var nx = n.x;
                  var ny = n.y;
                  var nz = n.z;
                  var m = this._matLight;
                  m.m00 = 1 - nx * lx;
                  m.m01 = -nx * ly;
                  m.m02 = -nx * lz;
                  m.m03 = 0;
                  m.m04 = -ny * lx;
                  m.m05 = 1 - ny * ly;
                  m.m06 = -ny * lz;
                  m.m07 = 0;
                  m.m08 = -nz * lx;
                  m.m09 = -nz * ly;
                  m.m10 = 1 - nz * lz;
                  m.m11 = 0;
                  m.m12 = lx * d;
                  m.m13 = ly * d;
                  m.m14 = lz * d;
                  m.m15 = 1;
                  Mat4.toArray(this._data, this._matLight, UBOShadow.MAT_LIGHT_PLANE_PROJ_OFFSET);

                  this._globalDescriptorSet.getBuffer(UBOShadow.BLOCK.binding).update(this.data);
                }
              }, {
                key: "updateShadowList",
                value: function updateShadowList(scene, frstm) {
                  var shadowVisible = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
                  this._pendingModels.length = 0;

                  if (!scene.mainLight || !shadowVisible) {
                    return;
                  }

                  var models = scene.models;

                  for (var i = 0; i < models.length; i++) {
                    var model = models[i];

                    if (!model.enabled || !model.node || !model.castShadow) {
                      continue;
                    }

                    if (model.worldBounds) {
                      aabb.transform(_ab, model.worldBounds, this._matLight);

                      if (!intersect.aabb_frustum(_ab, frstm)) {
                        continue;
                      }
                    }

                    var data = this._record.get(model);

                    if (data && !!data.instancedBuffer !== model.isInstancingEnabled) {
                      this.destroyShadowData(model);
                      data = undefined;
                    }

                    if (!data) {
                      data = this.createShadowData(model);

                      this._record.set(model, data);
                    }

                    this._pendingModels.push(data);
                  }
                }
              }, {
                key: "recordCommandBuffer",
                value: function recordCommandBuffer(device, renderPass, cmdBuff) {
                  this._device = device;
                  var models = this._pendingModels;
                  var modelLen = models.length;

                  if (!modelLen) {
                    return;
                  }

                  var buffer = InstancedBuffer.get(this._instancingMaterial.passes[0]);

                  if (buffer) {
                    buffer.clear();
                  }

                  var hPass = this._material.passes[0].handle;
                  var descriptorSet = DSPool.get(PassPool.get(hPass, PassView.DESCRIPTOR_SET));
                  cmdBuff.bindDescriptorSet(SetIndex.MATERIAL, descriptorSet);

                  for (var i = 0; i < modelLen; i++) {
                    var _models$i = models[i],
                        model = _models$i.model,
                        shaders = _models$i.hShaders,
                        instancedBuffer = _models$i.instancedBuffer;

                    for (var j = 0; j < shaders.length; j++) {
                      var subModel = model.subModels[j];
                      var hShader = shaders[j];

                      if (instancedBuffer) {
                        instancedBuffer.merge(subModel, model.instancedAttributes, 0, hShader);
                      } else {
                        var ia = subModel.inputAssembler;
                        var shader = ShaderPool.get(hShader);
                        var pso = PipelineStateManager.getOrCreatePipelineState(device, hPass, shader, renderPass, ia);
                        cmdBuff.bindPipelineState(pso);
                        cmdBuff.bindDescriptorSet(SetIndex.LOCAL, subModel.descriptorSet);
                        cmdBuff.bindInputAssembler(ia);
                        cmdBuff.draw(ia);
                      }
                    }
                  }

                  if (buffer && buffer.hasPendingModels) {
                    buffer.uploadBuffers();
                    descriptorSet = DSPool.get(PassPool.get(buffer.hPass, PassView.DESCRIPTOR_SET));
                    cmdBuff.bindDescriptorSet(SetIndex.MATERIAL, descriptorSet);
                    var lastPSO = null;

                    for (var b = 0; b < buffer.instances.length; ++b) {
                      var instance = buffer.instances[b];

                      if (!instance.count) {
                        continue;
                      }

                      var _shader = ShaderPool.get(instance.hShader);

                      var _pso = PipelineStateManager.getOrCreatePipelineState(device, buffer.hPass, _shader, renderPass, instance.ia);

                      if (lastPSO !== _pso) {
                        cmdBuff.bindPipelineState(_pso);
                        cmdBuff.bindDescriptorSet(SetIndex.LOCAL, DSPool.get(instance.hDescriptorSet));
                        lastPSO = _pso;
                      }

                      cmdBuff.bindInputAssembler(instance.ia);
                      cmdBuff.draw(instance.ia);
                    }
                  }
                }
              }, {
                key: "createShadowData",
                value: function createShadowData(model) {
                  var hShaders = [];
                  var material = model.isInstancingEnabled ? this._instancingMaterial : this._material;
                  var instancedBuffer = model.isInstancingEnabled ? InstancedBuffer.get(material.passes[0]) : null;
                  var subModels = model.subModels;

                  for (var i = 0; i < subModels.length; i++) {
                    var hShader = material.passes[0].getShaderVariant(model.getMacroPatches(i));
                    hShaders.push(hShader);
                  }

                  return {
                    model: model,
                    hShaders: hShaders,
                    instancedBuffer: instancedBuffer
                  };
                }
              }, {
                key: "destroyShadowData",
                value: function destroyShadowData(model) {
                  this._record["delete"](model);
                }
              }, {
                key: "destroy",
                value: function destroy() {
                  this._record.clear();

                  if (this._material) {
                    this._material.destroy();
                  }
                }
              }, {
                key: "enabled",

                /**
                 * @en Whether activate planar shadow
                 * @zh 是否启用平面阴影？
                 */
                get: function get() {
                  return this._enabled;
                },
                set: function set(val) {
                  if (this._enabled === val) {
                    return;
                  }

                  this._enabled = val;
                  this._dirty = true;
                  this._enabled ? this.activate() : this._updatePipeline();
                }
                /**
                 * @en The normal of the plane which receives shadow
                 * @zh 阴影接收平面的法线
                 */

              }, {
                key: "normal",
                get: function get() {
                  return this._normal;
                },
                set: function set(val) {
                  Vec3.copy(this._normal, val);
                  this._dirty = true;
                }
                /**
                 * @en The distance from coordinate origin to the receiving plane.
                 * @zh 阴影接收平面与原点的距离
                 */

              }, {
                key: "distance",
                get: function get() {
                  return this._distance;
                },
                set: function set(val) {
                  this._distance = val;
                  this._dirty = true;
                }
                /**
                 * @en Shadow color
                 * @zh 阴影颜色
                 */

              }, {
                key: "shadowColor",
                get: function get() {
                  return this._shadowColor;
                },
                set: function set(color) {
                  this._shadowColor = color;

                  if (this._enabled) {
                    Color.toArray(this._data, color, UBOShadow.SHADOW_COLOR_OFFSET);

                    if (this._globalDescriptorSet) {
                      this._globalDescriptorSet.getBuffer(UBOShadow.BLOCK.binding).update(this.data);
                    }
                  }

                  this._dirty = true;
                }
                /**
                 * @en Shadow type
                 * @zh 阴影类型
                 */

              }, {
                key: "type",
                get: function get() {
                  return this._enabled ? this._type : -1;
                },
                set: function set(val) {
                  this._type = val;

                  this._updatePipeline();

                  this._updatePlanarInfo();
                }
              }, {
                key: "matLight",
                get: function get() {
                  return this._matLight;
                }
              }, {
                key: "data",
                get: function get() {
                  return this._data;
                }
              }, {
                key: "sphere",
                get: function get() {
                  return this._sphere;
                }
              }]);

              return Shadows;
            }());

            /*
             Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

             http://www.cocos.com

             Permission is hereby granted, free of charge, to any person obtaining a copy
             of this software and associated engine source code (the "Software"), a limited,
              worldwide, royalty-free, non-assignable, revocable and non-exclusive license
             to use Cocos Creator solely to develop games on your target platforms. You shall
              not use Cocos Creator software for developing other software or tools that's
              used for developing games. You are not granted to publish, distribute,
              sublicense, and/or sell copies of Cocos Creator.

             The software or tools in this License Agreement are licensed, not sold.
             Xiamen Yaji Software Co., Ltd. reserves all rights not expressly granted to you.

             THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
             THE SOFTWARE.
            */
            /**
             * @en Finds a node by hierarchy path, the path is case-sensitive.
             * It will traverse the hierarchy by splitting the path using '/' character.
             * This function will still returns the node even if it is inactive.
             * It is recommended to not use this function every frame instead cache the result at startup.
             * @zh 通过路径从节点树中查找节点的方法，路径是大小写敏感的，并且通过 `/` 来分隔节点层级。
             * 即使节点的状态是未启用的也可以找到，建议将结果缓存，而不是每次需要都去查找。
             * @param path The path of the target node
             * @param referenceNode If given, the search will be limited in the sub node tree of the reference node
             */

            function find(path, referenceNode) {
              if (!referenceNode) {
                var scene = legacyCC.director.getScene();

                if (!scene) {

                  return null;
                }

                referenceNode = scene;
              }

              return referenceNode.getChildByPath(path);
            }
            legacyCC.find = find;

            var _keyMap;

            (function (_keyMap) {
              _keyMap[_keyMap["positions"] = GFXAttributeName.ATTR_POSITION] = "positions";
              _keyMap[_keyMap["normals"] = GFXAttributeName.ATTR_NORMAL] = "normals";
              _keyMap[_keyMap["uvs"] = GFXAttributeName.ATTR_TEX_COORD] = "uvs";
              _keyMap[_keyMap["colors"] = GFXAttributeName.ATTR_COLOR] = "colors";
            })(_keyMap || (_keyMap = {}));

            function readMesh(mesh) {
              var iPrimitive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              var out = {
                positions: []
              };
              var dataView = new DataView(mesh.data.buffer, mesh.data.byteOffset, mesh.data.byteLength);
              var struct = mesh.struct;
              var primitive = struct.primitives[iPrimitive];

              for (var _iterator = _createForOfIteratorHelperLoose(primitive.vertexBundelIndices), _step; !(_step = _iterator()).done;) {
                var idx = _step.value;
                var bundle = struct.vertexBundles[idx];
                var offset = bundle.view.offset;
                var _bundle$view = bundle.view,
                    length = _bundle$view.length,
                    stride = _bundle$view.stride;

                for (var _iterator2 = _createForOfIteratorHelperLoose(bundle.attributes), _step2; !(_step2 = _iterator2()).done;) {
                  var attr = _step2.value;
                  var name = _keyMap[attr.name];

                  if (name) {
                    out[name] = (out[name] || []).concat(readBuffer(dataView, attr.format, offset, length, stride));
                  }

                  offset += GFXFormatInfos[attr.format].size;
                }
              }

              var view = primitive.indexView;
              out.indices = readBuffer(dataView, GFXFormat["R".concat(view.stride * 8, "UI")], view.offset, view.length);
              return out;
            }

            var _defAttrs = [{
              name: GFXAttributeName.ATTR_POSITION,
              format: GFXFormat.RGB32F
            }, {
              name: GFXAttributeName.ATTR_NORMAL,
              format: GFXFormat.RGB32F
            }, {
              name: GFXAttributeName.ATTR_TEX_COORD,
              format: GFXFormat.RG32F
            }, {
              name: GFXAttributeName.ATTR_TANGENT,
              format: GFXFormat.RGBA32F
            }, {
              name: GFXAttributeName.ATTR_COLOR,
              format: GFXFormat.RGBA32F
            }];
            var v3_1$3 = new Vec3();
            function createMesh(geometry, out, options) {
              options = options || {}; // Collect attributes and calculate length of result vertex buffer.

              var attributes = [];
              var stride = 0;
              var channels = [];
              var vertCount = 0;
              var attr;
              var positions = geometry.positions.slice();

              if (positions.length > 0) {
                attr = null;

                if (geometry.attributes) {
                  for (var _iterator = _createForOfIteratorHelperLoose(geometry.attributes), _step; !(_step = _iterator()).done;) {
                    var att = _step.value;

                    if (att.name === GFXAttributeName.ATTR_POSITION) {
                      attr = att;
                      break;
                    }
                  }
                }

                if (!attr) {
                  attr = _defAttrs[0];
                }

                attributes.push(attr);
                var info = GFXFormatInfos[attr.format];
                vertCount = Math.max(vertCount, Math.floor(positions.length / info.count));
                channels.push({
                  offset: stride,
                  data: positions,
                  attribute: attr
                });
                stride += info.size;
              }

              if (geometry.normals && geometry.normals.length > 0) {
                attr = null;

                if (geometry.attributes) {
                  for (var _iterator2 = _createForOfIteratorHelperLoose(geometry.attributes), _step2; !(_step2 = _iterator2()).done;) {
                    var _att = _step2.value;

                    if (_att.name === GFXAttributeName.ATTR_NORMAL) {
                      attr = _att;
                      break;
                    }
                  }
                }

                if (!attr) {
                  attr = _defAttrs[1];
                }

                var _info = GFXFormatInfos[attr.format];
                attributes.push(attr);
                vertCount = Math.max(vertCount, Math.floor(geometry.normals.length / _info.count));
                channels.push({
                  offset: stride,
                  data: geometry.normals,
                  attribute: attr
                });
                stride += _info.size;
              }

              if (geometry.uvs && geometry.uvs.length > 0) {
                attr = null;

                if (geometry.attributes) {
                  for (var _iterator3 = _createForOfIteratorHelperLoose(geometry.attributes), _step3; !(_step3 = _iterator3()).done;) {
                    var _att2 = _step3.value;

                    if (_att2.name === GFXAttributeName.ATTR_TEX_COORD) {
                      attr = _att2;
                      break;
                    }
                  }
                }

                if (!attr) {
                  attr = _defAttrs[2];
                }

                var _info2 = GFXFormatInfos[attr.format];
                attributes.push(attr);
                vertCount = Math.max(vertCount, Math.floor(geometry.uvs.length / _info2.count));
                channels.push({
                  offset: stride,
                  data: geometry.uvs,
                  attribute: attr
                });
                stride += _info2.size;
              }

              if (geometry.tangents && geometry.tangents.length > 0) {
                attr = null;

                if (geometry.attributes) {
                  for (var _iterator4 = _createForOfIteratorHelperLoose(geometry.attributes), _step4; !(_step4 = _iterator4()).done;) {
                    var _att3 = _step4.value;

                    if (_att3.name === GFXAttributeName.ATTR_TANGENT) {
                      attr = _att3;
                      break;
                    }
                  }
                }

                if (!attr) {
                  attr = _defAttrs[3];
                }

                var _info3 = GFXFormatInfos[attr.format];
                attributes.push(attr);
                vertCount = Math.max(vertCount, Math.floor(geometry.tangents.length / _info3.count));
                channels.push({
                  offset: stride,
                  data: geometry.tangents,
                  attribute: attr
                });
                stride += _info3.size;
              }

              if (geometry.colors && geometry.colors.length > 0) {
                attr = null;

                if (geometry.attributes) {
                  for (var _iterator5 = _createForOfIteratorHelperLoose(geometry.attributes), _step5; !(_step5 = _iterator5()).done;) {
                    var _att4 = _step5.value;

                    if (_att4.name === GFXAttributeName.ATTR_COLOR) {
                      attr = _att4;
                      break;
                    }
                  }
                }

                if (!attr) {
                  attr = _defAttrs[4];
                }

                var _info4 = GFXFormatInfos[attr.format];
                attributes.push(attr);
                vertCount = Math.max(vertCount, Math.floor(geometry.colors.length / _info4.count));
                channels.push({
                  offset: stride,
                  data: geometry.colors,
                  attribute: attr
                });
                stride += _info4.size;
              }

              if (geometry.customAttributes) {
                for (var _iterator6 = _createForOfIteratorHelperLoose(geometry.customAttributes), _step6; !(_step6 = _iterator6()).done;) {
                  var ca = _step6.value;
                  var _info5 = GFXFormatInfos[ca.attr.format];
                  attributes.push(ca.attr);
                  vertCount = Math.max(vertCount, Math.floor(ca.values.length / _info5.count));
                  channels.push({
                    offset: stride,
                    data: ca.values,
                    attribute: ca.attr
                  });
                  stride += _info5.size;
                }
              } // Use this to generate final merged buffer.


              var bufferBlob = new BufferBlob(); // Fill vertex buffer.

              var vertexBuffer = new ArrayBuffer(vertCount * stride);
              var vertexBufferView = new DataView(vertexBuffer);

              for (var _i = 0, _channels = channels; _i < _channels.length; _i++) {
                var channel = _channels[_i];
                writeBuffer(vertexBufferView, channel.data, channel.attribute.format, channel.offset, stride);
              }

              bufferBlob.setNextAlignment(0);
              var vertexBundle = {
                attributes: attributes,
                view: {
                  offset: bufferBlob.getLength(),
                  length: vertexBuffer.byteLength,
                  count: vertCount,
                  stride: stride
                }
              };
              bufferBlob.addBuffer(vertexBuffer); // Fill index buffer.

              var indexBuffer = null;
              var idxCount = 0;
              var idxStride = 2;

              if (geometry.indices) {
                var indices = geometry.indices;
                idxCount = indices.length;
                indexBuffer = new ArrayBuffer(idxStride * idxCount);
                var indexBufferView = new DataView(indexBuffer);
                writeBuffer(indexBufferView, indices, GFXFormat.R16UI);
              } // Create primitive.


              var primitive = {
                primitiveMode: geometry.primitiveMode || GFXPrimitiveMode.TRIANGLE_LIST,
                vertexBundelIndices: [0]
              };

              if (indexBuffer) {
                bufferBlob.setNextAlignment(idxStride);
                primitive.indexView = {
                  offset: bufferBlob.getLength(),
                  length: indexBuffer.byteLength,
                  count: idxCount,
                  stride: idxStride
                };
                bufferBlob.addBuffer(indexBuffer);
              }

              var minPosition = geometry.minPos;

              if (!minPosition && options.calculateBounds) {
                minPosition = Vec3.set(new Vec3(), Infinity, Infinity, Infinity);

                for (var iVertex = 0; iVertex < vertCount; ++iVertex) {
                  Vec3.set(v3_1$3, positions[iVertex * 3 + 0], positions[iVertex * 3 + 1], positions[iVertex * 3 + 2]);
                  Vec3.min(minPosition, minPosition, v3_1$3);
                }
              }

              var maxPosition = geometry.maxPos;

              if (!maxPosition && options.calculateBounds) {
                maxPosition = Vec3.set(new Vec3(), -Infinity, -Infinity, -Infinity);

                for (var _iVertex = 0; _iVertex < vertCount; ++_iVertex) {
                  Vec3.set(v3_1$3, positions[_iVertex * 3 + 0], positions[_iVertex * 3 + 1], positions[_iVertex * 3 + 2]);
                  Vec3.max(maxPosition, maxPosition, v3_1$3);
                }
              } // Create mesh struct.


              var meshStruct = {
                vertexBundles: [vertexBundle],
                primitives: [primitive]
              };

              if (minPosition) {
                meshStruct.minPosition = new Vec3(minPosition.x, minPosition.y, minPosition.z);
              }

              if (maxPosition) {
                meshStruct.maxPosition = new Vec3(maxPosition.x, maxPosition.y, maxPosition.z);
              } // Create mesh.


              if (!out) {
                out = new Mesh();
              }

              out.reset({
                struct: meshStruct,
                data: new Uint8Array(bufferBlob.getCombined())
              });
              return out;
            }

            /**
             * @category 3d/primitive
             */

            /**
             * @en
             * The definition of the parameter for building a primitive geometry.
             * @zh
             * 几何体参数选项。
             */

            /**
             * @en
             * Apply the options to default.
             * @zh
             * 应用默认的几何参数选项。
             */
            function applyDefaultGeometryOptions(options) {
              options = options || {};

              if (options.includeNormal === undefined) {
                options.includeNormal = true;
              }

              if (options.includeUV === undefined) {
                options.includeUV = true;
              }

              return options;
            }
            /**
             * @en
             * The definition of the geometry, this struct can build a mesh.
             * @zh
             * 几何体信息。
             */

            /**
             * @category 3d/primitive
             */

            /**
             * @en
             * This function generates a box with specified extents and centered at origin,
             * but may be repositioned through the `center` option.
             * @zh
             * 生成一个立方体，其大小是定义的范围且中心在原点。
             * @param options 参数选项。
             */
            function box(options) {
              options = options || {};
              var ws = options.widthSegments || 1;
              var hs = options.heightSegments || 1;
              var ls = options.lengthSegments || 1;
              var hw = (options.width || 1) / 2;
              var hh = (options.height || 1) / 2;
              var hl = (options.length || 1) / 2;
              var corners = [Vec3.set(c0, -hw, -hh, hl), Vec3.set(c1, hw, -hh, hl), Vec3.set(c2, hw, hh, hl), Vec3.set(c3, -hw, hh, hl), Vec3.set(c4, hw, -hh, -hl), Vec3.set(c5, -hw, -hh, -hl), Vec3.set(c6, -hw, hh, -hl), Vec3.set(c7, hw, hh, -hl)];
              var faceAxes = [[2, 3, 1], // FRONT
              [4, 5, 7], // BACK
              [7, 6, 2], // TOP
              [1, 0, 4], // BOTTOM
              [1, 4, 2], // RIGHT
              [5, 0, 6] // LEFT
              ];
              var faceNormals = [[0, 0, 1], // FRONT
              [0, 0, -1], // BACK
              [0, 1, 0], // TOP
              [0, -1, 0], // BOTTOM
              [1, 0, 0], // RIGHT
              [-1, 0, 0] // LEFT
              ];
              var faceTangents = [[-1, 0, 0, 1], // FRONT
              [-1, 0, 0, 1], // BACK
              [-1, 0, 0, 1], // TOP
              [-1, 0, 0, 1], // BOTTOM
              [0, 0, -1, 1], // RIGHT
              [0, 0, 1, 1] // LEFT
              ];
              var positions = [];
              var normals = [];
              var uvs = [];
              var tangents = [];
              var indices = [];
              var minPos = new Vec3(-hw, -hh, -hl);
              var maxPos = new Vec3(hw, hh, hl);
              var boundingRadius = Math.sqrt(hw * hw + hh * hh + hl * hl);

              function _buildPlane(side, uSegments, vSegments) {
                var u;
                var v;
                var ix;
                var iy;
                var offset = positions.length / 3;
                var faceAxe = faceAxes[side];
                var faceNormal = faceNormals[side];
                var faceTangent = faceTangents[side];

                for (iy = 0; iy <= vSegments; iy++) {
                  for (ix = 0; ix <= uSegments; ix++) {
                    u = ix / uSegments;
                    v = iy / vSegments;
                    Vec3.lerp(temp1, corners[faceAxe[0]], corners[faceAxe[1]], u);
                    Vec3.lerp(temp2, corners[faceAxe[0]], corners[faceAxe[2]], v);
                    Vec3.subtract(temp3, temp2, corners[faceAxe[0]]);
                    Vec3.add(r, temp1, temp3);
                    positions.push(r.x, r.y, r.z);
                    normals.push(faceNormal[0], faceNormal[1], faceNormal[2]);
                    uvs.push(u, v);
                    tangents.push(faceTangent[0], faceTangent[1], faceTangent[2], faceTangent[3]);

                    if (ix < uSegments && iy < vSegments) {
                      var useg1 = uSegments + 1;
                      var a = ix + iy * useg1;
                      var b = ix + (iy + 1) * useg1;
                      var c = ix + 1 + (iy + 1) * useg1;
                      var d = ix + 1 + iy * useg1;
                      indices.push(offset + a, offset + d, offset + b);
                      indices.push(offset + b, offset + d, offset + c);
                    }
                  }
                }
              }

              _buildPlane(0, ws, hs); // FRONT


              _buildPlane(4, ls, hs); // RIGHT


              _buildPlane(1, ws, hs); // BACK


              _buildPlane(5, ls, hs); // LEFT


              _buildPlane(3, ws, ls); // BOTTOM


              _buildPlane(2, ws, ls); // TOP


              return {
                positions: positions,
                normals: normals,
                uvs: uvs,
                tangents: tangents,
                indices: indices,
                minPos: minPos,
                maxPos: maxPos,
                boundingRadius: boundingRadius
              };
            }
            var temp1 = new Vec3();
            var temp2 = new Vec3();
            var temp3 = new Vec3();
            var r = new Vec3();
            var c0 = new Vec3();
            var c1 = new Vec3();
            var c2 = new Vec3();
            var c3 = new Vec3();
            var c4 = new Vec3();
            var c5 = new Vec3();
            var c6 = new Vec3();
            var c7 = new Vec3();

            /**
             * @category 3d/primitive
             */
            var temp1$1 = new Vec3(0, 0, 0);
            var temp2$1 = new Vec3(0, 0, 0);
            /**
             * @en
             * Generate a cylinder with radiusTop radiusBottom 0.5, height 2 and centered at origin,
             * but may be repositioned through the `center` option.
             * @zh
             * 生成一个圆柱。
             * @param radiusTop 顶部半径。
             * @param radiusBottom 底部半径。
             * @param opts 圆柱参数选项。
             */

            function cylinder() {
              var radiusTop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.5;
              var radiusBottom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;
              var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;
              var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
              var halfHeight = height * 0.5;
              var radialSegments = opts.radialSegments || 32;
              var heightSegments = opts.heightSegments || 1;
              var capped = opts.capped !== undefined ? opts.capped : true;
              var arc = opts.arc || 2.0 * Math.PI;
              var cntCap = 0;

              if (!capped) {
                if (radiusTop > 0) {
                  cntCap++;
                }

                if (radiusBottom > 0) {
                  cntCap++;
                }
              } // calculate vertex count


              var vertCount = (radialSegments + 1) * (heightSegments + 1);

              if (capped) {
                vertCount += (radialSegments + 1) * cntCap + radialSegments * cntCap;
              } // calculate index count


              var indexCount = radialSegments * heightSegments * 2 * 3;

              if (capped) {
                indexCount += radialSegments * cntCap * 3;
              }

              var indices = new Array(indexCount);
              var positions = new Array(vertCount * 3);
              var normals = new Array(vertCount * 3);
              var uvs = new Array(vertCount * 2);
              var maxRadius = Math.max(radiusTop, radiusBottom);
              var minPos = new Vec3(-maxRadius, -halfHeight, -maxRadius);
              var maxPos = new Vec3(maxRadius, halfHeight, maxRadius);
              var boundingRadius = Math.sqrt(maxRadius * maxRadius + halfHeight * halfHeight);
              var index = 0;
              var indexOffset = 0;
              generateTorso();

              if (capped) {
                if (radiusBottom > 0) {
                  generateCap(false);
                }

                if (radiusTop > 0) {
                  generateCap(true);
                }
              }

              return {
                positions: positions,
                normals: normals,
                uvs: uvs,
                indices: indices,
                minPos: minPos,
                maxPos: maxPos,
                boundingRadius: boundingRadius
              }; // =======================
              // internal fucntions
              // =======================

              function generateTorso() {
                var indexArray = []; // this will be used to calculate the normal

                var r = radiusTop - radiusBottom;
                var slope = r * r / height * Math.sign(r); // generate positions, normals and uvs

                for (var y = 0; y <= heightSegments; y++) {
                  var indexRow = [];
                  var v = y / heightSegments; // calculate the radius of the current row

                  var radius = v * r + radiusBottom;

                  for (var x = 0; x <= radialSegments; ++x) {
                    var u = x / radialSegments;
                    var theta = u * arc;
                    var sinTheta = Math.sin(theta);
                    var cosTheta = Math.cos(theta); // vertex

                    positions[3 * index] = radius * sinTheta;
                    positions[3 * index + 1] = v * height - halfHeight;
                    positions[3 * index + 2] = radius * cosTheta; // normal

                    Vec3.normalize(temp1$1, Vec3.set(temp2$1, sinTheta, -slope, cosTheta));
                    normals[3 * index] = temp1$1.x;
                    normals[3 * index + 1] = temp1$1.y;
                    normals[3 * index + 2] = temp1$1.z; // uv

                    uvs[2 * index] = (1 - u) * 2 % 1;
                    uvs[2 * index + 1] = v; // save index of vertex in respective row

                    indexRow.push(index); // increase index

                    ++index;
                  } // now save positions of the row in our index array


                  indexArray.push(indexRow);
                } // generate indices


                for (var _y = 0; _y < heightSegments; ++_y) {
                  for (var _x = 0; _x < radialSegments; ++_x) {
                    // we use the index array to access the correct indices
                    var i1 = indexArray[_y][_x];
                    var i2 = indexArray[_y + 1][_x];
                    var i3 = indexArray[_y + 1][_x + 1];
                    var i4 = indexArray[_y][_x + 1]; // face one

                    indices[indexOffset] = i1;
                    ++indexOffset;
                    indices[indexOffset] = i4;
                    ++indexOffset;
                    indices[indexOffset] = i2;
                    ++indexOffset; // face two

                    indices[indexOffset] = i4;
                    ++indexOffset;
                    indices[indexOffset] = i3;
                    ++indexOffset;
                    indices[indexOffset] = i2;
                    ++indexOffset;
                  }
                }
              }

              function generateCap(top) {
                var radius = top ? radiusTop : radiusBottom;
                var sign = top ? 1 : -1; // save the index of the first center vertex

                var centerIndexStart = index; // first we generate the center vertex data of the cap.
                // because the geometry needs one set of uvs per face,
                // we must generate a center vertex per face/segment

                for (var x = 1; x <= radialSegments; ++x) {
                  // vertex
                  positions[3 * index] = 0;
                  positions[3 * index + 1] = halfHeight * sign;
                  positions[3 * index + 2] = 0; // normal

                  normals[3 * index] = 0;
                  normals[3 * index + 1] = sign;
                  normals[3 * index + 2] = 0; // uv

                  uvs[2 * index] = 0.5;
                  uvs[2 * index + 1] = 0.5; // increase index

                  ++index;
                } // save the index of the last center vertex


                var centerIndexEnd = index; // now we generate the surrounding positions, normals and uvs

                for (var _x2 = 0; _x2 <= radialSegments; ++_x2) {
                  var u = _x2 / radialSegments;
                  var theta = u * arc;
                  var cosTheta = Math.cos(theta);
                  var sinTheta = Math.sin(theta); // vertex

                  positions[3 * index] = radius * sinTheta;
                  positions[3 * index + 1] = halfHeight * sign;
                  positions[3 * index + 2] = radius * cosTheta; // normal

                  normals[3 * index] = 0;
                  normals[3 * index + 1] = sign;
                  normals[3 * index + 2] = 0; // uv

                  uvs[2 * index] = 0.5 - sinTheta * 0.5 * sign;
                  uvs[2 * index + 1] = 0.5 + cosTheta * 0.5; // increase index

                  ++index;
                } // generate indices


                for (var _x3 = 0; _x3 < radialSegments; ++_x3) {
                  var c = centerIndexStart + _x3;
                  var i = centerIndexEnd + _x3;

                  if (top) {
                    // face top
                    indices[indexOffset] = i + 1;
                    ++indexOffset;
                    indices[indexOffset] = c;
                    ++indexOffset;
                    indices[indexOffset] = i;
                    ++indexOffset;
                  } else {
                    // face bottom
                    indices[indexOffset] = c;
                    ++indexOffset;
                    indices[indexOffset] = i + 1;
                    ++indexOffset;
                    indices[indexOffset] = i;
                    ++indexOffset;
                  }
                }
              }
            }

            /**
             * @category 3d/primitive
             */
            /**
             * @en
             * The definition of the parameter for building a plane.
             * @zh
             * 平面参数选项。
             */

            /**
             * @zh
             * 应用默认的平面参数选项。
             * @param options 平面参数选项。
             */
            function applyDefaultPlaneOptions(options) {
              options = applyDefaultGeometryOptions(options);
              options.width = options.width || 10;
              options.length = options.length || 10;
              options.widthSegments = options.widthSegments || 10;
              options.lengthSegments = options.lengthSegments || 10;
              return options;
            }

            var temp1$2 = new Vec3(0, 0, 0);
            var temp2$2 = new Vec3(0, 0, 0);
            var temp3$1 = new Vec3(0, 0, 0);
            var r$1 = new Vec3(0, 0, 0);
            var c00 = new Vec3(0, 0, 0);
            var c10 = new Vec3(0, 0, 0);
            var c01 = new Vec3(0, 0, 0);
            /**
             * @en
             * This function generates a plane on XOZ plane with positive Y direction.
             * @zh
             * 生成一个平面，其位于XOZ平面，方向为Y轴正方向。
             * @param options 平面参数选项。
             */

            function plane$1(options) {
              var normalizedOptions = applyDefaultPlaneOptions(options);
              var width = normalizedOptions.width,
                  length = normalizedOptions.length,
                  uSegments = normalizedOptions.widthSegments,
                  vSegments = normalizedOptions.lengthSegments;
              var hw = width * 0.5;
              var hl = length * 0.5;
              var positions = [];
              var uvs = [];
              var indices = [];
              var minPos = new Vec3(-hw, 0, -hl);
              var maxPos = new Vec3(hw, 0, hl);
              var boundingRadius = Math.sqrt(width * width + length * length);
              Vec3.set(c00, -hw, 0, hl);
              Vec3.set(c10, hw, 0, hl);
              Vec3.set(c01, -hw, 0, -hl);

              for (var y = 0; y <= vSegments; y++) {
                for (var x = 0; x <= uSegments; x++) {
                  var u = x / uSegments;
                  var v = y / vSegments;
                  Vec3.lerp(temp1$2, c00, c10, u);
                  Vec3.lerp(temp2$2, c00, c01, v);
                  Vec3.subtract(temp3$1, temp2$2, c00);
                  Vec3.add(r$1, temp1$2, temp3$1);
                  positions.push(r$1.x, r$1.y, r$1.z);

                  if (normalizedOptions.includeUV) {
                    uvs.push(u, v);
                  }

                  if (x < uSegments && y < vSegments) {
                    var useg1 = uSegments + 1;
                    var a = x + y * useg1;
                    var b = x + (y + 1) * useg1;
                    var c = x + 1 + (y + 1) * useg1;
                    var d = x + 1 + y * useg1;
                    indices.push(a, d, b);
                    indices.push(d, c, b);
                  }
                }
              }

              var result = {
                positions: positions,
                indices: indices,
                minPos: minPos,
                maxPos: maxPos,
                boundingRadius: boundingRadius
              };

              if (normalizedOptions.includeNormal) {
                var nVertex = (vSegments + 1) * (uSegments + 1);
                var normals = new Array(3 * nVertex);
                result.normals = normals;

                for (var i = 0; i < nVertex; ++i) {
                  normals[i * 3 + 0] = 0;
                  normals[i * 3 + 1] = 1;
                  normals[i * 3 + 2] = 0;
                }
              }

              if (normalizedOptions.includeUV) {
                result.uvs = uvs;
              }

              return result;
            }

            /**
             * @category 3d/primitive
             */
            /**
             * @en
             * The definition of the parameter for building a capsule.
             * @zh
             * 胶囊体参数选项。
             */

            var temp1$3 = new Vec3(0, 0, 0);
            var temp2$3 = new Vec3(0, 0, 0);
            /**
             * Generate a capsule with radiusTop radiusBottom 0.5, height 2, centered at origin,
             * but may be repositioned through the `center` option.
             * @zh
             * 生成一个胶囊体。
             * @param radiusTop 顶部半径。
             * @param radiusBottom 底部半径。
             * @param opts 胶囊体参数选项。
             */

            function capsule() {
              var radiusTop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.5;
              var radiusBottom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;
              var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;
              var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
              var torsoHeight = height - radiusTop - radiusBottom;
              var sides = opts.sides || 32;
              var heightSegments = opts.heightSegments || 32;
              var bottomProp = radiusBottom / height;
              var torProp = torsoHeight / height;
              var topProp = radiusTop / height;
              var bottomSegments = Math.floor(heightSegments * bottomProp);
              var topSegments = Math.floor(heightSegments * topProp);
              var torSegments = Math.floor(heightSegments * torProp);
              var topOffset = torsoHeight + radiusBottom - height / 2;
              var torOffset = radiusBottom - height / 2;
              var bottomOffset = radiusBottom - height / 2;
              var arc = opts.arc || 2.0 * Math.PI; // calculate vertex count

              var positions = [];
              var normals = [];
              var uvs = [];
              var indices = [];
              var maxRadius = Math.max(radiusTop, radiusBottom);
              var minPos = new Vec3(-maxRadius, -height / 2, -maxRadius);
              var maxPos = new Vec3(maxRadius, height / 2, maxRadius);
              var boundingRadius = height / 2;
              var index = 0;
              var indexArray = [];
              generateBottom();
              generateTorso();
              generateTop();
              return {
                positions: positions,
                normals: normals,
                uvs: uvs,
                indices: indices,
                minPos: minPos,
                maxPos: maxPos,
                boundingRadius: boundingRadius
              }; // =======================
              // internal fucntions
              // =======================

              function generateTorso() {
                // this will be used to calculate the normal
                var slope = (radiusTop - radiusBottom) / torsoHeight; // generate positions, normals and uvs

                for (var y = 0; y <= torSegments; y++) {
                  var indexRow = [];
                  var lat = y / torSegments;
                  var radius = lat * (radiusTop - radiusBottom) + radiusBottom;

                  for (var x = 0; x <= sides; ++x) {
                    var u = x / sides;
                    var v = lat * torProp + bottomProp;
                    var theta = u * arc - arc / 4;
                    var sinTheta = Math.sin(theta);
                    var cosTheta = Math.cos(theta); // vertex

                    positions.push(radius * sinTheta);
                    positions.push(lat * torsoHeight + torOffset);
                    positions.push(radius * cosTheta); // normal

                    Vec3.normalize(temp1$3, Vec3.set(temp2$3, sinTheta, -slope, cosTheta));
                    normals.push(temp1$3.x);
                    normals.push(temp1$3.y);
                    normals.push(temp1$3.z); // uv

                    uvs.push(u, v); // save index of vertex in respective row

                    indexRow.push(index); // increase index

                    ++index;
                  } // now save positions of the row in our index array


                  indexArray.push(indexRow);
                } // generate indices


                for (var _y = 0; _y < torSegments; ++_y) {
                  for (var _x = 0; _x < sides; ++_x) {
                    // we use the index array to access the correct indices
                    var i1 = indexArray[_y][_x];
                    var i2 = indexArray[_y + 1][_x];
                    var i3 = indexArray[_y + 1][_x + 1];
                    var i4 = indexArray[_y][_x + 1]; // face one

                    indices.push(i1);
                    indices.push(i4);
                    indices.push(i2); // face two

                    indices.push(i4);
                    indices.push(i3);
                    indices.push(i2);
                  }
                }
              }

              function generateBottom() {
                for (var lat = 0; lat <= bottomSegments; ++lat) {
                  var theta = lat * Math.PI / bottomSegments / 2;
                  var sinTheta = Math.sin(theta);
                  var cosTheta = -Math.cos(theta);

                  for (var lon = 0; lon <= sides; ++lon) {
                    var phi = lon * 2 * Math.PI / sides - Math.PI / 2.0;
                    var sinPhi = Math.sin(phi);
                    var cosPhi = Math.cos(phi);
                    var x = sinPhi * sinTheta;
                    var y = cosTheta;
                    var z = cosPhi * sinTheta;
                    var u = lon / sides;
                    var v = lat / heightSegments;
                    positions.push(x * radiusBottom, y * radiusBottom + bottomOffset, z * radiusBottom);
                    normals.push(x, y, z);
                    uvs.push(u, v);

                    if (lat < bottomSegments && lon < sides) {
                      var seg1 = sides + 1;
                      var a = seg1 * lat + lon;
                      var b = seg1 * (lat + 1) + lon;
                      var c = seg1 * (lat + 1) + lon + 1;
                      var d = seg1 * lat + lon + 1;
                      indices.push(a, d, b);
                      indices.push(d, c, b);
                    }

                    ++index;
                  }
                }
              }

              function generateTop() {
                for (var lat = 0; lat <= topSegments; ++lat) {
                  var theta = lat * Math.PI / topSegments / 2 + Math.PI / 2;
                  var sinTheta = Math.sin(theta);
                  var cosTheta = -Math.cos(theta);

                  for (var lon = 0; lon <= sides; ++lon) {
                    var phi = lon * 2 * Math.PI / sides - Math.PI / 2.0;
                    var sinPhi = Math.sin(phi);
                    var cosPhi = Math.cos(phi);
                    var x = sinPhi * sinTheta;
                    var y = cosTheta;
                    var z = cosPhi * sinTheta;
                    var u = lon / sides;
                    var v = lat / heightSegments + (1 - topProp);
                    positions.push(x * radiusTop, y * radiusTop + topOffset, z * radiusTop);
                    normals.push(x, y, z);
                    uvs.push(u, v);

                    if (lat < topSegments && lon < sides) {
                      var seg1 = sides + 1;
                      var a = seg1 * lat + lon + indexArray[torSegments][sides] + 1;
                      var b = seg1 * (lat + 1) + lon + indexArray[torSegments][sides] + 1;
                      var c = seg1 * (lat + 1) + lon + 1 + indexArray[torSegments][sides] + 1;
                      var d = seg1 * lat + lon + 1 + indexArray[torSegments][sides] + 1;
                      indices.push(a, d, b);
                      indices.push(d, c, b);
                    }
                  }
                }
              }
            }

            var skybox_mesh = null;
            var skybox_material = null;
            var Skybox = exports('a0', /*#__PURE__*/function () {
              function Skybox() {
                _classCallCheck(this, Skybox);

                this._enabled = false;
                this._isRGBE = false;
                this._useIBL = false;
                this._envmap = null;
                this._globalDescriptorSet = null;
                this._model = null;
                this._default = null;
              }

              _createClass(Skybox, [{
                key: "activate",
                value: function activate() {
                  var pipeline = legacyCC.director.root.pipeline;
                  this._globalDescriptorSet = pipeline.descriptorSet;
                  this._default = builtinResMgr.get('default-cube-texture');

                  if (!this._model) {
                    this._model = new Model();
                  }

                  if (!skybox_material) {
                    var mat = new Material();
                    mat.initialize({
                      effectName: 'pipeline/skybox',
                      defines: {
                        USE_RGBE_CUBEMAP: this._isRGBE
                      }
                    });
                    skybox_material = new MaterialInstance({
                      parent: mat
                    });
                  } else {
                    skybox_material.recompileShaders({
                      USE_RGBE_CUBEMAP: this._isRGBE
                    });
                  }

                  if (!skybox_mesh) {
                    skybox_mesh = createMesh(box({
                      width: 2,
                      height: 2,
                      length: 2
                    }));
                  }

                  this._model.initSubModel(0, skybox_mesh.renderingSubMeshes[0], skybox_material);

                  this.envmap = this._envmap;

                  this._updatePipeline();
                }
              }, {
                key: "_updatePipeline",
                value: function _updatePipeline() {
                  var value = this._useIBL ? this._isRGBE ? 2 : 1 : 0;
                  var root = legacyCC.director.root;
                  var pipeline = root.pipeline;
                  var current = pipeline.macros.CC_USE_IBL;

                  if (current === value) {
                    return;
                  }

                  pipeline.macros.CC_USE_IBL = value;
                  root.onGlobalPipelineStateChanged();
                }
              }, {
                key: "_updateGlobalBinding",
                value: function _updateGlobalBinding() {
                  var texture = this.envmap.getGFXTexture();
                  var sampler = samplerLib.getSampler(legacyCC.director._device, this.envmap.getSamplerHash());

                  this._globalDescriptorSet.bindSampler(UNIFORM_ENVIRONMENT.binding, sampler);

                  this._globalDescriptorSet.bindTexture(UNIFORM_ENVIRONMENT.binding, texture);
                }
              }, {
                key: "model",
                get: function get() {
                  return this._model;
                }
                /**
                 * @en Whether activate skybox in the scene
                 * @zh 是否启用天空盒？
                 */

              }, {
                key: "enabled",
                get: function get() {
                  return this._enabled;
                },
                set: function set(val) {
                  if (this._enabled === val) {
                    return;
                  }

                  this._enabled = val;
                  this._enabled ? this.activate() : this._updatePipeline();
                }
                /**
                 * @en Whether use environment lighting
                 * @zh 是否启用环境光照？
                 */

              }, {
                key: "useIBL",
                get: function get() {
                  return this._useIBL;
                },
                set: function set(val) {
                  this._useIBL = val;

                  this._updatePipeline();
                }
                /**
                 * @en Whether enable RGBE data support in skybox shader
                 * @zh 是否需要开启 shader 内的 RGBE 数据支持？
                 */

              }, {
                key: "isRGBE",
                get: function get() {
                  return this._isRGBE;
                },
                set: function set(val) {
                  this._isRGBE = val;

                  if (this._enabled) {
                    if (skybox_material) {
                      skybox_material.recompileShaders({
                        USE_RGBE_CUBEMAP: this._isRGBE
                      });
                    }

                    if (this._model) {
                      this._model.setSubModelMaterial(0, skybox_material);
                    }
                  }

                  this._updatePipeline();
                }
                /**
                 * @en The texture cube used for the skybox
                 * @zh 使用的立方体贴图
                 */

              }, {
                key: "envmap",
                get: function get() {
                  return this._envmap;
                },
                set: function set(val) {
                  this._envmap = val || this._default;

                  if (this._envmap) {
                    legacyCC.director.root.pipeline.ambient.albedoArray[3] = this._envmap.mipmapLevel;

                    this._updateGlobalBinding();
                  }
                }
              }]);

              return Skybox;
            }());

            var _forward$2 = new Vec3(0, 0, -1);

            var _qt$2 = new Quat();

            var _matView = new Mat4();

            var _matProj = new Mat4();

            var _matViewProj = new Mat4();

            var _matViewProjInv = new Mat4();

            var SpotLight = exports('a1', /*#__PURE__*/function (_Light) {
              _inherits(SpotLight, _Light);

              _createClass(SpotLight, [{
                key: "position",
                get: function get() {
                  return this._pos;
                }
              }, {
                key: "size",
                set: function set(size) {
                  this._size = size;
                },
                get: function get() {
                  return this._size;
                }
              }, {
                key: "range",
                set: function set(range) {
                  this._range = range;
                  this._needUpdate = true;
                },
                get: function get() {
                  return this._range;
                }
              }, {
                key: "luminance",
                set: function set(lum) {
                  this._luminance = lum;
                },
                get: function get() {
                  return this._luminance;
                }
              }, {
                key: "direction",
                get: function get() {
                  return this._dir;
                }
              }, {
                key: "spotAngle",
                get: function get() {
                  return this._spotAngle;
                },
                set: function set(val) {
                  this._angle = val;
                  this._spotAngle = Math.cos(val * 0.5);
                  this._needUpdate = true;
                }
              }, {
                key: "aabb",
                get: function get() {
                  return this._aabb;
                }
              }, {
                key: "frustum",
                get: function get() {
                  return this._frustum;
                }
              }]);

              function SpotLight() {
                var _this;

                _classCallCheck(this, SpotLight);

                _this = _possibleConstructorReturn(this, _getPrototypeOf(SpotLight).call(this));
                _this._dir = new Vec3(1.0, -1.0, -1.0);
                _this._size = 0.15;
                _this._range = 5.0;
                _this._luminance = 1700 / nt2lm(_this._size);
                _this._spotAngle = Math.cos(Math.PI / 6);
                _this._pos = void 0;
                _this._aabb = void 0;
                _this._frustum = void 0;
                _this._angle = 0;
                _this._needUpdate = false;
                _this._type = LightType.SPOT;
                _this._aabb = aabb.create();
                _this._frustum = frustum.create();
                _this._pos = new Vec3();
                return _this;
              }

              _createClass(SpotLight, [{
                key: "update",
                value: function update() {
                  if (this._node && (this._node.hasChangedFlags || this._needUpdate)) {
                    this._node.getWorldPosition(this._pos);

                    Vec3.transformQuat(this._dir, _forward$2, this._node.getWorldRotation(_qt$2));
                    Vec3.normalize(this._dir, this._dir);
                    aabb.set(this._aabb, this._pos.x, this._pos.y, this._pos.z, this._range, this._range, this._range); // view matrix

                    this._node.getWorldRT(_matView);

                    Mat4.invert(_matView, _matView);
                    Mat4.perspective(_matProj, this._angle, 1, 0.001, this._range); // view-projection

                    Mat4.multiply(_matViewProj, _matProj, _matView); // Mat4.invert(_matViewProjInv, _matViewProj);

                    this._frustum.update(_matViewProj, _matViewProjInv);

                    this._needUpdate = false;
                  }
                }
              }]);

              return SpotLight;
            }(Light));

            var BaseRenderData = function BaseRenderData() {
              _classCallCheck(this, BaseRenderData);

              this.material = null;
              this.vertexCount = 0;
              this.indicesCount = 0;
            };
            var RenderData = exports('dc', /*#__PURE__*/function (_BaseRenderData) {
              _inherits(RenderData, _BaseRenderData);

              function RenderData() {
                var _getPrototypeOf2;

                var _this;

                _classCallCheck(this, RenderData);

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(RenderData)).call.apply(_getPrototypeOf2, [this].concat(args)));
                _this.vData = null;
                _this.uvDirty = true;
                _this.vertDirty = true;
                _this._data = [];
                _this._indices = [];
                _this._pivotX = 0;
                _this._pivotY = 0;
                _this._width = 0;
                _this._height = 0;
                return _this;
              }

              _createClass(RenderData, [{
                key: "updateSizeNPivot",
                value: function updateSizeNPivot(width, height, pivotX, pivotY) {
                  if (width !== this._width || height !== this._height || pivotX !== this._pivotX || pivotY !== this._pivotY) {
                    this._width = width;
                    this._height = height;
                    this._pivotX = pivotX;
                    this._pivotY = pivotY;
                    this.vertDirty = true;
                  }
                }
              }, {
                key: "clear",
                value: function clear() {
                  this._data.length = 0;
                  this._indices.length = 0;
                  this._pivotX = 0;
                  this._pivotY = 0;
                  this._width = 0;
                  this._height = 0;
                  this.uvDirty = true;
                  this.vertDirty = true;
                  this.material = null;
                  this.vertexCount = 0;
                  this.indicesCount = 0;
                }
              }, {
                key: "dataLength",
                get: function get() {
                  return this._data.length;
                },
                set: function set(length) {
                  var data = this._data;

                  if (data.length !== length) {
                    // // Free extra data
                    var value = data.length;
                    var i = 0;

                    for (i = length; i < value; i++) {
                      _dataPool.free(data[i]);
                    }

                    for (i = value; i < length; i++) {
                      data[i] = _dataPool.alloc();
                    }

                    data.length = length;
                  }
                }
              }, {
                key: "data",
                get: function get() {
                  return this._data;
                }
              }], [{
                key: "add",
                value: function add() {
                  return _pool.add();
                }
              }, {
                key: "remove",
                value: function remove(data) {
                  var idx = _pool.data.indexOf(data);

                  if (idx === -1) {
                    return;
                  }

                  _pool.data[idx].clear();

                  _pool.removeAt(idx);
                }
              }]);

              return RenderData;
            }(BaseRenderData));
            var MeshRenderData = exports('d_', /*#__PURE__*/function (_BaseRenderData2) {
              _inherits(MeshRenderData, _BaseRenderData2);

              function MeshRenderData() {
                var _getPrototypeOf3;

                var _this2;

                _classCallCheck(this, MeshRenderData);

                for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
                  args[_key3] = arguments[_key3];
                }

                _this2 = _possibleConstructorReturn(this, (_getPrototypeOf3 = _getPrototypeOf(MeshRenderData)).call.apply(_getPrototypeOf3, [this].concat(args)));
                _this2.vData = new Float32Array(256 * 9 * Float32Array.BYTES_PER_ELEMENT);
                _this2.iData = new Uint16Array(256 * 6);
                _this2.vertexStart = 0;
                _this2.indicesStart = 0;
                _this2.byteStart = 0;
                _this2.byteCount = 0;
                _this2._formatByte = 9 * Float32Array.BYTES_PER_ELEMENT;
                return _this2;
              }

              _createClass(MeshRenderData, [{
                key: "request",
                value: function request(vertexCount, indicesCount) {
                  var byteOffset = this.byteCount + vertexCount * this._formatByte;
                  var indicesOffset = this.indicesCount + indicesCount;

                  if (vertexCount + this.vertexCount > 65535) {
                    return false;
                  }

                  var byteLength = this.vData.byteLength;
                  var indicesLength = this.iData.length;
                  var vCount = this.vData.length;
                  var iCount = this.iData.length;

                  if (byteOffset > byteLength || indicesOffset > indicesLength) {
                    while (byteLength < byteOffset || indicesLength < indicesOffset) {
                      vCount *= 2;
                      iCount *= 2;
                      byteLength = vCount * 4;
                      indicesLength = iCount;
                    } // copy old data


                    var oldVData = new Float32Array(this.vData.buffer);
                    this.vData = new Float32Array(vCount);
                    this.vData.set(oldVData, 0);
                    var oldIData = new Uint16Array(this.iData.buffer);
                    this.iData = new Uint16Array(iCount);
                    this.iData.set(oldIData, 0);
                  }

                  this.vertexCount += vertexCount; // vertexOffset

                  this.indicesCount += indicesCount; // indicesOffset

                  this.byteCount = byteOffset; // byteOffset

                  return true;
                }
              }, {
                key: "reset",
                value: function reset() {
                  this.vertexCount = 0;
                  this.indicesCount = 0;
                  this.byteCount = 0;
                  this.vertexStart = 0;
                  this.indicesStart = 0;
                  this.byteStart = 0;
                }
              }]);

              return MeshRenderData;
            }(BaseRenderData));

            var _dataPool = new Pool(function () {
              return {
                x: 0,
                y: 0,
                z: 0,
                u: 0,
                v: 0,
                color: Color.WHITE.clone()
              };
            }, 128);

            var _pool = new RecyclePool(function () {
              return new RenderData();
            }, 32);

            var _dec$f, _dec2$6, _dec3$2, _dec4$2, _class$f, _class2$d, _descriptor$c, _descriptor2$a, _temp$f;
            var _matInsInfo = {
              parent: null,
              owner: null,
              subModelIdx: 0
            };
            var RenderableComponent = exports('d3', (_dec$f = ccclass('cc.RenderableComponent'), _dec2$6 = type([Material]), _dec3$2 = type(Material), _dec4$2 = displayName(), _dec$f(_class$f = (_class2$d = (_temp$f = /*#__PURE__*/function (_Component) {
              _inherits(RenderableComponent, _Component);

              function RenderableComponent() {
                var _getPrototypeOf2;

                var _this;

                _classCallCheck(this, RenderableComponent);

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(RenderableComponent)).call.apply(_getPrototypeOf2, [this].concat(args)));

                _initializerDefineProperty(_this, "_materials", _descriptor$c, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_visFlags", _descriptor2$a, _assertThisInitialized(_this));

                _this._materialInstances = [];
                _this._models = [];
                return _this;
              }

              _createClass(RenderableComponent, [{
                key: "getMaterial",

                /**
                 * @en Get the shared material asset of the specified sub-model.
                 * @zh 获取指定子模型的共享材质资源。
                 */
                value: function getMaterial(idx) {
                  if (idx < 0 || idx >= this._materials.length) {
                    return null;
                  }

                  return this._materials[idx];
                }
                /**
                 * @en Set the shared material asset of the specified sub-model,
                 * new material instance will be created automatically if the sub-model is already using one.
                 * @zh 设置指定子模型的 sharedMaterial，如果对应位置有材质实例则会创建一个对应的材质实例。
                 */

              }, {
                key: "setMaterial",
                value: function setMaterial(material, index) {
                  if (material && material instanceof MaterialInstance) {
                    console.error('Can\'t set a material instance to a sharedMaterial slot');
                  }

                  this._materials[index] = material;
                  var inst = this._materialInstances[index];

                  if (inst) {
                    if (inst.parent !== this._materials[index]) {
                      inst.destroy();
                      this._materialInstances[index] = null;

                      this._onMaterialModified(index, this._materials[index]);
                    }
                  } else {
                    this._onMaterialModified(index, this._materials[index]);
                  }
                }
              }, {
                key: "getMaterialInstance",

                /**
                 * @en Get the material instance of the specified sub-model.
                 * @zh 获取指定子模型的材质实例。
                 */
                value: function getMaterialInstance(idx) {
                  var mat = this._materials[idx];

                  if (!mat) {
                    return null;
                  }

                  if (!this._materialInstances[idx]) {
                    _matInsInfo.parent = this._materials[idx];
                    _matInsInfo.owner = this;
                    _matInsInfo.subModelIdx = idx;
                    var instantiated = new MaterialInstance(_matInsInfo);
                    this.setMaterialInstance(idx, instantiated);
                  }

                  return this._materialInstances[idx];
                }
                /**
                 * @en Set the material instance of the specified sub-model.
                 * @zh 获取指定子模型的材质实例。
                 */

              }, {
                key: "setMaterialInstance",
                value: function setMaterialInstance(index, matInst) {
                  if (matInst && matInst.parent) {
                    if (matInst !== this._materialInstances[index]) {
                      this._materialInstances[index] = matInst;

                      this._onMaterialModified(index, matInst);
                    }
                  } else {
                    if (matInst !== this._materials[index]) {
                      this.setMaterial(matInst, index);
                    }
                  }
                }
                /**
                 * @en Get the actual rendering material of the specified sub-model.
                 * (material instance if there is one, or the shared material asset)
                 * @zh 获取指定位置可供渲染的材质，如果有材质实例则使用材质实例，如果没有则使用材质资源
                 */

              }, {
                key: "getRenderMaterial",
                value: function getRenderMaterial(index) {
                  return this._materialInstances[index] || this._materials[index];
                }
              }, {
                key: "_collectModels",
                value: function _collectModels() {
                  return this._models;
                }
              }, {
                key: "_attachToScene",
                value: function _attachToScene() {}
              }, {
                key: "_detachFromScene",
                value: function _detachFromScene() {}
              }, {
                key: "_onMaterialModified",
                value: function _onMaterialModified(index, material) {}
              }, {
                key: "_onRebuildPSO",
                value: function _onRebuildPSO(index, material) {}
              }, {
                key: "_clearMaterials",
                value: function _clearMaterials() {}
              }, {
                key: "_onVisibilityChange",
                value: function _onVisibilityChange(val) {}
              }, {
                key: "visibility",
                get: function get() {
                  return this._visFlags;
                },
                set: function set(val) {
                  this._visFlags = val;

                  this._onVisibilityChange(val);
                }
              }, {
                key: "sharedMaterials",
                get: function get() {
                  // if we don't create an array copy, the editor will modify the original array directly.
                  return  this._materials;
                },
                set: function set(val) {
                  for (var i = 0; i < val.length; i++) {
                    if (val[i] !== this._materials[i]) {
                      this.setMaterial(val[i], i);
                    }
                  }

                  if (val.length < this._materials.length) {
                    for (var _i = val.length; _i < this._materials.length; _i++) {
                      this.setMaterial(null, _i);
                    }

                    this._materials.splice(val.length);
                  }
                }
                /**
                 * @en The materials of the model.
                 * @zh 模型材质。
                 */

              }, {
                key: "materials",
                get: function get() {
                  for (var i = 0; i < this._materials.length; i++) {
                    this._materialInstances[i] = this.getMaterialInstance(i);
                  }

                  return this._materialInstances;
                },
                set: function set(val) {
                  var dLen = val.length - this._materials.length;

                  if (dLen > 0) {
                    this._materials.length = val.length;
                    this._materialInstances.length = val.length;
                  } else if (dLen < 0) {
                    for (var i = this._materials.length - dLen; i < this._materials.length; ++i) {
                      this.setMaterialInstance(i, null);
                    }
                  }

                  for (var _i2 = 0; _i2 < this._materialInstances.length; _i2++) {
                    // tslint:disable-next-line: triple-equals // both of them may be undefined or null
                    if (this._materialInstances[_i2] != val[_i2]) {
                      this.setMaterialInstance(_i2, val[_i2]);
                    }
                  }
                }
              }, {
                key: "sharedMaterial",
                get: function get() {
                  return this.getMaterial(0);
                }
              }, {
                key: "material",
                get: function get() {
                  return this.getMaterialInstance(0);
                },
                set: function set(val) {
                  if (this._materials.length === 1 && this._materials[0] === val) {
                    return;
                  }

                  this.setMaterialInstance(0, val);
                }
              }]);

              return RenderableComponent;
            }(Component), _temp$f), (_descriptor$c = _applyDecoratedDescriptor(_class2$d.prototype, "_materials", [_dec2$6], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [];
              }
            }), _descriptor2$a = _applyDecoratedDescriptor(_class2$d.prototype, "_visFlags", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return Layers.Enum.NONE;
              }
            }), _applyDecoratedDescriptor(_class2$d.prototype, "sharedMaterials", [_dec3$2, _dec4$2], Object.getOwnPropertyDescriptor(_class2$d.prototype, "sharedMaterials"), _class2$d.prototype)), _class2$d)) || _class$f));
            legacyCC.RenderableComponent = RenderableComponent;

            var _dec$g, _dec2$7, _class$g, _class2$e, _descriptor$d, _descriptor2$b, _descriptor3$8, _descriptor4$5, _descriptor5$5, _descriptor6$1, _temp$g, _dec3$3, _dec4$3, _dec5$2, _dec6$1, _dec7$1, _dec8$1, _dec9$1, _dec10, _dec11, _dec12, _dec13, _class4$1, _class5$1, _descriptor7$1, _descriptor8$1, _descriptor9, _descriptor10, _descriptor11, _class6, _temp2$1;
            /**
             * @en Shadow projection mode.
             * @zh 阴影投射方式。
             */

            var ModelShadowCastingMode = Enum({
              /**
               * @en Disable shadow projection.
               * @zh 不投射阴影。
               */
              OFF: 0,

              /**
               * @en Enable shadow projection.
               * @zh 开启阴影投射。
               */
              ON: 1
            });
            /**
             * @en Shadow receive mode.
             * @zh 阴影接收方式。
             */

            var ModelShadowReceivingMode = Enum({
              /**
               * @en Disable shadow projection.
               * @zh 不接收阴影。
               */
              OFF: 0,

              /**
               * @en Enable shadow projection.
               * @zh 开启阴影投射。
               */
              ON: 1
            });
            /**
             * @en model light map settings.
             * @zh 模型光照图设置
             */

            var ModelLightmapSettings = (_dec$g = ccclass('cc.ModelLightmapSettings'), _dec2$7 = formerlySerializedAs('_recieveShadow'), _dec$g(_class$g = (_class2$e = (_temp$g = /*#__PURE__*/function () {
              function ModelLightmapSettings() {
                _classCallCheck(this, ModelLightmapSettings);

                _initializerDefineProperty(this, "texture", _descriptor$d, this);

                _initializerDefineProperty(this, "uvParam", _descriptor2$b, this);

                _initializerDefineProperty(this, "_bakeable", _descriptor3$8, this);

                _initializerDefineProperty(this, "_castShadow", _descriptor4$5, this);

                _initializerDefineProperty(this, "_receiveShadow", _descriptor5$5, this);

                _initializerDefineProperty(this, "_lightmapSize", _descriptor6$1, this);
              }

              _createClass(ModelLightmapSettings, [{
                key: "bakeable",

                /**
                 * @en bakeable.
                 * @zh 是否可烘培。
                 */
                get: function get() {
                  return this._bakeable;
                },
                set: function set(val) {
                  this._bakeable = val;
                }
                /**
                 * @en cast shadow.
                 * @zh 是否投射阴影。
                 */

              }, {
                key: "castShadow",
                get: function get() {
                  return this._castShadow;
                },
                set: function set(val) {
                  this._castShadow = val;
                }
                /**
                 * @en receive shadow.
                 * @zh 是否接受阴影。
                 */

              }, {
                key: "receiveShadow",
                get: function get() {
                  return this._receiveShadow;
                },
                set: function set(val) {
                  this._receiveShadow = val;
                }
                /**
                 * @en lightmap size.
                 * @zh 光照图大小
                 */

              }, {
                key: "lightmapSize",
                get: function get() {
                  return this._lightmapSize;
                },
                set: function set(val) {
                  this._lightmapSize = val;
                }
              }]);

              return ModelLightmapSettings;
            }(), _temp$g), (_descriptor$d = _applyDecoratedDescriptor(_class2$e.prototype, "texture", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor2$b = _applyDecoratedDescriptor(_class2$e.prototype, "uvParam", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Vec4();
              }
            }), _descriptor3$8 = _applyDecoratedDescriptor(_class2$e.prototype, "_bakeable", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return false;
              }
            }), _descriptor4$5 = _applyDecoratedDescriptor(_class2$e.prototype, "_castShadow", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return false;
              }
            }), _descriptor5$5 = _applyDecoratedDescriptor(_class2$e.prototype, "_receiveShadow", [_dec2$7], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return false;
              }
            }), _descriptor6$1 = _applyDecoratedDescriptor(_class2$e.prototype, "_lightmapSize", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 64;
              }
            }), _applyDecoratedDescriptor(_class2$e.prototype, "bakeable", [editable], Object.getOwnPropertyDescriptor(_class2$e.prototype, "bakeable"), _class2$e.prototype), _applyDecoratedDescriptor(_class2$e.prototype, "castShadow", [editable], Object.getOwnPropertyDescriptor(_class2$e.prototype, "castShadow"), _class2$e.prototype), _applyDecoratedDescriptor(_class2$e.prototype, "receiveShadow", [editable], Object.getOwnPropertyDescriptor(_class2$e.prototype, "receiveShadow"), _class2$e.prototype), _applyDecoratedDescriptor(_class2$e.prototype, "lightmapSize", [editable], Object.getOwnPropertyDescriptor(_class2$e.prototype, "lightmapSize"), _class2$e.prototype)), _class2$e)) || _class$g);
            /**
             * @en Mesh renderer component
             * @zh 网格渲染器组件。
             */

            var MeshRenderer = exports('as', (_dec3$3 = ccclass('cc.MeshRenderer'), _dec4$3 = help(), _dec5$2 = executionOrder(100), _dec6$1 = menu(), _dec7$1 = type(ModelShadowCastingMode), _dec8$1 = tooltip(), _dec9$1 = type(ModelShadowReceivingMode), _dec10 = tooltip(), _dec11 = type(Mesh), _dec12 = tooltip(), _dec13 = visible(), _dec3$3(_class4$1 = _dec4$3(_class4$1 = _dec5$2(_class4$1 = _dec6$1(_class4$1 = executeInEditMode(_class4$1 = (_class5$1 = (_temp2$1 = _class6 = /*#__PURE__*/function (_RenderableComponent) {
              _inherits(MeshRenderer, _RenderableComponent);

              _createClass(MeshRenderer, [{
                key: "shadowCastingMode",

                /**
                 * @en Shadow projection mode.
                 * @zh 阴影投射方式。
                 */
                get: function get() {
                  return this._shadowCastingMode;
                },
                set: function set(val) {
                  this._shadowCastingMode = val;

                  this._updateCastShadow();
                }
                /**
                 * @en receive shadow.
                 * @zh 是否接受阴影。
                 */

              }, {
                key: "receiveShadow",
                get: function get() {
                  return this._shadowReceivingMode;
                },
                set: function set(val) {
                  this._shadowReceivingMode = val;

                  this._updateReceiveShadow();
                }
                /**
                 * @en The mesh of the model.
                 * @zh 模型的网格数据。
                 */

              }, {
                key: "mesh",
                get: function get() {
                  return this._mesh;
                },
                set: function set(val) {
                  var _this$_mesh;

                  var old = this._mesh;
                  this._mesh = val;
                  (_this$_mesh = this._mesh) === null || _this$_mesh === void 0 ? void 0 : _this$_mesh.initialize();

                  this._watchMorphInMesh();

                  this._onMeshChanged(old);

                  this._updateModels();

                  if (this.enabledInHierarchy) {
                    this._attachToScene();
                  }
                }
              }, {
                key: "model",
                get: function get() {
                  return this._model;
                }
              }, {
                key: "enableMorph",
                get: function get() {
                  return this._enableMorph;
                },
                set: function set(value) {
                  this._enableMorph = value;
                }
              }]);

              function MeshRenderer() {
                var _this;

                _classCallCheck(this, MeshRenderer);

                _this = _possibleConstructorReturn(this, _getPrototypeOf(MeshRenderer).call(this));

                _initializerDefineProperty(_this, "lightmapSettings", _descriptor7$1, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_mesh", _descriptor8$1, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_shadowCastingMode", _descriptor9, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_shadowReceivingMode", _descriptor10, _assertThisInitialized(_this));

                _this._modelType = void 0;
                _this._model = null;
                _this._morphInstance = null;

                _initializerDefineProperty(_this, "_enableMorph", _descriptor11, _assertThisInitialized(_this));

                _this._modelType = Model;
                return _this;
              }

              _createClass(MeshRenderer, [{
                key: "onLoad",
                value: function onLoad() {
                  var _this$_mesh2;

                  (_this$_mesh2 = this._mesh) === null || _this$_mesh2 === void 0 ? void 0 : _this$_mesh2.initialize();

                  this._watchMorphInMesh();

                  this._updateModels();

                  this._updateCastShadow();

                  this._updateReceiveShadow();
                } // Redo, Undo, Prefab restore, etc.

              }, {
                key: "onRestore",
                value: function onRestore() {
                  this._updateModels();
                }
              }, {
                key: "onEnable",
                value: function onEnable() {
                  if (!this._model) {
                    this._updateModels();
                  }

                  this._attachToScene();
                }
              }, {
                key: "onDisable",
                value: function onDisable() {
                  if (this._model) {
                    this._detachFromScene();
                  }
                }
              }, {
                key: "onDestroy",
                value: function onDestroy() {
                  if (this._model) {
                    legacyCC.director.root.destroyModel(this._model);
                    this._model = null;
                    this._models.length = 0;
                  }

                  if (this._morphInstance) {
                    this._morphInstance.destroy();
                  }
                }
              }, {
                key: "setWeights",
                value: function setWeights(weights, subMeshIndex) {
                  if (this._morphInstance) {
                    this._morphInstance.setWeights(subMeshIndex, weights);
                  }
                }
              }, {
                key: "setInstancedAttribute",
                value: function setInstancedAttribute(name, value) {
                  if (!this.model) {
                    return;
                  }

                  var list = this.model.instancedAttributes.list;

                  for (var i = 0; i < list.length; i++) {
                    if (list[i].name === name) {
                      list[i].view.set(value);
                      break;
                    }
                  }
                }
              }, {
                key: "_updateLightmap",
                value: function _updateLightmap(lightmap, uOff, vOff, uScale, vScale) {
                  this.lightmapSettings.texture = lightmap;
                  this.lightmapSettings.uvParam.x = uOff;
                  this.lightmapSettings.uvParam.y = vOff;
                  this.lightmapSettings.uvParam.z = uScale;
                  this.lightmapSettings.uvParam.w = vScale;

                  this._onUpdateLightingmap();
                }
              }, {
                key: "_updateModels",
                value: function _updateModels() {
                  if (!this.enabledInHierarchy || !this._mesh) {
                    return;
                  }

                  if (this._model) {
                    this._model.destroy();

                    this._model.initialize(this.node);
                  } else {
                    this._createModel();
                  }

                  this._updateModelParams();

                  this._onUpdateLightingmap();
                }
              }, {
                key: "_createModel",
                value: function _createModel() {
                  var preferMorphOverPlain = !!this._morphInstance; // Note we only change to use `MorphModel` if
                  // we are required to render morph and the `this._modelType` is exactly the basic `Model`.
                  // We do this since the `this._modelType` might be changed in classes derived from `Model`.
                  // We shall not overwrite it.
                  // Please notice that we do not enforce that
                  // derived classes should use a morph-able model type(i.e. model type derived from `MorphModel`).
                  // So we should take care of the edge case.

                  var modelType = preferMorphOverPlain && this._modelType === Model ? MorphModel : this._modelType;
                  this._model = legacyCC.director.root.createModel(modelType);
                  this._model.visFlags = this.visibility;

                  this._model.initialize(this.node);

                  this._models.length = 0;

                  this._models.push(this._model);

                  if (this._morphInstance && this._model instanceof MorphModel) {
                    this._model.setMorphRendering(this._morphInstance);
                  }
                }
              }, {
                key: "_attachToScene",
                value: function _attachToScene() {
                  if (!this.node.scene || !this._model) {
                    return;
                  }

                  var scene = this._getRenderScene();

                  if (this._model.scene != null) {
                    this._detachFromScene();
                  }

                  scene.addModel(this._model);
                }
              }, {
                key: "_detachFromScene",
                value: function _detachFromScene() {
                  if (this._model && this._model.scene) {
                    this._model.scene.removeModel(this._model);
                  }
                }
              }, {
                key: "_updateModelParams",
                value: function _updateModelParams() {
                  if (!this._mesh || !this._model) {
                    return;
                  }

                  this.node.hasChangedFlags |= TransformBit.POSITION;
                  this._model.transform.hasChangedFlags |= TransformBit.POSITION;
                  this._model.isDynamicBatching = this._isBatchingEnabled();
                  var meshCount = this._mesh ? this._mesh.subMeshCount : 0;
                  var renderingMesh = this._mesh.renderingSubMeshes;

                  if (renderingMesh) {
                    for (var i = 0; i < meshCount; ++i) {
                      var material = this.getRenderMaterial(i);
                      var subMeshData = renderingMesh[i];

                      if (subMeshData) {
                        this._model.initSubModel(i, subMeshData, material || this._getBuiltinMaterial());
                      }
                    }
                  }

                  this._model.createBoundingShape(this._mesh.minPosition, this._mesh.maxPosition);

                  this._model.enabled = true;
                }
              }, {
                key: "_onUpdateLightingmap",
                value: function _onUpdateLightingmap() {
                  if (this.model !== null) {
                    this.model.updateLightingmap(this.lightmapSettings.texture, this.lightmapSettings.uvParam);
                  }

                  this.setInstancedAttribute('a_lightingMapUVParam', [this.lightmapSettings.uvParam.x, this.lightmapSettings.uvParam.y, this.lightmapSettings.uvParam.z, this.lightmapSettings.uvParam.w]);
                }
              }, {
                key: "_onMaterialModified",
                value: function _onMaterialModified(idx, material) {
                  if (!this._model || !this._model.inited) {
                    return;
                  }

                  this._onRebuildPSO(idx, material || this._getBuiltinMaterial());
                }
              }, {
                key: "_onRebuildPSO",
                value: function _onRebuildPSO(idx, material) {
                  if (!this._model || !this._model.inited) {
                    return;
                  }

                  this._model.isDynamicBatching = this._isBatchingEnabled();

                  this._model.setSubModelMaterial(idx, material);

                  this._onUpdateLightingmap();
                }
              }, {
                key: "_onMeshChanged",
                value: function _onMeshChanged(old) {}
              }, {
                key: "_clearMaterials",
                value: function _clearMaterials() {
                  if (!this._model) {
                    return;
                  }

                  var subModels = this._model.subModels;

                  for (var i = 0; i < subModels.length; ++i) {
                    this._onMaterialModified(i, null);
                  }
                }
              }, {
                key: "_getBuiltinMaterial",
                value: function _getBuiltinMaterial() {
                  // classic ugly pink indicating missing material
                  return builtinResMgr.get('missing-material');
                }
              }, {
                key: "_onVisibilityChange",
                value: function _onVisibilityChange(val) {
                  if (!this._model) {
                    return;
                  }

                  this._model.visFlags = val;
                }
              }, {
                key: "_updateCastShadow",
                value: function _updateCastShadow() {
                  if (!this._model) {
                    return;
                  }

                  if (this._shadowCastingMode === ModelShadowCastingMode.OFF) {
                    this._model.castShadow = false;
                  } else {
                    assertIsTrue(this._shadowCastingMode === ModelShadowCastingMode.ON, "ShadowCastingMode ".concat(this._shadowCastingMode, " is not supported."));
                    this._model.castShadow = true;
                  }
                }
              }, {
                key: "_updateReceiveShadow",
                value: function _updateReceiveShadow() {
                  if (!this._model) {
                    return;
                  }

                  if (this._shadowReceivingMode === ModelShadowReceivingMode.OFF) {
                    this._model.receiveShadow = false;
                  } else {
                    this._model.receiveShadow = true;
                  }
                }
              }, {
                key: "_isBatchingEnabled",
                value: function _isBatchingEnabled() {
                  for (var i = 0; i < this._materials.length; ++i) {
                    var mat = this._materials[i];

                    if (!mat) {
                      continue;
                    }

                    for (var p = 0; p < mat.passes.length; ++p) {
                      var pass = mat.passes[p];

                      if (pass.batchingScheme) {
                        return true;
                      }
                    }
                  }

                  return false;
                }
              }, {
                key: "_watchMorphInMesh",
                value: function _watchMorphInMesh() {
                  if (this._morphInstance) {
                    this._morphInstance.destroy();

                    this._morphInstance = null;
                  }

                  if (!this._enableMorph) {
                    return;
                  }

                  if (!this._mesh || !this._mesh.struct.morph || !this._mesh.morphRendering) {
                    return;
                  }

                  var morph = this._mesh.struct.morph;
                  this._morphInstance = this._mesh.morphRendering.createInstance();
                  var nSubMeshes = this._mesh.struct.primitives.length;

                  for (var iSubMesh = 0; iSubMesh < nSubMeshes; ++iSubMesh) {
                    var subMeshMorph = morph.subMeshMorphs[iSubMesh];

                    if (!subMeshMorph) {
                      continue;
                    }

                    var initialWeights = subMeshMorph.weights || morph.weights;
                    var weights = initialWeights ? initialWeights.slice() : new Array(subMeshMorph.targets.length).fill(0);

                    this._morphInstance.setWeights(iSubMesh, weights);
                  }

                  if (this._model && this._model instanceof MorphModel) {
                    this._model.setMorphRendering(this._morphInstance);
                  }
                }
              }, {
                key: "_syncMorphWeights",
                value: function _syncMorphWeights(subMeshIndex) {
                  if (!this._morphInstance) {
                    return;
                  }

                  var subMeshMorphInstance = this._morphInstance[subMeshIndex];

                  if (!subMeshMorphInstance || !subMeshMorphInstance.renderResources) {
                    return;
                  }

                  subMeshMorphInstance.renderResources.setWeights(subMeshMorphInstance.weights);
                }
              }]);

              return MeshRenderer;
            }(RenderableComponent), _class6.ShadowCastingMode = ModelShadowCastingMode, _class6.ShadowReceivingMode = ModelShadowReceivingMode, _temp2$1), (_descriptor7$1 = _applyDecoratedDescriptor(_class5$1.prototype, "lightmapSettings", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new ModelLightmapSettings();
              }
            }), _descriptor8$1 = _applyDecoratedDescriptor(_class5$1.prototype, "_mesh", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor9 = _applyDecoratedDescriptor(_class5$1.prototype, "_shadowCastingMode", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return ModelShadowCastingMode.OFF;
              }
            }), _descriptor10 = _applyDecoratedDescriptor(_class5$1.prototype, "_shadowReceivingMode", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return ModelShadowReceivingMode.ON;
              }
            }), _applyDecoratedDescriptor(_class5$1.prototype, "shadowCastingMode", [_dec7$1, _dec8$1], Object.getOwnPropertyDescriptor(_class5$1.prototype, "shadowCastingMode"), _class5$1.prototype), _applyDecoratedDescriptor(_class5$1.prototype, "receiveShadow", [_dec9$1, _dec10], Object.getOwnPropertyDescriptor(_class5$1.prototype, "receiveShadow"), _class5$1.prototype), _applyDecoratedDescriptor(_class5$1.prototype, "mesh", [_dec11, _dec12], Object.getOwnPropertyDescriptor(_class5$1.prototype, "mesh"), _class5$1.prototype), _applyDecoratedDescriptor(_class5$1.prototype, "enableMorph", [_dec13], Object.getOwnPropertyDescriptor(_class5$1.prototype, "enableMorph"), _class5$1.prototype), _descriptor11 = _applyDecoratedDescriptor(_class5$1.prototype, "_enableMorph", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return true;
              }
            })), _class5$1)) || _class4$1) || _class4$1) || _class4$1) || _class4$1) || _class4$1));

            /**
             * @category core
             */

            var _vec3 = new Vec3();
            /**
             * @en
             * Conversion of non-UI nodes to UI Node (Local) Space coordinate system.
             * @zh
             * 非 UI 节点转换到 UI 节点(局部) 空间坐标系。
             * @deprecated 将在 1.2 移除，请使用 Camera 的 `convertToUINode`。
             * @param mainCamera 主相机。
             * @param wpos 世界空间位置。
             * @param uiNode UI节点。
             * @param out 返回局部坐标。
             */


            function WorldNode3DToLocalNodeUI(mainCamera, wpos, uiNode, out) {
              if (!out) {
                out = new Vec3();
              }

              mainCamera.convertToUINode(wpos, uiNode, out);
              var pos = uiNode.position;
              out.add(pos);
              return out;
            }
            /**
             * @en
             * Conversion of non-UI nodes to UI Node (World) Space coordinate system.
             * @zh
             * 非 UI 节点转换到 UI 节点(世界) 空间坐标系。
             * @deprecated 将在 1.2 移除，请使用 Camera 的 `convertToUINode`。
             * @param mainCamera 主相机。
             * @param wpos 世界空间位置。
             * @param out 返回世界坐标。
             */

            function WorldNode3DToWorldNodeUI(mainCamera, wpos, out) {
              if (!out) {
                out = new Vec3();
              }

              mainCamera.worldToScreen(wpos, out);
              out.x = out.x / legacyCC.view.getScaleX();
              out.y = out.y / legacyCC.view.getScaleY();
              return out;
            }
            /**
             * @en It will be removed in v1.2. Please use [[Camera.convertToUINode]]。
             * @zh 将在 v1.2 移除，请使用 Camera 的 `convertToUINode`。
             * @deprecated 
             */

            var convertUtils = exports('aL', {
              WorldNode3DToLocalNodeUI: WorldNode3DToLocalNodeUI,
              WorldNode3DToWorldNodeUI: WorldNode3DToWorldNodeUI
            });
            legacyCC.pipelineUtils = convertUtils;
            replaceProperty(legacyCC.pipelineUtils, 'cc.pipelineUtils', [{
              'name': 'WorldNode3DToLocalNodeUI',
              'newName': 'convertToUINode',
              'targetName': 'cc.Camera.prototype',
              'customFunction': function customFunction() {
                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                var camera = args[0];
                var out = args[3] || _vec3;
                camera.convertToUINode(args[1], args[2], out);
                out.add(args[2].position);
                return args[3] || out.clone();
              }
            }]);

            /*
             Copyright (c) 2013-2016 Chukong Technologies Inc.
             Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

             http://www.cocos.com

             Permission is hereby granted, free of charge, to any person obtaining a copy
             of this software and associated engine source code (the "Software"), a limited,
              worldwide, royalty-free, non-assignable, revocable and non-exclusive license
             to use Cocos Creator solely to develop games on your target platforms. You shall
              not use Cocos Creator software for developing other software or tools that's
              used for developing games. You are not granted to publish, distribute,
              sublicense, and/or sell copies of Cocos Creator.

             The software or tools in this License Agreement are licensed, not sold.
             Xiamen Yaji Software Co., Ltd. reserves all rights not expressly granted to you.

             THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
             THE SOFTWARE.
            */

            var _decorator = /*#__PURE__*/Object.freeze({
                __proto__: null,
                ccclass: ccclass,
                property: property,
                requireComponent: requireComponent,
                executionOrder: executionOrder,
                disallowMultiple: disallowMultiple,
                executeInEditMode: executeInEditMode,
                menu: menu,
                playOnFocus: playOnFocus,
                inspector: inspector,
                icon: icon,
                help: help,
                type: type,
                integer: integer,
                float: _float,
                boolean: _boolean,
                string: string
            });
            exports('aM', _decorator);

            var _dec$h, _class$h, _class2$f, _descriptor$e, _temp$h, _dec2$8, _dec3$4, _class4$2, _class5$2, _descriptor2$c, _descriptor3$9, _temp2$2;
            /**
             * @en
             * A temp fallback to contain the original serialized data which can not be loaded.
             * @zh
             * 包含无法加载的原始序列化数据的临时回退。
             */

            var MissingClass = (_dec$h = ccclass('cc.MissingClass'), _dec$h(_class$h = (_class2$f = (_temp$h = function MissingClass() {
              _classCallCheck(this, MissingClass);

              _initializerDefineProperty(this, "_$erialized", _descriptor$e, this);
            }, _temp$h), (_descriptor$e = _applyDecoratedDescriptor(_class2$f.prototype, "_$erialized", [serializable, editorOnly], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            })), _class2$f)) || _class$h);
            /**
             * @en
             * A temp fallback to contain the original component which can not be loaded.
             * @zh
             * 包含无法加载的原始组件的临时回退。
             */

            var MissingScript = exports('d0', (_dec2$8 = ccclass('cc.MissingScript'), _dec3$4 = inspector(), _dec2$8(_class4$2 = _dec3$4(_class4$2 = (_class5$2 = (_temp2$2 = /*#__PURE__*/function (_Component) {
              _inherits(MissingScript, _Component);

              _createClass(MissingScript, null, [{
                key: "safeFindClass",
                // _scriptUuid: {
                //    get: function () {
                //        var id = this._$erialized.__type__;
                //        if (EditorExtends.UuidUtils.isUuid(id)) {
                //            return EditorExtends.UuidUtils.decompressUuid(id);
                //        }
                //        return '';
                //    },
                // },

                /*
                 * @param {string} id
                 * @return {function} constructor
                 */
                value: function safeFindClass(id, data) {
                  var cls = _getClassById(id);

                  if (cls) {
                    return cls;
                  }

                  if (id) {
                    legacyCC.deserialize.reportMissingClass(id);
                    return MissingScript.getMissingWrapper(id, data);
                  }

                  return null;
                }
              }, {
                key: "getMissingWrapper",
                value: function getMissingWrapper(id, data) {
                  if (data.node && (/^[0-9a-zA-Z+/]{23}$/.test(id) || BUILTIN_CLASSID_RE.test(id))) {
                    // is component
                    return MissingScript;
                  } else {
                    return MissingClass;
                  }
                }
              }]);

              function MissingScript() {
                var _this;

                _classCallCheck(this, MissingScript);

                _this = _possibleConstructorReturn(this, _getPrototypeOf(MissingScript).call(this));

                _initializerDefineProperty(_this, "compiled", _descriptor2$c, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_$erialized", _descriptor3$9, _assertThisInitialized(_this));

                return _this;
              }

              _createClass(MissingScript, [{
                key: "onLoad",
                value: function onLoad() {
                  warnID(4600, this.node.name);
                }
              }]);

              return MissingScript;
            }(Component), _temp2$2), (_descriptor2$c = _applyDecoratedDescriptor(_class5$2.prototype, "compiled", [editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return false;
              }
            }), _descriptor3$9 = _applyDecoratedDescriptor(_class5$2.prototype, "_$erialized", [serializable, editorOnly], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            })), _class5$2)) || _class4$2) || _class4$2));
            legacyCC._MissingScript = MissingScript;

            // tslint:disable: no-shadowed-variable

            /**
             * @en Contains information collected during deserialization
             * @zh 包含反序列化时的一些信息。
             * @class Details
             *
             */

            var Details = /*#__PURE__*/function () {
              function Details() {

                _classCallCheck(this, Details);

                this.uuidList = void 0;
                this.uuidObjList = void 0;
                this.uuidPropList = void 0;
                this._stillUseUrl = void 0;

                /**
                 * list of the depends assets' uuid
                 */
                this.uuidList = [];
                /**
                 * the obj list whose field needs to load asset by uuid
                 */

                this.uuidObjList = [];
                /**
                 * the corresponding field name which referenced to the asset
                 */

                this.uuidPropList = []; // TODO - DELME since 2.0

                this._stillUseUrl = createMap(true);
              }
              /**
               * @zh
               * 重置。
               * @method reset
               */


              _createClass(Details, [{
                key: "reset",
                value: function reset() {
                  this.uuidList.length = 0;
                  this.uuidObjList.length = 0;
                  this.uuidPropList.length = 0;
                  clear(this._stillUseUrl);
                } // /**
                //  * @method getUuidOf
                //  * @param {Object} obj
                //  * @param {String} propName
                //  * @return {String}
                //  */
                // getUuidOf (obj, propName) {
                //     for (var i = 0; i < this.uuidObjList.length; i++) {
                //         if (this.uuidObjList[i] === obj && this.uuidPropList[i] === propName) {
                //             return this.uuidList[i];
                //         }
                //     }
                //     return "";
                // }

                /**
                 * @method push
                 * @param {Object} obj
                 * @param {String} propName
                 * @param {String} uuid
                 */

              }, {
                key: "push",
                value: function push(obj, propName, uuid, _stillUseUrl) {
                  if (_stillUseUrl) {
                    this._stillUseUrl[this.uuidList.length] = true;
                  }

                  this.uuidList.push(uuid);
                  this.uuidObjList.push(obj);
                  this.uuidPropList.push(propName);
                }
              }]);

              return Details;
            }();
            Details.pool = void 0;
            Details.pool = new Pool$1(function (obj) {
              obj.reset();
            }, 10);

            Details.pool.get = function () {
              return this._get() || new Details();
            }; // IMPLEMENT OF DESERIALIZATION


            function _dereference(self) {
              // 这里不采用遍历反序列化结果的方式，因为反序列化的结果如果引用到复杂的外部库，很容易堆栈溢出。
              var deserializedList = self.deserializedList;
              var idPropList = self._idPropList;
              var idList = self._idList;
              var idObjList = self._idObjList;
              var onDereferenced = self._classFinder && self._classFinder.onDereferenced;
              var i;
              var propName;
              var id;

              {
                for (i = 0; i < idList.length; i++) {
                  propName = idPropList[i];
                  id = idList[i];
                  idObjList[i][propName] = deserializedList[id];
                }
              }
            }

            function compileObjectTypeJit(sources, defaultValue, accessorToSet, propNameLiteralToSet, assumeHavePropIfIsValue, stillUseUrl) {
              if (defaultValue instanceof legacyCC.ValueType) {
                // fast case
                if (!assumeHavePropIfIsValue) {
                  sources.push('if(prop){');
                }

                var ctorCode = getClassName(defaultValue);
                sources.push("s._deserializeTypedObject(o".concat(accessorToSet, ",prop,").concat(ctorCode, ");"));

                if (!assumeHavePropIfIsValue) {
                  sources.push('}else o' + accessorToSet + '=null;');
                }
              } else {
                sources.push('if(prop){');
                sources.push('s._deserializeObjField(o,prop,' + propNameLiteralToSet + ( ',null,') + !!stillUseUrl + ');');
                sources.push('}else o' + accessorToSet + '=null;');
              }
            }

            var compileDeserialize =  function (self, klass) {
              var TYPE = DELIMETER + 'type';
              var DEFAULT = DELIMETER + 'default';
              var SAVE_URL_AS_ASSET = DELIMETER + 'saveUrlAsAsset';
              var FORMERLY_SERIALIZED_AS = DELIMETER + 'formerlySerializedAs';
              var attrs = getClassAttrs(klass);
              var props = klass.__values__; // self, obj, serializedData, klass, target

              var sources = ['var prop;'];
              var fastMode = BUILTIN_CLASSID_RE.test(_getClassId(klass)); // sources.push('var vb,vn,vs,vo,vu,vf;');    // boolean, number, string, object, undefined, function
              // tslint:disable-next-line: prefer-for-of

              for (var p = 0; p < props.length; p++) {
                var propName = props[p];

                var accessorToSet = void 0;
                var propNameLiteralToSet = void 0;

                if (CCClass.IDENTIFIER_RE.test(propName)) {
                  propNameLiteralToSet = '"' + propName + '"';
                  accessorToSet = '.' + propName;
                } else {
                  propNameLiteralToSet = CCClass.escapeForJS(propName);
                  accessorToSet = '[' + propNameLiteralToSet + ']';
                }

                var accessorToGet = accessorToSet;

                if (attrs[propName + FORMERLY_SERIALIZED_AS]) {
                  var propNameToRead = attrs[propName + FORMERLY_SERIALIZED_AS];

                  if (CCClass.IDENTIFIER_RE.test(propNameToRead)) {
                    accessorToGet = '.' + propNameToRead;
                  } else {
                    accessorToGet = '[' + CCClass.escapeForJS(propNameToRead) + ']';
                  }
                }

                sources.push('prop=d' + accessorToGet + ';');
                sources.push("if(typeof ".concat( 'prop', "!==\"undefined\"){"));
                var stillUseUrl = attrs[propName + SAVE_URL_AS_ASSET]; // function undefined object(null) string boolean number

                var defaultValue = CCClass.getDefault(attrs[propName + DEFAULT]);

                if (fastMode) {
                  var isPrimitiveType = void 0;
                  var userType = attrs[propName + TYPE];

                  if (defaultValue === undefined && userType) {
                    isPrimitiveType = userType === legacyCC.String || userType === legacyCC.Integer || userType === legacyCC.Float || userType === legacyCC.Boolean;
                  } else {
                    var defaultType = _typeof(defaultValue);

                    isPrimitiveType = defaultType === 'string' && !stillUseUrl || defaultType === 'number' || defaultType === 'boolean';
                  }

                  if (isPrimitiveType) {
                    sources.push("o".concat(accessorToSet, "=prop;"));
                  } else {
                    compileObjectTypeJit(sources, defaultValue, accessorToSet, propNameLiteralToSet, true, stillUseUrl);
                  }
                } else {
                  sources.push("if(typeof ".concat( 'prop', "!==\"object\"){") + 'o' + accessorToSet + '=prop;' + '}else{');
                  compileObjectTypeJit(sources, defaultValue, accessorToSet, propNameLiteralToSet, false, stillUseUrl);
                  sources.push('}');
                }

                sources.push('}');
              }

              if (legacyCC.js.isChildClassOf(klass, legacyCC._BaseNode) || legacyCC.js.isChildClassOf(klass, legacyCC.Component)) {
                {
                  sources.push('d._id&&(o._id=d._id);');
                }
              }

              if (props[props.length - 1] === '_$erialized') {
                // deep copy original serialized data
                sources.push('o._$erialized=JSON.parse(JSON.stringify(d));'); // parse the serialized data as primitive javascript object, so its __id__ will be dereferenced

                sources.push('s._deserializePrimitiveObject(o._$erialized,d);');
              }

              return Function('s', 'o', 'd', 'k', 't', sources.join(''));
            } ;

            function _deserializeFireClass(self, obj, serialized, klass, target) {
              var deserialize;

              if (klass.hasOwnProperty('__deserialize__')) {
                deserialize = klass.__deserialize__;
              } else {
                deserialize = compileDeserialize(self, klass); // if (TEST && !isPhantomJS) {
                //     log(deserialize);
                // }

                value(klass, '__deserialize__', deserialize, true);
              }

              deserialize(self, obj, serialized, klass, target); // if preview or build worker
            } // function _compileTypedObject (accessor, klass, ctorCode) {
            //     if (klass === cc.Vec2) {
            //         return `{` +
            //                     `o${accessor}.x=prop.x||0;` +
            //                     `o${accessor}.y=prop.y||0;` +
            //                `}`;
            //     }
            //     else if (klass === cc.Color) {
            //         return `{` +
            //                    `o${accessor}.r=prop.r||0;` +
            //                    `o${accessor}.g=prop.g||0;` +
            //                    `o${accessor}.b=prop.b||0;` +
            //                    `o${accessor}.a=(prop.a===undefined?255:prop.a);` +
            //                `}`;
            //     }
            //     else if (klass === cc.Size) {
            //         return `{` +
            //                    `o${accessor}.width=prop.width||0;` +
            //                    `o${accessor}.height=prop.height||0;` +
            //                `}`;
            //     }
            //     else {
            //         return `s._deserializeTypedObject(o${accessor},prop,${ctorCode});`;
            //     }
            // }
            // tslint:disable-next-line: class-name


            var _Deserializer = /*#__PURE__*/function () {
              function _Deserializer(result, target, classFinder, customEnv, ignoreEditorOnly) {
                _classCallCheck(this, _Deserializer);

                this.result = void 0;
                this.customEnv = void 0;
                this.deserializedList = void 0;
                this.deserializedData = void 0;
                this._classFinder = void 0;
                this._target = void 0;
                this._ignoreEditorOnly = void 0;
                this._idList = void 0;
                this._idObjList = void 0;
                this._idPropList = void 0;
                this.result = result;
                this.customEnv = customEnv;
                this.deserializedList = [];
                this.deserializedData = null;
                this._classFinder = classFinder;

                this._idList = [];
                this._idObjList = [];
                this._idPropList = [];
              }

              _createClass(_Deserializer, [{
                key: "deserialize",
                value: function deserialize(jsonObj) {
                  if (Array.isArray(jsonObj)) {
                    var jsonArray = jsonObj;
                    var refCount = jsonArray.length;
                    this.deserializedList.length = refCount; // deserialize

                    for (var i = 0; i < refCount; i++) {
                      if (jsonArray[i]) {
                        {
                          this.deserializedList[i] = this._deserializeObject(jsonArray[i], false);
                        }
                      }
                    }

                    this.deserializedData = refCount > 0 ? this.deserializedList[0] : []; //// callback
                    // for (var j = 0; j < refCount; j++) {
                    //    if (referencedList[j].onAfterDeserialize) {
                    //        referencedList[j].onAfterDeserialize();
                    //    }
                    // }
                  } else {
                    this.deserializedList.length = 1;

                    {
                      this.deserializedData = jsonObj ? this._deserializeObject(jsonObj, false) : null;
                    }

                    this.deserializedList[0] = this.deserializedData; //// callback
                    // if (deserializedData.onAfterDeserialize) {
                    //    deserializedData.onAfterDeserialize();
                    // }
                  } // dereference


                  _dereference(this);

                  return this.deserializedData;
                }
                /**
                 * @param {Object} serialized - The obj to deserialize, must be non-nil
                 * @param {Boolean} _stillUseUrl
                 * @param {Object} [target=null] - editor only
                 * @param {Object} [owner] - debug only
                 * @param {String} [propName] - debug only
                 */

              }, {
                key: "_deserializeObject",
                value: function _deserializeObject(serialized, _stillUseUrl, target, owner, propName) {
                  var prop;
                  var obj = null; // the obj to return

                  var klass = null;
                  var type = serialized.__type__;

                  if (type === 'TypedArray') {
                    var array = serialized.array; // @ts-ignore

                    obj = new window[serialized.ctor](array.length);

                    for (var i = 0; i < array.length; ++i) {
                      obj[i] = array[i];
                    }

                    return obj;
                  } else if (type) {
                    // @ts-ignore
                    var deserializeByType = function deserializeByType() {
                      {
                        // instantiate a new object
                        obj = new klass();
                      }

                      if (obj._deserialize) {
                        obj._deserialize(serialized.content, self);

                        return;
                      }

                      if (legacyCC.Class._isCCClass(klass)) {
                        _deserializeFireClass(self, obj, serialized, klass, target);
                      } else {
                        self._deserializeTypedObject(obj, serialized, klass);
                      }
                    }; // @ts-ignore

                    // Type Object (including CCClass)
                    klass = this._classFinder(type, serialized, owner, propName);

                    if (!klass) {
                      var notReported = this._classFinder === _getClassById;

                      if (notReported) {
                        legacyCC.deserialize.reportMissingClass(type);
                      }

                      return null;
                    }

                    var self = this;

                    {
                      deserializeByType();
                    }
                  } else if (!Array.isArray(serialized)) {
                    // embedded primitive javascript object
                    obj =  {};

                    this._deserializePrimitiveObject(obj, serialized);
                  } else {
                    // Array
                    {
                      obj = new Array(serialized.length);
                    }

                    for (var _i2 = 0; _i2 < serialized.length; _i2++) {
                      prop = serialized[_i2];

                      if (_typeof(prop) === 'object' && prop) {
                        {
                          this._deserializeObjField(obj, prop, '' + _i2, null, _stillUseUrl);
                        }
                      } else {
                        obj[_i2] = prop;
                      }
                    }
                  }

                  return obj;
                } // 和 _deserializeObject 不同的地方在于会判断 id 和 uuid

              }, {
                key: "_deserializeObjField",
                value: function _deserializeObjField(obj, jsonObj, propName, target, _stillUseUrl) {
                  var id = jsonObj.__id__;

                  if (id === undefined) {
                    var uuid = jsonObj.__uuid__;

                    if (uuid) {
                      // if (ENABLE_TARGET) {
                      // 这里不做任何操作，因为有可能调用者需要知道依赖哪些 asset。
                      // 调用者使用 uuidList 时，可以判断 obj[propName] 是否为空，为空则表示待进一步加载，
                      // 不为空则只是表明依赖关系。
                      //    if (target && target[propName] && target[propName]._uuid === uuid) {
                      //        console.assert(obj[propName] === target[propName]);
                      //        return;
                      //    }
                      // }
                      this.result.push(obj, propName, uuid, _stillUseUrl);
                    } else {
                      {
                        obj[propName] = this._deserializeObject(jsonObj, _stillUseUrl);
                      }
                    }
                  } else {
                    var dObj = this.deserializedList[id];

                    if (dObj) {
                      obj[propName] = dObj;
                    } else {
                      this._idList.push(id);

                      this._idObjList.push(obj);

                      this._idPropList.push(propName);
                    }
                  }
                }
              }, {
                key: "_deserializePrimitiveObject",
                value: function _deserializePrimitiveObject(instance, serialized) {
                  var self = this;

                  for (var propName in serialized) {
                    if (serialized.hasOwnProperty(propName)) {
                      var prop = serialized[propName];

                      if (_typeof(prop) !== 'object') {
                        if (propName !== '__type__'
                        /* && k != '__id__'*/
                        ) {
                            instance[propName] = prop;
                          }
                      } else {
                        if (prop) {
                          {
                            self._deserializeObjField(instance, prop, propName);
                          }
                        } else {
                          instance[propName] = null;
                        }
                      }
                    }
                  }
                }
              }, {
                key: "_deserializeTypedObject",
                value: function _deserializeTypedObject(instance, serialized, klass) {
                  if (klass === legacyCC.Vec2) {
                    instance.x = serialized.x || 0;
                    instance.y = serialized.y || 0;
                    return;
                  } else if (klass === legacyCC.Vec3) {
                    instance.x = serialized.x || 0;
                    instance.y = serialized.y || 0;
                    instance.z = serialized.z || 0;
                    return;
                  } else if (klass === legacyCC.Color) {
                    instance.r = serialized.r || 0;
                    instance.g = serialized.g || 0;
                    instance.b = serialized.b || 0;
                    var a = serialized.a;
                    instance.a = a === undefined ? 255 : a;
                    return;
                  } else if (klass === legacyCC.Size) {
                    instance.width = serialized.width || 0;
                    instance.height = serialized.height || 0;
                    return;
                  }

                  var DEFAULT = DELIMETER + 'default';
                  var attrs = getClassAttrs(klass);
                  var fastDefinedProps = klass.__props__ || Object.keys(instance); // 遍历 instance，如果具有类型，才不会把 __type__ 也读进来
                  // tslint:disable-next-line: prefer-for-of

                  for (var i = 0; i < fastDefinedProps.length; i++) {
                    var propName = fastDefinedProps[i];
                    var value = serialized[propName];

                    if (value === undefined || !serialized.hasOwnProperty(propName)) {
                      // not serialized,
                      // recover to default value in ValueType, because eliminated properties equals to
                      // its default value in ValueType, not default value in user class
                      value = CCClass.getDefault(attrs[propName + DEFAULT]);
                    }

                    if (_typeof(value) !== 'object') {
                      instance[propName] = value;
                    } else if (value) {
                      {
                        this._deserializeObjField(instance, value, propName);
                      }
                    } else {
                      instance[propName] = null;
                    }
                  }
                }
              }]);

              return _Deserializer;
            }();

            _Deserializer.pool = void 0;
            _Deserializer.pool = new Pool$1(function (obj) {
              obj.result = null;
              obj.customEnv = null;
              obj.deserializedList.length = 0;
              obj.deserializedData = null;
              obj._classFinder = null;

              obj._idList.length = 0;
              obj._idObjList.length = 0;
              obj._idPropList.length = 0;
            }, 1); // @ts-ignore

            _Deserializer.pool.get = function (result, target, classFinder, customEnv, ignoreEditorOnly) {
              var cache = this._get();

              if (cache) {
                cache.result = result;
                cache.customEnv = customEnv;
                cache._classFinder = classFinder;

                return cache;
              } else {
                return new _Deserializer(result, target, classFinder, customEnv, ignoreEditorOnly);
              }
            };
            /**
             * @module cc
             */

            /**
             * @en Deserialize json to `Asset`.
             * @zh 将 JSON 反序列化为对象实例。
             *
             * 当指定了 target 选项时，如果 target 引用的其它 asset 的 uuid 不变，则不会改变 target 对 asset 的引用，
             * 也不会将 uuid 保存到 result 对象中。
             *
             * @method deserialize
             * @param {String|Object} data - the serialized `Asset` json string or json object.
             * @param {Details} [details] - additional loading result
             * @param {Object} [options]
             * @return {object} the main data(asset)
             */


            function deserialize(data, details, options) {
              options = options || {};
              var classFinder = options.classFinder || _getClassById; // 启用 createAssetRefs 后，如果有 url 属性则会被统一强制设置为 { uuid: 'xxx' }，必须后面再特殊处理

              var createAssetRefs = options.createAssetRefs || legacyCC.sys.platform === legacyCC.sys.EDITOR_CORE;
              var target = ( TEST) ;
              var customEnv = options.customEnv;
              var ignoreEditorOnly = options.ignoreEditorOnly;

              if (typeof data === 'string') {
                data = JSON.parse(data);
              } // var oldJson = JSON.stringify(data, null, 2);


              var tempDetails = !details;
              details = details || Details.pool.get(); // @ts-ignore

              var deserializer = _Deserializer.pool.get(details, target, classFinder, customEnv, ignoreEditorOnly);

              legacyCC.game._isCloning = true;
              var res = deserializer.deserialize(data);
              legacyCC.game._isCloning = false;

              _Deserializer.pool.put(deserializer);

              if (createAssetRefs) {
                details.assignAssetsBy(EditorExtends.serialize.asAsset);
              }

              if (tempDetails) {
                Details.pool.put(details);
              } // var afterJson = JSON.stringify(data, null, 2);
              // if (oldJson !== afterJson) {
              //     throw new Error('JSON SHOULD not changed');
              // }


              return res;
            }
            deserialize.Details = Details;

            deserialize.reportMissingClass = function (id) {
              {
                warnID(5302, id);
              }
            };

            legacyCC.deserialize = deserialize;

            var Destroyed = CCObject.Flags.Destroyed;
            var PersistentMask = CCObject.Flags.PersistentMask;
            var objsToClearTmpVar = []; // used to reset _iN$t variable

            /**
             * Invoke _instantiate method if supplied.
             * The _instantiate callback will be called only on the root object, its associated object will not be called.
             * @param instantiated If supplied, _instantiate just need to initialize the instantiated object, no need to create new object by itself.
             * @returns The instantiated object.
             */

            function instantiate(original, internalForce) {

              var clone;

              if (original instanceof CCObject) {
                // @ts-ignore
                if (original._instantiate) {
                  legacyCC.game._isCloning = true; // @ts-ignore

                  clone = original._instantiate();
                  legacyCC.game._isCloning = false;
                  return clone;
                } else if (original instanceof legacyCC.Asset) {
                  throw new TypeError(getError(6903));
                }
              }

              legacyCC.game._isCloning = true;
              clone = doInstantiate(original);
              legacyCC.game._isCloning = false;
              return clone;
            }
            /*
             * @en
             * Do instantiate object, the object to instantiate must be non-nil.
             * @zh
             * 这是一个通用的 instantiate 方法，可能效率比较低。
             * 之后可以给各种类型重写快速实例化的特殊实现，但应该在单元测试中将结果和这个方法的结果进行对比。
             * 值得注意的是，这个方法不可重入。
             * @param obj - 该方法仅供内部使用，用户需负责保证参数合法。什么参数是合法的请参考 cc.instantiate 的实现。
             * @param parent - 只有在该对象下的场景物体会被克隆。
             * @return {Object}
             * @private
             */

            function doInstantiate(obj, parent) {

              var clone;

              if (obj._iN$t) {
                // User can specify an existing object by assigning the "_iN$t" property.
                // enumerateObject will always push obj to objsToClearTmpVar
                clone = obj._iN$t;
              } else if (obj.constructor) {
                var klass = obj.constructor;
                clone = new klass();
              } else {
                clone = Object.create(null);
              }

              enumerateObject(obj, clone, parent);

              for (var i = 0, len = objsToClearTmpVar.length; i < len; ++i) {
                objsToClearTmpVar[i]._iN$t = null;
              }

              objsToClearTmpVar.length = 0;
              return clone;
            } // @param {Object} obj - The object to instantiate, typeof must be 'object' and should not be an array.


            function enumerateCCClass(klass, obj, clone, parent) {
              var props = klass.__values__; // tslint:disable: prefer-for-of

              for (var p = 0; p < props.length; p++) {
                var key = props[p];
                var value = obj[key];

                if (_typeof(value) === 'object' && value) {
                  var initValue = clone[key];

                  if (initValue instanceof ValueType && initValue.constructor === value.constructor) {
                    initValue.set(value);
                  } else {
                    clone[key] = value._iN$t || instantiateObj(value, parent);
                  }
                } else {
                  clone[key] = value;
                }
              }
            }

            function enumerateObject(obj, clone, parent) {
              // 目前使用“_iN$t”这个特殊字段来存实例化后的对象，这样做主要是为了防止循环引用
              // 注意，为了避免循环引用，所有新创建的实例，必须在赋值前被设为源对象的_iN$t
              value(obj, '_iN$t', clone, true);
              objsToClearTmpVar.push(obj);
              var klass = obj.constructor;

              if (legacyCC.Class._isCCClass(klass)) {
                enumerateCCClass(klass, obj, clone, parent);
              } else {
                // primitive javascript object
                for (var key in obj) {
                  if (!obj.hasOwnProperty(key) || key.charCodeAt(0) === 95 && key.charCodeAt(1) === 95 && // starts with "__"
                  key !== '__type__') {
                    continue;
                  }

                  var value$1 = obj[key];

                  if (_typeof(value$1) === 'object' && value$1) {
                    if (value$1 === clone) {
                      continue; // value is obj._iN$t
                    }

                    clone[key] = value$1._iN$t || instantiateObj(value$1, parent);
                  } else {
                    clone[key] = value$1;
                  }
                }
              }

              if (obj instanceof CCObject) {
                clone._objFlags &= PersistentMask;
              }
            }
            /*
             * @param {Object|Array} obj - the original non-nil object, typeof must be 'object'
             * @return {Object|Array} - the original non-nil object, typeof must be 'object'
             */


            function instantiateObj(obj, parent) {
              if (obj instanceof ValueType) {
                return obj.clone();
              }

              if (obj instanceof legacyCC.Asset) {
                // 所有资源直接引用，不需要拷贝
                return obj;
              }

              var clone;

              if (Array.isArray(obj)) {
                var len = obj.length;
                clone = new Array(len); // @ts-ignore

                obj._iN$t = clone;

                for (var i = 0; i < len; ++i) {
                  var value = obj[i];

                  if (_typeof(value) === 'object' && value) {
                    clone[i] = value._iN$t || instantiateObj(value, parent);
                  } else {
                    clone[i] = value;
                  }
                }

                objsToClearTmpVar.push(obj);
                return clone;
              } else if (obj._objFlags & Destroyed) {
                // the same as cc.isValid(obj)
                return null;
              }

              var ctor = obj.constructor;

              if (legacyCC.Class._isCCClass(ctor)) {
                if (parent) {
                  if (parent instanceof legacyCC.Component) {
                    if (obj instanceof legacyCC._BaseNode || obj instanceof legacyCC.Component) {
                      return obj;
                    }
                  } else if (parent instanceof legacyCC._BaseNode) {
                    if (obj instanceof legacyCC._BaseNode) {
                      if (!obj.isChildOf(parent)) {
                        // should not clone other nodes if not descendant
                        return obj;
                      }
                    } else if (obj instanceof legacyCC.Component) {
                      if (!obj.node.isChildOf(parent)) {
                        // should not clone other component if not descendant
                        return obj;
                      }
                    }
                  }
                }

                clone = new ctor();
              } else if (ctor === Object) {
                clone = {};
              } else if (!ctor) {
                clone = Object.create(null);
              } else {
                // unknown type
                return obj;
              }

              enumerateObject(obj, clone, parent);
              return clone;
            }

            instantiate._clone = doInstantiate;
            legacyCC.instantiate = instantiate;

            var _dec$i, _class$i, _class2$g, _descriptor$f, _descriptor2$d, _descriptor3$a, _descriptor4$6, _class3$7, _temp$i, _BuiltinElementTypeTr;
            var StorageUnit;

            (function (StorageUnit) {
              StorageUnit[StorageUnit["Uint8"] = 0] = "Uint8";
              StorageUnit[StorageUnit["Uint16"] = 1] = "Uint16";
              StorageUnit[StorageUnit["Uint32"] = 2] = "Uint32";
              StorageUnit[StorageUnit["Int8"] = 3] = "Int8";
              StorageUnit[StorageUnit["Int16"] = 4] = "Int16";
              StorageUnit[StorageUnit["Int32"] = 5] = "Int32";
              StorageUnit[StorageUnit["Float32"] = 6] = "Float32";
              StorageUnit[StorageUnit["Float64"] = 7] = "Float64";
            })(StorageUnit || (StorageUnit = {}));

            var ElementType;

            (function (ElementType) {
              ElementType[ElementType["Scalar"] = 0] = "Scalar";
              ElementType[ElementType["Vec2"] = 1] = "Vec2";
              ElementType[ElementType["Vec3"] = 2] = "Vec3";
              ElementType[ElementType["Vec4"] = 3] = "Vec4";
              ElementType[ElementType["Quat"] = 4] = "Quat";
              ElementType[ElementType["Mat4"] = 5] = "Mat4";
            })(ElementType || (ElementType = {}));

            var elementTypeBits = 3;
            function combineStorageUnitElementType(unit, elementType) {
              return (elementType << elementTypeBits) + unit;
            }
            function extractStorageUnitElementType(combined) {
              return {
                storageUnit: ~(-1 << elementTypeBits) & combined,
                elementType: combined >> elementTypeBits
              };
            }
            var CompactValueTypeArray = exports('aP', (_dec$i = ccclass('cc.CompactValueTypeArray'), _dec$i(_class$i = (_class2$g = (_temp$i = _class3$7 = /*#__PURE__*/function () {
              function CompactValueTypeArray() {
                _classCallCheck(this, CompactValueTypeArray);

                _initializerDefineProperty(this, "_byteOffset", _descriptor$f, this);

                _initializerDefineProperty(this, "_unitCount", _descriptor2$d, this);

                _initializerDefineProperty(this, "_unitElement", _descriptor3$a, this);

                _initializerDefineProperty(this, "_length", _descriptor4$6, this);
              }

              _createClass(CompactValueTypeArray, [{
                key: "decompress",

                /**
                 * Decompresses this CVTA.
                 * @param arrayBuffer The buffer this CVTA stored in.
                 */
                value: function decompress(arrayBuffer) {
                  var _extractStorageUnitEl = extractStorageUnitElementType(this._unitElement),
                      storageUnit = _extractStorageUnitEl.storageUnit,
                      elementType = _extractStorageUnitEl.elementType;

                  var elementTraits = getElementTraits(elementType);
                  var storageConstructor = getStorageConstructor(storageUnit);
                  var storage = new storageConstructor(arrayBuffer, this._byteOffset, this._unitCount);
                  var result = new Array(this._length);

                  for (var i = 0; i < this._length; ++i) {
                    result[i] = elementTraits.decompress(storage, i);
                  }

                  return result;
                }
              }], [{
                key: "lengthFor",

                /**
                 * Returns the length in bytes that a buffer needs to encode the specified value array in form of CVTA.
                 * @param values The value array.
                 * @param unit Target element type.
                 */
                value: function lengthFor(values, elementType, unit) {
                  var elementTraits = getElementTraits(elementType);
                  return elementTraits.requiredUnits * values.length * getStorageConstructor(unit).BYTES_PER_ELEMENT;
                }
                /**
                 * Compresses the specified value array in form of CVTA into target buffer.
                 * @param values The value array.
                 * @param unit Target element type.
                 * @param arrayBuffer Target buffer.
                 * @param byteOffset Offset into target buffer.
                 */

              }, {
                key: "compress",
                value: function compress(values, elementType, unit, arrayBuffer, byteOffset, presumedByteOffset) {
                  var elementTraits = getElementTraits(elementType);
                  var storageConstructor = getStorageConstructor(unit);
                  var unitCount = elementTraits.requiredUnits * values.length;
                  var storage = new storageConstructor(arrayBuffer, byteOffset, unitCount);

                  for (var i = 0; i < values.length; ++i) {
                    elementTraits.compress(storage, i, values[i]);
                  }

                  var result = new CompactValueTypeArray();
                  result._unitElement = combineStorageUnitElementType(unit, elementType);
                  result._byteOffset = presumedByteOffset;
                  result._unitCount = unitCount;
                  result._length = values.length;
                  return result;
                }
              }]);

              return CompactValueTypeArray;
            }(), _class3$7.StorageUnit = StorageUnit, _class3$7.ElementType = ElementType, _temp$i), (_descriptor$f = _applyDecoratedDescriptor(_class2$g.prototype, "_byteOffset", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            }), _descriptor2$d = _applyDecoratedDescriptor(_class2$g.prototype, "_unitCount", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            }), _descriptor3$a = _applyDecoratedDescriptor(_class2$g.prototype, "_unitElement", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return combineStorageUnitElementType(StorageUnit.Uint8, ElementType.Scalar);
              }
            }), _descriptor4$6 = _applyDecoratedDescriptor(_class2$g.prototype, "_length", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            })), _class2$g)) || _class$i));

            function getElementTraits(elementType) {
              return BuiltinElementTypeTraits[elementType];
            }

            function getStorageConstructor(unit) {
              switch (unit) {
                case StorageUnit.Uint8:
                  return Uint8Array;

                case StorageUnit.Uint16:
                  return Uint16Array;

                case StorageUnit.Uint32:
                  return Uint32Array;

                case StorageUnit.Int8:
                  return Int8Array;

                case StorageUnit.Int16:
                  return Int16Array;

                case StorageUnit.Int32:
                  return Int32Array;

                case StorageUnit.Float32:
                  return Float32Array;

                case StorageUnit.Float64:
                  return Float64Array;
              }
            }

            var BuiltinElementTypeTraits = (_BuiltinElementTypeTr = {}, _defineProperty(_BuiltinElementTypeTr, ElementType.Scalar, {
              requiredUnits: 1,
              compress: function compress(storage, index, value) {
                storage[index] = value;
              },
              decompress: function decompress(storage, index) {
                return storage[index];
              }
            }), _defineProperty(_BuiltinElementTypeTr, ElementType.Vec2, {
              requiredUnits: 2,
              compress: function compress(storage, index, value) {
                storage[index * 2] = value.x;
                storage[index * 2 + 1] = value.y;
              },
              decompress: function decompress(storage, index) {
                return new Vec3(storage[index * 2], storage[index * 2 + 1]);
              }
            }), _defineProperty(_BuiltinElementTypeTr, ElementType.Vec3, {
              requiredUnits: 3,
              compress: function compress(storage, index, value) {
                storage[index * 3] = value.x;
                storage[index * 3 + 1] = value.y;
                storage[index * 3 + 2] = value.z;
              },
              decompress: function decompress(storage, index) {
                return new Vec3(storage[index * 3], storage[index * 3 + 1], storage[index * 3 + 2]);
              }
            }), _defineProperty(_BuiltinElementTypeTr, ElementType.Vec4, {
              requiredUnits: 4,
              compress: function compress(storage, index, value) {
                storage[index * 4] = value.x;
                storage[index * 4 + 1] = value.y;
                storage[index * 4 + 2] = value.z;
                storage[index * 4 + 3] = value.w;
              },
              decompress: function decompress(storage, index) {
                return new Vec4(storage[index * 4], storage[index * 4 + 1], storage[index * 4 + 2], storage[index * 4 + 3]);
              }
            }), _defineProperty(_BuiltinElementTypeTr, ElementType.Quat, {
              requiredUnits: 4,
              compress: function compress(storage, index, value) {
                storage[index * 4] = value.x;
                storage[index * 4 + 1] = value.y;
                storage[index * 4 + 2] = value.z;
                storage[index * 4 + 3] = value.w;
              },
              decompress: function decompress(storage, index) {
                return new Quat(storage[index * 4], storage[index * 4 + 1], storage[index * 4 + 2], storage[index * 4 + 3]);
              }
            }), _defineProperty(_BuiltinElementTypeTr, ElementType.Mat4, {
              requiredUnits: 16,
              compress: function compress(storage, index, value) {
                Mat4.toArray(storage, value, index * 16);
              },
              decompress: function decompress(storage, index) {
                return Mat4.fromArray(new Mat4(), storage, index * 16);
              }
            }), _BuiltinElementTypeTr);

            /*
             Copyright (c) 2018 Xiamen Yaji Software Co., Ltd.

             http://www.cocos.com

             Permission is hereby granted, free of charge, to any person obtaining a copy
             of this software and associated engine source code (the "Software"), a limited,
              worldwide, royalty-free, non-assignable, revocable and non-exclusive license
             to use Cocos Creator solely to develop games on your target platforms. You shall
              not use Cocos Creator software for developing other software or tools that's
              used for developing games. You are not granted to publish, distribute,
              sublicense, and/or sell copies of Cocos Creator.

             The software or tools in this License Agreement are licensed, not sold.
             Xiamen Yaji Software Co., Ltd. reserves all rights not expressly granted to you.

             THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
             THE SOFTWARE.
            */
            legacyCC._decorator = _decorator;

            function deepFlatten(strList, array) {
              for (var _iterator = _createForOfIteratorHelperLoose(array), _step; !(_step = _iterator()).done;) {
                var item = _step.value;

                if (Array.isArray(item)) {
                  deepFlatten(strList, item);
                } // else if (item instanceof Declaration) {
                //     strList.push(item.toString());
                // }
                else {
                    strList.push(item);
                  }
              }
            }

            function flattenCodeArray(array) {
              var separator =  '';
              var strList = [];
              deepFlatten(strList, array);
              return strList.join(separator);
            }

            var Destroyed$1 = CCObject.Flags.Destroyed; // @ts-ignore

            var PersistentMask$1 = CCObject.Flags.PersistentMask;
            var DEFAULT = DELIMETER + 'default';
            var IDENTIFIER_RE = CCClass.IDENTIFIER_RE;
            var VAR = 'var ';
            var LOCAL_OBJ = 'o';
            var LOCAL_TEMP_OBJ = 't';
            var LOCAL_ARRAY = 'a';
            var LINE_INDEX_OF_NEW_OBJ = 0;
            var DEFAULT_MODULE_CACHE = {
              'cc.ClickEvent': false,
              'cc.PrefabInfo': false
            };
            var escapeForJS = CCClass.escapeForJS; // HELPER CLASSES
            // ('foo', 'bar')
            // -> 'var foo = bar;'

            var Declaration = /*#__PURE__*/function () {
              function Declaration(varName, expression) {
                _classCallCheck(this, Declaration);

                this.varName = void 0;
                this.expression = void 0;
                this.varName = varName;
                this.expression = expression;
              }

              _createClass(Declaration, [{
                key: "toString",
                value: function toString() {
                  return VAR + this.varName + '=' + this.expression + ';';
                }
              }]);

              return Declaration;
            }(); // ('a =', 'var b = x')
            // -> 'var b = a = x';
            // ('a =', 'x')
            // -> 'a = x';


            function mergeDeclaration(statement, expression) {
              if (expression instanceof Declaration) {
                return new Declaration(expression.varName, statement + expression.expression);
              } else {
                return statement + expression;
              }
            } // ('a', ['var b = x', 'b.foo = bar'])
            // -> 'var b = a = x;'
            // -> 'b.foo = bar;'
            // ('a', 'var b = x')
            // -> 'var b = a = x;'
            // ('a', 'x')
            // -> 'a = x;'


            function writeAssignment(codeArray, statement, expression) {
              if (Array.isArray(expression)) {
                expression[0] = mergeDeclaration(statement, expression[0]);
                codeArray.push(expression);
              } else {
                codeArray.push(mergeDeclaration(statement, expression) + ';');
              }
            } // ('foo', 'bar')
            // -> 'targetExpression.foo = bar'
            // ('foo1', 'bar1')
            // ('foo2', 'bar2')
            // -> 't = targetExpression;'
            // -> 't.foo1 = bar1;'
            // -> 't.foo2 = bar2;'


            var Assignments = /*#__PURE__*/function () {
              function Assignments(targetExpression) {
                _classCallCheck(this, Assignments);

                this._exps = void 0;
                this._targetExp = void 0;
                this._exps = [];
                this._targetExp = targetExpression;
              }

              _createClass(Assignments, [{
                key: "append",
                value: function append(key, expression) {
                  this._exps.push([key, expression]);
                }
              }, {
                key: "writeCode",
                value: function writeCode(codeArray) {
                  var targetVar;

                  if (this._exps.length > 1) {
                    codeArray.push(LOCAL_TEMP_OBJ + '=' + this._targetExp + ';');
                    targetVar = LOCAL_TEMP_OBJ;
                  } else if (this._exps.length === 1) {
                    targetVar = this._targetExp;
                  } else {
                    return;
                  } // tslint:disable: prefer-for-of


                  for (var i = 0; i < this._exps.length; i++) {
                    var pair = this._exps[i];
                    writeAssignment(codeArray, targetVar + getPropAccessor(pair[0]) + '=', pair[1]);
                  }
                }
              }]);

              return Assignments;
            }();

            Assignments.pool = void 0;
            Assignments.pool = new Pool$1(function (obj) {
              obj._exps.length = 0;
              obj._targetExp = null;
            }, 1); // @ts-ignore

            Assignments.pool.get = function (targetExpression) {
              var cache = this._get() || new Assignments();
              cache._targetExp = targetExpression;
              return cache;
            }; // HELPER FUNCTIONS


            function getPropAccessor(key) {
              return IDENTIFIER_RE.test(key) ? '.' + key : '[' + escapeForJS(key) + ']';
            } //

            /*
             * Variables:
             * {Object[]} O - objs list
             * {Function[]} F - constructor list
             * {Node} [R] - specify an instantiated prefabRoot that all references to prefabRoot in prefab will redirect to
             * {Object} o - current creating object
             */


            var Parser = /*#__PURE__*/function () {
              /*
              * @method constructor
              * @param {Object} obj - the object to parse
              * @param {Node} [parent]
              */
              function Parser(obj, parent) {
                _classCallCheck(this, Parser);

                this.parent = void 0;
                this.objsToClear_iN$t = void 0;
                this.codeArray = void 0;
                this.objs = void 0;
                this.funcs = void 0;
                this.funcModuleCache = void 0;
                this.globalVariables = void 0;
                this.globalVariableId = void 0;
                this.localVariableId = void 0;
                this.result = void 0;
                this.parent = parent;
                this.objsToClear_iN$t = []; // used to reset _iN$t variable

                this.codeArray = []; // datas for generated code

                this.objs = [];
                this.funcs = [];
                this.funcModuleCache = createMap();
                mixin(this.funcModuleCache, DEFAULT_MODULE_CACHE); // {String[]} - variable names for circular references,
                //              not really global, just local variables shared between sub functions

                this.globalVariables = []; // incremental id for new global variables

                this.globalVariableId = 0; // incremental id for new local variables

                this.localVariableId = 0; // generate codeArray
                // if (Array.isArray(obj)) {
                //    this.codeArray.push(this.instantiateArray(obj));
                // }
                // else {

                this.codeArray.push(VAR + LOCAL_OBJ + ',' + LOCAL_TEMP_OBJ + ';', 'if(R){', LOCAL_OBJ + '=R;', '}else{', LOCAL_OBJ + '=R=new ' + this.getFuncModule(obj.constructor, true) + '();', '}');
                obj._iN$t = {
                  globalVar: 'R'
                };
                this.objsToClear_iN$t.push(obj);
                this.enumerateObject(this.codeArray, obj); // }
                // generate code

                var globalVariablesDeclaration;

                if (this.globalVariables.length > 0) {
                  globalVariablesDeclaration = VAR + this.globalVariables.join(',') + ';';
                }

                var code = flattenCodeArray(['return (function(R){', globalVariablesDeclaration || [], this.codeArray, 'return o;', '})']); // generate method and bind with objs

                this.result = Function('O', 'F', code)(this.objs, this.funcs); // if (TEST && !isPhantomJS) {
                //     console.log(code);
                // }
                // cleanup

                for (var i = 0, len = this.objsToClear_iN$t.length; i < len; ++i) {
                  this.objsToClear_iN$t[i]._iN$t = null;
                }

                this.objsToClear_iN$t.length = 0;
              }

              _createClass(Parser, [{
                key: "getFuncModule",
                value: function getFuncModule(func, usedInNew) {
                  var clsName = getClassName(func);

                  if (clsName) {
                    var cache = this.funcModuleCache[clsName];

                    if (cache) {
                      return cache;
                    } else if (cache === undefined) {
                      var clsNameIsModule = clsName.indexOf('.') !== -1;

                      if (clsNameIsModule) {
                        try {
                          // ensure is module
                          clsNameIsModule = func === Function('return ' + clsName)();

                          if (clsNameIsModule) {
                            this.funcModuleCache[clsName] = clsName;
                            return clsName;
                          }
                        } catch (e) {}
                      }
                    }
                  }

                  var index = this.funcs.indexOf(func);

                  if (index < 0) {
                    index = this.funcs.length;
                    this.funcs.push(func);
                  }

                  var res = 'F[' + index + ']';

                  if (usedInNew) {
                    res = '(' + res + ')';
                  }

                  this.funcModuleCache[clsName] = res;
                  return res;
                }
              }, {
                key: "getObjRef",
                value: function getObjRef(obj) {
                  var index = this.objs.indexOf(obj);

                  if (index < 0) {
                    index = this.objs.length;
                    this.objs.push(obj);
                  }

                  return 'O[' + index + ']';
                }
              }, {
                key: "setValueType",
                value: function setValueType(codeArray, defaultValue, srcValue, targetExpression) {
                  // @ts-ignore
                  var assignments = Assignments.pool.get(targetExpression);
                  var fastDefinedProps = defaultValue.constructor.__props__;

                  if (!fastDefinedProps) {
                    fastDefinedProps = Object.keys(defaultValue);
                  }

                  for (var i = 0; i < fastDefinedProps.length; i++) {
                    var propName = fastDefinedProps[i];
                    var prop = srcValue[propName];

                    if (defaultValue[propName] === prop) {
                      continue;
                    }

                    var expression = this.enumerateField(srcValue, propName, prop);
                    assignments.append(propName, expression);
                  }

                  assignments.writeCode(codeArray);
                  Assignments.pool.put(assignments);
                }
              }, {
                key: "enumerateCCClass",
                value: function enumerateCCClass(codeArray, obj, klass) {
                  var props = klass.__values__;
                  var attrs = getClassAttrs(klass);

                  for (var p = 0; p < props.length; p++) {
                    var key = props[p];
                    var val = obj[key];
                    var defaultValue = attrs[key + DEFAULT];

                    if (equalsToDefault(defaultValue, val)) {
                      continue;
                    }

                    if (_typeof(val) === 'object' && val instanceof legacyCC.ValueType) {
                      defaultValue = CCClass.getDefault(defaultValue);

                      if (defaultValue && defaultValue.constructor === val.constructor) {
                        // fast case
                        var targetExpression = LOCAL_OBJ + getPropAccessor(key);
                        this.setValueType(codeArray, defaultValue, val, targetExpression);
                        continue;
                      }
                    }

                    this.setObjProp(codeArray, obj, key, val);
                  }
                }
              }, {
                key: "instantiateArray",
                value: function instantiateArray(value) {
                  if (value.length === 0) {
                    return '[]';
                  }

                  var arrayVar = LOCAL_ARRAY + ++this.localVariableId;
                  var declaration = new Declaration(arrayVar, 'new Array(' + value.length + ')');
                  var codeArray = [declaration]; // assign a _iN$t flag to indicate that this object has been parsed.

                  value._iN$t = {
                    globalVar: '',
                    // the name of declared global variable used to access this object
                    source: codeArray // the source code array for this object

                  };
                  this.objsToClear_iN$t.push(value);

                  for (var i = 0; i < value.length; ++i) {
                    var statement = arrayVar + '[' + i + ']=';
                    var expression = this.enumerateField(value, i, value[i]);
                    writeAssignment(codeArray, statement, expression);
                  }

                  return codeArray;
                }
              }, {
                key: "enumerateField",
                value: function enumerateField(obj, key, value) {
                  if (_typeof(value) === 'object' && value) {
                    var _iN$t = value._iN$t;

                    if (_iN$t) {
                      // parsed
                      var globalVar = _iN$t.globalVar;

                      if (!globalVar) {
                        // declare a global var
                        globalVar = _iN$t.globalVar = 'v' + ++this.globalVariableId;
                        this.globalVariables.push(globalVar); // insert assignment statement to assign to global var

                        var line = _iN$t.source[LINE_INDEX_OF_NEW_OBJ];
                        _iN$t.source[LINE_INDEX_OF_NEW_OBJ] = mergeDeclaration(globalVar + '=', line); // if (typeof line ==='string' && line.startsWith(VAR)) {
                        //     // var o=xxx -> var o=global=xxx
                        //     var LEN_OF_VAR_O = 5;
                        //     _iN$t.source[LINE_INDEX_OF_NEW_OBJ] = line.slice(0, LEN_OF_VAR_O) + '=' + globalVar + line.slice(LEN_OF_VAR_O);
                        // }
                      }

                      return globalVar;
                    } else if (Array.isArray(value)) {
                      return this.instantiateArray(value);
                    } else {
                      return this.instantiateObj(value);
                    }
                  } else if (typeof value === 'function') {
                    return this.getFuncModule(value);
                  } else if (typeof value === 'string') {
                    return escapeForJS(value);
                  } else {
                    if (key === '_objFlags' && obj instanceof CCObject) {
                      value &= PersistentMask$1;
                    }

                    return value;
                  }
                }
              }, {
                key: "setObjProp",
                value: function setObjProp(codeArray, obj, key, value) {
                  var statement = LOCAL_OBJ + getPropAccessor(key) + '=';
                  var expression = this.enumerateField(obj, key, value);
                  writeAssignment(codeArray, statement, expression);
                } // codeArray - the source code array for this object

              }, {
                key: "enumerateObject",
                value: function enumerateObject(codeArray, obj) {
                  var klass = obj.constructor;

                  if (legacyCC.Class._isCCClass(klass)) {
                    this.enumerateCCClass(codeArray, obj, klass);
                  } else {
                    // primitive javascript object
                    for (var key in obj) {
                      if (!obj.hasOwnProperty(key) || key.charCodeAt(0) === 95 && key.charCodeAt(1) === 95 && // starts with "__"
                      key !== '__type__') {
                        continue;
                      }

                      var value = obj[key];

                      if (_typeof(value) === 'object' && value && value === obj._iN$t) {
                        continue;
                      }

                      this.setObjProp(codeArray, obj, key, value);
                    }
                  }
                }
              }, {
                key: "instantiateObj",
                value: function instantiateObj(obj) {
                  if (obj instanceof legacyCC.ValueType) {
                    return CCClass.getNewValueTypeCode(obj);
                  }

                  if (obj instanceof legacyCC.Asset) {
                    // register to asset list and just return the reference.
                    return this.getObjRef(obj);
                  }

                  if (obj._objFlags & Destroyed$1) {
                    // the same as cc.isValid(obj)
                    return null;
                  }

                  var createCode;
                  var ctor = obj.constructor;

                  if (legacyCC.Class._isCCClass(ctor)) {
                    if (this.parent) {
                      if (this.parent instanceof legacyCC.Component) {
                        if (obj instanceof legacyCC._BaseNode || obj instanceof legacyCC.Component) {
                          return this.getObjRef(obj);
                        }
                      } else if (this.parent instanceof legacyCC._BaseNode) {
                        if (obj instanceof legacyCC._BaseNode) {
                          if (!obj.isChildOf(this.parent)) {
                            // should not clone other nodes if not descendant
                            return this.getObjRef(obj);
                          }
                        } else if (obj instanceof legacyCC.Component) {
                          if (!obj.node.isChildOf(this.parent)) {
                            // should not clone other component if not descendant
                            return this.getObjRef(obj);
                          }
                        }
                      }
                    }

                    createCode = new Declaration(LOCAL_OBJ, 'new ' + this.getFuncModule(ctor, true) + '()');
                  } else if (ctor === Object) {
                    createCode = new Declaration(LOCAL_OBJ, '{}');
                  } else if (!ctor) {
                    createCode = new Declaration(LOCAL_OBJ, 'Object.create(null)');
                  } else {
                    // do not clone unknown type
                    return this.getObjRef(obj);
                  }

                  var codeArray = [createCode]; // assign a _iN$t flag to indicate that this object has been parsed.

                  obj._iN$t = {
                    globalVar: '',
                    // the name of declared global variable used to access this object
                    source: codeArray // the source code array for this object
                    // propName: '',     // the propName this object defined in its source code,
                    //                  // if defined, use LOCAL_OBJ.propName to access the obj, else just use o

                  };
                  this.objsToClear_iN$t.push(obj);
                  this.enumerateObject(codeArray, obj);
                  return ['(function(){', codeArray, 'return o;})();'];
                }
              }]);

              return Parser;
            }();

            function equalsToDefault(def, value) {
              if (typeof def === 'function') {
                try {
                  def = def();
                } catch (e) {
                  return false;
                }
              }

              if (def === value) {
                return true;
              }

              if (def && value) {
                if (def instanceof legacyCC.ValueType && def.equals(value)) {
                  return true;
                }

                if (Array.isArray(def) && Array.isArray(value) || def.constructor === Object && value.constructor === Object) {
                  try {
                    return Array.isArray(def) && Array.isArray(value) && def.length === 0 && value.length === 0;
                  } catch (e) {}
                }
              }

              return false;
            }
            function compile(node) {
              var root = node instanceof legacyCC._BaseNode && node;
              var parser = new Parser(node, root);
              return parser.result;
            }

            var _dec$j, _class$j, _class2$h, _descriptor$g, _descriptor2$e, _descriptor3$b, _class3$8, _temp$j;
            /**
             * @en An enumeration used with the [[Prefab.optimizationPolicy]] to specify how to optimize the instantiate operation.
             * @zh Prefab 创建实例所用的优化策略，配合 [[Prefab.optimizationPolicy]] 使用。
             */

            var OptimizationPolicy = Enum({
              /**
               * @en The optimization policy is automatically chosen based on the number of instantiations.
               * When you first create an instance, the behavior is the same as SINGLE_INSTANCE. MULTI_INSTANCE will be automatically used after multiple creation.
               * @zh 根据创建次数自动调整优化策略。初次创建实例时，行为等同 SINGLE_INSTANCE，多次创建后将自动采用 MULTI_INSTANCE。
               */
              AUTO: 0,

              /**
               * @en Optimize for single instance creation.<br>
               * This option skips code generation for this prefab.
               * When this prefab will usually create only one instances, please select this option.
               * @zh 优化单次创建性能。<br>
               * 该选项会跳过针对这个 prefab 的代码生成优化操作。当该 prefab 加载后，一般只会创建一个实例时，请选择此项。
               */
              SINGLE_INSTANCE: 1,

              /**
               * @en Optimize for creating instances multiple times.<br>
               * This option enables code generation for this prefab.
               * When this prefab will usually create multiple instances, please select this option.
               * It is also recommended to select this option if the prefab instance in the scene has Auto Sync enabled and there are multiple instances in the scene.
               * @zh 优化多次创建性能。<br>
               * 该选项会启用针对这个 prefab 的代码生成优化操作。当该 prefab 加载后，一般会创建多个实例时，请选择此项。如果该 prefab 在场景中的节点启用了自动关联，并且在场景中有多份实例，也建议选择此项。
               */
              MULTI_INSTANCE: 2
            });
            /**
             * @en Class for prefab handling.
             * @zh 预制资源类。
             */

            var Prefab = exports('aR', (_dec$j = ccclass('cc.Prefab'), _dec$j(_class$j = (_class2$h = (_temp$j = _class3$8 = /*#__PURE__*/function (_Asset) {
              _inherits(Prefab, _Asset);

              /**
               * @en Enumeration for optimization policy
               * @zh Prefab 创建实例所用的优化策略枚举类型
               */

              /**
               * @en The main [[Node]] in the prefab
               * @zh Prefab 中的根节点，[[Node]] 类型
               */

              /**
               * @zh
               * 设置实例化这个 prefab 时所用的优化策略。根据使用情况设置为合适的值，能优化该 prefab 实例化所用的时间。推荐在编辑器的资源中设置。
               * @en
               * Indicates the optimization policy for instantiating this prefab.
               * Set to a suitable value based on usage, can optimize the time it takes to instantiate this prefab.
               * Suggest to set this policy in the editor's asset inspector.
               * @default Prefab.OptimizationPolicy.AUTO
               * @example
               * ```ts
               * import { Prefab } from 'cc';
               * prefab.optimizationPolicy = Prefab.OptimizationPolicy.MULTI_INSTANCE;
               * ```
               */

              /**
               * @en Indicates the raw assets of this prefab can be load after prefab loaded.
               * @zh 指示该 Prefab 依赖的资源可否在 Prefab 加载后再延迟加载。
               * @default false
               */
              // Cache function to optimize instance creation.
              function Prefab() {
                var _this;

                _classCallCheck(this, Prefab);

                _this = _possibleConstructorReturn(this, _getPrototypeOf(Prefab).call(this));

                _initializerDefineProperty(_this, "data", _descriptor$g, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "optimizationPolicy", _descriptor2$e, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "asyncLoadAssets", _descriptor3$b, _assertThisInitialized(_this));

                _this._createFunction = void 0;
                _this._instantiatedTimes = void 0;
                _this._createFunction = null;
                _this._instantiatedTimes = 0;
                return _this;
              }

              _createClass(Prefab, [{
                key: "createNode",
                value: function createNode(cb) {
                  var node = legacyCC.instantiate(this);
                  node.name = this.name;
                  cb(null, node);
                }
                /**
                 * @en
                 * Dynamically translation prefab data into minimized code.<br/>
                 * This method will be called automatically before the first time the prefab being instantiated,<br/>
                 * but you can re-call to refresh the create function once you modified the original prefab data in script.
                 * @zh
                 * 将预制数据动态转换为最小化代码。<br/>
                 * 此方法将在第一次实例化预制件之前自动调用，<br/>
                 * 但是您可以在脚本中修改原始预制数据后重新调用以刷新创建功能。
                 */

              }, {
                key: "compileCreateFunction",
                value: function compileCreateFunction() {
                  this._createFunction = compile(this.data);
                } // just instantiate, will not initialize the Node, this will be called during Node's initialization.
                // @param {Node} [rootToRedirect] - specify an instantiated prefabRoot that all references to prefabRoot in prefab
                //                                  will redirect to

              }, {
                key: "_doInstantiate",
                value: function _doInstantiate(rootToRedirect) {
                  if (this.data._prefab) {
                    // prefab asset is always synced
                    this.data._prefab._synced = true;
                  } else {
                    // temp guard code
                    warnID(3700);
                  }

                  if (!this._createFunction) {
                    this.compileCreateFunction();
                  }

                  return this._createFunction(rootToRedirect); // this.data._instantiate();
                }
              }, {
                key: "_instantiate",
                value: function _instantiate() {
                  var node;
                  var useJit = false;

                  {
                    if (this.optimizationPolicy === OptimizationPolicy.SINGLE_INSTANCE) {
                      useJit = false;
                    } else if (this.optimizationPolicy === OptimizationPolicy.MULTI_INSTANCE) {
                      useJit = true;
                    } else {
                      // auto
                      useJit = this._instantiatedTimes + 1 >= Prefab.OptimizationPolicyThreshold;
                    }
                  }

                  if (useJit) {
                    // instantiate node
                    node = this._doInstantiate(); // initialize node

                    this.data._instantiate(node);
                  } else {
                    // prefab asset is always synced
                    this.data._prefab._synced = true; // instantiate node

                    node = this.data._instantiate();
                  }

                  ++this._instantiatedTimes;
                  return node;
                }
              }]);

              return Prefab;
            }(Asset), _class3$8.OptimizationPolicy = OptimizationPolicy, _class3$8.OptimizationPolicyThreshold = 3, _temp$j), (_descriptor$g = _applyDecoratedDescriptor(_class2$h.prototype, "data", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor2$e = _applyDecoratedDescriptor(_class2$h.prototype, "optimizationPolicy", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return OptimizationPolicy.AUTO;
              }
            }), _descriptor3$b = _applyDecoratedDescriptor(_class2$h.prototype, "asyncLoadAssets", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return false;
              }
            })), _class2$h)) || _class$j));
            legacyCC.Prefab = Prefab;

            {
              obsolete(legacyCC, 'cc._Prefab', 'Prefab');
            }

            var _dec$k, _class$k, _class2$i, _descriptor$h, _descriptor2$f, _temp$k;
            /**
             * @en Class for scene loading.
             * @zh 场景资源类。
             *
             */

            var SceneAsset = exports('aS', (_dec$k = ccclass('cc.SceneAsset'), _dec$k(_class$k = (_class2$i = (_temp$k = /*#__PURE__*/function (_Asset) {
              _inherits(SceneAsset, _Asset);

              function SceneAsset() {
                var _getPrototypeOf2;

                var _this;

                _classCallCheck(this, SceneAsset);

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SceneAsset)).call.apply(_getPrototypeOf2, [this].concat(args)));

                _initializerDefineProperty(_this, "scene", _descriptor$h, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "asyncLoadAssets", _descriptor2$f, _assertThisInitialized(_this));

                return _this;
              }

              return SceneAsset;
            }(Asset), _temp$k), (_descriptor$h = _applyDecoratedDescriptor(_class2$i.prototype, "scene", [editable, serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor2$f = _applyDecoratedDescriptor(_class2$i.prototype, "asyncLoadAssets", [editable, serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return false;
              }
            })), _class2$i)) || _class$k));
            legacyCC.SceneAsset = SceneAsset;

            var _dec$l, _class$l, _class2$j, _descriptor$i, _temp$l;
            var SpriteAtlas = exports('aT', (_dec$l = ccclass('cc.SpriteAtlas'), _dec$l(_class$l = (_class2$j = (_temp$l = /*#__PURE__*/function (_Asset) {
              _inherits(SpriteAtlas, _Asset);

              function SpriteAtlas() {
                var _getPrototypeOf2;

                var _this;

                _classCallCheck(this, SpriteAtlas);

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(SpriteAtlas)).call.apply(_getPrototypeOf2, [this].concat(args)));

                _initializerDefineProperty(_this, "spriteFrames", _descriptor$i, _assertThisInitialized(_this));

                return _this;
              }

              _createClass(SpriteAtlas, [{
                key: "getTexture",

                /**
                 * @en Get the [[Texture2D]] asset of the atlas.
                 * @zh 获取精灵图集的贴图。请注意，由于结构调整优化，在 v1.1 版本之前，此函数的返回值为 imageAsset，在 v1.1 版本之后修正为 texture，想要获取 imageAsset 可使用 getTexture().image 获取
                 * @returns The texture2d asset
                 */
                value: function getTexture() {
                  var keys = Object.keys(this.spriteFrames);

                  if (keys.length > 0) {
                    var spriteFrame = this.spriteFrames[keys[0]];
                    return spriteFrame && spriteFrame.texture;
                  } else {
                    return null;
                  }
                }
                /**
                 * @en Gets the [[SpriteFrame]] correspond to the given key in sprite atlas.
                 * @zh 根据键值获取精灵。
                 *
                 * @param key The SpriteFrame name
                 * @returns The SpriteFrame asset
                 */

              }, {
                key: "getSpriteFrame",
                value: function getSpriteFrame(key) {
                  var sf = this.spriteFrames[key];

                  if (!sf) {
                    return null;
                  }

                  if (!sf.name) {
                    sf.name = key;
                  }

                  return sf;
                }
                /**
                 * @en Returns all sprite frames in the sprite atlas.
                 * @zh 获取精灵图集所有精灵。
                 * @returns All sprite frames
                 */

              }, {
                key: "getSpriteFrames",
                value: function getSpriteFrames() {
                  var frames = [];
                  var spriteFrames = this.spriteFrames;

                  for (var _i = 0, _Object$keys = Object.keys(spriteFrames); _i < _Object$keys.length; _i++) {
                    var _key2 = _Object$keys[_i];
                    frames.push(spriteFrames[_key2]);
                  }

                  return frames;
                }
              }, {
                key: "_serialize",
                value: function _serialize(exporting) {
                  var frames = [];

                  for (var _i2 = 0, _Object$keys2 = Object.keys(this.spriteFrames); _i2 < _Object$keys2.length; _i2++) {
                    var _key3 = _Object$keys2[_i2];
                    var spriteFrame = this.spriteFrames[_key3];
                    var id = spriteFrame ? spriteFrame._uuid : '';

                    if (id && exporting) {
                      id = EditorExtends.UuidUtils.compressUuid(id, true);
                    }

                    frames.push(_key3);
                    frames.push(id);
                  }

                  return {
                    name: this._name,
                    spriteFrames: frames
                  };
                }
              }, {
                key: "_deserialize",
                value: function _deserialize(serializeData, handle) {
                  var data = serializeData;
                  this._name = data.name;
                  var frames = data.spriteFrames;
                  this.spriteFrames = createMap();

                  for (var i = 0; i < frames.length; i += 2) {
                    handle.result.push(this.spriteFrames, frames[i], frames[i + 1]);
                  }
                }
              }]);

              return SpriteAtlas;
            }(Asset), _temp$l), (_descriptor$i = _applyDecoratedDescriptor(_class2$j.prototype, "spriteFrames", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return createMap();
              }
            })), _class2$j)) || _class$l));
            legacyCC.SpriteAtlas = SpriteAtlas;

            var _dec$m, _class$m, _class2$k, _descriptor$j, _temp$m;
            /**
             * @en Class for text file.
             * @zh 文本资源。
             */

            var TextAsset = exports('aU', (_dec$m = ccclass('cc.TextAsset'), _dec$m(_class$m = (_class2$k = (_temp$m = /*#__PURE__*/function (_Asset) {
              _inherits(TextAsset, _Asset);

              function TextAsset() {
                var _getPrototypeOf2;

                var _this;

                _classCallCheck(this, TextAsset);

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(TextAsset)).call.apply(_getPrototypeOf2, [this].concat(args)));

                _initializerDefineProperty(_this, "text", _descriptor$j, _assertThisInitialized(_this));

                return _this;
              }

              _createClass(TextAsset, [{
                key: "toString",
                value: function toString() {
                  return this.text;
                }
              }]);

              return TextAsset;
            }(Asset), _temp$m), (_descriptor$j = _applyDecoratedDescriptor(_class2$k.prototype, "text", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return '';
              }
            })), _class2$k)) || _class$m));
            legacyCC.TextAsset = TextAsset;

            var _dec$n, _class$n, _class2$l, _descriptor$k, _temp$n;
            /**
             * @en Json asset, it will automatically parse the json to a JS object.
             * @zh Json 资源。
             * Json 资源加载后将直接解析为对象。如果你希望获得 JSON 的原始文本，你需要使用文本资源（使用文件名后缀“.txt”）。
             */

            var JsonAsset = exports('aV', (_dec$n = ccclass('cc.JsonAsset'), _dec$n(_class$n = (_class2$l = (_temp$n = /*#__PURE__*/function (_Asset) {
              _inherits(JsonAsset, _Asset);

              function JsonAsset() {
                var _getPrototypeOf2;

                var _this;

                _classCallCheck(this, JsonAsset);

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(JsonAsset)).call.apply(_getPrototypeOf2, [this].concat(args)));

                _initializerDefineProperty(_this, "json", _descriptor$k, _assertThisInitialized(_this));

                return _this;
              }

              return JsonAsset;
            }(Asset), _temp$n), (_descriptor$k = _applyDecoratedDescriptor(_class2$l.prototype, "json", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            })), _class2$l)) || _class$n));
            legacyCC.JsonAsset = JsonAsset;

            /*
             Copyright (c) 2013-2016 Chukong Technologies Inc.
             Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

             http://www.cocos.com

             Permission is hereby granted, free of charge, to any person obtaining a copy
             of this software and associated engine source code (the "Software"), a limited,
              worldwide, royalty-free, non-assignable, revocable and non-exclusive license
             to use Cocos Creator solely to develop games on your target platforms. You shall
              not use Cocos Creator software for developing other software or tools that's
              used for developing games. You are not granted to publish, distribute,
              sublicense, and/or sell copies of Cocos Creator.

             The software or tools in this License Agreement are licensed, not sold.
             Xiamen Yaji Software Co., Ltd. reserves all rights not expressly granted to you.

             THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
             THE SOFTWARE.
            */
            var HexChars = '0123456789abcdef'.split('');
            var _t = ['', '', '', ''];

            var UuidTemplate = _t.concat(_t, '-', _t, '-', _t, '-', _t, '-', _t, _t, _t);

            var Indices = UuidTemplate.map(function (x, i) {
              return x === '-' ? NaN : i;
            }).filter(isFinite);
            /**
             * @en
             * Decode uuid, returns the original uuid
             *
             * @zh
             * 解码 uuid，返回原始 uuid
             *
             * @param  base64 - the encoded uuid
             * @returns the original uuid
             *
             * @example
             * ```ts
             * const uuid = 'fcmR3XADNLgJ1ByKhqcC5Z';
             * const originalUuid = decodeUuid(uuid); // fc991dd7-0033-4b80-9d41-c8a86a702e59
             * ```
             */

            function decodeUuid(base64) {
              var strs = base64.split('@');
              var uuid = strs[0];

              if (uuid.length !== 22) {
                return base64;
              }

              UuidTemplate[0] = base64[0];
              UuidTemplate[1] = base64[1];

              for (var i = 2, j = 2; i < 22; i += 2) {
                var lhs = BASE64_VALUES[base64.charCodeAt(i)];
                var rhs = BASE64_VALUES[base64.charCodeAt(i + 1)];
                UuidTemplate[Indices[j++]] = HexChars[lhs >> 2];
                UuidTemplate[Indices[j++]] = HexChars[(lhs & 3) << 2 | rhs >> 4];
                UuidTemplate[Indices[j++]] = HexChars[rhs & 0xF];
              }

              return base64.replace(uuid, UuidTemplate.join(''));
            }

            /*
             Copyright (c) 2013-2016 Chukong Technologies Inc.
             Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

             http://www.cocos.com

             Permission is hereby granted, free of charge, to any person obtaining a copy
             of this software and associated engine source code (the "Software"), a limited,
              worldwide, royalty-free, non-assignable, revocable and non-exclusive license
             to use Cocos Creator solely to develop games on your target platforms. You shall
              not use Cocos Creator software for developing other software or tools that's
              used for developing games. You are not granted to publish, distribute,
              sublicense, and/or sell copies of Cocos Creator.

             The software or tools in this License Agreement are licensed, not sold.
             Xiamen Yaji Software Co., Ltd. reserves all rights not expressly granted to you.

             THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
             THE SOFTWARE.
             */
            /**
             * @class url
             * @static
             */

            var url = exports('cP', {
              /**
               * The base url of raw assets.
               * @private
               * @readOnly
               */
              _rawAssets: '',
              normalize: function normalize(url) {
                if (url) {
                  if (url.charCodeAt(0) === 46 && url.charCodeAt(1) === 47) {
                    // strip './'
                    url = url.slice(2);
                  } else if (url.charCodeAt(0) === 47) {
                    // strip '/'
                    url = url.slice(1);
                  }
                }

                return url;
              },

              /**
               * Returns the url of raw assets, you will only need this if the raw asset is inside the "resources" folder.
               *
               * @method raw
               * @param {String} url
               * @return {String}
               * @example {@link cocos/core/platform/url/raw.js}
               */
              raw: function raw(url) {

                url = this.normalize(url);

                if (!url.startsWith('resources/')) {
                  errorID( 7002, url);
                } else {
                  // Compatible with versions lower than 1.10
                  var uuid = legacyCC.loader._getResUuid(url.slice(10), legacyCC.Asset, null, true);

                  if (uuid) {
                    return legacyCC.AssetLibrary.getLibUrlNoExt(uuid, true) + extname(url);
                  }
                }

                return this._rawAssets + url;
              },
              _init: function _init(assets) {
                this._rawAssets = stripSep(assets) + '/';
              }
            });
            legacyCC.url = url;

            var Entry = function Entry(uuid, type) {
              _classCallCheck(this, Entry);

              this.uuid = void 0;
              this.type = void 0;
              this.uuid = uuid;
              this.type = type;
            };

            function isMatchByWord(path, test) {
              if (path.length > test.length) {
                var nextAscii = path.charCodeAt(test.length);
                return nextAscii === 47; // '/'
              }

              return true;
            }
            /*
             * @en AssetTable is used to find asset's uuid by url.
             * @zh AssetTable 用于查找资源的 uuid 和 url。
             */


            var AssetTable = /*#__PURE__*/function () {
              function AssetTable() {
                _classCallCheck(this, AssetTable);

                this._pathToUuid = void 0;
                this._pathToUuid = createMap(true);
              }
              /**
               * Retrieve the asset uuid with the asset path and type
               */


              _createClass(AssetTable, [{
                key: "getUuid",
                value: function getUuid(path, type) {
                  path = url.normalize(path);
                  var item = this._pathToUuid[path];

                  if (item) {
                    if (Array.isArray(item)) {
                      if (type) {
                        for (var i = 0; i < item.length; i++) {
                          var entry = item[i];

                          if (isChildClassOf(entry.type, type)) {
                            return entry.uuid;
                          }
                        } // not found


                        if ( isChildClassOf(type, SpriteFrame)) {
                          for (var _i = 0; _i < item.length; _i++) {
                            var _entry = item[_i];

                            if (isChildClassOf(_entry.type, SpriteAtlas)) {
                              // not support sprite frame in atlas
                              errorID(4932, path);
                              break;
                            }
                          }
                        }
                      } else {
                        return item[0].uuid;
                      }
                    } else if (!type || isChildClassOf(item.type, type)) {
                      return item.uuid;
                    } else if ( isChildClassOf(type, SpriteFrame) && isChildClassOf(item.type, SpriteAtlas)) {
                      // not support sprite frame in atlas
                      errorID(4932, path);
                    }
                  }

                  return '';
                }
                /**
                 * Retrieve an uuid array with the asset path and type
                 */

              }, {
                key: "getUuidArray",
                value: function getUuidArray(path, type, out_urls) {
                  path = url.normalize(path);

                  if (path[path.length - 1] === '/') {
                    path = path.slice(0, -1);
                  }

                  var path2uuid = this._pathToUuid;
                  var uuids = [];

                  var _foundAtlasUrl;

                  for (var p in path2uuid) {
                    if (p.startsWith(path) && isMatchByWord(p, path) || !path) {
                      var item = path2uuid[p];

                      if (Array.isArray(item)) {
                        for (var i = 0; i < item.length; i++) {
                          var entry = item[i];

                          if (!type || isChildClassOf(entry.type, type)) {
                            uuids.push(entry.uuid);

                            if (out_urls) {
                              out_urls.push(p);
                            }
                          } else if ( entry.type === SpriteAtlas) {
                            _foundAtlasUrl = p;
                          }
                        }
                      } else {
                        if (!type || isChildClassOf(item.type, type)) {
                          uuids.push(item.uuid);

                          if (out_urls) {
                            out_urls.push(p);
                          }
                        } else if ( item.type === SpriteAtlas) {
                          _foundAtlasUrl = p;
                        }
                      }
                    }
                  }

                  if ( uuids.length === 0 && _foundAtlasUrl && isChildClassOf(type, SpriteFrame)) {
                    // not support sprite frame in atlas
                    errorID(4932, _foundAtlasUrl);
                  }

                  return uuids;
                } // /**
                //  * @en Returns all asset paths in the table.
                //  * @zh 返回表中的所有资源路径。
                //  * @method getAllPaths
                //  * @return {string[]}
                //  */
                // getAllPaths () {
                //     return Object.keys(this._pathToUuid);
                // }

                /**
                 * @en Add an asset entry with path as key and asset uuid & type as value to the table
                 * @zh 以路径为 key，uuid 和资源类型为值添加到表中。
                 * @param path - the path of the asset, should NOT include filename extensions.
                 * @param uuid - The uuid of the asset
                 * @param type - Constructor of the asset
                 * @param isMainAsset
                 * @private
                 */

              }, {
                key: "add",
                value: function add(path, uuid, type, isMainAsset) {
                  // remove extname
                  // (can not use path.slice because length of extname maybe 0)
                  isMainAsset && (path = path.substring(0, path.length - extname(path).length));
                  var newEntry = new Entry(uuid, type);
                  pushToMap(this._pathToUuid, path, newEntry, isMainAsset);
                }
              }, {
                key: "_getInfo_DEBUG",
                value: function _getInfo_DEBUG(uuid, out_info) {
                  var path2uuid = this._pathToUuid;
                  var paths = Object.keys(path2uuid);

                  for (var p = 0; p < paths.length; ++p) {
                    var path = paths[p];
                    var item = path2uuid[path];

                    if (Array.isArray(item)) {
                      for (var i = 0; i < item.length; i++) {
                        var entry = item[i];

                        if (entry.uuid === uuid) {
                          out_info.path = path;
                          out_info.type = entry.type;
                          return true;
                        }
                      }
                    } else if (item.uuid === uuid) {
                      out_info.path = path;
                      out_info.type = item.type;
                      return true;
                    }
                  }

                  return false;
                }
              }, {
                key: "reset",
                value: function reset() {
                  this._pathToUuid = createMap(true);
                }
              }]);

              return AssetTable;
            }();

            var _qid = 0 | Math.random() * 998;

            var _queues = createMap(true);

            var _pool$1 = [];
            var _POOL_MAX_LENGTH = 10;
            var ItemState;

            (function (ItemState) {
              ItemState[ItemState["WORKING"] = 0] = "WORKING";
              ItemState[ItemState["COMPLETE"] = 1] = "COMPLETE";
              ItemState[ItemState["ERROR"] = 2] = "ERROR";
            })(ItemState || (ItemState = {}));

            var _queueDeps = createMap(true);

            function isIdValid(id) {
              var realId = id.url || id;
              return typeof realId === 'string';
            }

            function _parseUrlParam(url) {
              if (!url) return undefined;
              var split = url.split('?');

              if (!split || !split[0] || !split[1]) {
                return undefined;
              }

              var urlParam = {};
              var queries = split[1].split('&');
              queries.forEach(function (item) {
                var itemSplit = item.split('=');
                urlParam[itemSplit[0]] = itemSplit[1];
              });
              return urlParam;
            }

            function createItem(id, queueId) {
              var url = _typeof(id) === 'object' ? id.url : id;
              var result = {
                queueId: queueId,
                id: url,
                url: url,
                // real download url, maybe changed
                rawUrl: undefined,
                // url used in scripts
                urlParam: _parseUrlParam(url),
                type: "",
                error: null,
                content: null,
                complete: false,
                states: {},
                deps: null,
                isScene: id.uuid && legacyCC.game._sceneInfos.find(function (info) {
                  return info.uuid === id.uuid;
                })
              };

              if (_typeof(id) === 'object') {
                mixin(result, id);

                if (id.skips) {
                  for (var i = 0; i < id.skips.length; i++) {
                    var skip = id.skips[i];
                    result.states[skip] = ItemState.COMPLETE;
                  }
                }
              }

              result.rawUrl = result.url;

              if (url && !result.type) {
                result.type = extname(url).toLowerCase().substr(1);
              }

              return result;
            }

            var _checkedIds = [];

            function checkCircleReference(owner, item, recursiveCall) {
              if (!owner || !item) {
                return false;
              }

              var result = false;

              _checkedIds.push(item.id);

              if (item.deps) {
                var i,
                    deps = item.deps,
                    subDep;

                for (i = 0; i < deps.length; i++) {
                  subDep = deps[i];

                  if (subDep.id === owner.id) {
                    result = true;
                    break;
                  } else if (_checkedIds.indexOf(subDep.id) >= 0) {
                    continue;
                  } else if (subDep.deps && checkCircleReference(owner, subDep, true)) {
                    result = true;
                    break;
                  }
                }
              }

              if (!recursiveCall) {
                _checkedIds.length = 0;
              }

              return result;
            }
            /**
             * @en
             * LoadingItems is the queue of items which can flow them into the loading pipeline.<br/>
             * Please don't construct it directly, use [[create]] instead, because we use an internal pool to recycle the queues.<br/>
             * It hold a map of items, each entry in the map is a url to object key value pair.<br/>
             * Each item always contains the following property:<br/>
             * - id: The identification of the item, usually it's identical to url<br/>
             * - url: The url <br/>
             * - type: The type, it's the extension name of the url by default, could be specified manually too.<br/>
             * - error: The error happened in pipeline will be stored in this property.<br/>
             * - content: The content processed by the pipeline, the final result will also be stored in this property.<br/>
             * - complete: The flag indicate whether the item is completed by the pipeline.<br/>
             * - states: An object stores the states of each pipe the item go through, the state can be: Pipeline.ItemState.WORKING | Pipeline.ItemState.ERROR | Pipeline.ItemState.COMPLETE<br/>
             * <br/>
             * Item can hold other custom properties.<br/>
             * Each LoadingItems object will be destroyed for recycle after onComplete callback<br/>
             * So please don't hold its reference for later usage, you can copy properties in it though.
             * @zh
             * LoadingItems 是一个加载对象队列，可以用来输送加载对象到加载管线中。<br/>
             * 请不要直接使用 new 构造这个类的对象，你可以使用 [[create]] 来创建一个新的加载队列，这样可以允许我们的内部对象池回收并重利用加载队列。
             * 它有一个 map 属性用来存放加载项，在 map 对象中已 url 为 key 值。<br/>
             * 每个对象都会包含下列属性：<br/>
             * - id：该对象的标识，通常与 url 相同。<br/>
             * - url：路径 <br/>
             * - type: 类型，它这是默认的 URL 的扩展名，可以手动指定赋值。<br/>
             * - error：pipeline 中发生的错误将被保存在这个属性中。<br/>
             * - content: pipeline 中处理的临时结果，最终的结果也将被存储在这个属性中。<br/>
             * - complete：该标志表明该对象是否通过 pipeline 完成。<br/>
             * - states：该对象存储每个管道中对象经历的状态，状态可以是 Pipeline.ItemState.WORKING | Pipeline.ItemState.ERROR | Pipeline.ItemState.COMPLETE<br/>
             * <br/>
             * 对象可容纳其他自定义属性。<br/>
             * 每个 LoadingItems 对象都会在 onComplete 回调之后被销毁，所以请不要持有它的引用并在结束回调之后依赖它的内容执行任何逻辑，有这种需求的话你可以提前复制它的内容。
             */


            var LoadingItems = exports('cU', /*#__PURE__*/function (_CallbacksInvoker) {
              _inherits(LoadingItems, _CallbacksInvoker);

              /**
               * @en The item states of the LoadingItems, its value could be {{ItemState.WORKING}} | {{ItemState.COMPLETE}} | {{ItemState.ERROR}}
               * @zh LoadingItems 队列中的加载项状态，状态的值可能是 {{ItemState.WORKING}} | {{ItemState.COMPLETE}} | {{ItemState.ERROR}}
               */

              /**
               * @en This is a callback which will be invoked while an item flow out the pipeline.
               * You can pass the callback function in LoadingItems.create or set it later.
               * @zh 这个回调函数将在 item 加载结束后被调用。你可以在构造时传递这个回调函数或者是在构造之后直接设置。
               * @param completedCount The number of the items that are already completed.
               * @param totalCount The total number of the items.
               * @param item The latest item which flow out the pipeline.
               * @example
               * ```
               * import { log } from 'cc';
               * loadingItems.onProgress (completedCount, totalCount, item) {
               *     let progress = (100 * completedCount / totalCount).toFixed(2);
               *     log(progress + '%');
               * }
               * ```
               */

              /**
               * @en This is a callback which will be invoked while all items is completed,
               * You can pass the callback function in LoadingItems.create or set it later.
               * @zh 该函数将在加载队列全部完成时被调用。你可以在构造时传递这个回调函数或者是在构造之后直接设置。
               * @param errors All errored urls will be stored in this array, if no error happened, then it will be null
               * @param items All items.
               * @example
               * ```
               * import { log } from 'cc';
               * loadingItems.onComplete (errors, items) {
               *     if (error) {
               *         log('Completed with ' + errors.length + ' errors');
               *     } else {
               *         log('Completed ' + items.totalCount + ' items');
               *     }
               * }
               * ```
               */

              /**
               * @en The map of all items.
               * @zh 存储所有加载项的对象。
               */

              /**
               * @en The map of completed items.
               * @zh 存储已经完成的加载项。
               */

              /**
               * @en Total count of all items.
               * @zh 所有加载项的总数。
               */

              /**
               * @en Total count of completed items.
               * @zh 所有完成加载项的总数。
               */

              /**
               * @en Activated or not.
               * @zh 是否启用。
               */
              function LoadingItems(pipeline, urlList, onProgress, onComplete) {
                var _this;

                _classCallCheck(this, LoadingItems);

                _this = _possibleConstructorReturn(this, _getPrototypeOf(LoadingItems).call(this));
                _this.onProgress = void 0;
                _this.onComplete = void 0;
                _this.map = createMap(true);
                _this.completed = {};
                _this.totalCount = 0;
                _this.completedCount = 0;
                _this.active = void 0;
                _this._id = void 0;
                _this._pipeline = void 0;
                _this._errorUrls = [];
                _this._appending = false;
                _this._ownerQueue = null;
                _this._id = ++_qid;
                _queues[_this._id] = _assertThisInitialized(_this);
                _this._pipeline = pipeline;
                _this.onProgress = onProgress;
                _this.onComplete = onComplete;

                if (_this._pipeline) {
                  _this.active = true;
                } else {
                  _this.active = false;
                }

                if (urlList) {
                  if (urlList.length > 0) {
                    _this.append(urlList);
                  } else {
                    _this.allComplete();
                  }
                }

                return _this;
              }
              /**
               * @en The constructor function of LoadingItems, this will use recycled LoadingItems in the internal pool if possible.
               * You can pass onProgress and onComplete callbacks to visualize the loading process.
               * @zh LoadingItems 的构造函数，这种构造方式会重用内部对象缓冲池中的 LoadingItems 队列，以尽量避免对象创建。
               * 你可以传递 onProgress 和 onComplete 回调函数来获知加载进度信息。
               * @param {Pipeline} pipeline The pipeline to process the queue.
               * @param {Array} urlList The items array.
               * @param {Function} [onProgress] The progression callback, refer to [[onProgress]]
               * @param {Function} [onComplete] The completion callback, refer to [[LoadingItems.onComplete]]
               * @return {LoadingItems} The LoadingItems queue object
               * @example
               * ```
               * import { log, LoadingItems } from 'cc';
               * LoadingItems.create(loader, ['a.png', 'b.plist'], function (completedCount, totalCount, item) {
               *     let progress = (100 * completedCount / totalCount).toFixed(2);
               *     log(progress + '%');
               * }, function (errors, items) {
               *     if (errors) {
               *         for (let i = 0; i < errors.length; ++i) {
               *             log('Error url: ' + errors[i] + ', error: ' + items.getError(errors[i]));
               *         }
               *     }
               *     else {
               *         let result_a = items.getContent('a.png');
               *         // ...
               *     }
               * })
               * ```
               */


              _createClass(LoadingItems, [{
                key: "append",

                /**
                 * @en Add urls to the LoadingItems queue.
                 * @zh 向一个 LoadingItems 队列添加加载项。
                 * @param urlList 要追加的url列表，url可以是对象或字符串
                 * @param owner
                 * @return 在已接受的url列表中，可以拒绝某些无效项
                 */
                value: function append(urlList, owner) {
                  var _this2 = this;

                  if (!this.active) {
                    return [];
                  }

                  if (owner && !owner.deps) {
                    owner.deps = [];
                  }

                  this._appending = true;
                  var accepted = [],
                      i,
                      url,
                      item;

                  for (i = 0; i < urlList.length; ++i) {
                    url = urlList[i]; // Already queued in another items queue, url is actually the item

                    if (url.queueId && !this.map[url.id]) {
                      this.map[url.id] = url; // Register item deps for circle reference check

                      owner && owner.deps.push(url); // Queued and completed or Owner circle referenced by dependency

                      if (url.complete || checkCircleReference(owner, url)) {
                        this.totalCount++; // console.log('----- Completed already or circle referenced ' + url.id + ', rest: ' + (this.totalCount - this.completedCount-1));

                        this.itemComplete(url.id);
                        continue;
                      } // Not completed yet, should wait it
                      else {
                          var _ret = function () {
                            var self = _this2;
                            var queue = _queues[url.queueId];

                            if (queue) {
                              _this2.totalCount++;
                              LoadingItems.registerQueueDep(owner || _this2._id, url.id); // console.log('+++++ Waited ' + url.id);

                              queue.addListener(url.id, function (item) {
                                // console.log('----- Completed by waiting ' + item.id + ', rest: ' + (self.totalCount - self.completedCount-1));
                                self.itemComplete(item.id);
                              });
                            }

                            return "continue";
                          }();

                          if (_ret === "continue") continue;
                        }
                    } // Queue new items


                    if (isIdValid(url)) {
                      item = createItem(url, this._id);
                      var key = item.id; // No duplicated url

                      if (!this.map[key]) {
                        this.map[key] = item;
                        this.totalCount++; // Register item deps for circle reference check

                        owner && owner.deps.push(item);
                        LoadingItems.registerQueueDep(owner || this._id, key);
                        accepted.push(item); // console.log('+++++ Appended ' + item.id);
                      }
                    }
                  }

                  this._appending = false; // Manually complete

                  if (this.completedCount === this.totalCount) {
                    // console.log('===== All Completed ');
                    this.allComplete();
                  } else {
                    this._pipeline.flowIn(accepted);
                  }

                  return accepted;
                }
              }, {
                key: "_childOnProgress",
                value: function _childOnProgress(item) {
                  if (this.onProgress) {
                    var dep = _queueDeps[this._id];
                    this.onProgress(dep ? dep.completed.length : this.completedCount, dep ? dep.deps.length : this.totalCount, item);
                  }
                }
                /**
                 * @en Complete a LoadingItems queue, please do not call this method unless you know what's happening.
                 * @zh 完成一个 LoadingItems 队列，请不要调用这个函数，除非你知道自己在做什么。
                 */

              }, {
                key: "allComplete",
                value: function allComplete() {
                  var errors = this._errorUrls.length === 0 ? null : this._errorUrls;

                  if (this.onComplete) {
                    this.onComplete(errors, this);
                  }
                }
                /**
                 * @en Check whether all items are completed.
                 * @zh 检查是否所有加载项都已经完成。
                 */

              }, {
                key: "isCompleted",
                value: function isCompleted() {
                  return this.completedCount >= this.totalCount;
                }
                /**
                 * @en Check whether an item is completed.
                 * @zh 通过 id 检查指定加载项是否已经加载完成。
                 * @param id The item's id.
                 */

              }, {
                key: "isItemCompleted",
                value: function isItemCompleted(id) {
                  return !!this.completed[id];
                }
                /**
                 * @en Check whether an item exists.
                 * @zh 通过 id 检查加载项是否存在。
                 * @param id The item's id.
                 */

              }, {
                key: "exists",
                value: function exists(id) {
                  return !!this.map[id];
                }
                /**
                 * @en Returns the content of an internal item.
                 * @zh 通过 id 获取指定对象的内容。
                 * @param id The item's id.
                 */

              }, {
                key: "getContent",
                value: function getContent(id) {
                  var item = this.map[id];
                  var ret = null;

                  if (item) {
                    if (item.content) {
                      ret = item.content;
                    } else if (item.alias) {
                      ret = item.alias.content;
                    }
                  }

                  return ret;
                }
                /**
                 * @en Returns the error of an internal item.
                 * @zh 通过 id 获取指定对象的错误信息。
                 * @param id The item's id.
                 */

              }, {
                key: "getError",
                value: function getError(id) {
                  var item = this.map[id];
                  var ret = null;

                  if (item) {
                    if (item.error) {
                      ret = item.error;
                    } else if (item.alias) {
                      ret = item.alias.error;
                    }
                  }

                  return ret;
                }
                /**
                 * @en Remove an item, can only remove completed item, ongoing item can not be removed.
                 * @zh 移除加载项，这里只会移除已经完成的加载项，正在进行的加载项将不能被删除。
                 * @param url
                 */

              }, {
                key: "removeItem",
                value: function removeItem(url) {
                  var item = this.map[url];
                  if (!item) return;
                  if (!this.completed[item.alias || url]) return;
                  delete this.completed[url];
                  delete this.map[url];

                  if (item.alias) {
                    delete this.completed[item.alias.id];
                    delete this.map[item.alias.id];
                  }

                  this.completedCount--;
                  this.totalCount--;
                }
                /**
                 * @en Complete an item in the LoadingItems queue, please do not call this method unless you know what's happening.
                 * @zh 通知 LoadingItems 队列一个 item 对象已完成，请不要调用这个函数，除非你知道自己在做什么。
                 * @param id The item url
                 */

              }, {
                key: "itemComplete",
                value: function itemComplete(id) {
                  var item = this.map[id];

                  if (!item) {
                    return;
                  } // Register or unregister errors


                  var errorListId = this._errorUrls.indexOf(id);

                  if (item.error && errorListId === -1) {
                    this._errorUrls.push(id);
                  } else if (!item.error && errorListId !== -1) {
                    this._errorUrls.splice(errorListId, 1);
                  }

                  LoadingItems.finishDep(item.id);
                  this.emit(id, item);
                  this.removeAll(id);
                  this.completed[id] = item;
                  this.completedCount++;

                  if (this.onProgress) {
                    var dep = _queueDeps[this._id];
                    this.onProgress(dep ? dep.completed.length : this.completedCount, dep ? dep.deps.length : this.totalCount, item);
                  } // All completed


                  if (!this._appending && this.completedCount >= this.totalCount) {
                    // console.log('===== All Completed ');
                    this.allComplete();
                  }
                }
                /**
                 * @en Destroy the LoadingItems queue, the queue object won't be garbage collected, it will be recycled, so every after destroy is not reliable.
                 * @zh 销毁一个 LoadingItems 队列，这个队列对象会被内部缓冲池回收，所以销毁后的所有内部信息都是不可依赖的。
                 */

              }, {
                key: "destroy",
                value: function destroy() {
                  this.active = false;
                  this._appending = false;
                  this._pipeline = null;
                  this._ownerQueue = null;
                  this._errorUrls.length = 0;
                  this.onProgress = undefined;
                  this.onComplete = undefined;
                  this.map = createMap(true);
                  this.completed = {};
                  this.totalCount = 0;
                  this.completedCount = 0;
                  this.clear();
                  _queues[this._id] = null;

                  if (_queueDeps[this._id]) {
                    _queueDeps[this._id].completed.length = 0;
                    _queueDeps[this._id].deps.length = 0;
                  }

                  if (_pool$1.indexOf(this) === -1 && _pool$1.length < _POOL_MAX_LENGTH) {
                    _pool$1.push(this);
                  }
                }
                /**
                 * @en Add a listener for an item, the callback will be invoked when the item is completed.
                 * @zh 监听加载项（通过 key 指定）的完成事件。
                 * @param key - The item key
                 * @param callback - Callback function when item loaded
                 * @param target - Callback callee
                 */

              }, {
                key: "addListener",
                value: function addListener(key, callback, target) {
                  return _get(_getPrototypeOf(LoadingItems.prototype), "on", this).call(this, key, callback, target);
                }
                /**
                 * @en
                 * Check if the specified key has any registered callback.
                 * If a callback is also specified, it will only return true if the callback is registered.
                 * @zh
                 * 检查指定的加载项是否有完成事件监听器。
                 * 如果同时还指定了一个回调方法，并且回调有注册，它只会返回 true。
                 * @param key - The item key
                 * @param callback - Callback function when item loaded
                 * @param target - Callback callee
                 * @return Whether the corresponding listener for the item is registered
                 */

              }, {
                key: "hasListener",
                value: function hasListener(key, callback, target) {
                  return _get(_getPrototypeOf(LoadingItems.prototype), "hasEventListener", this).call(this, key, callback, target);
                }
                /**
                 * @en
                 * Removes a listener.
                 * It will only remove when key, callback, target all match correctly.
                 * @zh
                 * 移除指定加载项已经注册的完成事件监听器。
                 * 只会删除 key, callback, target 均匹配的监听器。
                 * @param key - The item key
                 * @param callback - Callback function when item loaded
                 * @param target - Callback callee
                 */

              }, {
                key: "removeListener",
                value: function removeListener(key, callback, target) {
                  return _get(_getPrototypeOf(LoadingItems.prototype), "off", this).call(this, key, callback, target);
                }
                /**
                 * @en Removes all callbacks registered in a certain event
                 * type or all callbacks registered with a certain target.
                 * @zh 删除指定目标的所有完成事件监听器。
                 * @param {String|Object} key - The item key to be removed or the target to be removed
                 */

              }, {
                key: "removeAllListeners",
                value: function removeAllListeners(key) {
                  _get(_getPrototypeOf(LoadingItems.prototype), "removeAll", this).call(this, key);
                }
              }], [{
                key: "create",
                value: function create(pipeline, urlList, onProgress, onComplete) {
                  if (onProgress === undefined) {
                    if (typeof urlList === 'function') {
                      onComplete = urlList;
                      urlList = onProgress = null;
                    }
                  } else if (onComplete === undefined) {
                    if (typeof urlList === 'function') {
                      onComplete = onProgress;
                      onProgress = urlList;
                      urlList = null;
                    } else {
                      onComplete = onProgress;
                      onProgress = null;
                    }
                  }

                  var queue = _pool$1.pop();

                  if (queue) {
                    queue._pipeline = pipeline;
                    queue.onProgress = onProgress;
                    queue.onComplete = onComplete;
                    _queues[queue._id] = queue;

                    if (queue._pipeline) {
                      queue.active = true;
                    }

                    if (urlList) {
                      queue.append(urlList);
                    }
                  } else {
                    queue = new LoadingItems(pipeline, urlList, onProgress, onComplete);
                  }

                  return queue;
                }
                /**
                 * @en Retrieve the LoadingItems queue object for an item.
                 * @zh 通过 item 对象获取它的 LoadingItems 队列。
                 * @param item The item to query
                 * @return The LoadingItems queue object
                 */

              }, {
                key: "getQueue",
                value: function getQueue(item) {
                  return item.queueId ? _queues[item.queueId] : null;
                }
                /**
                 * @en Complete an item in the LoadingItems queue, please do not call this method unless you know what's happening.
                 * @zh 通知 LoadingItems 队列一个 item 对象已完成，请不要调用这个函数，除非你知道自己在做什么。
                 * @param item The item which has completed
                 */

              }, {
                key: "itemComplete",
                value: function itemComplete(item) {
                  var queue = _queues[item.queueId];

                  if (queue) {
                    // console.log('----- Completed by pipeline ' + item.id + ', rest: ' + (queue.totalCount - queue.completedCount-1));
                    queue.itemComplete(item.id);
                  }
                }
              }, {
                key: "initQueueDeps",
                value: function initQueueDeps(queue) {
                  var dep = _queueDeps[queue._id];

                  if (!dep) {
                    dep = _queueDeps[queue._id] = {
                      completed: [],
                      deps: []
                    };
                  } else {
                    dep.completed.length = 0;
                    dep.deps.length = 0;
                  }
                }
              }, {
                key: "registerQueueDep",
                value: function registerQueueDep(owner, depId) {
                  var queueId = owner.queueId || owner;

                  if (!queueId) {
                    return false;
                  }

                  var queueDepList = _queueDeps[queueId]; // Owner is root queue

                  if (queueDepList) {
                    if (queueDepList.deps.indexOf(depId) === -1) {
                      queueDepList.deps.push(depId);
                    }
                  } // Owner is an item in the intermediate queue
                  else if (owner.id) {
                      for (var id in _queueDeps) {
                        var queue = _queueDeps[id]; // Found root queue

                        if (queue.deps.indexOf(owner.id) !== -1) {
                          if (queue.deps.indexOf(depId) === -1) {
                            queue.deps.push(depId);
                          }
                        }
                      }
                    }
                }
              }, {
                key: "finishDep",
                value: function finishDep(depId) {
                  for (var id in _queueDeps) {
                    var queue = _queueDeps[id]; // Found root queue

                    if (queue.deps.indexOf(depId) !== -1 && queue.completed.indexOf(depId) === -1) {
                      queue.completed.push(depId);
                    }
                  }
                }
              }]);

              return LoadingItems;
            }(CallbacksInvoker));
            LoadingItems.ItemState = new legacyCC.Enum(ItemState);
            legacyCC.LoadingItems = LoadingItems;

            var ItemState$1 = LoadingItems.ItemState;

            function flow(pipe, item) {
              var pipeId = pipe.id;
              var itemState = item.states[pipeId];
              var next = pipe.next;
              var pipeline = pipe.pipeline;

              if (item.error || itemState === ItemState$1.WORKING || itemState === ItemState$1.ERROR) {
                return;
              } else if (itemState === ItemState$1.COMPLETE) {
                if (next) {
                  flow(next, item);
                } else {
                  pipeline.flowOut(item);
                }
              } else {
                item.states[pipeId] = ItemState$1.WORKING; // Pass async callback in case it's a async call

                var result = pipe.handle(item, function (err, result) {
                  if (err) {
                    item.error = err;
                    item.states[pipeId] = ItemState$1.ERROR;
                    pipeline.flowOut(item);
                  } else {
                    // Result can be null, then it means no result for this pipe
                    if (result) {
                      item.content = result;
                    }

                    item.states[pipeId] = ItemState$1.COMPLETE;

                    if (next) {
                      flow(next, item);
                    } else {
                      pipeline.flowOut(item);
                    }
                  }
                }); // If result exists (not undefined, null is ok), then we go with sync call flow

                if (result instanceof Error) {
                  item.error = result;
                  item.states[pipeId] = ItemState$1.ERROR;
                  pipeline.flowOut(item);
                } else if (result !== undefined) {
                  // Result can be null, then it means no result for this pipe
                  if (result !== null) {
                    item.content = result;
                  }

                  item.states[pipeId] = ItemState$1.COMPLETE;

                  if (next) {
                    flow(next, item);
                  } else {
                    pipeline.flowOut(item);
                  }
                }
              }
            }
            /**
             * @en
             * A pipeline describes a sequence of manipulations, each manipulation is called a pipe.<br/>
             * It's designed for loading process. so items should be urls, and the url will be the identity of each item during the process.<br/>
             * A list of items can flow in the pipeline and it will output the results of all pipes.<br/>
             * They flow in the pipeline like water in tubes, they go through pipe by pipe separately.<br/>
             * Finally all items will flow out the pipeline and the process is finished.
             *
             * @zh
             * pipeline 描述了一系列的操作，每个操作都被称为 pipe。<br/>
             * 它被设计来做加载过程的流程管理。所以 item 应该是 url，并且该 url 将是在处理中的每个 item 的身份标识。<br/>
             * 一个 item 列表可以在 pipeline 中流动，它将输出加载项经过所有 pipe 之后的结果。<br/>
             * 它们穿过 pipeline 就像水在管子里流动，将会按顺序流过每个 pipe。<br/>
             * 最后当所有加载项都流出 pipeline 时，整个加载流程就结束了。
             */


            var Pipeline = exports('cS', /*#__PURE__*/function () {
              /**
               * @en The item states of the LoadingItems, its value could be {{ItemState.WORKING}} | {{ItemState.COMPLETE}} | {{ItemState.ERROR}}
               * @zh LoadingItems 队列中的加载项状态，状态的值可能是 {{ItemState.WORKING}} | {{ItemState.COMPLETE}} | {{ItemState.ERROR}}
               */

              /**
               * @en The constructor of the Pipeline, the order of pipes will remain as given.
               * A pipe is an {{IPipe}} object which must have an `id` and a `handle` function, the `id` must be unique.
               * It should also include an `async` property to identify whether the pipe's `handle` function is asynchronous.
               * @zh 构造函数，通过一系列的 pipe 来构造一个新的 pipeline，pipes 将会在给定的顺序中被锁定。<br/>
               * 一个 pipe 就是一个对象，它包含了字符串类型的 ‘id’ 和 ‘handle’ 函数，在 pipeline 中 id 必须是唯一的。<br/>
               * 它还可以包括 ‘async’ 属性以确定它是否是一个异步过程。
               * @param pipes All pipes for constructing the pipeline
               * @example
               * ```
               *  let pipeline = new Pipeline([
               *      {
               *          id: 'Downloader',
               *          handle: function (item, callback) {},
               *          async: true
               *      },
               *      {id: 'Parser', handle: function (item) {}, async: false}
               *  ]);
               * ```
               */
              function Pipeline(pipes) {
                _classCallCheck(this, Pipeline);

                this._pipes = void 0;
                this._cache = createMap(true);
                this._pipes = pipes;

                for (var i = 0; i < pipes.length; ++i) {
                  var pipe = pipes[i]; // Must have handle and id, handle for flow, id for state flag

                  if (!pipe.handle || !pipe.id) {
                    continue;
                  }

                  pipe.pipeline = this;
                  pipe.next = i < pipes.length - 1 ? pipes[i + 1] : null;
                }
              }
              /**
               * @en Insert a new pipe at the given index of the pipeline. <br/>
               * A pipe must contain an `id` in string and a `handle` function, the id must be unique in the pipeline.
               * @zh 在给定的索引位置插入一个新的 pipe。<br/>
               * 一个 pipe 必须包含一个字符串类型的 ‘id’ 和 ‘handle’ 函数，该 id 在 pipeline 必须是唯一标识。
               * @param pipe The pipe to be inserted
               * @param index The index to insert
               */


              _createClass(Pipeline, [{
                key: "insertPipe",
                value: function insertPipe(pipe, index) {
                  // Must have handle and id, handle for flow, id for state flag
                  if (!pipe.handle || !pipe.id || index > this._pipes.length) {
                    warnID(4921);
                    return;
                  }

                  if (this._pipes.indexOf(pipe) > 0) {
                    warnID(4922);
                    return;
                  }

                  pipe.pipeline = this;
                  var nextPipe = null;

                  if (index < this._pipes.length) {
                    nextPipe = this._pipes[index];
                  }

                  var previousPipe = null;

                  if (index > 0) {
                    previousPipe = this._pipes[index - 1];
                  }

                  if (previousPipe) {
                    previousPipe.next = pipe;
                  }

                  pipe.next = nextPipe;

                  this._pipes.splice(index, 0, pipe);
                }
                /**
                 * @en Insert a pipe to the end of an existing pipe. The existing pipe must be a valid pipe in the pipeline.
                 * @zh 在当前 pipeline 的一个已知 pipe 后面插入一个新的 pipe。
                 * @param refPipe An existing pipe in the pipeline.
                 * @param newPipe The pipe to be inserted.
                 */

              }, {
                key: "insertPipeAfter",
                value: function insertPipeAfter(refPipe, newPipe) {
                  var index = this._pipes.indexOf(refPipe);

                  if (index < 0) {
                    return;
                  }

                  this.insertPipe(newPipe, index + 1);
                }
                /**
                 * @en Add a new pipe at the end of the pipeline. <br/>
                 * A pipe must contain an `id` in string and a `handle` function, the id must be unique in the pipeline.
                 * @zh 添加一个新的 pipe 到 pipeline 尾部。 <br/>
                 * 该 pipe 必须包含一个字符串类型 ‘id’ 和 ‘handle’ 函数，该 id 在 pipeline 必须是唯一标识。
                 * @param pipe The pipe to be appended
                 */

              }, {
                key: "appendPipe",
                value: function appendPipe(pipe) {
                  // Must have handle and id, handle for flow, id for state flag
                  if (!pipe.handle || !pipe.id) {
                    return;
                  }

                  pipe.pipeline = this;
                  pipe.next = null;

                  if (this._pipes.length > 0) {
                    this._pipes[this._pipes.length - 1].next = pipe;
                  }

                  this._pipes.push(pipe);
                }
                /**
                 * @en
                 * Let new items flow into the pipeline. <br/>
                 * Each item can be a simple url string or an object,
                 * if it's an object, it must contain `id` property. <br/>
                 * You can specify its type by `type` property, by default, the type is the extension name in url. <br/>
                 * By adding a `skips` property including pipe ids, you can skip these pipe. <br/>
                 * The object can contain any supplementary property as you want. <br/>
                 * @zh
                 * 让新的 item 流入 pipeline 中。<br/>
                 * 这里的每个 item 可以是一个简单字符串类型的 url 或者是一个对象,
                 * 如果它是一个对象的话，他必须要包含 ‘id’ 属性。<br/>
                 * 你也可以指定它的 ‘type’ 属性类型，默认情况下，该类型是 ‘url’ 的后缀名。<br/>
                 * 也通过添加一个 包含 ‘skips’ 属性的 item 对象，你就可以跳过 skips 中包含的 pipe。<br/>
                 * 该对象可以包含任何附加属性。
                 * @param items The {{IItem}} to be appended to the current pipeline
                 * @example
                 * ```
                 *  pipeline.flowIn([
                 *      'res/Background.png',
                 *      {
                 *          id: 'res/scene.json',
                 *          type: 'scene',
                 *          name: 'scene',
                 *          skips: ['Downloader']
                 *      }
                 *  ]);
                 * ```
                 */

              }, {
                key: "flowIn",
                value: function flowIn(items) {
                  var i,
                      pipe = this._pipes[0],
                      item;

                  if (pipe) {
                    // Cache all items first, in case synchronous loading flow same item repeatly
                    for (i = 0; i < items.length; i++) {
                      item = items[i];
                      if (!item.isScene) this._cache[item.id] = item;
                    }

                    for (i = 0; i < items.length; i++) {
                      item = items[i];
                      flow(pipe, item);
                    }
                  } else {
                    for (i = 0; i < items.length; i++) {
                      this.flowOut(items[i]);
                    }
                  }
                }
                /**
                 * @en
                 * Let new items flow into the pipeline and give a callback when the list of items are all completed. <br/>
                 * This is for loading dependencies for an existing item in flow, usually used in a pipe logic. <br/>
                 * For example, we have a loader for scene configuration file in JSON, the scene will only be fully loaded  <br/>
                 * after all its dependencies are loaded, then you will need to use function to flow in all dependencies  <br/>
                 * found in the configuration file, and finish the loader pipe only after all dependencies are loaded (in the callback).
                 * @zh
                 * 让新 items 流入 pipeline 并且当 item 列表完成时进行回调函数。<br/>
                 * 这个 API 的使用通常是为了加载依赖项。<br/>
                 * 例如：<br/>
                 * 我们需要加载一个场景配置的 JSON 文件，该场景会将所有的依赖项全部都加载完毕以后，进行回调表示加载完毕。
                 * @param owner The owner item
                 * @param urlList The list of urls to be appended as dependencies of the owner.
                 * @param callback The callback to be invoked when all dependencies are completed.
                 * @return Items accepted by the pipeline
                 */

              }, {
                key: "flowInDeps",
                value: function flowInDeps(owner, urlList, callback) {
                  var deps = LoadingItems.create(this, function (errors, items) {
                    callback(errors, items);
                    items.destroy();
                  });
                  return deps.append(urlList, owner);
                }
                /**
                 * @en This function is invoked when an item has completed all pipes, it will flow out of the pipeline.
                 * @zh 这个函数会在 `item` 完成了所有管道，它会被标记为 `complete` 并流出管线。
                 * @param item The item which is completed
                 */

              }, {
                key: "flowOut",
                value: function flowOut(item) {
                  if (item.error) {
                    delete this._cache[item.id];
                  } else if (!this._cache[item.id] && !item.isScene) {
                    this._cache[item.id] = item;
                  }

                  item.complete = true;
                  LoadingItems.itemComplete(item);
                }
                /**
                 * @en
                 * Copy the item states from one source item to all destination items. <br/>
                 * It's quite useful when a pipe generate new items from one source item,<br/>
                 * then you should flowIn these generated items into pipeline, <br/>
                 * but you probably want them to skip all pipes the source item already go through,<br/>
                 * you can achieve it with this API. <br/>
                 * <br/>
                 * For example, an unzip pipe will generate more items, but you won't want them to pass unzip or download pipe again.
                 * @zh
                 * 从一个源 item 向所有目标 item 复制它的 pipe 状态，用于避免重复通过部分 pipe。<br/>
                 * 当一个源 item 生成了一系列新的 items 时很有用，<br/>
                 * 你希望让这些新的依赖项进入 pipeline，但是又不希望它们通过源 item 已经经过的 pipe，<br/>
                 * 但是你可能希望他们源 item 已经通过并跳过所有 pipes，<br/>
                 * 这个时候就可以使用这个 API。
                 * @param srcItem The source item
                 * @param dstItems A single destination item or an array of destination items
                 */

              }, {
                key: "copyItemStates",
                value: function copyItemStates(srcItem, dstItems) {
                  if (!(dstItems instanceof Array)) {
                    dstItems.states = srcItem.states;
                    return;
                  }

                  for (var i = 0; i < dstItems.length; ++i) {
                    dstItems[i].states = srcItem.states;
                  }
                }
                /**
                 * @en Returns an item in pipeline.
                 * @zh 根据 id 获取一个 item
                 * @param id The id of the item
                 */

              }, {
                key: "getItem",
                value: function getItem(id) {
                  var item = this._cache[id];
                  if (!item) return item; // downloader.js downloadUuid

                  if (item.alias) item = item.alias;
                  return item;
                }
                /**
                 * @en Removes an completed item in pipeline.
                 * It will only remove the cache in the pipeline or loader, its dependencies won't be released.
                 * `loader` provided another method to completely cleanup the resource and its dependencies,
                 * please refer to {{Loader.release}}
                 * @zh 移除指定的已完成 item。
                 * 这将仅仅从 pipeline 或者 loader 中删除其缓存，并不会释放它所依赖的资源。
                 * `loader` 中提供了另一种删除资源及其依赖的清理方法，请参考 {{Loader.release}}
                 * @param id The id of the item
                 * @return succeed or not
                 */

              }, {
                key: "removeItem",
                value: function removeItem(id) {
                  var removed = this._cache[id];

                  if (removed && removed.complete) {
                    delete this._cache[id];
                  }

                  return removed;
                }
                /**
                 * @en Clear the current pipeline, this function will clean up the items.
                 * @zh 清空当前 pipeline，该函数将清理 items。
                 */

              }, {
                key: "clear",
                value: function clear() {
                  for (var id in this._cache) {
                    var _item = this._cache[id];
                    delete this._cache[id];

                    if (!_item.complete) {
                      _item.error = new Error('Canceled manually');
                      this.flowOut(_item);
                    }
                  }
                }
              }]);

              return Pipeline;
            }());
            Pipeline.ItemState = ItemState$1;
            legacyCC.Pipeline = Pipeline;

            var ID = 'MD5Pipe';
            var ExtnameRegex = /(\.[^.\n\\/]*)$/;
            var UuidRegex = /.*[/\\][0-9a-fA-F]{2}[/\\]([0-9a-fA-F-@]{8,}).*/;

            function getUuidFromURL(url) {
              var matches = url.match(UuidRegex);

              if (matches) {
                return matches[1];
              }

              return "";
            }
            /**
             * @en The md5 pipe in {{loader}}, it can transform the url to the real url with md5 suffix
             * @zh {{loader}} 中的 md5 管道，可以将资源 url 转换到包含 md5 后缀版本
             */


            var MD5Pipe = /*#__PURE__*/function () {
              function MD5Pipe(md5AssetsMap, md5NativeAssetsMap, libraryBase) {
                _classCallCheck(this, MD5Pipe);

                this.id = ID;
                this.async = false;
                this.pipeline = null;
                this.md5AssetsMap = void 0;
                this.md5NativeAssetsMap = void 0;
                this.libraryBase = void 0;
                this.id = ID;
                this.async = false;
                this.pipeline = null;
                this.md5AssetsMap = md5AssetsMap;
                this.md5NativeAssetsMap = md5NativeAssetsMap;
                this.libraryBase = libraryBase;
              }

              _createClass(MD5Pipe, [{
                key: "handle",
                value: function handle(item) {
                  var hashPatchInFolder = false; // HACK: explicitly use folder md5 for ttf files

                  if (item.type === 'ttf') {
                    hashPatchInFolder = true;
                  }

                  item.url = this.transformURL(item.url, hashPatchInFolder);
                  return item;
                }
                /**
                 * @en Transform an url to the real url with md5 suffix
                 * @zh 将一个 url 转换到包含 md5 后缀版本
                 * @param url The url to be parsed
                 * @param hashPatchInFolder NA
                 */

              }, {
                key: "transformURL",
                value: function transformURL(url, hashPatchInFolder) {
                  var uuid = getUuidFromURL(url);

                  if (uuid) {
                    var isNativeAsset = !url.match(this.libraryBase);
                    var map = isNativeAsset ? this.md5NativeAssetsMap : this.md5AssetsMap;
                    var hashValue = map[uuid];

                    if (hashValue) {
                      if (hashPatchInFolder) {
                        var dirname = legacyCC.path.dirname(url);
                        var basename = legacyCC.path.basename(url);
                        url = "".concat(dirname, ".").concat(hashValue, "/").concat(basename);
                      } else {
                        var matched = false;
                        url = url.replace(ExtnameRegex, function (match, p1) {
                          matched = true;
                          return "." + hashValue + p1;
                        });

                        if (!matched) {
                          url = url + "." + hashValue;
                        }
                      }
                    }
                  }

                  return url;
                }
              }]);

              return MD5Pipe;
            }(); // @ts-ignore


            MD5Pipe.ID = ID;
            Pipeline.MD5Pipe = MD5Pipe;

            var JsonUnpacker = /*#__PURE__*/function () {
              function JsonUnpacker() {
                _classCallCheck(this, JsonUnpacker);

                this.jsons = {};
              }

              _createClass(JsonUnpacker, [{
                key: "load",

                /*
                 * @param {String[]} indices
                 * @param {Object[]} packedJson
                 */
                value: function load(indices, packedJson) {
                  if (packedJson.length !== indices.length) {
                    errorID(4915);
                  }

                  for (var i = 0; i < indices.length; i++) {
                    var key = indices[i];
                    var json = packedJson[i];
                    this.jsons[key] = json;
                  }
                }
              }, {
                key: "retrieve",
                value: function retrieve(key) {
                  return this.jsons[key] || null;
                }
              }]);

              return JsonUnpacker;
            }();
            var TextureUnpacker = /*#__PURE__*/function () {
              function TextureUnpacker() {
                _classCallCheck(this, TextureUnpacker);

                this.contents = {};
              }

              _createClass(TextureUnpacker, [{
                key: "load",

                /*
                 * @param {String[]} indices
                 * @param {Object[]} packedJson
                 */
                value: function load(indices, packedJson) {
                  var datas = packedJson.data;

                  if (datas.length !== indices.length) {
                    errorID(4915);
                  }

                  for (var i = 0; i < indices.length; i++) {
                    this.contents[indices[i]] = {
                      base: datas[i][0],
                      mipmaps: datas[i][1]
                    };
                  }
                }
              }, {
                key: "retrieve",
                value: function retrieve(key) {
                  var content = this.contents[key];

                  if (content) {
                    return {
                      __type__: js._getClassId(Texture2D),
                      content: content
                    };
                  } else {
                    return null;
                  }
                }
              }]);

              return TextureUnpacker;
            }();

            /**
             * @hidden
             */

            var _noCacheRex = /\?/;
            function urlAppendTimestamp(url) {
              if (legacyCC.game.config['noCache'] && typeof url === 'string') {
                if (_noCacheRex.test(url)) //@ts-ignore
                  url += '&_t=' + (new Date() - 0);else //@ts-ignore
                  url += '?_t=' + (new Date() - 0);
              }

              return url;
            }
            function decompressJson(data, keys) {
              if (Array.isArray(data)) {
                for (var i = 0, l = data.length; i < l; i++) {
                  decompressJson(data[i], keys);
                }
              } else if (_typeof(data) === 'object') {
                for (var key in data) {
                  decompressJson(data[key], keys);

                  if (!Number.isNaN(Number(key))) {
                    data[keys[key]] = data[key];
                    delete data[key];
                  }
                }
              }

              return null;
            }

            // choose to load from the package with the largest state value.

            var PackState;

            (function (PackState) {
              PackState[PackState["Invalid"] = 0] = "Invalid";
              PackState[PackState["Removed"] = 1] = "Removed";
              PackState[PackState["Downloading"] = 2] = "Downloading";
              PackState[PackState["Loaded"] = 3] = "Loaded";
            })(PackState || (PackState = {}));

            var UnpackerData = function UnpackerData() {
              _classCallCheck(this, UnpackerData);

              this.unpacker = void 0;
              this.state = void 0;
              this.unpacker = null;
              this.state = PackState.Invalid;
            }; // {assetUuid: packUuid|[packUuid]}
            // If value is array of packUuid, then the first one will be prioritized for download,
            // so the smallest pack must be at the beginning of the array.


            var uuidToPack = {}; // {packUuid: assetIndices}

            var packIndices = {}; // {packUuid: UnpackerData}
            // We have to cache all packs in global because for now there's no operation context in loader.

            var globalUnpackers = {};

            function error(uuid, packUuid) {
              return new Error('Can not retrieve ' + uuid + ' from packer ' + packUuid);
            }

            function initPacks(packs) {
              packIndices = packs;

              for (var packUuid in packs) {
                var uuids = packs[packUuid];

                for (var i = 0; i < uuids.length; i++) {
                  var uuid = uuids[i]; // the smallest pack must be at the beginning of the array to download more first

                  var pushFront = uuids.length === 1;
                  pushToMap(uuidToPack, uuid, packUuid, pushFront);
                }
              }
            }
            function _loadNewPack(uuid, packUuid, callback) {
              var packUrl = legacyCC.AssetLibrary.getLibUrlNoExt(packUuid) + '.json';
              legacyCC.loader.load({
                url: packUrl,
                ignoreMaxConcurrency: true
              }, function (err, packJson) {
                if (err) {
                  errorID(4916, uuid);
                  return callback(err);
                }

                var res = _doLoadNewPack(uuid, packUuid, packJson);

                if (res) {
                  callback(null, res);
                } else {
                  callback(error(uuid, packUuid));
                }
              });
            }
            function _doPreload(packUuid, packJson) {
              var unpackerData = globalUnpackers[packUuid];

              if (!unpackerData) {
                unpackerData = globalUnpackers[packUuid] = new UnpackerData();
                unpackerData.state = PackState.Downloading;
              }

              if (unpackerData.state !== PackState.Loaded) {
                unpackerData.unpacker = new JsonUnpacker();
                unpackerData.unpacker.load(packIndices[packUuid], packJson);
                unpackerData.state = PackState.Loaded;
              }
            }
            function _doLoadNewPack(uuid, packUuid, packedJson) {
              var unpackerData = globalUnpackers[packUuid]; // double check cache after load

              if (unpackerData.state !== PackState.Loaded) {
                // init unpacker
                if (typeof packedJson === 'string') {
                  packedJson = JSON.parse(packedJson);
                }

                if (Array.isArray(packedJson)) {
                  unpackerData.unpacker = new JsonUnpacker();
                } else if (packedJson.type === _getClassId(Texture2D)) {
                  unpackerData.unpacker = new TextureUnpacker();
                }

                unpackerData.unpacker.load(packIndices[packUuid], packedJson);
                unpackerData.state = PackState.Loaded;
              }

              return unpackerData.unpacker.retrieve(uuid);
            }
            function _selectLoadedPack(packUuids) {
              var existsPackState = PackState.Invalid;
              var existsPackUuid = '';

              for (var i = 0; i < packUuids.length; i++) {
                var packUuid = packUuids[i];
                var unpackerData = globalUnpackers[packUuid];

                if (unpackerData) {
                  var state = unpackerData.state;

                  if (state === PackState.Loaded) {
                    return packUuid;
                  } else if (state > existsPackState) {
                    // load from the package with the largest state value,
                    existsPackState = state;
                    existsPackUuid = packUuid;
                  }
                }
              } // otherwise the first one (smallest one) will be load


              return existsPackState !== PackState.Invalid ? existsPackUuid : packUuids[0];
            }
            /**
             * @returns {Object} When returns undefined, the requested item is not in any pack, when returns null, the item is in a loading pack, when item json exists, it will return the result directly.
             */

            function load(item, callback) {
              var uuid = item.uuid;
              var packUuid = uuidToPack[uuid];

              if (!packUuid) {
                // Return undefined to let caller know it's not recognized.
                // We don't use false here because changing return value type may cause jit fail,
                // though return undefined may have the same issue.
                return;
              }

              if (Array.isArray(packUuid)) {
                packUuid = _selectLoadedPack(packUuid);
              }

              var unpackerData = globalUnpackers[packUuid];

              if (unpackerData && unpackerData.state === PackState.Loaded) {
                // ensure async
                var json = unpackerData.unpacker.retrieve(uuid);

                if (json) {
                  return json;
                } else {
                  return error(uuid, packUuid);
                }
              } else {
                if (!unpackerData) {
                  {
                    console.log('Create unpacker %s for %s', packUuid, uuid);
                  }

                  unpackerData = globalUnpackers[packUuid] = new UnpackerData();
                  unpackerData.state = PackState.Downloading;
                }

                _loadNewPack(uuid, packUuid, callback);
              } // Return null to let caller know it's loading asynchronously


              return null;
            }

            var PackDownloader = /*#__PURE__*/Object.freeze({
                __proto__: null,
                initPacks: initPacks,
                _loadNewPack: _loadNewPack,
                _doPreload: _doPreload,
                _doLoadNewPack: _doLoadNewPack,
                _selectLoadedPack: _selectLoadedPack,
                load: load
            });

            var ID$1 = 'SubPackPipe';
            var UuidRegex$1 = /.*[/\\][0-9a-fA-F]{2}[/\\]([0-9a-fA-F-@]{8,}).*/;

            function getUuidFromURL$1(url) {
              var matches = url.match(UuidRegex$1);

              if (matches) {
                return matches[1];
              }

              return "";
            }

            var _uuidToSubPack = Object.create(null);

            var SubPackPipe = /*#__PURE__*/function () {
              function SubPackPipe(subpackage) {
                _classCallCheck(this, SubPackPipe);

                this.id = ID$1;
                this.async = false;
                this.pipeline = null;

                var _loop = function _loop(packName) {
                  var pack = subpackage[packName];
                  pack.uuids && pack.uuids.forEach(function (val) {
                    var uuid = decodeUuid(val);
                    var uuids = uuid.split('@').map(function (name) {
                      return encodeURIComponent(name);
                    });
                    uuid = uuids.join('@');
                    _uuidToSubPack[uuid] = pack.path;
                  });
                };

                for (var packName in subpackage) {
                  _loop(packName);
                }
              }

              _createClass(SubPackPipe, [{
                key: "handle",
                value: function handle(item) {
                  item.url = this.transformURL(item.url);
                  return null;
                }
              }, {
                key: "transformURL",
                value: function transformURL(url) {
                  var uuid = getUuidFromURL$1(url);

                  if (uuid) {
                    var subpackage = _uuidToSubPack[uuid];

                    if (subpackage) {
                      // only replace url of native assets
                      return url.replace('res/raw-assets/', subpackage + 'raw-assets/');
                    }
                  }

                  return url;
                }
              }]);

              return SubPackPipe;
            }(); // @ts-ignore

            SubPackPipe.ID = ID$1;
            Pipeline.SubPackPipe = SubPackPipe;

            /*
            Copyright (c) 2013-2016 Chukong Technologies Inc.
            Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

            http://www.cocos.com

            Permission is hereby granted, free of charge, to any person obtaining a copy
            of this software and associated engine source code (the "Software"), a limited,
             worldwide, royalty-free, non-assignable, revocable and non-exclusive license
            to use Cocos Creator solely to develop games on your target platforms. You shall
             not use Cocos Creator software for developing other software or tools that's
             used for developing games. You are not granted to publish, distribute,
             sublicense, and/or sell copies of Cocos Creator.

            The software or tools in this License Agreement are licensed, not sold.
            Xiamen Yaji Software Co., Ltd. reserves all rights not expressly granted to you.

            THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
            IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
            FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
            AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
            LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
            OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
            THE SOFTWARE.
            */
            // configs

            var _libraryBase = '';
            var _rawAssetsBase = ''; // The base dir for raw assets in runtime

            var _uuidToRawAsset = createMap(true);

            function isScene(asset) {
              return asset && (asset.constructor === legacyCC.SceneAsset || asset instanceof legacyCC.Scene);
            } // types


            function RawAssetEntry(url, type) {
              // @ts-ignore
              this.url = url; // @ts-ignore

              this.type = type;
            } // publics


            /**
             * @en The asset library which manages load or unload assets in project.
             * @zh 管理项目中加载/卸载资源的资源库。
             */
            var AssetLibrary = exports('aW', {
              /**
               * 这里保存所有已经加载的场景资源，防止同一个资源在内存中加载出多份拷贝。
               *
               * 这里用不了WeakMap，在浏览器中所有加载过的资源都只能手工调用 unloadAsset 释放。
               *
               * 参考：
               * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap
               * https://github.com/TooTallNate/node-weak
               *
               * @private
               */
              _uuidToAsset: {},

              /**
               * @zh 加载资源
               * @en Load an asset
               * @param uuid - The uuid of the asset
               * @param callback - The callback function once load finished
               * @param options
               * @param options.readMainCache - Default is true. If false, the asset and all its depends assets will reload and create new instances from library.
               * @param options.writeMainCache - Default is true. If true, the result will cache to AssetLibrary, and MUST be unload by user manually.
               * @param options.existingAsset - load to existing asset, this argument is only available in editor
               */
              loadAsset: function loadAsset(uuid, callback, options) {
                if (typeof uuid !== 'string') {
                  return callInNextTick(callback, new Error('[AssetLibrary] uuid must be string'), null);
                } // var readMainCache = typeof (options && options.readMainCache) !== 'undefined' ? readMainCache : true;
                // var writeMainCache = typeof (options && options.writeMainCache) !== 'undefined' ? writeMainCache : true;


                var item = {
                  uuid: uuid,
                  type: 'uuid'
                };

                if (options && options.existingAsset) {
                  item.existingAsset = options.existingAsset;
                }

                legacyCC.loader.load(item, function (error, asset) {
                  if (error || !asset) {
                    error = new Error('[AssetLibrary] loading JSON or dependencies failed: ' + (error ? error.message : 'Unknown error'));
                  } else {
                    if (asset.constructor === legacyCC.SceneAsset) ;
                  }

                  if (callback) {
                    callback(error, asset);
                  }
                });
              },

              /**
               * @en Gets the url of the asset in library, without extension
               * @zh 获取资源在资源库中的 url，不包含后缀。
               * @param uuid The asset uuid
               * @param inRawAssetsDir Indicates whether the asset is in raw assets' sub directory
               */
              getLibUrlNoExt: function getLibUrlNoExt(uuid, inRawAssetsDir) {
                {
                  uuid = decodeUuid(uuid);
                }

                var uuids = uuid.split('@').map(function (name) {
                  return encodeURIComponent(name);
                });
                uuid = uuids.join('@');
                var base =  inRawAssetsDir ? _rawAssetsBase + 'assets/' : _libraryBase;
                return base + uuid.slice(0, 2) + '/' + uuid;
              },

              /**
               * @en Gets asset information in editor environment asynchronously.
               * @zh 在编辑器中查询资源信息，这是一个异步操作。
               * @param uuid The asset uuid
               * @param callback Callback for retrieving the result
               * @private
               */
              _queryAssetInfoInEditor: function _queryAssetInfoInEditor(uuid, callback) {
                {
                  callback(new Error('Unable to load resource: EditorExtends is not defined.'));
                }
              },

              /**
               * @en Gets asset information in runtime environment.
               * @zh 在运行时查询资源信息，这是一个异步操作。
               * @param uuid The asset uuid
               * @param result The result object containing url and raw mark
               * @return Return value equals the result
               * @private
               */
              _getAssetInfoInRuntime: function _getAssetInfoInRuntime(uuid, result) {
                result = result || {
                  url: null,
                  raw: false
                };
                var info = _uuidToRawAsset[uuid];

                if (info && !isChildClassOf(info.type, legacyCC.Asset)) {
                  // backward compatibility since 1.10
                  result.url = _rawAssetsBase + info.url;
                  result.raw = true;
                } else {
                  result.url = this.getLibUrlNoExt(uuid) + '.json';
                  result.raw = false;
                }

                return result;
              },

              /**
               * @zh
               * 在 setting 中的 uuid。
               */
              _uuidInSettings: function _uuidInSettings(uuid) {
                return uuid in _uuidToRawAsset;
              },

              /**
               * @zh
               * 获取资源信息。
               * @param {String} uuid 资源的 uuid。
               * @param {Function} callback
               * @param {Error} callback.error
               * @param {String} callback.url - the url of raw asset or imported asset
               * @param {Boolean} callback.raw - indicates whether the asset is raw asset
               * @param {Function} callback.ctorInEditor - the actual type of asset, used in editor only
               */
              queryAssetInfo: function queryAssetInfo(uuid, callback) {
                {
                  var info = this._getAssetInfoInRuntime(uuid);

                  callback(null, info.url, info.raw);
                }
              },

              /**
               * @en
               * parse uuid out of url
               * @zh
               * 从 url 解析 uuid。
               * @param url 资源地址。
               */
              parseUuidInEditor: function parseUuidInEditor(url) {
              },

              /**
               * @en Load a JSON resource asynchronously
               * @zh 异步加载 JSON 资源。
               * @param json The json content
               * @param callback The callback function after load
               * @private
               */
              loadJson: function loadJson(json, callback) {
                var randomUuid = '' + (new Date().getTime() + Math.random());
                var item = {
                  uuid: randomUuid,
                  type: 'uuid',
                  content: json,
                  skips: [legacyCC.loader.assetLoader.id, legacyCC.loader.downloader.id]
                };
                legacyCC.loader.load(item, function (error, asset) {
                  if (error) {
                    error = new Error('[AssetLibrary] loading JSON or dependencies failed: ' + error.message);
                  } else {
                    if ( isScene(asset)) {
                      var id = legacyCC.loader._getReferenceKey(randomUuid);

                      legacyCC.loader.removeItem(id);
                    }
                  }

                  asset._uuid = '';

                  if (callback) {
                    callback(error, asset);
                  }
                });
              },

              /**
               * @en Get the exists asset by uuid.
               * @zh 根据 uuid 获取存在的资源。
               * @param uuid
               * @return - The existing asset, if not loaded, just returns null.
               * @private
               */
              getAssetByUuid: function getAssetByUuid(uuid) {
                return AssetLibrary._uuidToAsset[uuid] || null;
              },
              // tslint:disable: no-shadowed-variable

              /**
               * @en
               * Init the asset library
               * @zh
               * 初始化 AssetLibrary。
               * @method init
               * @param options
               * @param options.libraryPath - Accept library url, normally use absolute path in editor, use relative path in runtime.
               * @param options.mountPaths - mount point of actual urls for raw assets (only used in editor)
               * @param [options.rawAssets] - uuid to raw asset's urls (only used in runtime)
               * @param [options.rawAssetsBase] - base of raw asset's urls (only used in runtime)
               * @param [options.packedAssets] - packed assets (only used in runtime)
               */
              init: function init(options) {
                // 不使用 url.format 的原因是 windows 不支持 file:// 和 /// 开头的协议，所以只能用 replace 操作直接把路径转成 URL。


                var libraryPath = options.libraryPath;
                libraryPath = libraryPath.replace(/\\/g, '/');
                _libraryBase = legacyCC.path.stripSep(libraryPath) + '/';
                _rawAssetsBase = options.rawAssetsBase;
                var md5AssetsMap = options.md5AssetsMap;

                if (md5AssetsMap && md5AssetsMap["import"]) {
                  // decode uuid
                  var i = 0;
                  var uuid = '';
                  var md5ImportMap = createMap(true);
                  var md5Entries = md5AssetsMap["import"];

                  for (i = 0; i < md5Entries.length; i += 2) {
                    uuid = decodeUuid(md5Entries[i]);
                    var uuids = uuid.split('@').map(function (name) {
                      return encodeURIComponent(name);
                    });
                    uuid = uuids.join('@');
                    md5ImportMap[uuid] = md5Entries[i + 1];
                  }

                  var md5RawAssetsMap = createMap(true);
                  md5Entries = md5AssetsMap['raw-assets'];

                  for (i = 0; i < md5Entries.length; i += 2) {
                    uuid = decodeUuid(md5Entries[i]);

                    var _uuids = uuid.split('@').map(function (name) {
                      return encodeURIComponent(name);
                    });

                    uuid = _uuids.join('@');
                    md5RawAssetsMap[uuid] = md5Entries[i + 1];
                  }

                  var md5Pipe = new MD5Pipe(md5ImportMap, md5RawAssetsMap, _libraryBase);
                  legacyCC.loader.insertPipeAfter(legacyCC.loader.assetLoader, md5Pipe);
                  legacyCC.loader.md5Pipe = md5Pipe;
                }

                var subPackages = options.subPackages;

                if (subPackages) {
                  legacyCC.loader.downloader.setSubPackages(subPackages);
                  var subPackPipe = new SubPackPipe(subPackages);
                  legacyCC.loader.insertPipeAfter(legacyCC.loader.assetLoader, subPackPipe);
                  legacyCC.loader.subPackPipe = subPackPipe;
                } // init raw assets


                var assetTables = legacyCC.loader._assetTables; // tslint:disable: forin

                for (var mount in assetTables) {
                  assetTables[mount].reset();
                }

                var rawAssets = options.rawAssets;

                if (rawAssets) {
                  for (var mountPoint in rawAssets) {
                    var assets = rawAssets[mountPoint];

                    for (var _uuid in assets) {
                      var info = assets[_uuid];
                      var url = info[0];
                      var typeId = info[1];

                      var type = _getClassById(typeId);

                      if (!type) {
                        error$1('Cannot get', typeId);
                        continue;
                      } // backward compatibility since 1.10


                      _uuidToRawAsset[_uuid] = new RawAssetEntry(mountPoint + '/' + url, type); // init resources

                      var isSubAsset = info[2] === 1;

                      if (!assetTables[mountPoint]) {
                        assetTables[mountPoint] = new AssetTable();
                      }

                      assetTables[mountPoint].add(url, _uuid, type, !isSubAsset);
                    }
                  }
                }

                if (options.packedAssets) {
                  initPacks(options.packedAssets);
                } // init cc.url


                legacyCC.url._init(options.mountPaths && options.mountPaths.assets || _rawAssetsBase + 'assets');
              }
            }); // 暂时屏蔽，因为目前没有缓存任何asset
            // if (DEV && Asset.prototype._onPreDestroy) {
            //    cc.error('_onPreDestroy of Asset has already defined');
            // }
            // Asset.prototype._onPreDestroy = function () {
            //    if (AssetLibrary._uuidToAsset[this._uuid] === this) {
            //        AssetLibrary.unloadAsset(this);
            //    }
            // };

            legacyCC.AssetLibrary = AssetLibrary;

            var _dec$o, _class$o;
            /**
             * @en Class for Font handling.
             * @zh 字体资源类。
             */

            var Font = exports('b1', (_dec$o = ccclass('cc.Font'), _dec$o(_class$o = /*#__PURE__*/function (_Asset) {
              _inherits(Font, _Asset);

              function Font() {
                _classCallCheck(this, Font);

                return _possibleConstructorReturn(this, _getPrototypeOf(Font).apply(this, arguments));
              }

              return Font;
            }(Asset)) || _class$o));
            legacyCC.Font = Font;

            var _dec$p, _class$p, _class2$m, _descriptor$l, _temp$o;
            /**
             * @en Class for TTFFont asset.
             * @zh TTF 字体资源类。
             */

            var TTFFont = exports('a_', (_dec$p = ccclass('cc.TTFFont'), _dec$p(_class$p = (_class2$m = (_temp$o = /*#__PURE__*/function (_Font) {
              _inherits(TTFFont, _Font);

              function TTFFont() {
                var _getPrototypeOf2;

                var _this;

                _classCallCheck(this, TTFFont);

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(TTFFont)).call.apply(_getPrototypeOf2, [this].concat(args)));

                _initializerDefineProperty(_this, "_fontFamily", _descriptor$l, _assertThisInitialized(_this));

                return _this;
              }

              _createClass(TTFFont, [{
                key: "_nativeAsset",
                get: function get() {
                  return this._fontFamily;
                },
                set: function set(value) {
                  this._fontFamily = value || 'Arial';
                }
              }]);

              return TTFFont;
            }(Font), _temp$o), (_descriptor$l = _applyDecoratedDescriptor(_class2$m.prototype, "_fontFamily", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _applyDecoratedDescriptor(_class2$m.prototype, "_nativeAsset", [override, string], Object.getOwnPropertyDescriptor(_class2$m.prototype, "_nativeAsset"), _class2$m.prototype)), _class2$m)) || _class$p));
            legacyCC.TTFFont = TTFFont;

            var _dec$q, _dec2$9, _class$q, _class2$n, _descriptor$m, _descriptor2$g, _descriptor3$c, _descriptor4$7, _temp$p;
            var BitmapFont = exports('b0', (_dec$q = ccclass('cc.BitmapFont'), _dec2$9 = type(SpriteFrame), _dec$q(_class$q = (_class2$n = (_temp$p = /*#__PURE__*/function (_Font) {
              _inherits(BitmapFont, _Font);

              function BitmapFont() {
                var _getPrototypeOf2;

                var _this;

                _classCallCheck(this, BitmapFont);

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(BitmapFont)).call.apply(_getPrototypeOf2, [this].concat(args)));

                _initializerDefineProperty(_this, "fntDataStr", _descriptor$m, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "spriteFrame", _descriptor2$g, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "fontSize", _descriptor3$c, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "fntConfig", _descriptor4$7, _assertThisInitialized(_this));

                return _this;
              }

              return BitmapFont;
            }(Font), _temp$p), (_descriptor$m = _applyDecoratedDescriptor(_class2$n.prototype, "fntDataStr", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return '';
              }
            }), _descriptor2$g = _applyDecoratedDescriptor(_class2$n.prototype, "spriteFrame", [_dec2$9], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor3$c = _applyDecoratedDescriptor(_class2$n.prototype, "fontSize", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return -1;
              }
            }), _descriptor4$7 = _applyDecoratedDescriptor(_class2$n.prototype, "fntConfig", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            })), _class2$n)) || _class$q));
            legacyCC.BitmapFont = BitmapFont;

            var _dec$r, _class$r;
            /**
             * @en Class for LabelAtlas handling.
             * @zh 艺术数字字体资源类。
             *
             */

            var LabelAtlas = exports('a$', (_dec$r = ccclass('cc.LabelAtlas'), _dec$r(_class$r = /*#__PURE__*/function (_BitmapFont) {
              _inherits(LabelAtlas, _BitmapFont);

              function LabelAtlas() {
                _classCallCheck(this, LabelAtlas);

                return _possibleConstructorReturn(this, _getPrototypeOf(LabelAtlas).apply(this, arguments));
              }

              return LabelAtlas;
            }(BitmapFont)) || _class$r));
            legacyCC.LabelAtlas = LabelAtlas;

            var ID$2 = 'AssetLoader';
            var reusedArray = [];
            /**
             * @en The load pipe in {{loader}} to load an asset with its uuid, it will recursively load its dependencies.
             * @zh {{loader}} 加载管线中的资源加载管道，用来通过 uuid 加载 asset 资源及其依赖
             */

            var AssetLoader = /*#__PURE__*/function () {
              function AssetLoader() {
                _classCallCheck(this, AssetLoader);

                this.id = ID$2;
                this.async = true;
                this.pipeline = null;
              }

              _createClass(AssetLoader, [{
                key: "handle",
                value: function handle(item, callback) {

                  var uuid = item.uuid;

                  if (!uuid) {
                    return item.content || null;
                  }

                  legacyCC.AssetLibrary.queryAssetInfo(uuid, function (error, url, isRawAsset) {
                    if (error) {
                      callback(error);
                    } else {
                      item.url = item.rawUrl = url;
                      item.isRawAsset = isRawAsset;

                      if (isRawAsset) {
                        var ext = extname(url).toLowerCase();

                        if (!ext) {
                          callback(new Error(getError(4931, uuid, url)));
                          return;
                        }

                        ext = ext.substr(1);
                        var queue = LoadingItems.getQueue(item);
                        reusedArray[0] = {
                          queueId: item.queueId,
                          id: url,
                          url: url,
                          type: ext,
                          error: null,
                          alias: item,
                          complete: true
                        };

                        queue && queue.append(reusedArray); // Dispatch to other raw type downloader

                        item.type = ext;
                        callback(null, item.content);
                      } else {
                        item.type = 'uuid';
                        callback(null, item.content);
                      }
                    }
                  });
                }
              }]);

              return AssetLoader;
            }(); // @ts-ignore


            AssetLoader.ID = ID$2;
            Pipeline.AssetLoader = AssetLoader;

            function parseDepends(key, parsed) {
              var item = legacyCC.loader.getItem(key);

              if (item) {
                var depends = item.dependKeys;

                if (depends) {
                  for (var i = 0; i < depends.length; i++) {
                    var depend = depends[i];

                    if (!parsed[depend]) {
                      parsed[depend] = true;
                      parseDepends(depend, parsed);
                    }
                  }
                }
              }
            }

            function visitAsset(asset, excludeMap) {
              // Skip assets generated programmatically or by user (e.g. label texture)
              if (!asset._uuid) {
                return;
              }

              var key = legacyCC.loader._getReferenceKey(asset);

              if (!excludeMap[key]) {
                excludeMap[key] = true;
                parseDepends(key, excludeMap);
              }
            }

            function visitComponent(comp, excludeMap) {
              var props = Object.getOwnPropertyNames(comp);

              for (var i = 0; i < props.length; i++) {
                var value = comp[props[i]];

                if (_typeof(value) === 'object' && value) {
                  if (Array.isArray(value)) {
                    for (var j = 0; j < value.length; j++) {
                      var val = value[j];

                      if (val instanceof RawAsset) {
                        visitAsset(val, excludeMap);
                      }
                    }
                  } else if (!value.constructor || value.constructor === Object) {
                    var keys = Object.getOwnPropertyNames(value);

                    for (var _j = 0; _j < keys.length; _j++) {
                      var _val = value[keys[_j]];

                      if (_val instanceof RawAsset) {
                        visitAsset(_val, excludeMap);
                      }
                    }
                  } else if (value instanceof RawAsset) {
                    visitAsset(value, excludeMap);
                  }
                }
              }
            }

            function visitNode(node, excludeMap) {
              for (var i = 0; i < node._components.length; i++) {
                visitComponent(node._components[i], excludeMap);
              }

              for (var _i = 0; _i < node._children.length; _i++) {
                visitNode(node._children[_i], excludeMap);
              }
            } // do auto release


            function autoRelease(oldSceneAssets, nextSceneAssets, persistNodes) {
              var releaseSettings = legacyCC.loader._autoReleaseSetting;
              var excludeMap = createMap(); // collect next scene assets

              if (nextSceneAssets) {
                for (var i = 0; i < nextSceneAssets.length; i++) {
                  excludeMap[nextSceneAssets[i]] = true;
                }
              } // collect assets used by persist nodes


              for (var _i2 = 0; _i2 < persistNodes.length; _i2++) {
                visitNode(persistNodes[_i2], excludeMap);
              } // remove ununsed scene assets


              if (oldSceneAssets) {
                for (var _i3 = 0; _i3 < oldSceneAssets.length; _i3++) {
                  var key = oldSceneAssets[_i3];

                  if (releaseSettings[key] !== false && !excludeMap[key]) {
                    legacyCC.loader.release(key);
                  }
                }
              } // remove auto release assets
              // (releasing asset will change _autoReleaseSetting, so don't use for-in)


              var keys = Object.keys(releaseSettings);

              for (var _i4 = 0; _i4 < keys.length; _i4++) {
                var _key = keys[_i4];

                if (releaseSettings[_key] === true && !excludeMap[_key]) {
                  legacyCC.loader.release(_key);
                }
              }
            } // get dependencies not including self

            function getDependsRecursively(key) {
              var depends = {};
              parseDepends(key, depends);
              return Object.keys(depends);
            }

            /*
             Copyright (c) 2013-2016 Chukong Technologies Inc.
             Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

             http://www.cocos.com

             Permission is hereby granted, free of charge, to any person obtaining a copy
             of this software and associated engine source code (the "Software"), a limited,
              worldwide, royalty-free, non-assignable, revocable and non-exclusive license
             to use Cocos Creator solely to develop games on your target platforms. You shall
              not use Cocos Creator software for developing other software or tools that's
              used for developing games. You are not granted to publish, distribute,
              sublicense, and/or sell copies of Cocos Creator.

             The software or tools in this License Agreement are licensed, not sold.
             Xiamen Yaji Software Co., Ltd. reserves all rights not expressly granted to you.

             THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
             THE SOFTWARE.
             */
            function downloadBinary(item, callback) {
              var url = item.url;
              var xhr = legacyCC.loader.getXMLHttpRequest(),
                  errInfo = 'Load binary data failed: ' + url + '';
              xhr.open('GET', url, true);
              xhr.responseType = "arraybuffer";

              xhr.onload = function () {
                var arrayBuffer = xhr.response;

                if (arrayBuffer) {
                  // var result = new Uint8Array(arrayBuffer);
                  callback(null, arrayBuffer);
                } else {
                  callback({
                    status: xhr.status,
                    errorMessage: errInfo + '(no response)'
                  });
                }
              };

              xhr.onerror = function () {
                callback({
                  status: xhr.status,
                  errorMessage: errInfo + '(error)'
                });
              };

              xhr.ontimeout = function () {
                callback({
                  status: xhr.status,
                  errorMessage: errInfo + '(time out)'
                });
              };

              xhr.send(null);
            }

            /*
             Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

             http://www.cocos.com

             Permission is hereby granted, free of charge, to any person obtaining a copy
             of this software and associated engine source code (the "Software"), a limited,
             worldwide, royalty-free, non-assignable, revocable and non-exclusive license
             to use Cocos Creator solely to develop games on your target platforms. You shall
             not use Cocos Creator software for developing other software or tools that's
             used for developing games. You are not granted to publish, distribute,
             sublicense, and/or sell copies of Cocos Creator.

             The software or tools in this License Agreement are licensed, not sold.
             Xiamen Yaji Software Co., Ltd. reserves all rights not expressly granted to you.

             THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
             THE SOFTWARE.
             */
            function downloadText (item, callback) {
              var url = item.url;
              url = urlAppendTimestamp(url);
              var xhr = legacyCC.loader.getXMLHttpRequest(),
                  errInfo = 'Load text file failed: ' + url;
              xhr.open('GET', url, true);
              if (xhr.overrideMimeType) xhr.overrideMimeType('text/plain; charset=utf-8');

              xhr.onload = function () {
                if (xhr.readyState === 4) {
                  if (xhr.status === 200 || xhr.status === 0) {
                    callback(null, xhr.responseText);
                  } else {
                    callback({
                      status: xhr.status,
                      errorMessage: errInfo + '(wrong status)'
                    });
                  }
                } else {
                  callback({
                    status: xhr.status,
                    errorMessage: errInfo + '(wrong readyState)'
                  });
                }
              };

              xhr.onerror = function () {
                callback({
                  status: xhr.status,
                  errorMessage: errInfo + '(error)'
                });
              };

              xhr.ontimeout = function () {
                callback({
                  status: xhr.status,
                  errorMessage: errInfo + '(time out)'
                });
              };

              xhr.send(null);
            }

            function skip() {
              return null;
            }

            function downloadScript(item, callback, isAsync) {
              var url = item.url,
                  d = document,
                  s = document.createElement('script');
              s.async = !!isAsync;
              s.src = urlAppendTimestamp(url);

              function loadHandler() {
                if (s.parentNode) s.parentNode.removeChild(s);
                s.removeEventListener('load', loadHandler, false);
                s.removeEventListener('error', errorHandler, false);
                callback(null, url);
              }

              function errorHandler() {
                if (s.parentNode) s.parentNode.removeChild(s);
                s.removeEventListener('load', loadHandler, false);
                s.removeEventListener('error', errorHandler, false);
                callback(new Error(getError(4928, url)));
              }

              s.addEventListener('load', loadHandler, false);
              s.addEventListener('error', errorHandler, false);
              d.body.appendChild(s);
            }

            function downloadImage(item, callback, isCrossOrigin, img) {
              if (isCrossOrigin === undefined) {
                isCrossOrigin = true;
              }

              var url = urlAppendTimestamp(item.url);
              img = img || new Image();

              if (isCrossOrigin && window.location.protocol !== 'file:') {
                img.crossOrigin = 'anonymous';
              } else {
                img.crossOrigin = null;
              }

              function loadCallback() {
                img.removeEventListener('load', loadCallback);
                img.removeEventListener('error', errorCallback);
                img.id = item.id;
                callback(null, img);
              }

              function errorCallback() {
                img.removeEventListener('load', loadCallback);
                img.removeEventListener('error', errorCallback); // Retry without crossOrigin mark if crossOrigin loading fails
                // Do not retry if protocol is https, even if the image is loaded, cross origin image isn't renderable.

                if (window.location.protocol !== 'https:' && img.crossOrigin && img.crossOrigin.toLowerCase() === 'anonymous') {
                  downloadImage(item, callback, false, img);
                } else {
                  callback(new Error(getError(4930, url)));
                }
              }

              if (img.complete && img.naturalWidth > 0 && img.src === url) {
                return img;
              } else {
                img.addEventListener('load', loadCallback);
                img.addEventListener('error', errorCallback);
                img.src = url;
              }
            }

            function downloadUuid(item, callback) {
              var result = load(item, callback);

              if (result === undefined) {
                // @ts-ignore
                return this.extMap['json'](item, callback);
              }

              return result || undefined;
            }

            var defaultMap = {
              // JS
              'js': downloadScript,
              // Images
              'png': downloadImage,
              'jpg': downloadImage,
              'bmp': downloadImage,
              'jpeg': downloadImage,
              'gif': downloadImage,
              'ico': downloadImage,
              'tiff': downloadImage,
              'webp': downloadImage,
              'image': downloadImage,
              'pvr': downloadBinary,
              'pkm': downloadBinary,
              'astc': downloadBinary,
              // Audio
              'mp3': downloadAudio,
              'ogg': downloadAudio,
              'wav': downloadAudio,
              'm4a': downloadAudio,
              // Txt
              'txt': downloadText,
              'xml': downloadText,
              'vsh': downloadText,
              'fsh': downloadText,
              'atlas': downloadText,
              'tmx': downloadText,
              'tsx': downloadText,
              'json': downloadText,
              'ExportJson': downloadText,
              'plist': downloadText,
              'fnt': downloadText,
              // Font
              'font': skip,
              'eot': skip,
              'ttf': skip,
              'woff': skip,
              'svg': skip,
              'ttc': skip,
              // Deserializer
              'uuid': downloadUuid,
              // Binary
              'binary': downloadBinary,
              'bin': downloadBinary,
              'default': downloadText
            };
            var ID$3 = 'Downloader';

            /**
             * @en The downloader pipe in {{loader}}, it can download several types of files:
             * 1. Text
             * 2. Image
             * 3. Script
             * 4. Audio
             * 5. Binary
             * All unknown type will be downloaded as plain text.
             * You can pass custom supported types in the {{loader.addDownloadHandlers}}.
             * @zh {{loader}} 中的下载管线，可以下载下列类型的文件：
             * 1. Text
             * 2. Image
             * 3. Script
             * 4. Audio
             * 5. Binary
             * 所有未知类型会被当做文本来下载，也可以通过 {{loader.addDownloadHandlers}} 来定制下载行为
             */
            var Downloader = exports('cQ', /*#__PURE__*/function () {
              function Downloader(extMap) {
                _classCallCheck(this, Downloader);

                this.id = ID$3;
                this.async = true;
                this.pipeline = null;
                this.extMap = void 0;
                this._curConcurrent = 0;
                this._loadQueue = [];
                this._subPackages = {};
                this.extMap = mixin(extMap, defaultMap);
              }
              /**
               * @en Set sub package configurations, only available in certain platforms
               * @zh 设置子包配置，只在部分平台支持
               * @param subPackages 
               */


              _createClass(Downloader, [{
                key: "setSubPackages",
                value: function setSubPackages(subPackages) {
                  this._subPackages = subPackages;
                }
                /**
                 * @en Add custom supported types handler or modify existing type handler.
                 * @zh 添加自定义支持的类型处理程序或修改现有的类型处理程序。
                 * @param extMap Custom supported types with corresponded handler
                 */

              }, {
                key: "addHandlers",
                value: function addHandlers(extMap) {
                  mixin(this.extMap, extMap);
                }
              }, {
                key: "_handleLoadQueue",
                value: function _handleLoadQueue() {
                  while (this._curConcurrent < legacyCC.macro.DOWNLOAD_MAX_CONCURRENT) {
                    var nextOne = this._loadQueue.shift();

                    if (!nextOne) {
                      break;
                    }

                    var syncRet = this.handle(nextOne.item, nextOne.callback);

                    if (syncRet !== undefined) {
                      if (syncRet instanceof Error) {
                        nextOne.callback(syncRet);
                      } else {
                        nextOne.callback(null, syncRet);
                      }
                    }
                  }
                }
              }, {
                key: "handle",
                value: function handle(item, callback) {
                  var self = this;
                  var downloadFunc = this.extMap[item.type] || this.extMap['default'];
                  var syncRet = undefined;

                  if (this._curConcurrent < legacyCC.macro.DOWNLOAD_MAX_CONCURRENT) {
                    this._curConcurrent++;
                    syncRet = downloadFunc.call(this, item, function (err, result) {
                      self._curConcurrent = Math.max(0, self._curConcurrent - 1);

                      self._handleLoadQueue();

                      callback && callback(err, result);
                    });

                    if (syncRet !== undefined) {
                      this._curConcurrent = Math.max(0, this._curConcurrent - 1);

                      this._handleLoadQueue();

                      return syncRet;
                    }
                  } else if (item.ignoreMaxConcurrency) {
                    syncRet = downloadFunc.call(this, item, callback);

                    if (syncRet !== undefined) {
                      return syncRet;
                    }
                  } else {
                    this._loadQueue.push({
                      item: item,
                      callback: callback
                    });
                  }
                }
                /**
                 * @en Load sub package with name.
                 * @zh 通过子包名加载子包代码。
                 * @param name - Sub package name
                 * @param completeCallback -  Callback invoked when sub package loaded
                 * @param {Error} completeCallback.error - error information
                 */

              }, {
                key: "loadSubpackage",
                value: function loadSubpackage(name, completeCallback) {
                  var pac = this._subPackages[name];

                  if (pac) {
                    if (pac.loaded) {
                      if (completeCallback) completeCallback();
                    } else {
                      downloadScript({
                        url: pac.path
                      }, function (err) {
                        if (!err) {
                          pac.loaded = true;
                        }

                        if (completeCallback) completeCallback(err);
                      });
                    }
                  } else if (completeCallback) {
                    completeCallback(new Error("Can't find subpackage ".concat(name)));
                  }
                }
              }]);

              return Downloader;
            }()); // @ts-ignore


            Downloader.ID = ID$3;
            Downloader.PackDownloader = PackDownloader;
            Pipeline.Downloader = Downloader;

            /**
             * A SAX Parser
             * @class saxParser
             */

            var SAXParser = /*#__PURE__*/function () {
              function SAXParser() {
                _classCallCheck(this, SAXParser);

                this._isSupportDOMParser = void 0;
                this._parser = void 0;

                if ( window.DOMParser) {
                  this._isSupportDOMParser = true;
                  this._parser = new DOMParser();
                } else {
                  this._isSupportDOMParser = false;
                  this._parser = null;
                }
              }
              /**
               * @method parse
               * @param {String} xmlTxt
               * @return {Document}
               */


              _createClass(SAXParser, [{
                key: "parse",
                value: function parse(xmlTxt) {
                  return this._parseXML(xmlTxt);
                }
              }, {
                key: "_parseXML",
                value: function _parseXML(textxml) {
                  // get a reference to the requested corresponding xml file
                  var xmlDoc;

                  if (this._isSupportDOMParser) {
                    xmlDoc = this._parser.parseFromString(textxml, "text/xml");
                  } else {
                    // Internet Explorer (untested!)
                    xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
                    xmlDoc.async = "false";
                    xmlDoc.loadXML(textxml);
                  }

                  return xmlDoc;
                }
              }]);

              return SAXParser;
            }();
            /**
             *
             * plistParser is a singleton object for parsing plist files
             * @class plistParser
             * @extends SAXParser
             */


            var PlistParser = /*#__PURE__*/function (_SAXParser) {
              _inherits(PlistParser, _SAXParser);

              function PlistParser() {
                _classCallCheck(this, PlistParser);

                return _possibleConstructorReturn(this, _getPrototypeOf(PlistParser).apply(this, arguments));
              }

              _createClass(PlistParser, [{
                key: "parse",

                /**
                 * @en parse a xml string as plist object.
                 * @zh 将xml字符串解析为plist对象。
                 * @param {String} xmlTxt - plist xml contents
                 * @return {*} plist object
                 */
                value: function parse(xmlTxt) {
                  var xmlDoc = this._parseXML(xmlTxt);

                  var plist = xmlDoc.documentElement;

                  if (plist.tagName !== 'plist') {
                    warnID(5100);
                    return {};
                  } // Get first real node


                  var node = null;

                  for (var i = 0, len = plist.childNodes.length; i < len; i++) {
                    node = plist.childNodes[i]; // @ts-ignore

                    if (node.nodeType === 1) break;
                  }

                  xmlDoc = null;
                  return this._parseNode(node);
                }
              }, {
                key: "_parseNode",
                value: function _parseNode(node) {
                  var data = null,
                      tagName = node.tagName;

                  if (tagName === "dict") {
                    data = this._parseDict(node);
                  } else if (tagName === "array") {
                    data = this._parseArray(node);
                  } else if (tagName === "string") {
                    if (node.childNodes.length === 1) data = node.firstChild.nodeValue;else {
                      //handle Firefox's 4KB nodeValue limit
                      data = "";

                      for (var i = 0; i < node.childNodes.length; i++) {
                        data += node.childNodes[i].nodeValue;
                      }
                    }
                  } else if (tagName === "false") {
                    data = false;
                  } else if (tagName === "true") {
                    data = true;
                  } else if (tagName === "real") {
                    data = parseFloat(node.firstChild.nodeValue);
                  } else if (tagName === "integer") {
                    data = parseInt(node.firstChild.nodeValue, 10);
                  }

                  return data;
                }
              }, {
                key: "_parseArray",
                value: function _parseArray(node) {
                  var data = [];

                  for (var i = 0, len = node.childNodes.length; i < len; i++) {
                    var child = node.childNodes[i];
                    if (child.nodeType !== 1) continue;
                    data.push(this._parseNode(child));
                  }

                  return data;
                }
              }, {
                key: "_parseDict",
                value: function _parseDict(node) {
                  var data = {};
                  var key = null;

                  for (var i = 0, len = node.childNodes.length; i < len; i++) {
                    var child = node.childNodes[i];
                    if (child.nodeType !== 1) continue; // Grab the key, next noe should be the value

                    if (child.tagName === 'key') key = child.firstChild.nodeValue;else // @ts-ignore
                      data[key] = this._parseNode(child); // Parse the value node
                  }

                  return data;
                }
              }]);

              return PlistParser;
            }(SAXParser);
            /**
             * @name plistParser
             * A Plist Parser
             */


            var plistParser = new PlistParser();

            function isSceneObj(json) {
              var SCENE_ID = 'cc.Scene';
              var PREFAB_ID = 'cc.Prefab';
              return json && (json[0] && json[0].__type__ === SCENE_ID || json[1] && json[1].__type__ === SCENE_ID || json[0] && json[0].__type__ === PREFAB_ID);
            }

            function parseDepends$1(item, asset, tdInfo, deferredLoadRawAssetsInRuntime) {
              var uuidList = tdInfo.uuidList;
              var objList = tdInfo.uuidObjList;
              var propList = tdInfo.uuidPropList; // @ts-ignore

              var stillUseUrl = tdInfo._stillUseUrl;
              var depends;
              var i, dependUuid; // cache dependencies for auto release

              var dependKeys = item.dependKeys = [];

              if (deferredLoadRawAssetsInRuntime) {
                depends = []; // parse depends assets

                for (i = 0; i < uuidList.length; i++) {
                  dependUuid = uuidList[i];
                  var obj = objList[i];
                  var prop = propList[i];

                  var info = legacyCC.AssetLibrary._getAssetInfoInRuntime(dependUuid);

                  if (info.raw) {
                    // skip preloading raw assets
                    var url = info.url;
                    obj[prop] = url;
                    dependKeys.push(url);
                  } else {
                    // declare depends assets
                    depends.push({
                      type: 'uuid',
                      uuid: dependUuid,
                      deferredLoadRaw: true,
                      _owner: obj,
                      _ownerProp: prop,
                      _stillUseUrl: stillUseUrl[i]
                    });
                  }
                }
              } else {
                depends = new Array(uuidList.length); // declare depends assets

                for (i = 0; i < uuidList.length; i++) {
                  dependUuid = uuidList[i];
                  depends[i] = {
                    type: 'uuid',
                    uuid: dependUuid,
                    _owner: objList[i],
                    _ownerProp: propList[i],
                    _stillUseUrl: stillUseUrl[i]
                  };
                } // load native object (Image/Audio) as depends


                if (asset._native && !asset.constructor.preventPreloadNativeObject) {
                  depends.push({
                    url: asset.nativeUrl,
                    _owner: asset,
                    _ownerProp: '_nativeAsset'
                  });
                }
              }

              return depends;
            }

            function loadDepends(pipeline, item, asset, depends, callback) {
              // Predefine content for dependencies usage
              item.content = asset;
              var dependKeys = item.dependKeys;
              pipeline.flowInDeps(item, depends, function (errors, items) {
                var item;
                var itemsMap = items.map;

                for (var src in itemsMap) {
                  item = itemsMap[src];

                  if (item.uuid && item.content) {
                    item.content._uuid = item.uuid;
                  }
                }

                for (var i = 0; i < depends.length; i++) {
                  // @ts-ignore
                  var loadCallback = function loadCallback(item) {
                    var value = item.content; // @ts-ignore

                    if (this._stillUseUrl) {
                      value = value ? value.nativeUrl : item.rawUrl;
                    } // @ts-ignore


                    this._owner[this._ownerProp] = value;

                    if (item.uuid !== asset._uuid && dependKeys.indexOf(item.id) < 0) {
                      dependKeys.push(item.id);
                    }
                  };

                  var dep = depends[i];
                  var dependSrc = dep.uuid;
                  var dependUrl = dep.url;
                  var dependObj = dep._owner;
                  var dependProp = dep._ownerProp;
                  item = itemsMap[dependUrl];

                  if (!item) {
                    continue;
                  }

                  var loadCallbackCtx = dep;

                  if (item.complete || item.content) {
                    if (item.error) {
                      {
                        legacyCC._throw(item.error);
                      }
                    } else {
                      loadCallback.call(loadCallbackCtx, item);
                    }
                  } else {
                    // item was removed from cache, but ready in pipeline actually
                    var queue = LoadingItems.getQueue(item);

                    if (queue) {
                      queue.addListener(dependSrc, loadCallback, loadCallbackCtx);
                    }
                  }
                }

                if (asset instanceof legacyCC.SceneAsset && asset.scene) {
                  (function () {
                    var map = Object.create(null);

                    for (var _i = 0, l = dependKeys.length; _i < l; _i++) {
                      map[dependKeys[_i]] = true;
                      getDependsRecursively(dependKeys[_i]).forEach(function (x) {
                        map[x] = true;
                      });
                    }

                    asset.scene.dependAssets = Object.keys(map);
                  })();
                } // Emit dependency errors in runtime, but not in editor,
                // because editor need to open the scene / prefab to let user fix missing asset issues


                {
                  callback(errors, asset);
                }
              });
            } // can deferred load raw assets in runtime


            function canDeferredLoad(asset, item, isScene) {

              var res = item.deferredLoadRaw;

              if (res) {
                // check if asset support deferred
                if (asset instanceof legacyCC.Asset && asset.constructor.preventDeferredLoadDependents) {
                  res = false;
                }
              } else if (isScene) {
                if (asset instanceof legacyCC.SceneAsset || asset instanceof legacyCC.Prefab) {
                  res = asset.asyncLoadAssets; //if (res) {
                  //    cc.log('deferred load raw assets for ' + item.id);
                  //}
                }
              }

              return res;
            }
            function loadUuid(item, callback) {

              var json;

              if (typeof item.content === 'string') {
                try {
                  json = JSON.parse(item.content);

                  if (!DEBUG && json.keys && json.data) {
                    var keys = json.keys;
                    json = json.data;
                    decompressJson(json, keys);
                  }
                } catch (e) {
                  return new Error(getError(4923, item.id, e.stack));
                }
              } else if (_typeof(item.content) === 'object') {
                json = item.content;
              } else {
                return new Error(getError(4924));
              }

              if (json === undefined || json === null) {
                return new Error(getError(4923, item.id));
              }

              var classFinder;
              var isScene = isSceneObj(json);

              if (isScene) {
                {
                  classFinder = legacyCC._MissingScript.safeFindClass;
                }
              } else {
                classFinder = function classFinder(id) {
                  var cls = _getClassById(id);

                  if (cls) {
                    return cls;
                  }

                  warnID(4903, id);
                  return Object;
                };
              }

              var tdInfo = legacyCC.deserialize.Details.pool.get();
              var asset;

              try {
                asset = legacyCC.deserialize(json, tdInfo, {
                  classFinder: classFinder,
                  target: item.existingAsset,
                  customEnv: item
                });
              } catch (e) {
                legacyCC.deserialize.Details.pool.put(tdInfo);
                console.error(e);
                return new Error("Failed to load asset ".concat(item.id, ", exception occurs during deserialization: ").concat( e.stack, ".")); // return new Error(debug.getError(4925, item.id, err));
              }

              asset._uuid = item.uuid;

              var deferredLoad = canDeferredLoad(asset, item, isScene);
              var depends = parseDepends$1(item, asset, tdInfo, deferredLoad);
              legacyCC.deserialize.Details.pool.put(tdInfo);

              var wrappedCallback = function wrappedCallback(err, asset) {
                if (!err && asset.onLoaded) {
                  try {
                    asset.onLoaded();
                  } catch (error) {
                    err = error;
                  }
                }

                callback(err, asset);
              };

              if (depends.length === 0) {
                return wrappedCallback(null, asset);
              } // @ts-ignore


              loadDepends(this.pipeline, item, asset, depends, wrappedCallback);
            }
            loadUuid.isSceneObj = isSceneObj;

            /*
             Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

             http://www.cocos.com

             Permission is hereby granted, free of charge, to any person obtaining a copy
             of this software and associated engine source code (the "Software"), a limited,
              worldwide, royalty-free, non-assignable, revocable and non-exclusive license
             to use Cocos Creator solely to develop games on your target platforms. You shall
              not use Cocos Creator software for developing other software or tools that's
              used for developing games. You are not granted to publish, distribute,
              sublicense, and/or sell copies of Cocos Creator.

             The software or tools in this License Agreement are licensed, not sold.
             Xiamen Yaji Software Co., Ltd. reserves all rights not expressly granted to you.

             THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
             THE SOFTWARE.
             */
            var _canvasContext = null; // letter symbol number CJK

            var _testString = "BES bswy:->@123\u4E01\u3041\u1101";
            var _fontFaces = {};

            var _intervalId = -1;

            var _loadingFonts = []; // 3 seconds timeout

            var _timeout = 3000;

            var useNativeCheck = function () {
              var nativeCheck;
              return function () {
                if (!nativeCheck) {
                  if (!!window.FontFace) {
                    var match = /Gecko.*Firefox\/(\d+)/.exec(window.navigator.userAgent);
                    var safari10Match = /OS X.*Version\/10\..*Safari/.exec(window.navigator.userAgent) && /Apple/.exec(window.navigator.vendor);

                    if (match) {
                      nativeCheck = parseInt(match[1], 10) > 42;
                    } else if (safari10Match) {
                      nativeCheck = false;
                    } else {
                      nativeCheck = true;
                    }
                  } else {
                    nativeCheck = false;
                  }
                }

                return nativeCheck;
              };
            }();

            function nativeCheckFontLoaded(start, font, callback) {
              var loader = new Promise(function (resolve, reject) {
                var check = function check() {
                  var now = Date.now();

                  if (now - start >= _timeout) {
                    reject();
                  } else {
                    // @ts-ignore
                    document.fonts.load("40px " + font).then(function (fonts) {
                      if (fonts.length >= 1) {
                        resolve();
                      } else {
                        setTimeout(check, 100);
                      }
                    }, function () {
                      reject();
                    });
                  }
                };

                check();
              });
              var timeoutId;
              var timer = new Promise(function (resolve, reject) {
                timeoutId = setTimeout(reject, _timeout);
              });
              Promise.race([timer, loader]).then(function () {
                if (timeoutId) {
                  clearTimeout(timeoutId);
                  timeoutId = null;
                }

                callback(null, font);
              }, function () {
                warnID(4933, font);
                callback(null, font);
              });
            }

            function _checkFontLoaded() {
              var allFontsLoaded = true;
              var now = Date.now();

              for (var i = _loadingFonts.length - 1; i >= 0; i--) {
                var fontLoadHandle = _loadingFonts[i];
                var fontFamily = fontLoadHandle.fontFamilyName; // load timeout

                if (now - fontLoadHandle.startTime > _timeout) {
                  warnID(4933, fontFamily);
                  fontLoadHandle.callback(null, fontFamily);

                  _loadingFonts.splice(i, 1);

                  continue;
                }

                var oldWidth = fontLoadHandle.refWidth; // @ts-ignore

                _canvasContext.font = "40px " + fontFamily; // @ts-ignore

                var newWidth = safeMeasureText(_canvasContext, _testString); // loaded successfully

                if (oldWidth !== newWidth) {
                  _loadingFonts.splice(i, 1);

                  fontLoadHandle.callback(null, fontFamily);
                } else {
                  allFontsLoaded = false;
                }
              }

              if (allFontsLoaded) {
                clearInterval(_intervalId);
                _intervalId = -1;
              }
            }

            function loadFont(item, callback) {
              var url = item.url;

              var fontFamilyName = _getFontFamily(url); // Already loaded fonts


              if (_fontFaces[fontFamilyName]) {
                return fontFamilyName;
              }

              if (!_canvasContext) {
                var labelCanvas = document.createElement("canvas");
                labelCanvas.width = 100;
                labelCanvas.height = 100;
                _canvasContext = labelCanvas.getContext("2d");
              } // Default width reference to test whether new font is loaded correctly


              var fontDesc = "40px " + fontFamilyName; // @ts-ignore

              _canvasContext.font = fontDesc; // @ts-ignore

              var refWidth = safeMeasureText(_canvasContext, _testString); // Setup font face style

              var fontStyle = document.createElement("style");
              fontStyle.type = "text/css";
              var fontStr = "";
              if (isNaN(fontFamilyName - 0)) fontStr += "@font-face { font-family:" + fontFamilyName + "; src:";else fontStr += "@font-face { font-family:'" + fontFamilyName + "'; src:";
              fontStr += "url('" + url + "');";
              fontStyle.textContent = fontStr + "}";
              document.body.appendChild(fontStyle); // Preload font with div

              var preloadDiv = document.createElement("div");
              var divStyle = preloadDiv.style;
              divStyle.fontFamily = fontFamilyName;
              preloadDiv.innerHTML = ".";
              divStyle.position = "absolute";
              divStyle.left = "-100px";
              divStyle.top = "-100px";
              document.body.appendChild(preloadDiv);

              if (useNativeCheck()) {
                nativeCheckFontLoaded(Date.now(), fontFamilyName, callback);
              } else {
                // Save loading font
                var fontLoadHandle = {
                  fontFamilyName: fontFamilyName,
                  refWidth: refWidth,
                  callback: callback,
                  startTime: Date.now()
                };

                _loadingFonts.push(fontLoadHandle);

                if (_intervalId === -1) {
                  _intervalId = setInterval(_checkFontLoaded, 100);
                }
              }

              _fontFaces[fontFamilyName] = fontStyle;
            }
            function _getFontFamily(fontHandle) {
              var ttfIndex = fontHandle.lastIndexOf(".ttf");
              if (ttfIndex === -1) return fontHandle;
              var slashPos = fontHandle.lastIndexOf("/");
              var fontFamilyName;

              if (slashPos === -1) {
                fontFamilyName = fontHandle.substring(0, ttfIndex) + "_LABEL";
              } else {
                fontFamilyName = fontHandle.substring(slashPos + 1, ttfIndex) + "_LABEL";
              }

              if (fontFamilyName.indexOf(" ") !== -1) {
                fontFamilyName = '"' + fontFamilyName + '"';
              }

              return fontFamilyName;
            }

            function loadNothing() {
              return null;
            }

            function loadJSON(item) {
              if (typeof item.content !== 'string') {
                return new Error('JSON Loader: Input item doesn\'t contain string content');
              }

              try {
                var result = JSON.parse(item.content);
                return result;
              } catch (e) {
                return new Error('JSON Loader: Parse json [' + item.id + '] failed : ' + e);
              }
            }

            function loadImage(item) {
              var loadByDeserializedAsset = item._owner instanceof legacyCC.Asset;

              if (loadByDeserializedAsset) {
                // already has cc.Asset
                return null;
              }

              var image = item.content;

              if (legacyCC.sys.platform !== legacyCC.sys.FB_PLAYABLE_ADS && !(image instanceof Image)) {
                return new Error('Image Loader: Input item doesn\'t contain Image content');
              } // load cc.ImageAsset


              var rawUrl = item.rawUrl;
              var imageAsset = item.imageAsset || new ImageAsset();
              imageAsset._uuid = item.uuid;
              imageAsset._url = rawUrl;

              imageAsset._setRawAsset(rawUrl, false);

              imageAsset._nativeAsset = image;
              return imageAsset;
            } // If audio is loaded by url directly, than this loader will wrap it into a new cc.AudioClip object.
            // If audio is loaded by deserialized AudioClip, than this loader will be skipped.


            function loadAudioAsAsset(item, callback) {
              var loadByDeserializedAsset = item._owner instanceof legacyCC.Asset;

              if (loadByDeserializedAsset) {
                // already has cc.Asset
                return null;
              }

              var audioClip = new legacyCC.AudioClip();

              audioClip._setRawAsset(item.rawUrl, false);

              audioClip._nativeAsset = item.content;
              return audioClip;
            }

            function loadPlist(item) {
              if (typeof item.content !== 'string') {
                return new Error('Plist Loader: Input item doesn\'t contain string content');
              }

              var result = plistParser.parse(item.content);

              if (result) {
                return result;
              } else {
                return new Error('Plist Loader: Parse [' + item.id + '] failed');
              }
            }

            function loadBinary(item) {
              // Invoke custom handle
              if (item.load) {
                return item.load(item.content);
              } else {
                return item.content;
              }
            } //===============//
            // PVR constants //
            //===============//
            // https://github.com/toji/texture-tester/blob/master/js/webgl-texture-util.js#L424


            var PVR_HEADER_LENGTH = 13; // The header length in 32 bit ints.

            var PVR_MAGIC = 0x03525650; //0x50565203;
            // Offsets into the header array.

            var PVR_HEADER_MAGIC = 0;
            var PVR_HEADER_HEIGHT = 6;
            var PVR_HEADER_WIDTH = 7;
            var PVR_HEADER_METADATA = 12;

            function loadPVRTex(item) {
              var buffer = item.content instanceof ArrayBuffer ? item.content : item.content.buffer; // Get a view of the arrayBuffer that represents the DDS header.

              var header = new Int32Array(buffer, 0, PVR_HEADER_LENGTH); // Do some sanity checks to make sure this is a valid DDS file.

              if (header[PVR_HEADER_MAGIC] === PVR_MAGIC) {
                // Gather other basic metrics and a view of the raw the DXT data.
                var width = header[PVR_HEADER_WIDTH];
                var height = header[PVR_HEADER_HEIGHT];
                var dataOffset = header[PVR_HEADER_METADATA] + 52; // todo: use new Uint8Array(buffer, dataOffset) instead

                buffer = buffer.slice(dataOffset, buffer.byteLength);
                var pvrtcData = new Uint8Array(buffer);
                var pvrAsset = {
                  _data: pvrtcData,
                  _compressed: true,
                  width: width,
                  height: height
                };
                return pvrAsset;
              } else if (header[11] === 0x21525650) {
                var headerLength = header[0],
                    _height = header[1],
                    _width = header[2]; // todo: use new Uint8Array(buffer, headerLength) instead

                buffer = buffer.slice(headerLength, buffer.byteLength);

                var _pvrtcData = new Uint8Array(buffer);

                var _pvrAsset = {
                  _data: _pvrtcData,
                  _compressed: true,
                  width: _width,
                  height: _height
                };
                return _pvrAsset;
              } else {
                return new Error("Invalid magic number in PVR header");
              }
            } //===============//
            // ETC constants //
            //===============//


            var ETC_PKM_HEADER_SIZE = 16;
            var ETC_PKM_FORMAT_OFFSET = 6;
            var ETC_PKM_ENCODED_WIDTH_OFFSET = 8;
            var ETC_PKM_ENCODED_HEIGHT_OFFSET = 10;
            var ETC_PKM_WIDTH_OFFSET = 12;
            var ETC_PKM_HEIGHT_OFFSET = 14;
            var ETC1_RGB_NO_MIPMAPS = 0;
            var ETC2_RGB_NO_MIPMAPS = 1;
            var ETC2_RGBA_NO_MIPMAPS = 3;

            function readBEUint16(header, offset) {
              return header[offset] << 8 | header[offset + 1];
            }

            function loadPKMTex(item) {
              var buffer = item.content instanceof ArrayBuffer ? item.content : item.content.buffer;
              var header = new Uint8Array(buffer);
              var format = readBEUint16(header, ETC_PKM_FORMAT_OFFSET);

              if (format !== ETC1_RGB_NO_MIPMAPS && format !== ETC2_RGB_NO_MIPMAPS && format !== ETC2_RGBA_NO_MIPMAPS) {
                return new Error("Invalid magic number in ETC header");
              }

              var width = readBEUint16(header, ETC_PKM_WIDTH_OFFSET);
              var height = readBEUint16(header, ETC_PKM_HEIGHT_OFFSET);
              var encodedWidth = readBEUint16(header, ETC_PKM_ENCODED_WIDTH_OFFSET);
              var encodedHeight = readBEUint16(header, ETC_PKM_ENCODED_HEIGHT_OFFSET); // todo: use new Uint8Array(buffer, ETC_PKM_HEADER_SIZE) instead

              buffer = buffer.slice(ETC_PKM_HEADER_SIZE, buffer.byteLength);
              var etcData = new Uint8Array(buffer);
              var etcAsset = {
                _data: etcData,
                _compressed: true,
                width: width,
                height: height
              };
              return etcAsset;
            } //===============//
            // ASTC constants //
            //===============//
            // struct astc_header
            // {
            // 	uint8_t magic[4];
            // 	uint8_t blockdim_x;
            // 	uint8_t blockdim_y;
            // 	uint8_t blockdim_z;
            // 	uint8_t xsize[3];			// x-size = xsize[0] + xsize[1] + xsize[2]
            // 	uint8_t ysize[3];			// x-size, y-size and z-size are given in texels;
            // 	uint8_t zsize[3];			// block count is inferred
            // };


            var ASTC_MAGIC = 0x5CA1AB13;
            var ASTC_HEADER_LENGTH = 16; // The header length

            var ASTC_HEADER_MAGIC = 4;
            var ASTC_HEADER_SIZE_X_BEGIN = 7;
            var ASTC_HEADER_SIZE_Y_BEGIN = 10;

            function loadASTCTex(item) {
              var buffer = item.content instanceof ArrayBuffer ? item.content : item.content.buffer;
              var header = new Uint8Array(buffer);
              var magicval = header[0] + (header[1] << 8) + (header[2] << 16) + (header[3] << 24);

              if (magicval !== ASTC_MAGIC) {
                return new Error('Invalid magic number in ASTC header');
              }

              var xdim = header[ASTC_HEADER_MAGIC];
              var ydim = header[ASTC_HEADER_MAGIC + 1];
              var zdim = header[ASTC_HEADER_MAGIC + 2];

              if ((xdim < 3 || xdim > 6 || ydim < 3 || ydim > 6 || zdim < 3 || zdim > 6) && (xdim < 4 || xdim === 7 || xdim === 9 || xdim === 11 || xdim > 12 || ydim < 4 || ydim === 7 || ydim === 9 || ydim === 11 || ydim > 12 || zdim !== 1)) {
                return new Error('Invalid block number in ASTC header');
              }

              var format = getASTCFormat(xdim, ydim);
              var xsize = header[ASTC_HEADER_SIZE_X_BEGIN] + (header[ASTC_HEADER_SIZE_X_BEGIN + 1] << 8) + (header[ASTC_HEADER_SIZE_X_BEGIN + 2] << 16);
              var ysize = header[ASTC_HEADER_SIZE_Y_BEGIN] + (header[ASTC_HEADER_SIZE_Y_BEGIN + 1] << 8) + (header[ASTC_HEADER_SIZE_Y_BEGIN + 2] << 16);
              buffer = buffer.slice(ASTC_HEADER_LENGTH, buffer.byteLength);
              var astcData = new Uint8Array(buffer);
              var astcAsset = {
                _data: astcData,
                _compressed: true,
                width: xsize,
                height: ysize,
                format: format
              };
              return astcAsset;
            }

            function getASTCFormat(xdim, ydim) {
              if (xdim === 4) {
                return PixelFormat.RGBA_ASTC_4x4;
              } else if (xdim === 5) {
                if (ydim === 4) {
                  return PixelFormat.RGBA_ASTC_5x4;
                } else {
                  return PixelFormat.RGBA_ASTC_5x5;
                }
              } else if (xdim === 6) {
                if (ydim === 5) {
                  return PixelFormat.RGBA_ASTC_6x5;
                } else {
                  return PixelFormat.RGBA_ASTC_6x6;
                }
              } else if (xdim === 8) {
                if (ydim === 5) {
                  return PixelFormat.RGBA_ASTC_8x5;
                } else if (ydim === 6) {
                  return PixelFormat.RGBA_ASTC_8x6;
                } else {
                  return PixelFormat.RGBA_ASTC_8x8;
                }
              } else if (xdim === 10) {
                if (ydim === 5) {
                  return PixelFormat.RGBA_ASTC_10x5;
                } else if (ydim === 6) {
                  return PixelFormat.RGBA_ASTC_10x6;
                } else if (ydim === 8) {
                  return PixelFormat.RGBA_ASTC_10x8;
                } else {
                  return PixelFormat.RGBA_ASTC_10x10;
                }
              } else {
                if (ydim === 10) {
                  return PixelFormat.RGBA_ASTC_12x10;
                } else {
                  return PixelFormat.RGBA_ASTC_12x12;
                }
              }
            }

            var defaultMap$1 = {
              // Images
              'png': loadImage,
              'jpg': loadImage,
              'bmp': loadImage,
              'jpeg': loadImage,
              'gif': loadImage,
              'ico': loadImage,
              'tiff': loadImage,
              'webp': loadImage,
              'image': loadImage,
              'pvr': loadPVRTex,
              'pkm': loadPKMTex,
              'astc': loadASTCTex,
              // Audio
              'mp3': loadAudioAsAsset,
              'ogg': loadAudioAsAsset,
              'wav': loadAudioAsAsset,
              'm4a': loadAudioAsAsset,
              // json
              'json': loadJSON,
              'ExportJson': loadJSON,
              // plist
              'plist': loadPlist,
              // asset
              'uuid': loadUuid,
              'prefab': loadUuid,
              'fire': loadUuid,
              'scene': loadUuid,
              // binary
              'binary': loadBinary,
              'bin': loadBinary,
              // Font
              'font': loadFont,
              'eot': loadFont,
              'ttf': loadFont,
              'woff': loadFont,
              'svg': loadFont,
              'ttc': loadFont,
              'default': loadNothing
            };
            var ID$4 = 'Loader';
            /**
             * @en The loader pipe in {{loader}}, it can load several types of files:
             * 1. Images
             * 2. JSON
             * 3. Plist
             * 4. Audio
             * 5. Font
             * 6. Binary
             * 7. Cocos Assets
             * It will not interfere with items of unknown type.
             * You can pass custom supported types in the {{loader.addLoadHandlers}}.
             * @zh {{loader}} 中的解析加载管线，可以解析加载下列类型的资源：
             * 1. Images
             * 2. JSON
             * 3. Plist
             * 4. Audio
             * 5. Font
             * 6. Binary
             * 7. Cocos Assets
             * 所有未知类型不会被处理，也可以通过 {{loader.addLoadHandlers}} 来定制加载行为
             */

            var Loader = exports('cR', /*#__PURE__*/function () {
              function Loader(extMap) {
                _classCallCheck(this, Loader);

                this.id = ID$4;
                this.async = true;
                this.pipeline = null;
                this.extMap = void 0;
                this.extMap = mixin(extMap, defaultMap$1);
              }
              /**
               * @en Add custom supported types handler or modify existing type handler.
               * @zh 添加自定义支持的类型处理程序或修改现有的类型处理程序。
               * @param extMap Custom supported types with corresponded handler
               * @param extMap Custom supported types with corresponded handler
               */


              _createClass(Loader, [{
                key: "addHandlers",
                value: function addHandlers(extMap) {
                  this.extMap = mixin(this.extMap, extMap);
                }
              }, {
                key: "handle",
                value: function handle(item, callback) {
                  var loadFunc = this.extMap[item.type] || this.extMap['default'];
                  return loadFunc.call(this, item, callback);
                }
              }]);

              return Loader;
            }()); // @ts-ignore


            Loader.ID = ID$4;
            Pipeline.Loader = Loader;

            var _tmpInfo = null;

            function getItemDesc(item) {
              if (item.uuid) {
                if (!_tmpInfo) {
                  _tmpInfo = {
                    path: "",
                    type: null
                  };
                }

                if (legacyCC.loader._assetTables.assets._getInfo_DEBUG(item.uuid, _tmpInfo)) {
                  _tmpInfo.path = 'resources/' + _tmpInfo.path;
                  return "\"".concat(_tmpInfo.path, "\" (type: ").concat(getClassName(_tmpInfo.type), ", uuid: ").concat(item.uuid, ")");
                } else {
                  return "\"".concat(item.rawUrl, "\" (").concat(item.uuid, ")");
                }
              } else {
                return "\"".concat(item.rawUrl, "\"");
              }
            }

            function doCheckCouldRelease(releasedKey, refOwnerItem, caches) {
              var loadedAgain = caches[releasedKey];

              if (!loadedAgain) {
                log("\"".concat(releasedKey, "\" was released but maybe still referenced by ").concat(getItemDesc(refOwnerItem)));
              }
            } // checks if asset was releasable


            var ReleasedAssetChecker = /*#__PURE__*/function () {
              function ReleasedAssetChecker() {
                _classCallCheck(this, ReleasedAssetChecker);

                this._releasedKeys = void 0;
                this._dirty = void 0;
                // { dependKey: true }
                this._releasedKeys = createMap(true);
                this._dirty = false;
              } // mark as released for further checking dependencies


              _createClass(ReleasedAssetChecker, [{
                key: "setReleased",
                value: function setReleased(item, releasedKey) {
                  this._releasedKeys[releasedKey] = true;
                  this._dirty = true;
                } // check dependencies

              }, {
                key: "checkCouldRelease",
                value: function checkCouldRelease(caches) {
                  if (!this._dirty) {
                    return;
                  }

                  this._dirty = false;
                  var released = this._releasedKeys; // check loader cache

                  for (var id in caches) {
                    var item = caches[id];

                    if (item.alias) {
                      item = item.alias;
                    }

                    var depends = item.dependKeys;

                    if (depends) {
                      for (var i = 0; i < depends.length; ++i) {
                        var depend = depends[i];

                        if (released[depend]) {
                          doCheckCouldRelease(depend, item, caches);
                          delete released[depend];
                        }
                      }
                    }
                  } // // check current scene
                  // let depends = director.getScene().dependAssets;
                  // for (let i = 0; i < depends.length; ++i) {
                  //     let depend = depends[i];
                  //     if (released[depend]) {
                  //         doCheckCouldRelease(depend, item, caches);
                  //         delete released[depend];
                  //     }
                  // }
                  // clear released


                  clear(released);
                }
              }]);

              return ReleasedAssetChecker;
            }();

            var assetTables = Object.create(null);
            assetTables.assets = new AssetTable();
            assetTables.internal = new AssetTable();

            function getXMLHttpRequest() {
              return window.XMLHttpRequest ? new window.XMLHttpRequest() : new ActiveXObject('MSXML2.XMLHTTP');
            }

            var _info = {
              url: null,
              raw: false
            };
            /*
             * @en Convert a resources by finding its real url with uuid, otherwise we will use the uuid or raw url as its url<br>
             * So we gurantee there will be url in result
             * @zh 通过使用 uuid 查找资源的真实 url 来转换资源，否则将使用 uuid 或原始 url 作为其 url<br>
             * 所以可以保证结果中会有 url
             * @param res
             */

            function getResWithUrl(res) {
              var id;
              var result;
              var isUuid;

              if (_typeof(res) === 'object') {
                result = res;

                if (res.url) {
                  return result;
                } else {
                  id = res.uuid;
                }
              } else {
                result = {};
                id = res;
              }

              isUuid = result.type ? result.type === 'uuid' : legacyCC.AssetLibrary._uuidInSettings(id);

              legacyCC.AssetLibrary._getAssetInfoInRuntime(id, _info);

              result.url = !isUuid ? id : _info.url;

              if (_info.url && result.type === 'uuid' && _info.raw) {
                result.type = null;
                result.isRawAsset = true;
              } else if (!isUuid) {
                result.isRawAsset = true;
              }

              return result;
            }

            var _sharedResources = [];
            var _sharedList = [];
            /**
             * @en Loader for resource loading process. The engine automatically initialize its singleton object {{loader}}.
             * @zh 资源加载管理器，引擎会自动创建一个单例对象 {{loader}}。
             */

            var CCLoader = /*#__PURE__*/function (_Pipeline) {
              _inherits(CCLoader, _Pipeline);

              /**
               * @en Gets a new XMLHttpRequest instance.
               * @zh 获取一个新的 XMLHttpRequest 的实例。
               */

              /**
               * @en The asset loader in loader's pipeline, it's by default the first pipe.<br>
               * It's used to identify an asset's type, and determine how to download it.
               * @zh loader 中的资源加载器，默认情况下是最先加载的。<br>
               * 用于标识资源的类型，并确定如何加载此资源。
               */

              /**
               * @en The md5 pipe in loader's pipeline, it could be absent if the project isn't build with md5 option.<br>
               * It's used to modify the url to the real downloadable url with md5 suffix.
               * @zh loader 中的 md5 加载管道，如果项目没有使用 md5 构建，则此项可能不存在。<br>
               * 用于修改带有 md5 后缀的真实可下载的 URL 。
               */

              /**
               * @en
               * The downloader in loader's pipeline, it's by default the second pipe.<br>
               * It's used to download files with several handlers: pure text, image, script, audio, font, uuid.<br>
               * You can add your own download function with addDownloadHandlers
               * @zh
               * loader 中的资源下载程序，默认情况下是第二个加载的。<br>
               * 它用于下载带有多个处理程序的文件：纯文本，图像，脚本，音频，字体，uuid。<br>
               * 您可以使用 addDownloadHandlers 来添加自己的下载函数
               */

              /**
               * @en
               * The loader in loader's pipeline, it's by default the third pipe.<br>
               * It's used to parse downloaded content with several handlers: JSON, image, plist, fnt, uuid.<br>
               * You can add your own download function with addLoadHandlers
               * @zh
               * loader 中的资源下载程序，默认情况下是第三个加载的。<br>
               * 它用于解析下载的内容及多个处理程序的文件：纯文本，图像，脚本，音频，字体，uuid。<br>
               * 您可以使用 addLoadHandlers 来添加自己的下载函数
               */

              /**
               * @en The default progression callback during the loading process, 
               * if no progression callback is passed to {{load}} function, then this default callback will be used.
               * @zh Loader 默认的进度回调函数，如果在调用 {{load}} 函数时没有指定进度回调函数的话，会调用默认进度回调函数。
               */
              function CCLoader() {
                var _this;

                _classCallCheck(this, CCLoader);

                var assetLoader = new AssetLoader();
                var downloader = new Downloader(); // tslint:disable-next-line: no-shadowed-letiable

                var loader = new Loader();
                _this = _possibleConstructorReturn(this, _getPrototypeOf(CCLoader).call(this, [assetLoader, downloader, loader]));
                _this.getXMLHttpRequest = void 0;
                _this.assetLoader = void 0;
                _this.md5Pipe = void 0;
                _this.downloader = void 0;
                _this.loader = void 0;
                _this.onProgress = void 0;
                _this._assetTables = void 0;
                _this._autoReleaseSetting = void 0;
                _this._releasedAssetChecker_DEBUG = void 0;
                _this.getXMLHttpRequest = getXMLHttpRequest;
                _this.assetLoader = assetLoader;
                _this.md5Pipe = null;
                _this.downloader = downloader;
                _this.loader = loader;
                _this.onProgress = null;
                _this._assetTables = assetTables; // assets to release automatically

                _this._autoReleaseSetting = createMap(true);

                {
                  _this._releasedAssetChecker_DEBUG = new ReleasedAssetChecker();
                }

                return _this;
              }
              /**
               * @en Initialize with director
               * @zh 使用 {{director}} 初始化
               * @param director The director instance of engine
               */


              _createClass(CCLoader, [{
                key: "init",
                value: function init(director) {
                  {
                    var self = this;
                    director.on(legacyCC.Director.EVENT_AFTER_UPDATE, function () {
                      self._releasedAssetChecker_DEBUG.checkCouldRelease(self._cache);
                    });
                  }
                }
                /**
                 * @en Add custom supported types handler or modify existing type handler for download process.
                 * @zh 为下载程序添加自定义支持的类型处理程序或修改现有的类型处理程序。
                 * @example
                 * ```ts
                 *  loader.addDownloadHandlers({
                 *      // This will match all url with `.scene` extension or all url with `scene` type
                 *      'scene' : function (url, callback) {}
                 *  });
                 * ```
                 * @param extMap Handlers for corresponding type in a map
                 */

              }, {
                key: "addDownloadHandlers",
                value: function addDownloadHandlers(extMap) {
                  this.downloader.addHandlers(extMap);
                }
                /**
                 * @en Add custom supported types handler or modify existing type handler for load process.
                 * @zh 为加载程序添加自定义支持的类型处理程序或修改现有的类型处理程序。
                 * @example
                 * ```ts
                 *  loader.addLoadHandlers({
                 *      // This will match all url with `.scene` extension or all url with `scene` type
                 *      'scene' : function (url, callback) {}
                 *  });
                 * ```
                 * @param extMap Handlers for corresponding type in a map
                 */

              }, {
                key: "addLoadHandlers",
                value: function addLoadHandlers(extMap) {
                  this.loader.addHandlers(extMap);
                } // tslint:disable: max-line-length

                /**
                 * @en
                 * Load resources with a progression callback and a complete callback.<br>
                 * The progression callback is the same as Pipeline's [[LoadingItems.onProgress]] <br>
                 * The complete callback is almost the same as Pipeline's [[LoadingItems.onComplete]] <br>
                 * The only difference is when user pass a single url as resources, the complete callback will set its result directly as the second parameter.
                 * @zh
                 * 使用进度回调和完整回调加载资源。<br>
                 * 进度回调与 Pipeline 的 [[LoadingItems.onProgress]] 相同<br>
                 * 完整的回调与 Pipeline 的 [[LoadingItems.onComplete]] 几乎相同<br>
                 * 唯一的区别是当用户将单个 URL 作为资源传递时，完整的回调将其结果直接设置为第二个参数。
                 * @example
                 * ```TypeScript
                 * import { loader, log, Texture2D } from 'cc';
                 * loader.load('a.png', function (err, tex) {
                 *     log('Result should be a texture: ' + (tex instanceof Texture2D));
                 * });
                 *
                 * loader.load('http://example.com/a.png', function (err, tex) {
                 *     log('Should load a texture from external url: ' + (tex instanceof Texture2D));
                 * });
                 *
                 * loader.load({url: 'http://example.com/getImageREST?file=a.png', type: 'png'}, function (err, tex) {
                 *     log('Should load a texture from RESTful API by specify the type: ' + (tex instanceof Texture2D));
                 * });
                 *
                 * loader.load(['a.png', 'b.json'], function (errors, results) {
                 *     if (errors) {
                 *         for (let i = 0; i < errors.length; i++) {
                 *             log('Error url [' + errors[i] + ']: ' + results.getError(errors[i]));
                 *         }
                 *     }
                 *     let aTex = results.getContent('a.png');
                 *     let bJsonObj = results.getContent('b.json');
                 * });
                 * ```
                 * @param resources - Url list or load request list
                 * @param progressCallback - Progression callback
                 * @param {Number} progressCallback.completedCount - The number of the items that are already completed
                 * @param {Number} progressCallback.totalCount - The total number of the items
                 * @param {Object} progressCallback.item - The latest item which flow out the pipeline
                 * @param completeCallback - Completion callback
                 */

              }, {
                key: "load",
                value: function load(resources, progressCallback, completeCallback) {

                  if (completeCallback === undefined) {
                    completeCallback = progressCallback;
                    progressCallback = this.onProgress || null;
                  }

                  var self = this;
                  var singleRes = false;
                  var resList;
                  var res;

                  if (resources instanceof Array) {
                    resList = resources;
                  } else {
                    if (resources) {
                      singleRes = true;
                      resList = [resources];
                    } else {
                      resList = [];
                    }
                  }

                  _sharedResources.length = 0; // tslint:disable-next-line: prefer-for-of

                  for (var i = 0; i < resList.length; ++i) {
                    var resource = resList[i]; // Backward compatibility

                    if (resource && resource.id) {
                      warnID(4920, resource.id);

                      if (!resource.uuid && !resource.url) {
                        resource.url = resource.id;
                      }
                    }

                    res = getResWithUrl(resource);

                    if (!res.url && !res.uuid) {
                      continue;
                    }

                    var item = this._cache[res.url];

                    _sharedResources.push(item || res);
                  }

                  var queue = LoadingItems.create(this, progressCallback, function (errors, items) {
                    callInNextTick(function () {
                      if (completeCallback) {
                        if (singleRes) {
                          var id = res.url;
                          completeCallback.call(self, items.getError(id), items.getContent(id));
                        } else {
                          completeCallback.call(self, errors, items);
                        }

                        completeCallback = null;
                      }

                      items.destroy();
                    });
                  });
                  LoadingItems.initQueueDeps(queue);
                  queue.append(_sharedResources);
                  _sharedResources.length = 0;
                }
                /**
                 * @en See: {{Pipeline.flowInDeps}}
                 * @zh 参考：{{Pipeline.flowInDeps}}
                 */

              }, {
                key: "flowInDeps",
                value: function flowInDeps(owner, urlList, callback) {
                  _sharedList.length = 0; // tslint:disable-next-line: prefer-for-of

                  for (var i = 0; i < urlList.length; ++i) {
                    var res = getResWithUrl(urlList[i]);

                    if (!res.url && !res.uuid) {
                      continue;
                    }

                    var item = this._cache[res.url];

                    if (item) {
                      _sharedList.push(item);
                    } else {
                      _sharedList.push(res);
                    }
                  } // @ts-ignore


                  var queue = LoadingItems.create(this, owner ? function (completedCount, totalCount, item) {
                    // @ts-ignore
                    if (queue._ownerQueue && queue._ownerQueue.onProgress) {
                      // @ts-ignore
                      queue._ownerQueue._childOnProgress(item);
                    }
                  } : null, function (errors, items) {
                    callback(errors, items); // Clear deps because it's already done
                    // Each item will only flowInDeps once, so it's still safe here

                    if (owner && owner.deps) {
                      owner.deps.length = 0;
                    }

                    items.destroy();
                  });

                  if (owner) {
                    var ownerQueue = LoadingItems.getQueue(owner); // Set the root ownerQueue, if no ownerQueue defined in ownerQueue, it's the root

                    queue._ownerQueue = ownerQueue && ownerQueue._ownerQueue || ownerQueue;
                  }

                  var accepted = queue.append(_sharedList, owner);
                  _sharedList.length = 0;
                  return accepted;
                }
              }, {
                key: "loadRes",

                /**
                 * @en
                 * Load assets from the "resources" folder inside the "assets" folder of your project.<br>
                 * <br>
                 * Note: All asset URLs in Creator use forward slashes, URLs using backslashes will not work.
                 * @zh
                 * 从项目的 “assets” 文件夹下的 “resources” 文件夹中加载资源<br>
                 * <br>
                 * 注意：Creator 中的所有资源 URL 都使用正斜杠，使用反斜杠的 URL 将不起作用。
                 * @param url - The url of the asset to be loaded, this url should be related path without file extension to the `resources` folder.
                 * @param type - If type is provided, only asset for correspond type will be loaded
                 * @param progressCallback - Progression callback
                 * @param {Number} progressCallback.completedCount - The number of the items that are already completed.
                 * @param {Number} progressCallback.totalCount - The total number of the items.
                 * @param {Object} progressCallback.item - The latest item which flow out the pipeline.
                 * @param completeCallback - Completion callback
                 * @param {Error} completeCallback.error - The error info or null if loaded successfully.
                 * @param {Object} completeCallback.resource - The loaded resource if it can be found otherwise returns null.
                 *
                 * @example
                 * ```ts
                 * import { loader, error, log, Prefab, SpriteFrame } from 'cc';
                 * // load the prefab (project/assets/resources/misc/character/cocos) from resources folder
                 * loader.loadRes('misc/character/cocos', function (err, prefab) {
                 *     if (err) {
                 *         error(err.message || err);
                 *         return;
                 *     }
                 *     log('Result should be a prefab: ' + (prefab instanceof Prefab));
                 * });
                 *
                 * // load the sprite frame of (project/assets/resources/imgs/cocos.png) from resources folder
                 * loader.loadRes('imgs/cocos', SpriteFrame, function (err, spriteFrame) {
                 *     if (err) {
                 *         error(err.message || err);
                 *         return;
                 *     }
                 *     log('Result should be a sprite frame: ' + (spriteFrame instanceof SpriteFrame));
                 * });
                 * ```
                 */
                value: function loadRes(url, type, mount, progressCallback, completeCallback) {
                  if (arguments.length !== 5) {
                    completeCallback = progressCallback;
                    progressCallback = mount;
                    mount = 'assets';
                  }

                  var args = this._parseLoadResArgs(type, progressCallback, completeCallback);

                  type = args.type;
                  progressCallback = args.onProgress;
                  completeCallback = args.onComplete;
                  var self = this;

                  var uuid = self._getResUuid(url, type, mount, true);

                  if (uuid) {
                    this.load({
                      type: 'uuid',
                      uuid: uuid
                    }, progressCallback, function (err, asset) {
                      if (asset) {
                        // should not release these assets, even if they are static referenced in the scene.
                        self.setAutoReleaseRecursively(uuid, false);
                      }

                      if (completeCallback) {
                        completeCallback(err, asset);
                      }
                    });
                  } else {
                    self._urlNotFound(url, type, completeCallback);
                  }
                }
                /**
                 * @en
                 * Load all assets in a folder inside the "assets/resources" folder of your project.<br>
                 * <br>
                 * Note: All asset URLs in Creator use forward slashes, URLs using backslashes will not work.
                 * @zh
                 * 将所有资产加载到项目 “assets / resources” 文件夹中
                 * <br>
                 * 注意：Creator 中的所有资源 URL 都使用正斜杠，使用反斜杠的 URL 将不起作用。
                 * @param url The url of the directory to be loaded, this url should be related path to the `resources` folder.
                 * @param type - If type is provided, only assets for correspond type will be loaded
                 * @param progressCallback - Progression callback
                 * @param {Number} progressCallback.completedCount - The number of the items that are already completed.
                 * @param {Number} progressCallback.totalCount - The total number of the items.
                 * @param {Object} progressCallback.item - The latest item which flow out the pipeline.
                 * @param completeCallback - Completion callback
                 * @param {Error} completeCallback.error - If one of the asset failed, the complete callback is immediately called
                 *                                         with the error. If all assets are loaded successfully, error will be null.
                 * @param {Asset[]|Array} completeCallback.assets - An array of all loaded assets.
                 *                                             If nothing to load, assets will be an empty array.
                 * @param {string[]} completeCallback.urls - An array that lists all the URLs of loaded assets.
                 *
                 * @example
                 * ```ts
                 * import { loader, error, Texture2D } from 'cc';
                 * // load the texture (resources/imgs/cocos.png) and the corresponding sprite frame
                 * loader.loadResDir('imgs/cocos', function (err, assets) {
                 *     if (err) {
                 *         error(err);
                 *         return;
                 *     }
                 *     let texture = assets[0];
                 *     let spriteFrame = assets[1];
                 * });
                 *
                 * // load all textures in "resources/imgs/"
                 * loader.loadResDir('imgs', Texture2D, function (err, textures) {
                 *     let texture1 = textures[0];
                 *     let texture2 = textures[1];
                 * });
                 *
                 * // load all JSONs in "resources/data/"
                 * loader.loadResDir('data', function (err, objects, urls) {
                 *     let data = objects[0];
                 *     let url = urls[0];
                 * });
                 * ```
                 */

              }, {
                key: "loadResDir",
                value: function loadResDir(url, type, mount, progressCallback, completeCallback) {
                  if (arguments.length !== 5) {
                    completeCallback = progressCallback;
                    progressCallback = mount;
                    mount = 'assets';
                  }

                  if (!assetTables[mount]) {
                    return;
                  }

                  var args = this._parseLoadResArgs(type, progressCallback, completeCallback);

                  type = args.type;
                  progressCallback = args.onProgress;
                  completeCallback = args.onComplete;
                  var urls = [];
                  var uuids = assetTables[mount].getUuidArray(url, type, urls);

                  this._loadResUuids(uuids, progressCallback, function (errors, assetRes, urlRes) {
                    // The spriteFrame url in spriteAtlas will be removed after build project
                    // To show users the exact structure in asset panel, we need to return the spriteFrame assets in spriteAtlas
                    var assetResLength = assetRes.length;

                    for (var i = 0; i < assetResLength; ++i) {
                      if (assetRes[i] instanceof SpriteAtlas) {
                        var spriteFrames = assetRes[i].getSpriteFrames(); // tslint:disable: forin

                        for (var k in spriteFrames) {
                          var sf = spriteFrames[k];
                          assetRes.push(sf);

                          if (urlRes) {
                            urlRes.push("".concat(urlRes[i], "/").concat(sf.name));
                          }
                        }
                      }
                    }

                    if (completeCallback) {
                      completeCallback(errors, assetRes, urlRes);
                    }
                  }, urls);
                }
                /**
                 * @en This method is like [[loadRes]] except that it accepts array of url.
                 * @zh 此方法除了接受 URL 数组参数外，与 [[loadRes]] 方法相同。
                 *
                 * @param url The url array of assets to be loaded, this url should be related path without extension to the `resources` folder.
                 * @param type - If type is provided, only assets for correspond type will be loaded
                 * @param progressCallback - Progression callback
                 * @param {Number} progressCallback.completedCount - The number of the items that are already completed.
                 * @param {Number} progressCallback.totalCount - The total number of the items.
                 * @param {Object} progressCallback.item - The latest item which flow out the pipeline.
                 * @param completeCallback - Completion callback
                 * @param {Error} completeCallback.error - If one of the asset failed, the complete callback is immediately called
                 *                                         with the error. If all assets are loaded successfully, error will be null.
                 * @param {Asset[]|Array} completeCallback.assets - An array of all loaded assets.
                 *                                                     If nothing to load, assets will be an empty array.
                 * @example
                 * ```ts
                 * import { loader, error, SpriteFrame } from 'cc';
                 * // load the SpriteFrames from resources folder
                 * let spriteFrames;
                 * let urls = ['misc/characters/character_01', 'misc/weapons/weapons_01'];
                 * loader.loadResArray(urls, SpriteFrame, function (err, assets) {
                 *     if (err) {
                 *         error(err);
                 *         return;
                 *     }
                 *     spriteFrames = assets;
                 *     // ...
                 * });
                 * ```
                 */

              }, {
                key: "loadResArray",
                value: function loadResArray(urls, type, mount, progressCallback, completeCallback) {
                  if (arguments.length !== 5) {
                    completeCallback = progressCallback;
                    progressCallback = mount;
                    mount = 'assets';
                  }

                  var args = this._parseLoadResArgs(type, progressCallback, completeCallback);

                  type = args.type;
                  progressCallback = args.onProgress;
                  completeCallback = args.onComplete;
                  var uuids = []; // tslint:disable: prefer-for-of

                  for (var i = 0; i < urls.length; i++) {
                    var _url = urls[i];

                    var uuid = this._getResUuid(_url, type, mount, true);

                    if (uuid) {
                      uuids.push(uuid);
                    } else {
                      this._urlNotFound(_url, type, completeCallback);

                      return;
                    }
                  }

                  this._loadResUuids(uuids, progressCallback, completeCallback);
                }
                /**
                 * @en
                 * Get resource data by id. <br>
                 * When you load resources with [[load]] or [[loadRes]],
                 * the url will be the unique identity of the resource.
                 * After loaded, you can acquire them by passing the url to this API.
                 * @zh
                 * 根据 ID 获取资源数据。<br>
                 * 当使用 [[load]] 或 [[loadRes]] 来加载资源时，<br>
                 * URL 将是资源的唯一标识。<br>
                 * 在完成加载之后，你可以通过将 URL 传递给此 API 来获取它们。
                 * @param url The asset url, it should be related path without extension to the `resources` folder.
                 * @param type If type is provided, the asset for correspond type will be returned
                 */

              }, {
                key: "getRes",
                value: function getRes(url, type) {
                  var item = this._cache[url];

                  if (!item) {
                    var uuid = this._getResUuid(url, type, null, true);

                    if (uuid) {
                      var ref = this._getReferenceKey(uuid);

                      item = this._cache[ref];
                    } else {
                      return null;
                    }
                  }

                  if (item && item.alias) {
                    item = item.alias;
                  }

                  return item && item.complete ? item.content : null;
                }
                /**
                 * @en Get total resources count in loader.
                 * @zh 获取加载的总资源数量
                 */

              }, {
                key: "getResCount",
                value: function getResCount() {
                  return Object.keys(this._cache).length;
                }
                /**
                 * @en
                 * Get all resource dependencies of the requested asset in an array, including itself.<br>
                 * The owner parameter accept the following types: 1. The asset itself; 2. The resource url; 3. The asset's uuid.<br>
                 * The returned array stores the dependencies with their uuids, after retrieve dependencies,<br>
                 * you can release them, access dependent assets by passing the uuid to [[getRes]], or other stuffs you want.<br>
                 * For release all dependencies of an asset, please refer to [[release]]
                 * Here is some examples:
                 * @zh
                 * 获取一个指定资源的所有依赖资源，包含它自身，并保存在数组中返回。<br>
                 * owner 参数接收以下几种类型：1. 资源 asset 对象；2. 资源目录下的 url；3. 资源的 uuid。<br>
                 * 返回的数组将仅保存依赖资源的 uuid，获取这些 uuid 后，你可以从 loader 释放这些资源；通过 [[getRes]] 获取某个资源或者进行其他你需要的操作。<br>
                 * 想要释放一个资源及其依赖资源，可以参考 [[release]]。<br>
                 * 下面是一些示例代码：
                 * @example
                 * ```ts
                 * import { loader, Texture2D } from 'cc';
                 * // Release all dependencies of a loaded prefab
                 * let deps = loader.getDependsRecursively(prefab);
                 * loader.release(deps);
                 * // Retrieve all dependent textures
                 * let deps = loader.getDependsRecursively('prefabs/sample');
                 * let textures = [];
                 * for (let i = 0; i < deps.length; ++i) {
                 *     let item = loader.getRes(deps[i]);
                 *     if (item instanceof Texture2D) {
                 *         textures.push(item);
                 *     }
                 * }
                 * ```
                 * @param owner - The asset itself or the asset url or the asset uuid
                 */

              }, {
                key: "getDependsRecursively",
                value: function getDependsRecursively$1(owner) {
                  if (owner) {
                    var key = this._getReferenceKey(owner);

                    var assets = getDependsRecursively(key);

                    assets.push(key);
                    return assets;
                  } else {
                    return [];
                  }
                }
                /**
                 * @en
                 * Release the content of an asset or an array of assets by uuid.<br>
                 * This method will not only remove the cache of the asset in loader, but also clean up its content.<br>
                 * For example, if you release a texture, the texture asset and its gl texture data will be freed up.<br>
                 * In complexe project, you can use this function with [[getDependsRecursively]] to free up memory in critical circumstances.<br>
                 * Notice, this method may cause the texture to be unusable, if there are still other nodes use the same texture, they may turn to black and report gl errors.<br>
                 * If you only want to remove the cache of an asset, please use [[Pipeline.removeItem]]
                 * @zh
                 * 通过 id（通常是资源 url）来释放一个资源或者一个资源数组。<br>
                 * 这个方法不仅会从 loader 中删除资源的缓存引用，还会清理它的资源内容。<br>
                 * 比如说，当你释放一个 texture 资源，这个 texture 和它的 gl 贴图数据都会被释放。<br>
                 * 在复杂项目中，我们建议你结合 [[getDependsRecursively]] 来使用，便于在设备内存告急的情况下更快地释放不再需要的资源的内存。<br>
                 * 注意，这个函数可能会导致资源贴图或资源所依赖的贴图不可用，如果场景中存在节点仍然依赖同样的贴图，它们可能会变黑并报 GL 错误。<br>
                 * 如果你只想删除一个资源的缓存引用，请使用 [[Pipeline.removeItem]]
                 *
                 * @example
                 * ```ts
                 * // Release a texture which is no longer need
                 * loader.release(texture);
                 * // Release all dependencies of a loaded prefab
                 * let deps = loader.getDependsRecursively('prefabs/sample');
                 * loader.release(deps);
                 * // If there is no instance of this prefab in the scene, the prefab and its dependencies like textures, sprite frames, etc, will be freed up.
                 * // If you have some other nodes share a texture in this prefab, you can skip it in two ways:
                 * // 1. Forbid auto release a texture before release
                 * loader.setAutoRelease(texture2d, false);
                 * // 2. Remove it from the dependencies array
                 * let deps = loader.getDependsRecursively('prefabs/sample');
                 * let index = deps.indexOf(texture2d._uuid);
                 * if (index !== -1)
                 *     deps.splice(index, 1);
                 * loader.release(deps);
                 * ```
                 * @param asset Asset or assets to be released
                 */

              }, {
                key: "release",
                value: function release(asset) {
                  if (Array.isArray(asset)) {
                    for (var i = 0; i < asset.length; i++) {
                      var key = asset[i];
                      this.release(key);
                    }
                  } else if (asset) {
                    var id = this._getReferenceKey(asset);

                    var item = this.getItem(id);

                    if (item) {
                      var removed = this.removeItem(id);
                      asset = item.content;

                      if (asset instanceof Asset) {
                        var nativeUrl = asset.nativeUrl;

                        if (nativeUrl) {
                          this.release(nativeUrl); // uncache loading item of native asset
                        }

                        asset.destroy();
                      }

                      if ( removed) {
                        this._releasedAssetChecker_DEBUG.setReleased(item, id);
                      }
                    }
                  }
                }
                /**
                 * @en Release the asset by its object. Refer to {{release}} for detailed informations.
                 * @zh 通过资源对象自身来释放资源。详细信息请参考 {{release}}
                 * @param asset The asset to be released
                 */

              }, {
                key: "releaseAsset",
                value: function releaseAsset(asset) {
                  var uuid = asset._uuid;

                  if (uuid) {
                    this.release(uuid);
                  }
                }
                /**
                 * @en Release the asset loaded by {{loadRes}}. Refer to {{release}} for detailed informations.
                 * @zh 释放通过 {{loadRes}} 加载的资源。详细信息请参考 {{release}}
                 * @param url The asset url, it should be related path without extension to the `resources` folder.
                 * @param type If type is provided, the asset for correspond type will be returned
                 */

              }, {
                key: "releaseRes",
                value: function releaseRes(url, type, mount) {
                  var uuid = this._getResUuid(url, type, mount, true);

                  if (uuid) {
                    this.release(uuid);
                  } else {
                    errorID(4914, url);
                  }
                }
                /**
                 * @en Release the all assets loaded by {{loadResDir}}. Refer to {{release}} for detailed informations.
                 * @zh 释放通过 {{loadResDir}} 加载的资源。详细信息请参考 {{release}}
                 * @param url The url of the directory to release, it should be related path to the `resources` folder.
                 * @param type If type is provided, the asset for correspond type will be returned
                 */

              }, {
                key: "releaseResDir",
                value: function releaseResDir(url, type, mount) {
                  mount = mount || 'assets';

                  if (!assetTables[mount]) {
                    return;
                  }

                  var uuids = assetTables[mount].getUuidArray(url, type);

                  for (var i = 0; i < uuids.length; i++) {
                    var uuid = uuids[i];
                    this.release(uuid);
                  }
                }
                /**
                 * @en Resource all assets. Refer to {{release}} for detailed informations.
                 * @zh 释放所有资源。详细信息请参考 {{release}}
                 */

              }, {
                key: "releaseAll",
                value: function releaseAll() {
                  for (var id in this._cache) {
                    this.release(id);
                  }
                } // AUTO RELEASE
                // override

              }, {
                key: "removeItem",
                value: function removeItem(key) {
                  var removed = Pipeline.prototype.removeItem.call(this, key);
                  delete this._autoReleaseSetting[key];
                  return removed;
                }
                /**
                 * @en
                 * Indicates whether to release the asset when loading a new scene.<br>
                 * By default, when loading a new scene, all assets in the previous scene will be released or preserved<br>
                 * according to whether the previous scene checked the "Auto Release Assets" option.<br>
                 * On the other hand, assets dynamically loaded by using `loader.loadRes` or `loader.loadResDir`<br>
                 * will not be affected by that option, remain not released by default.<br>
                 * Use this API to change the default behavior on a single asset, to force preserve or release specified asset when scene switching.<br>
                 * <br>
                 * See: {{setAutoReleaseRecursively}}, {{isAutoRelease}}
                 * @zh
                 * 设置当场景切换时是否自动释放资源。<br>
                 * 默认情况下，当加载新场景时，旧场景的资源根据旧场景是否勾选“Auto Release Assets”，将会被释放或者保留。<br>
                 * 而使用 `loader.loadRes` 或 `loader.loadResDir` 动态加载的资源，则不受场景设置的影响，默认不自动释放。<br>
                 * 使用这个 API 可以在单个资源上改变这个默认行为，强制在切换场景时保留或者释放指定资源。<br>
                 * <br>
                 * 参考：{{setAutoReleaseRecursively}}，{{isAutoRelease}}
                 *
                 * @example
                 * ```ts
                 * // auto release the texture event if "Auto Release Assets" disabled in current scene
                 * loader.setAutoRelease(texture2d, true);
                 * // don't release the texture even if "Auto Release Assets" enabled in current scene
                 * loader.setAutoRelease(texture2d, false);
                 * // first parameter can be url
                 * loader.setAutoRelease(audioUrl, false);
                 * ```
                 * @param assetOrUrlOrUuid - The asset or its url or its uuid
                 * @param autoRelease - Whether to release automatically during scene switch
                 */

              }, {
                key: "setAutoRelease",
                value: function setAutoRelease(assetOrUrlOrUuid, autoRelease) {
                  var key = this._getReferenceKey(assetOrUrlOrUuid);

                  if (key) {
                    this._autoReleaseSetting[key] = !!autoRelease;
                  }
                }
                /**
                 * @en
                 * Indicates whether to release the asset and its referenced other assets when loading a new scene.<br>
                 * By default, when loading a new scene, all assets in the previous scene will be released or preserved<br>
                 * according to whether the previous scene checked the "Auto Release Assets" option.<br>
                 * On the other hand, assets dynamically loaded by using `loader.loadRes` or `loader.loadResDir`<br>
                 * will not be affected by that option, remain not released by default.<br>
                 * Use this API to change the default behavior on the specified asset and its recursively referenced assets, to force preserve or release specified asset when scene switching.<br>
                 * <br>
                 * See: {{setAutoRelease}}, {{isAutoRelease}}
                 * @zh
                 * 设置当场景切换时是否自动释放资源及资源引用的其它资源。<br>
                 * 默认情况下，当加载新场景时，旧场景的资源根据旧场景是否勾选“Auto Release Assets”，将会被释放或者保留。<br>
                 * 而使用 `loader.loadRes` 或 `loader.loadResDir` 动态加载的资源，则不受场景设置的影响，默认不自动释放。<br>
                 * 使用这个 API 可以在指定资源及资源递归引用到的所有资源上改变这个默认行为，强制在切换场景时保留或者释放指定资源。<br>
                 * <br>
                 * 参考：{{setAutoRelease}}，{{isAutoRelease}}
                 *
                 * @example
                 * ```ts
                 * // auto release the SpriteFrame and its Texture event if "Auto Release Assets" disabled in current scene
                 * loader.setAutoReleaseRecursively(spriteFrame, true);
                 * // don't release the SpriteFrame and its Texture even if "Auto Release Assets" enabled in current scene
                 * loader.setAutoReleaseRecursively(spriteFrame, false);
                 * // don't release the Prefab and all the referenced assets
                 * loader.setAutoReleaseRecursively(prefab, false);
                 * ```
                 * @param assetOrUrlOrUuid - The asset or its url or its uuid
                 * @param autoRelease - Whether to release automatically during scene switch
                 */

              }, {
                key: "setAutoReleaseRecursively",
                value: function setAutoReleaseRecursively(assetOrUrlOrUuid, autoRelease) {
                  autoRelease = !!autoRelease;

                  var key = this._getReferenceKey(assetOrUrlOrUuid);

                  if (key) {
                    this._autoReleaseSetting[key] = autoRelease;

                    var depends = getDependsRecursively(key);

                    for (var i = 0; i < depends.length; i++) {
                      var depend = depends[i];
                      this._autoReleaseSetting[depend] = autoRelease;
                    }
                  }
                }
                /**
                 * @en Returns whether the asset is configured as auto released, despite how "Auto Release Assets" property is set on scene asset.<br>
                 * <br>
                 * See: {{setAutoRelease}}, {{setAutoReleaseRecursively}}
                 * @zh 返回指定的资源是否有被设置为自动释放，不论场景的“Auto Release Assets”如何设置。<br>
                 * <br>
                 * 参考：{{setAutoRelease}}，{{setAutoReleaseRecursively}}
                 * @param {Asset|string} assetOrUrl - asset object or the raw asset's url
                 * @returns {Boolean}
                 */

              }, {
                key: "isAutoRelease",
                value: function isAutoRelease(assetOrUrl) {
                  var key = this._getReferenceKey(assetOrUrl);

                  if (key) {
                    return !!this._autoReleaseSetting[key];
                  }

                  return false;
                }
                /**
                 * @en Retrieve asset's uuid
                 * @zh 获取资源的 uuid
                 */

              }, {
                key: "_getResUuid",
                value: function _getResUuid(url, type, mount, quiet) {
                  mount = mount || 'assets';
                  var uuid = '';

                  {
                    var assetTable = assetTables[mount];

                    if (url && assetTable) {
                      // Ignore parameter
                      var index = url.indexOf('?');

                      if (index !== -1) {
                        url = url.substr(0, index);
                      }

                      uuid = assetTable.getUuid(url, type);

                      if (!uuid) {
                        var extname$1 = extname(url);

                        if (extname$1) {
                          // strip extname
                          url = url.slice(0, -extname$1.length);
                          uuid = assetTable.getUuid(url, type);

                          if (uuid && !quiet) {
                            warnID(4901, url, extname$1);
                          }
                        }
                      }
                    }
                  }

                  if (!uuid && type) {
                    if (isChildClassOf(type, SpriteFrame) || isChildClassOf(type, Texture2D) || isChildClassOf(type, TextureCube)) {
                      warnID(4934);
                    }
                  }

                  return uuid;
                }
                /**
                 * @en Find the asset's reference id in loader, asset could be asset object, asset uuid or asset url
                 * @zh 在 laoder 中找到资源的引用 id ，参数可以是资源对象、资源的 uuid 或者是资源的 url
                 */

              }, {
                key: "_getReferenceKey",
                value: function _getReferenceKey(assetOrUrlOrUuid) {
                  var key;

                  if (_typeof(assetOrUrlOrUuid) === 'object') {
                    key = assetOrUrlOrUuid._uuid || null;
                  } else if (typeof assetOrUrlOrUuid === 'string') {
                    key = this._getResUuid(assetOrUrlOrUuid, undefined, undefined, true) || assetOrUrlOrUuid;
                  }

                  if (!key) {
                    warnID(4800, assetOrUrlOrUuid);
                    return key;
                  }

                  legacyCC.AssetLibrary._getAssetInfoInRuntime(key, _info);

                  return this._cache[_info.url] ? _info.url : key;
                } // Operation when complete the request without found any asset

              }, {
                key: "_urlNotFound",
                value: function _urlNotFound(url, type, completeCallback) {
                  callInNextTick(function () {
                    url = legacyCC.url.normalize(url);
                    var info = "".concat(type ? getClassName(type) : 'Asset', " in \"resources/").concat(url, "\" does not exist.");

                    if (completeCallback) {
                      completeCallback(new Error(info), []);
                    }
                  });
                }
              }, {
                key: "_parseLoadResArgs",
                value: function _parseLoadResArgs(type, onProgress, onComplete) {
                  if (onComplete === undefined) {
                    var isValidType = isChildClassOf(type, legacyCC.RawAsset);

                    if (onProgress) {
                      onComplete = onProgress;

                      if (isValidType) {
                        onProgress = this.onProgress || null;
                      }
                    } else if (onProgress === undefined && !isValidType) {
                      onComplete = type;
                      onProgress = this.onProgress || null;
                      type = null;
                    }

                    if (onProgress !== undefined && !isValidType) {
                      onProgress = type;
                      type = null;
                    }
                  }

                  return {
                    type: type,
                    onProgress: onProgress,
                    onComplete: onComplete
                  };
                } // Load assets with uuids

              }, {
                key: "_loadResUuids",
                value: function _loadResUuids(uuids, progressCallback, completeCallback, urls) {
                  if (uuids.length > 0) {
                    var self = this;
                    var res = uuids.map(function (uuid) {
                      return {
                        type: 'uuid',
                        uuid: uuid
                      };
                    });
                    this.load(res, progressCallback, function (errors, items) {
                      if (completeCallback) {
                        var assetRes = [];
                        var urlRes = urls && [];

                        for (var i = 0; i < res.length; ++i) {
                          var uuid = res[i].uuid;

                          var id = self._getReferenceKey(uuid);

                          var item = items.getContent(id);

                          if (item) {
                            // should not release these assets, even if they are static referenced in the scene.
                            self.setAutoReleaseRecursively(uuid, false);
                            assetRes.push(item);

                            if (urlRes) {
                              urlRes.push(urls[i]);
                            }
                          }
                        }

                        if (urls) {
                          completeCallback(errors, assetRes, urlRes);
                        } else {
                          completeCallback(errors, assetRes);
                        }
                      }
                    });
                  } else {
                    if (completeCallback) {
                      callInNextTick(function () {
                        if (urls) {
                          completeCallback(null, [], []);
                        } else {
                          completeCallback(null, []);
                        }
                      });
                    }
                  }
                }
              }]);

              return CCLoader;
            }(Pipeline);
            /**
             * Singleton object of CCLoader
             */

            var loader = exports('cT', legacyCC.loader = new CCLoader());

            /*
             Copyright (c) 2013-2016 Chukong Technologies Inc.
             Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

             http://www.cocos.com

             Permission is hereby granted, free of charge, to any person obtaining a copy
             of this software and associated engine source code (the "Software"), a limited,
             worldwide, royalty-free, non-assignable, revocable and non-exclusive license
             to use Cocos Creator solely to develop games on your target platforms. You shall
             not use Cocos Creator software for developing other software or tools that's
             used for developing games. You are not granted to publish, distribute,
             sublicense, and/or sell copies of Cocos Creator.

             The software or tools in this License Agreement are licensed, not sold.
             Xiamen Yaji Software Co., Ltd. reserves all rights not expressly granted to you.

             THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
             THE SOFTWARE.
            */

            /**
             * @en Load an image asset with the given url.
             * @zh 加载指定的图像资源。
             * @param url The url of the image
             * @param callback Callback for receiving the loaded asset
             * @param target The callee of the callback function
             * @returns The ImageAsset, it could be in the loading process, the callback will tell whether the loading process succeed or failed.
             * @private
             */
            function loadImage$1(url, callback, target) {
              assertID(!!url, 3103);
              var imageAsset = loader.getRes(url);

              if (imageAsset) {
                if (imageAsset.loaded) {
                  if (callback) {
                    callback.call(target, null, imageAsset);
                  }

                  return imageAsset;
                } else {
                  imageAsset.once('load', function () {
                    if (callback) {
                      callback.call(target, null, imageAsset);
                    }
                  }, target);
                  return imageAsset;
                }
              } else {
                imageAsset = new ImageAsset();
                loader.load({
                  url: url,
                  imageAsset: imageAsset
                }, function (err, asset) {
                  if (err) {
                    if (callback) {
                      callback.call(target, err || new Error('Unknown error'));
                    }

                    return imageAsset;
                  }

                  if (callback) {
                    callback.call(target, null, asset);
                  }
                });
                return imageAsset;
              }
            }
            /**
             * @en Cache the [[ImageAsset]] with url as key.
             * @zh 缓存指定的图像源，为它指定链接。此后，可以通过该链接直接加载它。
             * @param url The url as key
             * @param image The image to be cached
             * @private
             */

            function cacheImage(url, image) {
              if (url && image) {
                var imageAsset = new ImageAsset(image);
                var item = {
                  id: url,
                  url: url,
                  // real download url, maybe changed
                  error: null,
                  content: imageAsset,
                  complete: false
                };
                loader.flowOut(item);
                return imageAsset;
              }
            }
            /**
             * @en Try to load the actual data of the image asset.
             * @zh 尝试加载图像资源的实际数据。
             * @param imageAsset The image asset
             * @param callback The callback function after loaded
             * @private
             */

            function postLoadImage(imageAsset, callback) {
              if (imageAsset.loaded) {
                if (callback) {
                  callback();
                }

                return;
              }

              if (!imageAsset.nativeUrl) {
                if (callback) {
                  callback();
                }

                return;
              } // load image


              loader.load({
                url: imageAsset.nativeUrl,
                // For image, we should skip loader otherwise it will load a new ImageAsset
                skips: imageAsset.isCompressed ? undefined : ['Loader']
              }, function (err, image) {
                if (image) {
                  if ( image instanceof ImageAsset) {
                    return error$1('internal error: loader handle pipe must be skipped');
                  }

                  if (!imageAsset.loaded) {
                    imageAsset._nativeAsset = image;
                  }
                }

                if (callback) {
                  callback(err);
                }
              });
            }

            var textureUtil = /*#__PURE__*/Object.freeze({
                __proto__: null,
                loadImage: loadImage$1,
                cacheImage: cacheImage,
                postLoadImage: postLoadImage
            });
            exports('aQ', textureUtil);

            var _dec$s, _dec2$a, _dec3$5, _class$s, _class2$o, _descriptor$n, _descriptor2$h, _descriptor3$d, _temp$q;
            /**
             * @en The skeleton asset. It stores the path related to [[SkinnedMeshRenderer.skinningRoot]] of all bones and its bind pose matrix.
             * @zh 骨骼资源。骨骼资源记录了每个关节（相对于 [[SkinnedMeshRenderer.skinningRoot]]）的路径以及它的绑定姿势矩阵。
             */

            var Skeleton = exports('b5', (_dec$s = ccclass('cc.Skeleton'), _dec2$a = type([CCString]), _dec3$5 = type([Mat4]), _dec$s(_class$s = (_class2$o = (_temp$q = /*#__PURE__*/function (_Asset) {
              _inherits(Skeleton, _Asset);

              function Skeleton() {
                var _getPrototypeOf2;

                var _this;

                _classCallCheck(this, Skeleton);

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Skeleton)).call.apply(_getPrototypeOf2, [this].concat(args)));

                _initializerDefineProperty(_this, "_joints", _descriptor$n, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_bindposes", _descriptor2$h, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_hash", _descriptor3$d, _assertThisInitialized(_this));

                _this._invBindposes = null;
                return _this;
              }

              _createClass(Skeleton, [{
                key: "destroy",
                value: function destroy() {
                  legacyCC.director.root.dataPoolManager.releaseSkeleton(this);
                  return _get(_getPrototypeOf(Skeleton.prototype), "destroy", this).call(this);
                }
              }, {
                key: "joints",

                /**
                 * @en The path of all bones, the length always equals the length of [[bindposes]]
                 * @zh 所有关节的路径。该数组的长度始终与 [[bindposes]] 的长度相同。
                 */
                get: function get() {
                  return this._joints;
                },
                set: function set(value) {
                  this._joints = value;
                }
                /**
                 * @en The bind poses matrix of all bones, the length always equals the length of [[joints]]
                 * @zh 所有关节的绑定姿势矩阵。该数组的长度始终与 [[joints]] 的长度相同。
                 */

              }, {
                key: "bindposes",
                get: function get() {
                  return this._bindposes;
                },
                set: function set(value) {
                  this._bindposes = value;
                }
                /**
                 * @en Gets the inverse bind poses matrix
                 * @zh 获取反向绑定姿势矩阵
                 */

              }, {
                key: "inverseBindposes",
                get: function get() {
                  if (!this._invBindposes) {
                    this._invBindposes = [];

                    for (var i = 0; i < this._bindposes.length; i++) {
                      var inv = new Mat4();
                      Mat4.invert(inv, this._bindposes[i]);

                      this._invBindposes.push(inv);
                    }
                  }

                  return this._invBindposes;
                }
                /**
                 * @en Gets the hash of the skeleton asset
                 * @zh 获取骨骼资源的哈希值
                 */

              }, {
                key: "hash",
                get: function get() {
                  // hashes should already be computed offline, but if not, make one
                  if (!this._hash) {
                    var str = '';

                    for (var i = 0; i < this._bindposes.length; i++) {
                      var ibm = this._bindposes[i];
                      str += ibm.m00.toPrecision(2) + ' ' + ibm.m01.toPrecision(2) + ' ' + ibm.m02.toPrecision(2) + ' ' + ibm.m03.toPrecision(2) + ' ' + ibm.m04.toPrecision(2) + ' ' + ibm.m05.toPrecision(2) + ' ' + ibm.m06.toPrecision(2) + ' ' + ibm.m07.toPrecision(2) + ' ' + ibm.m08.toPrecision(2) + ' ' + ibm.m09.toPrecision(2) + ' ' + ibm.m10.toPrecision(2) + ' ' + ibm.m11.toPrecision(2) + ' ' + ibm.m12.toPrecision(2) + ' ' + ibm.m13.toPrecision(2) + ' ' + ibm.m14.toPrecision(2) + ' ' + ibm.m15.toPrecision(2) + '\n';
                    }

                    this._hash = murmurhash2_32_gc(str, 666);
                  }

                  return this._hash;
                }
              }]);

              return Skeleton;
            }(Asset), _temp$q), (_descriptor$n = _applyDecoratedDescriptor(_class2$o.prototype, "_joints", [_dec2$a], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [];
              }
            }), _descriptor2$h = _applyDecoratedDescriptor(_class2$o.prototype, "_bindposes", [_dec3$5], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [];
              }
            }), _descriptor3$d = _applyDecoratedDescriptor(_class2$o.prototype, "_hash", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            })), _class2$o)) || _class$s));
            legacyCC.Skeleton = Skeleton;

            /**
             * @hidden
             */
            replaceProperty(Mesh.prototype, 'Mesh.prototype', [{
              name: 'renderingMesh',
              newName: 'renderingSubMeshes'
            }]);
            removeProperty(Mesh.prototype, 'Mesh.prototype', [{
              name: 'hasFlatBuffers'
            }, {
              name: 'destroyFlatBuffers'
            }]);
            removeProperty(TextureBase.prototype, 'TextureBase.prototype', [{
              name: 'hasPremultipliedAlpha'
            }, {
              name: 'setPremultiplyAlpha'
            }, {
              name: 'setFlipY'
            }]);
            replaceProperty(RenderTexture.prototype, 'RenderTexture.prototype', [{
              name: 'getGFXWindow',
              customFunction: function customFunction() {
                // @ts-ignore
                return this._window;
              }
            }]);

            /*
             Copyright (c) 2013-2016 Chukong Technologies Inc.
             Copyright (c) 2017-2018 Xiamen Yaji Software Co., Ltd.

             http://www.cocos.com

             Permission is hereby granted, free of charge, to any person obtaining a copy
             of this software and associated engine source code (the "Software"), a limited,
              worldwide, royalty-free, non-assignable, revocable and non-exclusive license
             to use Cocos Creator solely to develop games on your target platforms. You shall
              not use Cocos Creator software for developing other software or tools that's
              used for developing games. You are not granted to publish, distribute,
              sublicense, and/or sell copies of Cocos Creator.

             The software or tools in this License Agreement are licensed, not sold.
             Xiamen Yaji Software Co., Ltd. reserves all rights not expressly granted to you.

             THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
             IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
             FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
             AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
             LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
             OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
             THE SOFTWARE.
            */
            legacyCC.textureUtil = textureUtil;

            var _dec$t, _dec2$b, _dec3$6, _dec4$4, _class$t, _class2$p, _descriptor$o, _descriptor2$i, _descriptor3$e, _temp$r;
            var RenderStage = exports('cG', (_dec$t = ccclass('RenderStage'), _dec2$b = displayOrder(), _dec3$6 = displayOrder(), _dec4$4 = displayOrder(), _dec$t(_class$t = (_class2$p = (_temp$r = /*#__PURE__*/function () {
              function RenderStage() {
                _classCallCheck(this, RenderStage);

                _initializerDefineProperty(this, "_name", _descriptor$o, this);

                _initializerDefineProperty(this, "_priority", _descriptor2$i, this);

                _initializerDefineProperty(this, "_tag", _descriptor3$e, this);
              }

              _createClass(RenderStage, [{
                key: "initialize",

                /**
                 * @en The initialization process, user shouldn't use it in most case, only useful when need to generate render pipeline programmatically.
                 * @zh 初始化函数，正常情况下不会用到，仅用于程序化生成渲染管线的情况。
                 * @param info The render stage information
                 */
                value: function initialize(info) {
                  this._name = info.name;
                  this._priority = info.priority;

                  if (info.tag) {
                    this._tag = info.tag;
                  }

                  return true;
                }
                /**
                 * @en Activate the current render stage in the given render flow
                 * @zh 为指定的渲染流程开启当前渲染阶段
                 * @param flow The render flow to activate this render stage
                 */

              }, {
                key: "activate",
                value: function activate(pipeline, flow) {
                  this._pipeline = pipeline;
                  this._flow = flow;
                }
                /**
                 * @en Destroy function
                 * @zh 销毁函数。
                 */

              }, {
                key: "name",

                /**
                 * @en Name of the current stage
                 * @zh 当前渲染阶段的名字。
                 */
                get: function get() {
                  return this._name;
                }
                /**
                 * @en Priority of the current stage
                 * @zh 当前渲染阶段的优先级。
                 */

              }, {
                key: "priority",
                get: function get() {
                  return this._priority;
                }
                /**
                 * @en Tag of the current stage
                 * @zh 当前渲染阶段的标签。
                 */

              }, {
                key: "tag",
                get: function get() {
                  return this._tag;
                }
                /**
                 * @en Name
                 * @zh 名称。
                 */

              }]);

              return RenderStage;
            }(), _temp$r), (_descriptor$o = _applyDecoratedDescriptor(_class2$p.prototype, "_name", [_dec2$b, serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return '';
              }
            }), _descriptor2$i = _applyDecoratedDescriptor(_class2$p.prototype, "_priority", [_dec3$6, serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            }), _descriptor3$e = _applyDecoratedDescriptor(_class2$p.prototype, "_tag", [_dec4$4, serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            })), _class2$p)) || _class$t));
            legacyCC.RenderStage = RenderStage;

            var _dec$u, _dec2$c, _dec3$7, _dec4$5, _dec5$3, _dec6$2, _class$u, _class2$q, _descriptor$p, _descriptor2$j, _descriptor3$f, _descriptor4$8, _temp$s;
            /**
             * @en Render flow information descriptor
             * @zh 渲染流程描述信息。
             */

            var RenderFlow = exports('cF', (_dec$u = ccclass('RenderFlow'), _dec2$c = displayOrder(), _dec3$7 = displayOrder(), _dec4$5 = displayOrder(), _dec5$3 = displayOrder(), _dec6$2 = type([RenderStage]), _dec$u(_class$u = (_class2$q = (_temp$s = /*#__PURE__*/function () {
              function RenderFlow() {
                _classCallCheck(this, RenderFlow);

                _initializerDefineProperty(this, "_name", _descriptor$p, this);

                _initializerDefineProperty(this, "_priority", _descriptor2$j, this);

                _initializerDefineProperty(this, "_tag", _descriptor3$f, this);

                _initializerDefineProperty(this, "_stages", _descriptor4$8, this);
              }

              _createClass(RenderFlow, [{
                key: "initialize",

                /**
                 * @en The initialization process, user shouldn't use it in most case, only useful when need to generate render pipeline programmatically.
                 * @zh 初始化函数，正常情况下不会用到，仅用于程序化生成渲染管线的情况。
                 * @param info The render flow information
                 */
                value: function initialize(info) {
                  this._name = info.name;
                  this._priority = info.priority;

                  if (info.tag) {
                    this._tag = info.tag;
                  }

                  return true;
                }
                /**
                 * @en Activate the current render flow in the given pipeline
                 * @zh 为指定的渲染管线开启当前渲染流程
                 * @param pipeline The render pipeline to activate this render flow
                 */

              }, {
                key: "activate",
                value: function activate(pipeline) {
                  this._pipeline = pipeline;

                  this._stages.sort(function (a, b) {
                    return a.priority - b.priority;
                  });

                  for (var i = 0, len = this._stages.length; i < len; i++) {
                    this._stages[i].activate(pipeline, this);
                  }
                }
                /**
                 * @en Render function, it basically run all render stages in sequence for the given view.
                 * @zh 渲染函数，对指定的渲染视图按顺序执行所有渲染阶段。
                 * @param view Render view。
                 */

              }, {
                key: "render",
                value: function render(view) {
                  for (var i = 0, len = this._stages.length; i < len; i++) {
                    this._stages[i].render(view);
                  }
                }
                /**
                 * @en Destroy function.
                 * @zh 销毁函数。
                 */

              }, {
                key: "destroy",
                value: function destroy() {
                  for (var i = 0, len = this._stages.length; i < len; i++) {
                    this._stages[i].destroy();
                  }

                  this._stages.length = 0;
                }
              }, {
                key: "name",

                /**
                 * @en The name of the render flow
                 * @zh 渲染流程的名字
                 */
                get: function get() {
                  return this._name;
                }
                /**
                 * @en Priority of the current flow
                 * @zh 当前渲染流程的优先级。
                 */

              }, {
                key: "priority",
                get: function get() {
                  return this._priority;
                }
                /**
                 * @en Tag of the current flow
                 * @zh 当前渲染流程的标签。
                 */

              }, {
                key: "tag",
                get: function get() {
                  return this._tag;
                }
                /**
                 * @en The stages of flow.
                 * @zh 渲染流程 stage 列表。
                 * @readonly
                 */

              }, {
                key: "stages",
                get: function get() {
                  return this._stages;
                }
              }]);

              return RenderFlow;
            }(), _temp$s), (_descriptor$p = _applyDecoratedDescriptor(_class2$q.prototype, "_name", [_dec2$c, serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return '';
              }
            }), _descriptor2$j = _applyDecoratedDescriptor(_class2$q.prototype, "_priority", [_dec3$7, serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            }), _descriptor3$f = _applyDecoratedDescriptor(_class2$q.prototype, "_tag", [_dec4$5, serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            }), _descriptor4$8 = _applyDecoratedDescriptor(_class2$q.prototype, "_stages", [_dec5$3, _dec6$2, serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [];
              }
            })), _class2$q)) || _class$u));
            legacyCC.RenderFlow = RenderFlow;

            var _dec$v, _dec2$d, _dec3$8, _dec4$6, _class$v, _class2$r, _descriptor$q, _descriptor2$k, _temp$t;
            /**
             * @en Render pipeline information descriptor
             * @zh 渲染管线描述信息。
             */

            var RenderPipeline = exports('cE', (_dec$v = ccclass('cc.RenderPipeline'), _dec2$d = displayOrder(), _dec3$8 = displayOrder(), _dec4$6 = type([RenderFlow]), _dec$v(_class$v = (_class2$r = (_temp$t = /*#__PURE__*/function (_Asset) {
              _inherits(RenderPipeline, _Asset);

              function RenderPipeline() {
                var _getPrototypeOf2;

                var _this;

                _classCallCheck(this, RenderPipeline);

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(RenderPipeline)).call.apply(_getPrototypeOf2, [this].concat(args)));

                _initializerDefineProperty(_this, "_tag", _descriptor$q, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_flows", _descriptor2$k, _assertThisInitialized(_this));

                _this._globalDescriptorSetLayout = {
                  bindings: [],
                  record: {}
                };
                _this._localDescriptorSetLayout = {
                  bindings: [],
                  record: {}
                };
                _this._macros = {};
                _this._commandBuffers = [];
                return _this;
              }

              _createClass(RenderPipeline, [{
                key: "initialize",

                /**
                 * @en The initialization process, user shouldn't use it in most case, only useful when need to generate render pipeline programmatically.
                 * @zh 初始化函数，正常情况下不会用到，仅用于程序化生成渲染管线的情况。
                 * @param info The render pipeline information
                 */
                value: function initialize(info) {
                  this._flows = info.flows;

                  if (info.tag) {
                    this._tag = info.tag;
                  }

                  return true;
                }
                /**
                 * @en Activate the render pipeline after loaded, it mainly activate the flows
                 * @zh 当渲染管线资源加载完成后，启用管线，主要是启用管线内的 flow
                 */

              }, {
                key: "activate",
                value: function activate() {
                  this._device = legacyCC.director.root.device;
                  this._descriptorSetLayout = this._device.createDescriptorSetLayout({
                    bindings: globalDescriptorSetLayout.bindings
                  });
                  this._descriptorSet = this._device.createDescriptorSet({
                    layout: this._descriptorSetLayout
                  });

                  for (var i = 0; i < this._flows.length; i++) {
                    this._flows[i].activate(this);
                  }

                  return true;
                }
                /**
                 * @en Render function, it basically run the render process of all flows in sequence for the given view.
                 * @zh 渲染函数，对指定的渲染视图按顺序执行所有渲染流程。
                 * @param view Render view。
                 */

              }, {
                key: "render",
                value: function render(views) {
                  for (var i = 0; i < views.length; i++) {
                    var view = views[i];

                    for (var j = 0; j < view.flows.length; j++) {
                      view.flows[j].render(view);
                    }
                  }
                }
                /**
                 * @en Internal destroy function
                 * @zh 内部销毁函数。
                 */

              }, {
                key: "destroy",
                value: function destroy() {
                  for (var i = 0; i < this._flows.length; i++) {
                    this._flows[i].destroy();
                  }

                  this._flows.length = 0;

                  if (this._descriptorSet) {
                    this._descriptorSet.destroy();

                    this._descriptorSet = null;
                  }

                  for (var _i = 0; _i < this._commandBuffers.length; _i++) {
                    this._commandBuffers[_i].destroy();
                  }

                  this._commandBuffers.length = 0;
                  return _get(_getPrototypeOf(RenderPipeline.prototype), "destroy", this).call(this);
                }
              }, {
                key: "globalDescriptorSetLayout",

                /**
                 * @en Layout of the pipeline-global descriptor set.
                 * @zh 管线层的全局描述符集布局。
                 * @readonly
                 */
                get: function get() {
                  return this._globalDescriptorSetLayout;
                }
                /**
                 * @en Layout of the model-local descriptor set.
                 * @zh 逐模型的描述符集布局。
                 * @readonly
                 */

              }, {
                key: "localDescriptorSetLayout",
                get: function get() {
                  return this._localDescriptorSetLayout;
                }
                /**
                 * @en The macros for this pipeline.
                 * @zh 管线宏定义。
                 * @readonly
                 */

              }, {
                key: "macros",
                get: function get() {
                  return this._macros;
                }
                /**
                 * @en The tag of pipeline.
                 * @zh 管线的标签。
                 * @readonly
                 */

              }, {
                key: "tag",
                get: function get() {
                  return this._tag;
                }
                /**
                 * @en The flows of pipeline.
                 * @zh 管线的渲染流程列表。
                 * @readonly
                 */

              }, {
                key: "flows",
                get: function get() {
                  return this._flows;
                }
                /**
                 * @en Tag
                 * @zh 标签
                 * @readonly
                 */

              }, {
                key: "device",
                get: function get() {
                  return this._device;
                }
              }, {
                key: "descriptorSetLayout",
                get: function get() {
                  return this._descriptorSetLayout;
                }
              }, {
                key: "descriptorSet",
                get: function get() {
                  return this._descriptorSet;
                }
              }, {
                key: "commandBuffers",
                get: function get() {
                  return this._commandBuffers;
                }
              }]);

              return RenderPipeline;
            }(Asset), _temp$t), (_descriptor$q = _applyDecoratedDescriptor(_class2$r.prototype, "_tag", [_dec2$d, serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            }), _descriptor2$k = _applyDecoratedDescriptor(_class2$r.prototype, "_flows", [_dec3$8, _dec4$6, serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [];
              }
            })), _class2$r)) || _class$v));
            legacyCC.RenderPipeline = RenderPipeline;

            var _dec$w, _dec2$e, _dec3$9, _dec4$7, _class$w, _class2$s, _descriptor$r, _descriptor2$l, _descriptor3$g, _descriptor4$9, _descriptor5$6, _descriptor6$2, _temp$u, _dec5$4, _dec6$3, _class4$3, _class5$3, _descriptor7$2, _descriptor8$2, _temp2$3, _dec7$2, _dec8$2, _class7, _class8, _descriptor9$1, _descriptor10$1, _temp3, _dec9$2, _dec10$1, _dec11$1, _class10, _class11, _descriptor11$1, _descriptor12, _descriptor13, _descriptor14, _descriptor15, _temp4, _dec12$1, _dec13$1, _dec14, _dec15, _dec16, _dec17, _class13, _class14, _descriptor16, _descriptor17, _descriptor18, _descriptor19, _descriptor20, _descriptor21, _temp5, _dec18, _dec19, _dec20, _dec21, _dec22, _dec23, _dec24, _dec25, _class16, _class17, _descriptor22, _descriptor23, _descriptor24, _descriptor25, _descriptor26, _descriptor27, _descriptor28, _descriptor29, _temp6, _dec26, _dec27, _dec28, _class19, _class20, _descriptor30, _descriptor31, _descriptor32, _temp7, _dec29, _dec30, _dec31, _class22, _class23, _descriptor33, _descriptor34, _descriptor35, _temp8;
            ccenum(GFXTextureType);
            ccenum(GFXTextureUsageBit);
            ccenum(GFXStoreOp);
            ccenum(GFXLoadOp);
            ccenum(GFXTextureLayout);
            /**
             * @en The tag of the render flow, including SCENE, POSTPROCESS and UI.
             * @zh 渲染流程的标签，包含：常规场景（SCENE），后处理（POSTPROCESS），UI 界面（UI）
             */

            var RenderFlowTag;

            (function (RenderFlowTag) {
              RenderFlowTag[RenderFlowTag["SCENE"] = 0] = "SCENE";
              RenderFlowTag[RenderFlowTag["POSTPROCESS"] = 1] = "POSTPROCESS";
              RenderFlowTag[RenderFlowTag["UI"] = 2] = "UI";
            })(RenderFlowTag || (RenderFlowTag = {}));

            ccenum(RenderFlowTag);
            var RenderTextureDesc = (_dec$w = ccclass('RenderTextureDesc'), _dec2$e = type(GFXTextureType), _dec3$9 = type(GFXTextureUsageBit), _dec4$7 = type(GFXFormat), _dec$w(_class$w = (_class2$s = (_temp$u = function RenderTextureDesc() {
              _classCallCheck(this, RenderTextureDesc);

              _initializerDefineProperty(this, "name", _descriptor$r, this);

              _initializerDefineProperty(this, "type", _descriptor2$l, this);

              _initializerDefineProperty(this, "usage", _descriptor3$g, this);

              _initializerDefineProperty(this, "format", _descriptor4$9, this);

              _initializerDefineProperty(this, "width", _descriptor5$6, this);

              _initializerDefineProperty(this, "height", _descriptor6$2, this);
            }, _temp$u), (_descriptor$r = _applyDecoratedDescriptor(_class2$s.prototype, "name", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return '';
              }
            }), _descriptor2$l = _applyDecoratedDescriptor(_class2$s.prototype, "type", [_dec2$e], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return GFXTextureType.TEX2D;
              }
            }), _descriptor3$g = _applyDecoratedDescriptor(_class2$s.prototype, "usage", [_dec3$9], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return GFXTextureUsageBit.COLOR_ATTACHMENT;
              }
            }), _descriptor4$9 = _applyDecoratedDescriptor(_class2$s.prototype, "format", [_dec4$7], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return GFXFormat.UNKNOWN;
              }
            }), _descriptor5$6 = _applyDecoratedDescriptor(_class2$s.prototype, "width", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return -1;
              }
            }), _descriptor6$2 = _applyDecoratedDescriptor(_class2$s.prototype, "height", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return -1;
              }
            })), _class2$s)) || _class$w);
            var RenderTextureConfig = (_dec5$4 = ccclass('RenderTextureConfig'), _dec6$3 = type(RenderTexture), _dec5$4(_class4$3 = (_class5$3 = (_temp2$3 = function RenderTextureConfig() {
              _classCallCheck(this, RenderTextureConfig);

              _initializerDefineProperty(this, "name", _descriptor7$2, this);

              _initializerDefineProperty(this, "texture", _descriptor8$2, this);
            }, _temp2$3), (_descriptor7$2 = _applyDecoratedDescriptor(_class5$3.prototype, "name", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return '';
              }
            }), _descriptor8$2 = _applyDecoratedDescriptor(_class5$3.prototype, "texture", [_dec6$3], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            })), _class5$3)) || _class4$3);
            var MaterialConfig = (_dec7$2 = ccclass('MaterialConfig'), _dec8$2 = type(Material), _dec7$2(_class7 = (_class8 = (_temp3 = function MaterialConfig() {
              _classCallCheck(this, MaterialConfig);

              _initializerDefineProperty(this, "name", _descriptor9$1, this);

              _initializerDefineProperty(this, "material", _descriptor10$1, this);
            }, _temp3), (_descriptor9$1 = _applyDecoratedDescriptor(_class8.prototype, "name", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return '';
              }
            }), _descriptor10$1 = _applyDecoratedDescriptor(_class8.prototype, "material", [_dec8$2], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            })), _class8)) || _class7);
            var FrameBufferDesc = (_dec9$2 = ccclass('FrameBufferDesc'), _dec10$1 = type([CCString]), _dec11$1 = type(RenderTexture), _dec9$2(_class10 = (_class11 = (_temp4 = function FrameBufferDesc() {
              _classCallCheck(this, FrameBufferDesc);

              _initializerDefineProperty(this, "name", _descriptor11$1, this);

              _initializerDefineProperty(this, "renderPass", _descriptor12, this);

              _initializerDefineProperty(this, "colorTextures", _descriptor13, this);

              _initializerDefineProperty(this, "depthStencilTexture", _descriptor14, this);

              _initializerDefineProperty(this, "texture", _descriptor15, this);
            }, _temp4), (_descriptor11$1 = _applyDecoratedDescriptor(_class11.prototype, "name", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return '';
              }
            }), _descriptor12 = _applyDecoratedDescriptor(_class11.prototype, "renderPass", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            }), _descriptor13 = _applyDecoratedDescriptor(_class11.prototype, "colorTextures", [_dec10$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [];
              }
            }), _descriptor14 = _applyDecoratedDescriptor(_class11.prototype, "depthStencilTexture", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return '';
              }
            }), _descriptor15 = _applyDecoratedDescriptor(_class11.prototype, "texture", [_dec11$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            })), _class11)) || _class10);
            var ColorDesc = (_dec12$1 = ccclass('ColorDesc'), _dec13$1 = type(GFXFormat), _dec14 = type(GFXLoadOp), _dec15 = type(GFXStoreOp), _dec16 = type(GFXTextureLayout), _dec17 = type(GFXTextureLayout), _dec12$1(_class13 = (_class14 = (_temp5 = function ColorDesc() {
              _classCallCheck(this, ColorDesc);

              _initializerDefineProperty(this, "format", _descriptor16, this);

              _initializerDefineProperty(this, "loadOp", _descriptor17, this);

              _initializerDefineProperty(this, "storeOp", _descriptor18, this);

              _initializerDefineProperty(this, "sampleCount", _descriptor19, this);

              _initializerDefineProperty(this, "beginLayout", _descriptor20, this);

              _initializerDefineProperty(this, "endLayout", _descriptor21, this);
            }, _temp5), (_descriptor16 = _applyDecoratedDescriptor(_class14.prototype, "format", [_dec13$1], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return GFXFormat.UNKNOWN;
              }
            }), _descriptor17 = _applyDecoratedDescriptor(_class14.prototype, "loadOp", [_dec14], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return GFXLoadOp.CLEAR;
              }
            }), _descriptor18 = _applyDecoratedDescriptor(_class14.prototype, "storeOp", [_dec15], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return GFXStoreOp.STORE;
              }
            }), _descriptor19 = _applyDecoratedDescriptor(_class14.prototype, "sampleCount", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 1;
              }
            }), _descriptor20 = _applyDecoratedDescriptor(_class14.prototype, "beginLayout", [_dec16], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return GFXTextureLayout.UNDEFINED;
              }
            }), _descriptor21 = _applyDecoratedDescriptor(_class14.prototype, "endLayout", [_dec17], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return GFXTextureLayout.PRESENT_SRC;
              }
            })), _class14)) || _class13);
            var DepthStencilDesc = (_dec18 = ccclass('DepthStencilDesc'), _dec19 = type(GFXFormat), _dec20 = type(GFXLoadOp), _dec21 = type(GFXStoreOp), _dec22 = type(GFXLoadOp), _dec23 = type(GFXStoreOp), _dec24 = type(GFXTextureLayout), _dec25 = type(GFXTextureLayout), _dec18(_class16 = (_class17 = (_temp6 = function DepthStencilDesc() {
              _classCallCheck(this, DepthStencilDesc);

              _initializerDefineProperty(this, "format", _descriptor22, this);

              _initializerDefineProperty(this, "depthLoadOp", _descriptor23, this);

              _initializerDefineProperty(this, "depthStoreOp", _descriptor24, this);

              _initializerDefineProperty(this, "stencilLoadOp", _descriptor25, this);

              _initializerDefineProperty(this, "stencilStoreOp", _descriptor26, this);

              _initializerDefineProperty(this, "sampleCount", _descriptor27, this);

              _initializerDefineProperty(this, "beginLayout", _descriptor28, this);

              _initializerDefineProperty(this, "endLayout", _descriptor29, this);
            }, _temp6), (_descriptor22 = _applyDecoratedDescriptor(_class17.prototype, "format", [_dec19], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return GFXFormat.UNKNOWN;
              }
            }), _descriptor23 = _applyDecoratedDescriptor(_class17.prototype, "depthLoadOp", [_dec20], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return GFXLoadOp.CLEAR;
              }
            }), _descriptor24 = _applyDecoratedDescriptor(_class17.prototype, "depthStoreOp", [_dec21], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return GFXStoreOp.STORE;
              }
            }), _descriptor25 = _applyDecoratedDescriptor(_class17.prototype, "stencilLoadOp", [_dec22], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return GFXLoadOp.CLEAR;
              }
            }), _descriptor26 = _applyDecoratedDescriptor(_class17.prototype, "stencilStoreOp", [_dec23], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return GFXStoreOp.STORE;
              }
            }), _descriptor27 = _applyDecoratedDescriptor(_class17.prototype, "sampleCount", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 1;
              }
            }), _descriptor28 = _applyDecoratedDescriptor(_class17.prototype, "beginLayout", [_dec24], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return GFXTextureLayout.UNDEFINED;
              }
            }), _descriptor29 = _applyDecoratedDescriptor(_class17.prototype, "endLayout", [_dec25], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return GFXTextureLayout.DEPTH_STENCIL_ATTACHMENT_OPTIMAL;
              }
            })), _class17)) || _class16);
            var RenderPassDesc = (_dec26 = ccclass('RenderPassDesc'), _dec27 = type([ColorDesc]), _dec28 = type(DepthStencilDesc), _dec26(_class19 = (_class20 = (_temp7 = function RenderPassDesc() {
              _classCallCheck(this, RenderPassDesc);

              _initializerDefineProperty(this, "index", _descriptor30, this);

              _initializerDefineProperty(this, "colorAttachments", _descriptor31, this);

              _initializerDefineProperty(this, "depthStencilAttachment", _descriptor32, this);
            }, _temp7), (_descriptor30 = _applyDecoratedDescriptor(_class20.prototype, "index", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return -1;
              }
            }), _descriptor31 = _applyDecoratedDescriptor(_class20.prototype, "colorAttachments", [_dec27], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [];
              }
            }), _descriptor32 = _applyDecoratedDescriptor(_class20.prototype, "depthStencilAttachment", [_dec28], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new DepthStencilDesc();
              }
            })), _class20)) || _class19);
            var RenderQueueSortMode;

            (function (RenderQueueSortMode) {
              RenderQueueSortMode[RenderQueueSortMode["FRONT_TO_BACK"] = 0] = "FRONT_TO_BACK";
              RenderQueueSortMode[RenderQueueSortMode["BACK_TO_FRONT"] = 1] = "BACK_TO_FRONT";
            })(RenderQueueSortMode || (RenderQueueSortMode = {}));

            ccenum(RenderQueueSortMode);
            /**
             * @en The render queue descriptor
             * @zh 渲染队列描述信息
             */

            var RenderQueueDesc = (_dec29 = ccclass('RenderQueueDesc'), _dec30 = type(RenderQueueSortMode), _dec31 = type([CCString]), _dec29(_class22 = (_class23 = (_temp8 = function RenderQueueDesc() {
              _classCallCheck(this, RenderQueueDesc);

              _initializerDefineProperty(this, "isTransparent", _descriptor33, this);

              _initializerDefineProperty(this, "sortMode", _descriptor34, this);

              _initializerDefineProperty(this, "stages", _descriptor35, this);
            }, _temp8), (_descriptor33 = _applyDecoratedDescriptor(_class23.prototype, "isTransparent", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return false;
              }
            }), _descriptor34 = _applyDecoratedDescriptor(_class23.prototype, "sortMode", [_dec30], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return RenderQueueSortMode.FRONT_TO_BACK;
              }
            }), _descriptor35 = _applyDecoratedDescriptor(_class23.prototype, "stages", [_dec31], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [];
              }
            })), _class23)) || _class22);

            /**
             * @en The predefined priority of render view
             * @zh 预设渲染视图优先级。
             */
            var RenderViewPriority;
            /**
             * @en Render view information descriptor
             * @zh 渲染视图描述信息。
             */

            (function (RenderViewPriority) {
              RenderViewPriority[RenderViewPriority["GENERAL"] = 100] = "GENERAL";
            })(RenderViewPriority || (RenderViewPriority = {}));

            /**
             * @en Render view represents a view from its camera, it also manages a list of [[RenderFlow]]s which will be executed for it.
             * @zh 渲染视图代表了它的相机所拍摄的视图，它也管理一组在视图上执行的 [[RenderFlow]]。
             */
            var RenderView = exports('cH', /*#__PURE__*/function () {
              _createClass(RenderView, [{
                key: "name",

                /**
                 * @en Name
                 * @zh 名称。
                 */
                get: function get() {
                  return this._name;
                }
                /**
                 * @en The GFX window
                 * @zh GFX 窗口。
                 */

              }, {
                key: "window",
                get: function get() {
                  return this._window;
                },
                set: function set(val) {
                  this._window = val;
                }
                /**
                 * @en The priority among other render views, used for sorting.
                 * @zh 在所有 RenderView 中的优先级，用于排序。
                 */

              }, {
                key: "priority",
                get: function get() {
                  return this._priority;
                },
                set: function set(val) {
                  this._priority = val;

                  if (legacyCC.director.root) {
                    legacyCC.director.root.sortViews();
                  }
                }
                /**
                 * @en The visibility is a mask which allows nodes in the scene be seen by the current view if their [[Node.layer]] bit is included in this mask.
                 * @zh 可见性是一个掩码，如果场景中节点的 [[Node.layer]] 位被包含在该掩码中，则对应节点对该视图是可见的。
                 */

              }, {
                key: "visibility",
                set: function set(vis) {
                  this._visibility = vis;
                },
                get: function get() {
                  return this._visibility;
                }
                /**
                 * @en The camera correspond to this render view
                 * @zh 该视图对应的相机。
                 * @readonly
                 */

              }, {
                key: "camera",
                get: function get() {
                  return this._camera;
                }
                /**
                 * @en Whether the view is enabled
                 * @zh 是否启用。
                 * @readonly
                 */

              }, {
                key: "isEnable",
                get: function get() {
                  return this._isEnable;
                }
                /**
                 * @en Render flow list
                 * @zh 渲染流程列表。
                 * @readonly
                 */

              }, {
                key: "flows",
                get: function get() {
                  return this._flows;
                }
              }]);

              /**
               * @en The constructor
               * @zh 构造函数。
               * @param camera
               */
              function RenderView() {
                _classCallCheck(this, RenderView);

                this._name = '';
                this._window = null;
                this._priority = 0;
                this._visibility = CAMERA_DEFAULT_MASK;
                this._isEnable = false;
                this._flows = [];
              }
              /**
               * @en Initialization function with a render view information descriptor
               * @zh 使用一个渲染视图描述信息来初始化。
               * @param info Render view information descriptor
               */


              _createClass(RenderView, [{
                key: "initialize",
                value: function initialize(info) {
                  this._camera = info.camera;
                  this._name = info.name;
                  this.priority = info.priority;
                  this.setExecuteFlows(info.flows);
                  return true;
                }
                /**
                 * @en The destroy function
                 * @zh 销毁函数。
                 */

              }, {
                key: "destroy",
                value: function destroy() {
                  this._window = null;
                  this._priority = 0;
                }
                /**
                 * @en Enable or disable this render view
                 * @zh 启用或禁用该渲染视图。
                 * @param isEnable Whether to enable or disable this view
                 */

              }, {
                key: "enable",
                value: function enable(isEnable) {
                  this._isEnable = isEnable;
                }
                /**
                 * @en Set the execution render flows with their names, the flows found in the pipeline will then be executed for this view in the render process
                 * @zh 使用对应的名字列表设置需要执行的渲染流程，所有在渲染管线中找到的对应渲染流程都会用来对当前视图执行渲染。
                 * @param flows The names of all [[RenderFlow]]s
                 */

              }, {
                key: "setExecuteFlows",
                value: function setExecuteFlows(flows) {
                  this._flows.length = 0;
                  var pipeline = legacyCC.director.root.pipeline;
                  var pipelineFlows = pipeline.flows;

                  if (flows && flows.length === 1 && flows[0] === 'UIFlow') {
                    for (var i = 0; i < pipelineFlows.length; i++) {
                      if (pipelineFlows[i].name === 'UIFlow') {
                        this._flows.push(pipelineFlows[i]);

                        break;
                      }
                    }

                    return;
                  }

                  for (var _i = 0; _i < pipelineFlows.length; ++_i) {
                    var f = pipelineFlows[_i];

                    if (f.tag === RenderFlowTag.SCENE || flows && flows.indexOf(f.name) !== -1) {
                      this._flows.push(f);
                    }
                  }
                }
              }, {
                key: "onGlobalPipelineStateChanged",
                value: function onGlobalPipelineStateChanged() {
                  var pipeline = legacyCC.director.root.pipeline;
                  var pipelineFlows = pipeline.flows;

                  for (var i = 0; i < this._flows.length; ++i) {
                    var flow = this._flows[i];

                    for (var j = 0; j < pipelineFlows.length; j++) {
                      if (pipelineFlows[j].name === flow.name) {
                        this._flows[i] = pipelineFlows[j];
                        break;
                      }
                    }
                  }
                }
              }]);

              return RenderView;
            }());

            /**
             * @category pipeline
             */

            /**
             * @zh 前向阶段优先级。
             * @en The priority of stage in forward rendering
             */
            var ForwardStagePriority;
            /**
             * @zh 前向渲染流程优先级。
             * @en The priority of flows in forward rendering
             */

            (function (ForwardStagePriority) {
              ForwardStagePriority[ForwardStagePriority["FORWARD"] = 10] = "FORWARD";
              ForwardStagePriority[ForwardStagePriority["UI"] = 20] = "UI";
            })(ForwardStagePriority || (ForwardStagePriority = {}));

            var ForwardFlowPriority;

            (function (ForwardFlowPriority) {
              ForwardFlowPriority[ForwardFlowPriority["SHADOW"] = 0] = "SHADOW";
              ForwardFlowPriority[ForwardFlowPriority["FORWARD"] = 1] = "FORWARD";
              ForwardFlowPriority[ForwardFlowPriority["UI"] = 10] = "UI";
            })(ForwardFlowPriority || (ForwardFlowPriority = {}));

            /**
             * @en Comparison sorting function. Opaque objects are sorted by priority -> depth front to back -> shader ID.
             * @zh 比较排序函数。不透明对象按优先级 -> 深度由前向后 -> Shader ID 顺序排序。
             */

            function opaqueCompareFn(a, b) {
              return a.hash - b.hash || a.depth - b.depth || a.shaderId - b.shaderId;
            }
            /**
             * @en Comparison sorting function. Transparent objects are sorted by priority -> depth back to front -> shader ID.
             * @zh 比较排序函数。半透明对象按优先级 -> 深度由后向前 -> Shader ID 顺序排序。
             */

            function transparentCompareFn(a, b) {
              return a.hash - b.hash || b.depth - a.depth || a.shaderId - b.shaderId;
            }
            /**
             * @en The render queue. It manages a [[GFXRenderPass]] queue which will be executed by the [[RenderStage]].
             * @zh 渲染队列。它管理一个 [[GFXRenderPass]] 队列，队列中的渲染过程会被 [[RenderStage]] 所执行。
             */

            var RenderQueue$1 = /*#__PURE__*/function () {
              /**
               * @en A cached array of render passes
               * @zh 基于缓存数组的渲染过程队列。
               */

              /**
               * @en Construct a RenderQueue with render queue descriptor
               * @zh 利用渲染队列描述来构造一个 RenderQueue。
               * @param desc Render queue descriptor
               */
              function RenderQueue(desc) {
                _classCallCheck(this, RenderQueue);

                this.queue = void 0;
                this._passDesc = void 0;
                this._passPool = void 0;
                this._passDesc = desc;
                this._passPool = new RecyclePool(function () {
                  return {
                    hash: 0,
                    depth: 0,
                    shaderId: 0,
                    subModel: null,
                    passIdx: 0
                  };
                }, 64);
                this.queue = new CachedArray(64, this._passDesc.sortFunc);
              }
              /**
               * @en Clear the render queue
               * @zh 清空渲染队列。
               */


              _createClass(RenderQueue, [{
                key: "clear",
                value: function clear() {
                  this.queue.clear();

                  this._passPool.reset();
                }
                /**
                 * @en Insert a render pass into the queue
                 * @zh 插入渲染过程。
                 * @param renderObj The render object of the pass
                 * @param modelIdx The model id
                 * @param passIdx The pass id
                 * @returns Whether the new render pass is successfully added
                 */

              }, {
                key: "insertRenderPass",
                value: function insertRenderPass(renderObj, subModelIdx, passIdx) {
                  var subModel = renderObj.model.subModels[subModelIdx];
                  var hPass = SubModelPool.get(subModel.handle, SubModelView.PASS_0 + passIdx);
                  var isTransparent = BlendStatePool.get(PassPool.get(hPass, PassView.BLEND_STATE)).targets[0].blend;

                  if (isTransparent !== this._passDesc.isTransparent || !(PassPool.get(hPass, PassView.PHASE) & this._passDesc.phases)) {
                    return false;
                  }

                  var hash = 0 << 30 | PassPool.get(hPass, PassView.PRIORITY) << 16 | subModel.priority << 8 | passIdx;

                  var rp = this._passPool.add();

                  rp.hash = hash;
                  rp.depth = renderObj.depth || 0;
                  rp.shaderId = SubModelPool.get(subModel.handle, SubModelView.SHADER_0 + passIdx);
                  rp.subModel = subModel;
                  rp.passIdx = passIdx;
                  this.queue.push(rp);
                  return true;
                }
                /**
                 * @en Sort the current queue
                 * @zh 排序渲染队列。
                 */

              }, {
                key: "sort",
                value: function sort() {
                  this.queue.sort();
                }
              }, {
                key: "recordCommandBuffer",
                value: function recordCommandBuffer(device, renderPass, cmdBuff) {
                  for (var i = 0; i < this.queue.length; ++i) {
                    var _this$queue$array$i = this.queue.array[i],
                        subModel = _this$queue$array$i.subModel,
                        passIdx = _this$queue$array$i.passIdx;
                    var inputAssembler = subModel.inputAssembler,
                        hSubModel = subModel.handle;
                    var hPass = SubModelPool.get(hSubModel, SubModelView.PASS_0 + passIdx);
                    var shader = ShaderPool.get(SubModelPool.get(hSubModel, SubModelView.SHADER_0 + passIdx));
                    var pso = PipelineStateManager.getOrCreatePipelineState(device, hPass, shader, renderPass, inputAssembler);
                    cmdBuff.bindPipelineState(pso);
                    cmdBuff.bindDescriptorSet(SetIndex.MATERIAL, DSPool.get(PassPool.get(hPass, PassView.DESCRIPTOR_SET)));
                    cmdBuff.bindDescriptorSet(SetIndex.LOCAL, DSPool.get(SubModelPool.get(hSubModel, SubModelView.DESCRIPTOR_SET)));
                    cmdBuff.bindInputAssembler(inputAssembler);
                    cmdBuff.draw(inputAssembler);
                  }
                }
              }]);

              return RenderQueue;
            }();

            var _dec$x, _dec2$f, _dec3$a, _class$x, _class2$t, _descriptor$s, _class3$9, _temp$v;
            var colors = [];
            /**
             * @en The UI render stage
             * @zh UI渲阶段。
             */

            var UIStage = exports('cO', (_dec$x = ccclass('UIStage'), _dec2$f = type([RenderQueueDesc]), _dec3$a = displayOrder(), _dec$x(_class$x = (_class2$t = (_temp$v = _class3$9 = /*#__PURE__*/function (_RenderStage) {
              _inherits(UIStage, _RenderStage);

              function UIStage() {
                var _getPrototypeOf2;

                var _this;

                _classCallCheck(this, UIStage);

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(UIStage)).call.apply(_getPrototypeOf2, [this].concat(args)));

                _initializerDefineProperty(_this, "renderQueues", _descriptor$s, _assertThisInitialized(_this));

                _this._renderQueues = [];
                _this._renderArea = {
                  x: 0,
                  y: 0,
                  width: 0,
                  height: 0
                };
                return _this;
              }

              _createClass(UIStage, [{
                key: "initialize",
                value: function initialize(info) {
                  _get(_getPrototypeOf(UIStage.prototype), "initialize", this).call(this, info);

                  this.renderQueues = [{
                    isTransparent: true,
                    stages: ['default'],
                    sortMode: RenderQueueSortMode.BACK_TO_FRONT
                  }];
                  return true;
                }
              }, {
                key: "activate",
                value: function activate(pipeline, flow) {
                  _get(_getPrototypeOf(UIStage.prototype), "activate", this).call(this, pipeline, flow);

                  for (var i = 0; i < this.renderQueues.length; i++) {
                    var phase = 0;

                    for (var j = 0; j < this.renderQueues[i].stages.length; j++) {
                      phase |= getPhaseID(this.renderQueues[i].stages[j]);
                    }

                    var sortFunc = opaqueCompareFn;

                    switch (this.renderQueues[i].sortMode) {
                      case RenderQueueSortMode.BACK_TO_FRONT:
                        sortFunc = transparentCompareFn;
                        break;

                      case RenderQueueSortMode.FRONT_TO_BACK:
                        sortFunc = opaqueCompareFn;
                        break;
                    }

                    this._renderQueues[i] = new RenderQueue$1({
                      isTransparent: this.renderQueues[i].isTransparent,
                      phases: phase,
                      sortFunc: sortFunc
                    });
                  }
                }
              }, {
                key: "destroy",
                value: function destroy() {}
              }, {
                key: "render",
                value: function render(view) {
                  var pipeline = this._pipeline;
                  var isHDR = pipeline.isHDR;
                  pipeline.isHDR = false;
                  var device = pipeline.device;

                  this._renderQueues[0].clear();

                  var renderObjects = pipeline.renderObjects;

                  for (var i = 0; i < renderObjects.length; i++) {
                    var ro = renderObjects[i];
                    var subModels = ro.model.subModels;

                    for (var j = 0; j < subModels.length; j++) {
                      var passes = subModels[j].passes;

                      for (var k = 0; k < passes.length; k++) {
                        this._renderQueues[0].insertRenderPass(ro, j, k);
                      }
                    }
                  }

                  this._renderQueues[0].sort();

                  var camera = view.camera;
                  var vp = camera.viewport;
                  this._renderArea.x = vp.x * camera.width;
                  this._renderArea.y = vp.y * camera.height;
                  this._renderArea.width = vp.width * camera.width;
                  this._renderArea.height = vp.height * camera.height;
                  colors[0] = camera.clearColor;
                  var cmdBuff = pipeline.commandBuffers[0];
                  var framebuffer = view.window.framebuffer;
                  var renderPass = framebuffer.colorTextures[0] ? framebuffer.renderPass : pipeline.getRenderPass(camera.clearFlag);
                  cmdBuff.begin();
                  cmdBuff.beginRenderPass(renderPass, framebuffer, this._renderArea, [camera.clearColor], camera.clearDepth, camera.clearStencil);
                  cmdBuff.bindDescriptorSet(SetIndex.GLOBAL, pipeline.descriptorSet);

                  this._renderQueues[0].recordCommandBuffer(device, renderPass, cmdBuff);

                  cmdBuff.endRenderPass();
                  cmdBuff.end();
                  device.queue.submit(pipeline.commandBuffers);
                  pipeline.isHDR = isHDR;
                }
              }]);

              return UIStage;
            }(RenderStage), _class3$9.initInfo = {
              name: 'UIStage',
              priority: ForwardStagePriority.UI
            }, _temp$v), (_descriptor$s = _applyDecoratedDescriptor(_class2$t.prototype, "renderQueues", [_dec2$f, serializable, _dec3$a], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [];
              }
            })), _class2$t)) || _class$x));

            var _dec$y, _class$y, _class2$u, _temp$w;
            var UIFlow = exports('cN', (_dec$y = ccclass('UIFlow'), _dec$y(_class$y = (_temp$w = _class2$u = /*#__PURE__*/function (_RenderFlow) {
              _inherits(UIFlow, _RenderFlow);

              function UIFlow() {
                _classCallCheck(this, UIFlow);

                return _possibleConstructorReturn(this, _getPrototypeOf(UIFlow).apply(this, arguments));
              }

              _createClass(UIFlow, [{
                key: "initialize",
                value: function initialize(info) {
                  _get(_getPrototypeOf(UIFlow.prototype), "initialize", this).call(this, info);

                  var uiStage = new UIStage();
                  uiStage.initialize(UIStage.initInfo);

                  this._stages.push(uiStage);

                  return true;
                }
              }, {
                key: "destroy",
                value: function destroy() {
                  _get(_getPrototypeOf(UIFlow.prototype), "destroy", this).call(this);
                }
              }, {
                key: "render",
                value: function render(view) {
                  var pipeline = this._pipeline;
                  pipeline.updateUBOs(view);

                  _get(_getPrototypeOf(UIFlow.prototype), "render", this).call(this, view);
                }
              }]);

              return UIFlow;
            }(RenderFlow), _class2$u.initInfo = {
              name: 'UIFlow',
              priority: ForwardFlowPriority.UI,
              tag: RenderFlowTag.UI
            }, _temp$w)) || _class$y));

            /**
             * @category pipeline
             */

            /**
             * @en Convert color in SRGB space to linear space
             * @zh SRGB 颜色空间转换为线性空间。
             * @param out Output color object
             * @param gamma Gamma value in SRGB space
             */
            function SRGBToLinear(out, gamma) {
              // out.r = Math.pow(gamma.r, 2.2);
              // out.g = Math.pow(gamma.g, 2.2);
              // out.b = Math.pow(gamma.b, 2.2);
              out.r = gamma.r * gamma.r;
              out.g = gamma.g * gamma.g;
              out.b = gamma.b * gamma.b;
            }

            /**
             * @en The render queue for dynamic batching
             * @zh 渲染合批队列。
             */

            var RenderBatchedQueue = /*#__PURE__*/function () {
              function RenderBatchedQueue() {
                _classCallCheck(this, RenderBatchedQueue);

                this.queue = new Set();
              }

              _createClass(RenderBatchedQueue, [{
                key: "clear",

                /**
                 * @en Clear the render queue
                 * @zh 清空渲染队列。
                 */
                value: function clear() {
                  var it = this.queue.values();
                  var res = it.next();

                  while (!res.done) {
                    res.value.clear();
                    res = it.next();
                  }

                  this.queue.clear();
                }
                /**
                 * @en Record command buffer for the current queue
                 * @zh 记录命令缓冲。
                 * @param cmdBuff The command buffer to store the result
                 */

              }, {
                key: "recordCommandBuffer",
                value: function recordCommandBuffer(device, renderPass, cmdBuff) {
                  // upload buffers
                  var it = this.queue.values();
                  var res = it.next();

                  while (!res.done) {
                    for (var b = 0; b < res.value.batches.length; ++b) {
                      var batch = res.value.batches[b];

                      if (!batch.mergeCount) {
                        continue;
                      }

                      for (var v = 0; v < batch.vbs.length; ++v) {
                        batch.vbs[v].update(batch.vbDatas[v]);
                      }

                      batch.vbIdx.update(batch.vbIdxData.buffer);
                      batch.ubo.update(batch.uboData);
                    }

                    res = it.next();
                  } // draw


                  it = this.queue.values();
                  res = it.next();

                  while (!res.done) {
                    var boundPSO = false;

                    for (var _b = 0; _b < res.value.batches.length; ++_b) {
                      var _batch = res.value.batches[_b];

                      if (!_batch.mergeCount) {
                        continue;
                      }

                      if (!boundPSO) {
                        var shader = ShaderPool.get(_batch.hShader);
                        var pso = PipelineStateManager.getOrCreatePipelineState(device, _batch.hPass, shader, renderPass, _batch.ia);
                        cmdBuff.bindPipelineState(pso);
                        cmdBuff.bindDescriptorSet(SetIndex.MATERIAL, DSPool.get(PassPool.get(_batch.hPass, PassView.DESCRIPTOR_SET)));
                        boundPSO = true;
                      }

                      cmdBuff.bindDescriptorSet(SetIndex.LOCAL, _batch.descriptorSet, res.value.dynamicOffsets);
                      cmdBuff.bindInputAssembler(_batch.ia);
                      cmdBuff.draw(_batch.ia);
                    }

                    res = it.next();
                  }
                }
              }]);

              return RenderBatchedQueue;
            }();

            /**
             * @en Render queue for instanced batching
             * @zh 渲染合批队列。
             */

            var RenderInstancedQueue = /*#__PURE__*/function () {
              function RenderInstancedQueue() {
                _classCallCheck(this, RenderInstancedQueue);

                this.queue = new Set();
              }

              _createClass(RenderInstancedQueue, [{
                key: "clear",

                /**
                 * @en Clear the render queue
                 * @zh 清空渲染队列。
                 */
                value: function clear() {
                  var it = this.queue.values();
                  var res = it.next();

                  while (!res.done) {
                    res.value.clear();
                    res = it.next();
                  }

                  this.queue.clear();
                }
                /**
                 * @en Record command buffer for the current queue
                 * @zh 记录命令缓冲。
                 * @param cmdBuff The command buffer to store the result
                 */

              }, {
                key: "recordCommandBuffer",
                value: function recordCommandBuffer(device, renderPass, cmdBuff) {
                  // upload buffers
                  var it = this.queue.values();
                  var res = it.next();

                  while (!res.done) {
                    if (res.value.hasPendingModels) res.value.uploadBuffers();
                    res = it.next();
                  } // draw


                  it = this.queue.values();
                  res = it.next();

                  while (!res.done) {
                    var _res$value = res.value,
                        instances = _res$value.instances,
                        hPass = _res$value.hPass,
                        hasPendingModels = _res$value.hasPendingModels;

                    if (hasPendingModels) {
                      cmdBuff.bindDescriptorSet(SetIndex.MATERIAL, DSPool.get(PassPool.get(hPass, PassView.DESCRIPTOR_SET)));
                      var lastPSO = null;

                      for (var b = 0; b < instances.length; ++b) {
                        var instance = instances[b];

                        if (!instance.count) {
                          continue;
                        }

                        var shader = ShaderPool.get(instance.hShader);
                        var pso = PipelineStateManager.getOrCreatePipelineState(device, hPass, shader, renderPass, instance.ia);

                        if (lastPSO !== pso) {
                          cmdBuff.bindPipelineState(pso);
                          lastPSO = pso;
                        }

                        cmdBuff.bindDescriptorSet(SetIndex.LOCAL, DSPool.get(instance.hDescriptorSet), res.value.dynamicOffsets);
                        cmdBuff.bindInputAssembler(instance.ia);
                        cmdBuff.draw(instance.ia);
                      }
                    }

                    res = it.next();
                  }
                }
              }]);

              return RenderInstancedQueue;
            }();

            var BatchedBuffer = /*#__PURE__*/function () {
              _createClass(BatchedBuffer, null, [{
                key: "get",
                value: function get(pass) {
                  var extraKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
                  var buffers = BatchedBuffer._buffers;
                  if (!buffers.has(pass)) buffers.set(pass, {});
                  var record = buffers.get(pass);
                  return record[extraKey] || (record[extraKey] = new BatchedBuffer(pass));
                }
              }]);

              function BatchedBuffer(pass) {
                _classCallCheck(this, BatchedBuffer);

                this.batches = [];
                this.dynamicOffsets = [];
                this._device = void 0;
                this._device = pass.device;
              }

              _createClass(BatchedBuffer, [{
                key: "destroy",
                value: function destroy() {
                  for (var i = 0; i < this.batches.length; ++i) {
                    var batch = this.batches[i];

                    for (var j = 0; j < batch.vbs.length; ++j) {
                      batch.vbs[j].destroy();
                    }

                    batch.vbIdx.destroy();
                    batch.ia.destroy();
                    batch.ubo.destroy();
                  }

                  this.batches.length = 0;
                }
              }, {
                key: "merge",
                value: function merge(subModel, passIdx, ro) {
                  var flatBuffers = subModel.subMesh.flatBuffers;

                  if (flatBuffers.length === 0) {
                    return;
                  }

                  var vbSize = 0;
                  var vbIdxSize = 0;
                  var vbCount = flatBuffers[0].count;
                  var hPass = SubModelPool.get(subModel.handle, SubModelView.PASS_0 + passIdx);
                  var hShader = SubModelPool.get(subModel.handle, SubModelView.SHADER_0 + passIdx);
                  var descriptorSet = subModel.descriptorSet;
                  var isBatchExist = false;

                  for (var i = 0; i < this.batches.length; ++i) {
                    var batch = this.batches[i];

                    if (batch.vbs.length === flatBuffers.length && batch.mergeCount < UBOLocalBatched.BATCHING_COUNT) {
                      isBatchExist = true;

                      for (var j = 0; j < batch.vbs.length; ++j) {
                        var vb = batch.vbs[j];

                        if (vb.stride !== flatBuffers[j].stride) {
                          isBatchExist = false;
                          break;
                        }
                      }

                      if (isBatchExist) {
                        for (var _j = 0; _j < batch.vbs.length; ++_j) {
                          var flatBuff = flatBuffers[_j];
                          var batchVB = batch.vbs[_j];
                          var vbBuf = batch.vbDatas[_j];
                          vbSize = (vbCount + batch.vbCount) * flatBuff.stride;

                          if (vbSize > batchVB.size) {
                            batchVB.resize(vbSize);
                            batch.vbDatas[_j] = new Uint8Array(vbSize);

                            batch.vbDatas[_j].set(vbBuf);
                          }

                          batch.vbDatas[_j].set(flatBuff.buffer, batch.vbCount * flatBuff.stride);
                        }

                        var vbIdxBuf = batch.vbIdxData;
                        vbIdxSize = (vbCount + batch.vbCount) * 4;

                        if (vbIdxSize > batch.vbIdx.size) {
                          batch.vbIdx.resize(vbIdxSize);
                          batch.vbIdxData = new Float32Array(vbIdxSize / Float32Array.BYTES_PER_ELEMENT);
                          batch.vbIdxData.set(vbIdxBuf);
                          vbIdxBuf = batch.vbIdxData;
                        }

                        var start = batch.vbCount;
                        var end = start + vbCount;
                        var mergeCount = batch.mergeCount;

                        if (vbIdxBuf[start] !== mergeCount || vbIdxBuf[end - 1] !== mergeCount) {
                          for (var _j2 = start; _j2 < end; _j2++) {
                            vbIdxBuf[_j2] = mergeCount + 0.1; // guard against underflow
                          }
                        } // update world matrix


                        Mat4.toArray(batch.uboData, ro.model.transform.worldMatrix, UBOLocalBatched.MAT_WORLDS_OFFSET + batch.mergeCount * 16);

                        if (!batch.mergeCount) {
                          descriptorSet.bindBuffer(UBOLocalBatched.BLOCK.binding, batch.ubo);
                          descriptorSet.update();
                          batch.hPass = hPass;
                          batch.hShader = hShader;
                          batch.descriptorSet = descriptorSet;
                        }

                        ++batch.mergeCount;
                        batch.vbCount += vbCount;
                        batch.ia.vertexCount += vbCount;
                        return;
                      }
                    }
                  } // Create a new batch


                  var vbs = [];
                  var vbDatas = [];
                  var totalVBs = [];

                  for (var _i = 0; _i < flatBuffers.length; ++_i) {
                    var _flatBuff = flatBuffers[_i];

                    var newVB = this._device.createBuffer({
                      usage: GFXBufferUsageBit.VERTEX | GFXBufferUsageBit.TRANSFER_DST,
                      memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                      size: _flatBuff.count * _flatBuff.stride,
                      stride: _flatBuff.stride
                    });

                    newVB.update(_flatBuff.buffer.buffer);
                    vbs.push(newVB);
                    vbDatas.push(new Uint8Array(newVB.size));
                    totalVBs.push(newVB);
                  }

                  var vbIdx = this._device.createBuffer({
                    usage: GFXBufferUsageBit.VERTEX | GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                    size: vbCount * 4,
                    stride: 4
                  });

                  var vbIdxData = new Float32Array(vbCount);
                  vbIdxData.fill(0);
                  vbIdx.update(vbIdxData);
                  totalVBs.push(vbIdx);
                  var attributes = subModel.inputAssembler.attributes;
                  var attrs = new Array(attributes.length + 1);

                  for (var a = 0; a < attributes.length; ++a) {
                    attrs[a] = attributes[a];
                  }

                  attrs[attributes.length] = {
                    name: 'a_dyn_batch_id',
                    format: GFXFormat.R32F,
                    stream: flatBuffers.length
                  };

                  var ia = this._device.createInputAssembler({
                    attributes: attrs,
                    vertexBuffers: totalVBs
                  });

                  var ubo = this._device.createBuffer({
                    usage: GFXBufferUsageBit.UNIFORM | GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                    size: UBOLocalBatched.SIZE
                  });

                  descriptorSet.bindBuffer(UBOLocalBatched.BLOCK.binding, ubo);
                  descriptorSet.update();
                  var uboData = new Float32Array(UBOLocalBatched.COUNT);
                  Mat4.toArray(uboData, ro.model.transform.worldMatrix, UBOLocalBatched.MAT_WORLDS_OFFSET);
                  this.batches.push({
                    mergeCount: 1,
                    vbs: vbs,
                    vbDatas: vbDatas,
                    vbIdx: vbIdx,
                    vbIdxData: vbIdxData,
                    vbCount: vbCount,
                    ia: ia,
                    ubo: ubo,
                    uboData: uboData,
                    hPass: hPass,
                    hShader: hShader,
                    descriptorSet: descriptorSet
                  });
                }
              }, {
                key: "clear",
                value: function clear() {
                  for (var i = 0; i < this.batches.length; ++i) {
                    var batch = this.batches[i];
                    batch.vbCount = 0;
                    batch.mergeCount = 0;
                    batch.ia.vertexCount = 0;
                  }
                }
              }]);

              return BatchedBuffer;
            }();
            BatchedBuffer._buffers = new Map();

            var _lightPassPool = new Pool(function () {
              return {
                subModel: null,
                passIdx: -1,
                dynamicOffsets: []
              };
            }, 16);

            var _vec4Array = new Float32Array(4);

            var _sphere = sphere.create(0, 0, 0, 1);

            var _dynamicOffsets = [];
            var _lightIndices = [];

            function cullSphereLight(light, model) {
              return !!(model.worldBounds && !intersect.aabb_aabb(model.worldBounds, light.aabb));
            }

            function cullSpotLight(light, model) {
              return !!(model.worldBounds && (!intersect.aabb_aabb(model.worldBounds, light.aabb) || !intersect.aabb_frustum(model.worldBounds, light.frustum)));
            }

            var _phaseID = getPhaseID('forward-add');

            function getLightPassIndex(subModels) {
              for (var j = 0; j < subModels.length; j++) {
                var passes = subModels[j].passes;

                for (var k = 0; k < passes.length; k++) {
                  if (passes[k].phase === _phaseID) {
                    return k;
                  }
                }
              }

              return -1;
            }
            /**
             * @zh 叠加光照队列。
             */


            var RenderAdditiveLightQueue = /*#__PURE__*/function () {
              function RenderAdditiveLightQueue(pipeline) {
                _classCallCheck(this, RenderAdditiveLightQueue);

                this._device = void 0;
                this._validLights = [];
                this._lightPasses = [];
                this._lightBufferCount = 16;
                this._lightBufferStride = void 0;
                this._lightBufferElementCount = void 0;
                this._lightBuffer = void 0;
                this._firstlightBufferView = void 0;
                this._lightBufferData = void 0;
                this._isHDR = void 0;
                this._fpScale = void 0;
                this._renderObjects = void 0;
                this._instancedQueue = void 0;
                this._batchedQueue = void 0;
                this._lightMeterScale = 10000.0;
                this._device = pipeline.device;
                this._isHDR = pipeline.isHDR;
                this._fpScale = pipeline.fpScale;
                this._renderObjects = pipeline.renderObjects;
                this._instancedQueue = new RenderInstancedQueue();
                this._batchedQueue = new RenderBatchedQueue();
                this._lightBufferStride = Math.ceil(UBOForwardLight.SIZE / this._device.uboOffsetAlignment) * this._device.uboOffsetAlignment;
                this._lightBufferElementCount = this._lightBufferStride / Float32Array.BYTES_PER_ELEMENT;
                this._lightBuffer = this._device.createBuffer({
                  memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                  usage: GFXBufferUsageBit.UNIFORM,
                  stride: this._lightBufferStride,
                  size: this._lightBufferStride * this._lightBufferCount
                });
                this._firstlightBufferView = this._device.createBuffer({
                  buffer: this._lightBuffer,
                  offset: 0,
                  range: UBOForwardLight.SIZE
                });
                this._lightBufferData = new Float32Array(this._lightBufferElementCount * this._lightBufferCount);
              }

              _createClass(RenderAdditiveLightQueue, [{
                key: "gatherLightPasses",
                value: function gatherLightPasses(view) {
                  var validLights = this._validLights;
                  var sphereLights = view.camera.scene.sphereLights;

                  this._instancedQueue.clear();

                  this._batchedQueue.clear();

                  validLights.length = 0;

                  for (var i = 0; i < this._lightPasses.length; i++) {
                    var lp = this._lightPasses[i];
                    lp.dynamicOffsets.length = 0;
                  }

                  _lightPassPool.freeArray(this._lightPasses);

                  this._lightPasses.length = 0;

                  for (var _i = 0; _i < sphereLights.length; _i++) {
                    var light = sphereLights[_i];
                    sphere.set(_sphere, light.position.x, light.position.y, light.position.z, light.range);

                    if (intersect.sphere_frustum(_sphere, view.camera.frustum)) {
                      validLights.push(light);
                    }
                  }

                  var spotLights = view.camera.scene.spotLights;

                  for (var _i2 = 0; _i2 < spotLights.length; _i2++) {
                    var _light = spotLights[_i2];
                    sphere.set(_sphere, _light.position.x, _light.position.y, _light.position.z, _light.range);

                    if (intersect.sphere_frustum(_sphere, view.camera.frustum)) {
                      validLights.push(_light);
                    }
                  }

                  if (!validLights.length) return;

                  this._updateUBOs(view);

                  for (var _i3 = 0; _i3 < this._renderObjects.length; _i3++) {
                    var ro = this._renderObjects[_i3];
                    var model = ro.model;
                    var subModels = model.subModels; // this assumes light pass index is the same for all submodels

                    var lightPassIdx = getLightPassIndex(subModels);
                    if (lightPassIdx < 0) continue;
                    _lightIndices.length = 0;

                    for (var l = 0; l < validLights.length; l++) {
                      var _light2 = validLights[l];
                      var isCulled = false;

                      switch (_light2.type) {
                        case LightType.SPHERE:
                          isCulled = cullSphereLight(_light2, model);
                          break;

                        case LightType.SPOT:
                          isCulled = cullSpotLight(_light2, model);
                          break;
                      }

                      if (!isCulled) {
                        _lightIndices.push(l);
                      }
                    }

                    if (!_lightIndices.length) continue;

                    for (var j = 0; j < subModels.length; j++) {
                      var subModel = subModels[j];
                      var pass = subModel.passes[lightPassIdx];
                      var batchingScheme = pass.batchingScheme;
                      subModel.descriptorSet.bindBuffer(UBOForwardLight.BLOCK.binding, this._firstlightBufferView);
                      subModel.descriptorSet.update();

                      if (batchingScheme === BatchingSchemes.INSTANCING) {
                        // instancing
                        for (var _l = 0; _l < _lightIndices.length; _l++) {
                          var idx = _lightIndices[_l];
                          var buffer = InstancedBuffer.get(pass, idx);
                          buffer.merge(subModel, model.instancedAttributes, lightPassIdx);
                          buffer.dynamicOffsets[0] = this._lightBufferStride * idx;

                          this._instancedQueue.queue.add(buffer);
                        }
                      } else if (batchingScheme === BatchingSchemes.VB_MERGING) {
                        // vb-merging
                        for (var _l2 = 0; _l2 < _lightIndices.length; _l2++) {
                          var _idx = _lightIndices[_l2];

                          var _buffer = BatchedBuffer.get(pass, _idx);

                          _buffer.merge(subModel, lightPassIdx, ro);

                          _buffer.dynamicOffsets[0] = this._lightBufferStride * _idx;

                          this._batchedQueue.queue.add(_buffer);
                        }
                      } else {
                        // standard draw
                        var _lp = _lightPassPool.alloc();

                        _lp.subModel = subModel;
                        _lp.passIdx = lightPassIdx;

                        for (var _l3 = 0; _l3 < _lightIndices.length; _l3++) {
                          _lp.dynamicOffsets.push(this._lightBufferStride * _lightIndices[_l3]);
                        }

                        this._lightPasses.push(_lp);
                      }
                    }
                  }
                }
              }, {
                key: "recordCommandBuffer",
                value: function recordCommandBuffer(device, renderPass, cmdBuff) {
                  this._instancedQueue.recordCommandBuffer(device, renderPass, cmdBuff);

                  this._batchedQueue.recordCommandBuffer(device, renderPass, cmdBuff);

                  for (var i = 0; i < this._lightPasses.length; i++) {
                    var _this$_lightPasses$i = this._lightPasses[i],
                        subModel = _this$_lightPasses$i.subModel,
                        passIdx = _this$_lightPasses$i.passIdx,
                        dynamicOffsets = _this$_lightPasses$i.dynamicOffsets;
                    var shader = ShaderPool.get(SubModelPool.get(subModel.handle, SubModelView.SHADER_0 + passIdx));
                    var pass = subModel.passes[passIdx];
                    var ia = subModel.inputAssembler;
                    var pso = PipelineStateManager.getOrCreatePipelineState(device, pass.handle, shader, renderPass, ia);
                    var matDS = DSPool.get(PassPool.get(pass.handle, PassView.DESCRIPTOR_SET));
                    var localDS = subModel.descriptorSet;
                    cmdBuff.bindPipelineState(pso);
                    cmdBuff.bindDescriptorSet(SetIndex.MATERIAL, matDS);
                    cmdBuff.bindInputAssembler(ia);

                    for (var j = 0; j < dynamicOffsets.length; ++j) {
                      _dynamicOffsets[0] = dynamicOffsets[j];
                      cmdBuff.bindDescriptorSet(SetIndex.LOCAL, localDS, _dynamicOffsets);
                      cmdBuff.draw(ia);
                    }
                  }
                }
              }, {
                key: "_updateUBOs",
                value: function _updateUBOs(view) {
                  var exposure = view.camera.exposure;

                  if (this._validLights.length > this._lightBufferCount) {
                    this._firstlightBufferView.destroy();

                    this._lightBufferCount = nextPow2$1(this._validLights.length);

                    this._lightBuffer.resize(this._lightBufferStride * this._lightBufferCount);

                    this._lightBufferData = new Float32Array(this._lightBufferElementCount * this._lightBufferCount);

                    this._firstlightBufferView.initialize({
                      buffer: this._lightBuffer,
                      offset: 0,
                      range: UBOForwardLight.SIZE
                    });
                  }

                  for (var l = 0, offset = 0; l < this._validLights.length; l++, offset += this._lightBufferElementCount) {
                    var light = this._validLights[l];

                    switch (light.type) {
                      case LightType.SPHERE:
                        var sphereLit = light;
                        Vec3.toArray(_vec4Array, sphereLit.position);
                        _vec4Array[3] = 0;

                        this._lightBufferData.set(_vec4Array, offset + UBOForwardLight.LIGHT_POS_OFFSET);

                        _vec4Array[0] = sphereLit.size;
                        _vec4Array[1] = sphereLit.range;
                        _vec4Array[2] = 0.0;

                        this._lightBufferData.set(_vec4Array, offset + UBOForwardLight.LIGHT_SIZE_RANGE_ANGLE_OFFSET);

                        Vec3.toArray(_vec4Array, light.color);

                        if (light.useColorTemperature) {
                          var tempRGB = light.colorTemperatureRGB;
                          _vec4Array[0] *= tempRGB.x;
                          _vec4Array[1] *= tempRGB.y;
                          _vec4Array[2] *= tempRGB.z;
                        }

                        if (this._isHDR) {
                          _vec4Array[3] = sphereLit.luminance * this._fpScale * this._lightMeterScale;
                        } else {
                          _vec4Array[3] = sphereLit.luminance * exposure * this._lightMeterScale;
                        }

                        this._lightBufferData.set(_vec4Array, offset + UBOForwardLight.LIGHT_COLOR_OFFSET);

                        break;

                      case LightType.SPOT:
                        var spotLit = light;
                        Vec3.toArray(_vec4Array, spotLit.position);
                        _vec4Array[3] = 1;

                        this._lightBufferData.set(_vec4Array, offset + UBOForwardLight.LIGHT_POS_OFFSET);

                        _vec4Array[0] = spotLit.size;
                        _vec4Array[1] = spotLit.range;
                        _vec4Array[2] = spotLit.spotAngle;

                        this._lightBufferData.set(_vec4Array, offset + UBOForwardLight.LIGHT_SIZE_RANGE_ANGLE_OFFSET);

                        Vec3.toArray(_vec4Array, spotLit.direction);

                        this._lightBufferData.set(_vec4Array, offset + UBOForwardLight.LIGHT_DIR_OFFSET);

                        Vec3.toArray(_vec4Array, light.color);

                        if (light.useColorTemperature) {
                          var _tempRGB = light.colorTemperatureRGB;
                          _vec4Array[0] *= _tempRGB.x;
                          _vec4Array[1] *= _tempRGB.y;
                          _vec4Array[2] *= _tempRGB.z;
                        }

                        if (this._isHDR) {
                          _vec4Array[3] = spotLit.luminance * this._fpScale * this._lightMeterScale;
                        } else {
                          _vec4Array[3] = spotLit.luminance * exposure * this._lightMeterScale;
                        }

                        this._lightBufferData.set(_vec4Array, offset + UBOForwardLight.LIGHT_COLOR_OFFSET);

                        break;
                    }
                  }

                  this._lightBuffer.update(this._lightBufferData);
                }
              }]);

              return RenderAdditiveLightQueue;
            }();

            var _dec$z, _dec2$g, _dec3$b, _class$z, _class2$v, _descriptor$t, _class3$a, _temp$x;
            var colors$1 = [{
              r: 0,
              g: 0,
              b: 0,
              a: 1
            }];
            /**
             * @en The forward render stage
             * @zh 前向渲染阶段。
             */

            var ForwardStage = exports('cK', (_dec$z = ccclass('ForwardStage'), _dec2$g = type([RenderQueueDesc]), _dec3$b = displayOrder(), _dec$z(_class$z = (_class2$v = (_temp$x = _class3$a = /*#__PURE__*/function (_RenderStage) {
              _inherits(ForwardStage, _RenderStage);

              function ForwardStage() {
                var _this;

                _classCallCheck(this, ForwardStage);

                _this = _possibleConstructorReturn(this, _getPrototypeOf(ForwardStage).call(this));

                _initializerDefineProperty(_this, "renderQueues", _descriptor$t, _assertThisInitialized(_this));

                _this._renderQueues = [];
                _this._renderArea = {
                  x: 0,
                  y: 0,
                  width: 0,
                  height: 0
                };
                _this._batchedQueue = void 0;
                _this._instancedQueue = void 0;
                _this._phaseID = getPhaseID('default');
                _this._batchedQueue = new RenderBatchedQueue();
                _this._instancedQueue = new RenderInstancedQueue();
                return _this;
              }

              _createClass(ForwardStage, [{
                key: "initialize",
                value: function initialize(info) {
                  _get(_getPrototypeOf(ForwardStage.prototype), "initialize", this).call(this, info);

                  this.renderQueues = [{
                    isTransparent: false,
                    sortMode: RenderQueueSortMode.FRONT_TO_BACK,
                    stages: ['default']
                  }, {
                    isTransparent: true,
                    sortMode: RenderQueueSortMode.BACK_TO_FRONT,
                    stages: ['default', 'planarShadow']
                  }];
                  return true;
                }
              }, {
                key: "activate",
                value: function activate(pipeline, flow) {
                  _get(_getPrototypeOf(ForwardStage.prototype), "activate", this).call(this, pipeline, flow);

                  for (var i = 0; i < this.renderQueues.length; i++) {
                    var phase = 0;

                    for (var j = 0; j < this.renderQueues[i].stages.length; j++) {
                      phase |= getPhaseID(this.renderQueues[i].stages[j]);
                    }

                    var sortFunc = opaqueCompareFn;

                    switch (this.renderQueues[i].sortMode) {
                      case RenderQueueSortMode.BACK_TO_FRONT:
                        sortFunc = transparentCompareFn;
                        break;

                      case RenderQueueSortMode.FRONT_TO_BACK:
                        sortFunc = opaqueCompareFn;
                        break;
                    }

                    this._renderQueues[i] = new RenderQueue$1({
                      isTransparent: this.renderQueues[i].isTransparent,
                      phases: phase,
                      sortFunc: sortFunc
                    });
                  }

                  this._additiveLightQueue = new RenderAdditiveLightQueue(this._pipeline);
                }
              }, {
                key: "destroy",
                value: function destroy() {}
              }, {
                key: "render",
                value: function render(view) {
                  this._instancedQueue.clear();

                  this._batchedQueue.clear();

                  var pipeline = this._pipeline;
                  var device = pipeline.device;

                  this._renderQueues.forEach(this.renderQueueClearFunc);

                  var renderObjects = pipeline.renderObjects;
                  var m = 0;
                  var p = 0;
                  var k = 0;

                  for (var i = 0; i < renderObjects.length; ++i) {
                    var ro = renderObjects[i];
                    var subModels = ro.model.subModels;

                    for (m = 0; m < subModels.length; ++m) {
                      var subModel = subModels[m];
                      var passes = subModel.passes;

                      for (p = 0; p < passes.length; ++p) {
                        var pass = passes[p];
                        if (pass.phase !== this._phaseID) continue;
                        var batchingScheme = pass.batchingScheme;

                        if (batchingScheme === BatchingSchemes.INSTANCING) {
                          var instancedBuffer = InstancedBuffer.get(pass);
                          instancedBuffer.merge(subModel, ro.model.instancedAttributes, p);

                          this._instancedQueue.queue.add(instancedBuffer);
                        } else if (batchingScheme === BatchingSchemes.VB_MERGING) {
                          var batchedBuffer = BatchedBuffer.get(pass);
                          batchedBuffer.merge(subModel, p, ro);

                          this._batchedQueue.queue.add(batchedBuffer);
                        } else {
                          for (k = 0; k < this._renderQueues.length; k++) {
                            this._renderQueues[k].insertRenderPass(ro, m, p);
                          }
                        }
                      }
                    }
                  }

                  this._renderQueues.forEach(this.renderQueueSortFunc);

                  this._additiveLightQueue.gatherLightPasses(view);

                  var camera = view.camera;
                  var cmdBuff = pipeline.commandBuffers[0];
                  var vp = camera.viewport;
                  this._renderArea.x = vp.x * camera.width;
                  this._renderArea.y = vp.y * camera.height;
                  this._renderArea.width = vp.width * camera.width * pipeline.shadingScale;
                  this._renderArea.height = vp.height * camera.height * pipeline.shadingScale;

                  if (camera.clearFlag & GFXClearFlag.COLOR) {
                    if (pipeline.isHDR) {
                      SRGBToLinear(colors$1[0], camera.clearColor);
                      var scale = pipeline.fpScale / camera.exposure;
                      colors$1[0].r *= scale;
                      colors$1[0].g *= scale;
                      colors$1[0].b *= scale;
                    } else {
                      colors$1[0].r = camera.clearColor.r;
                      colors$1[0].g = camera.clearColor.g;
                      colors$1[0].b = camera.clearColor.b;
                    }
                  }

                  colors$1[0].a = camera.clearColor.a;
                  var framebuffer = view.window.framebuffer;
                  var renderPass = framebuffer.colorTextures[0] ? framebuffer.renderPass : pipeline.getRenderPass(camera.clearFlag);
                  cmdBuff.begin();
                  cmdBuff.beginRenderPass(renderPass, framebuffer, this._renderArea, colors$1, camera.clearDepth, camera.clearStencil);
                  cmdBuff.bindDescriptorSet(SetIndex.GLOBAL, pipeline.descriptorSet);

                  this._renderQueues[0].recordCommandBuffer(device, renderPass, cmdBuff);

                  this._instancedQueue.recordCommandBuffer(device, renderPass, cmdBuff);

                  this._batchedQueue.recordCommandBuffer(device, renderPass, cmdBuff);

                  this._additiveLightQueue.recordCommandBuffer(device, renderPass, cmdBuff);

                  if (pipeline.shadows.type === ShadowType.Planar) pipeline.shadows.recordCommandBuffer(device, renderPass, cmdBuff);

                  this._renderQueues[1].recordCommandBuffer(device, renderPass, cmdBuff);

                  cmdBuff.endRenderPass();
                  cmdBuff.end();
                  device.queue.submit(pipeline.commandBuffers);
                }
                /**
                 * @en Clear the given render queue
                 * @zh 清空指定的渲染队列
                 * @param rq The render queue
                 */

              }, {
                key: "renderQueueClearFunc",
                value: function renderQueueClearFunc(rq) {
                  rq.clear();
                }
                /**
                 * @en Sort the given render queue
                 * @zh 对指定的渲染队列执行排序
                 * @param rq The render queue
                 */

              }, {
                key: "renderQueueSortFunc",
                value: function renderQueueSortFunc(rq) {
                  rq.sort();
                }
              }]);

              return ForwardStage;
            }(RenderStage), _class3$a.initInfo = {
              name: 'ForwardStage',
              priority: ForwardStagePriority.FORWARD
            }, _temp$x), (_descriptor$t = _applyDecoratedDescriptor(_class2$v.prototype, "renderQueues", [_dec2$g, serializable, _dec3$b], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [];
              }
            })), _class2$v)) || _class$z));

            var _dec$A, _class$A, _class2$w, _temp$y;
            var ForwardFlow = exports('cJ', (_dec$A = ccclass('ForwardFlow'), _dec$A(_class$A = (_temp$y = _class2$w = /*#__PURE__*/function (_RenderFlow) {
              _inherits(ForwardFlow, _RenderFlow);

              function ForwardFlow() {
                _classCallCheck(this, ForwardFlow);

                return _possibleConstructorReturn(this, _getPrototypeOf(ForwardFlow).apply(this, arguments));
              }

              _createClass(ForwardFlow, [{
                key: "initialize",

                /**
                 * @en The shared initialization information of forward render flow
                 * @zh 共享的前向渲染流程初始化参数
                 */
                value: function initialize(info) {
                  _get(_getPrototypeOf(ForwardFlow.prototype), "initialize", this).call(this, info);

                  var forwardStage = new ForwardStage();
                  forwardStage.initialize(ForwardStage.initInfo);

                  this._stages.push(forwardStage);

                  return true;
                }
              }, {
                key: "activate",
                value: function activate(pipeline) {
                  _get(_getPrototypeOf(ForwardFlow.prototype), "activate", this).call(this, pipeline);
                }
              }, {
                key: "render",
                value: function render(view) {
                  var pipeline = this._pipeline;
                  pipeline.updateUBOs(view);

                  _get(_getPrototypeOf(ForwardFlow.prototype), "render", this).call(this, view);
                }
              }, {
                key: "destroy",
                value: function destroy() {
                  _get(_getPrototypeOf(ForwardFlow.prototype), "destroy", this).call(this);
                }
              }]);

              return ForwardFlow;
            }(RenderFlow), _class2$w.initInfo = {
              name: PIPELINE_FLOW_FORWARD,
              priority: ForwardFlowPriority.FORWARD
            }, _temp$y)) || _class$A));

            /**
             * @zh
             * 阴影渲染队列
             */

            var RenderShadowMapBatchedQueue = /*#__PURE__*/function () {
              function RenderShadowMapBatchedQueue() {
                _classCallCheck(this, RenderShadowMapBatchedQueue);

                this._subModelsArray = [];
                this._passArray = [];
                this._shaderArray = [];
                this._shadowMapBuffer = null;
                this._phaseID = getPhaseID('shadow-add');
                this._instancedQueue = new RenderInstancedQueue();
                this._batchedQueue = new RenderBatchedQueue();
              }

              _createClass(RenderShadowMapBatchedQueue, [{
                key: "clear",

                /**
                 * @zh
                 * clear ligth-Batched-Queue
                 */
                value: function clear(shadowMapBuffer) {
                  this._subModelsArray.length = 0;
                  this._shaderArray.length = 0;
                  this._passArray.length = 0;

                  this._instancedQueue.clear();

                  this._batchedQueue.clear();

                  this._shadowMapBuffer = shadowMapBuffer;
                }
              }, {
                key: "add",
                value: function add(renderObj, subModelIdx, passIdx) {
                  var subModel = renderObj.model.subModels[subModelIdx];
                  var pass = subModel.passes[passIdx];

                  if (pass.phase === this._phaseID) {
                    if (this._shadowMapBuffer) {
                      if (pass.batchingScheme === BatchingSchemes.INSTANCING) {
                        // instancing
                        var buffer = InstancedBuffer.get(pass);
                        buffer.merge(subModel, renderObj.model.instancedAttributes, passIdx);

                        this._instancedQueue.queue.add(buffer);
                      } else if (pass.batchingScheme === BatchingSchemes.VB_MERGING) {
                        // vb-merging
                        var _buffer = BatchedBuffer.get(pass);

                        _buffer.merge(subModel, passIdx, renderObj);

                        this._batchedQueue.queue.add(_buffer);
                      } else {
                        // standard draw
                        var shader = ShaderPool.get(SubModelPool.get(subModel.handle, SubModelView.SHADER_0 + passIdx));

                        this._subModelsArray.push(subModel);

                        this._shaderArray.push(shader);

                        this._passArray.push(pass.handle);
                      }
                    } else {
                      this._subModelsArray.length = 0;
                      this._shaderArray.length = 0;
                      this._passArray.length = 0;

                      this._instancedQueue.clear();

                      this._batchedQueue.clear();
                    }
                  }
                }
                /**
                 * @zh
                 * record CommandBuffer
                 */

              }, {
                key: "recordCommandBuffer",
                value: function recordCommandBuffer(device, renderPass, cmdBuff) {
                  this._instancedQueue.recordCommandBuffer(device, renderPass, cmdBuff);

                  this._batchedQueue.recordCommandBuffer(device, renderPass, cmdBuff);

                  for (var i = 0; i < this._subModelsArray.length; ++i) {
                    var subModel = this._subModelsArray[i];
                    var shader = this._shaderArray[i];
                    var hPass = this._passArray[i];
                    var ia = subModel.inputAssembler;
                    var pso = PipelineStateManager.getOrCreatePipelineState(device, hPass, shader, renderPass, ia);
                    var descriptorSet = DSPool.get(PassPool.get(hPass, PassView.DESCRIPTOR_SET));
                    cmdBuff.bindPipelineState(pso);
                    cmdBuff.bindDescriptorSet(SetIndex.MATERIAL, descriptorSet);
                    cmdBuff.bindDescriptorSet(SetIndex.LOCAL, subModel.descriptorSet);
                    cmdBuff.bindInputAssembler(ia);
                    cmdBuff.draw(ia);
                  }
                }
              }]);

              return RenderShadowMapBatchedQueue;
            }();

            var _dec$B, _class$B, _class2$x, _temp$z;
            var colors$2 = [{
              r: 1,
              g: 1,
              b: 1,
              a: 1
            }];
            var bufs = [];
            /**
             * @en Shadow map render stage
             * @zh 阴影渲染阶段。
             */

            var ShadowStage = exports('cM', (_dec$B = ccclass('ShadowStage'), _dec$B(_class$B = (_temp$z = _class2$x = /*#__PURE__*/function (_RenderStage) {
              _inherits(ShadowStage, _RenderStage);

              _createClass(ShadowStage, [{
                key: "setShadowFrameBuffer",

                /**
                 * @en A common initialization info for shadow map render stage
                 * @zh 一个通用的 ShadowStage 的初始化信息对象
                 */

                /**
                 * @en Sets the frame buffer for shadow map
                 * @zh 设置阴影渲染的 FrameBuffer
                 * @param shadowFrameBuffer 
                 */
                value: function setShadowFrameBuffer(shadowFrameBuffer) {
                  this._shadowFrameBuffer = shadowFrameBuffer;
                }
              }]);

              function ShadowStage() {
                var _this;

                _classCallCheck(this, ShadowStage);

                _this = _possibleConstructorReturn(this, _getPrototypeOf(ShadowStage).call(this));
                _this._additiveShadowQueue = void 0;
                _this._shadowFrameBuffer = null;
                _this._renderArea = {
                  x: 0,
                  y: 0,
                  width: 0,
                  height: 0
                };
                _this._additiveShadowQueue = new RenderShadowMapBatchedQueue();
                return _this;
              }

              _createClass(ShadowStage, [{
                key: "destroy",
                value: function destroy() {}
              }, {
                key: "render",
                value: function render(view) {
                  var _view$camera$scene;

                  var pipeline = this._pipeline;
                  var shadowInfo = pipeline.shadows;

                  this._additiveShadowQueue.clear(pipeline.descriptorSet.getBuffer(UBOShadow.BLOCK.binding));

                  if ((_view$camera$scene = view.camera.scene) === null || _view$camera$scene === void 0 ? void 0 : _view$camera$scene.mainLight) {
                    var shadowObjects = pipeline.shadowObjects;
                    var m = 0;
                    var p = 0;

                    for (var i = 0; i < shadowObjects.length; ++i) {
                      var ro = shadowObjects[i];
                      var subModels = ro.model.subModels;

                      for (m = 0; m < subModels.length; m++) {
                        var passes = subModels[m].passes;

                        for (p = 0; p < passes.length; p++) {
                          this._additiveShadowQueue.add(ro, m, p);
                        }
                      }
                    }
                  }

                  var camera = view.camera;
                  var cmdBuff = pipeline.commandBuffers[0];
                  var vp = camera.viewport;
                  var shadowMapSize = shadowInfo.size;
                  this._renderArea.x = vp.x * shadowMapSize.x;
                  this._renderArea.y = vp.y * shadowMapSize.y;
                  this._renderArea.width = vp.width * shadowMapSize.x * pipeline.shadingScale;
                  this._renderArea.height = vp.height * shadowMapSize.y * pipeline.shadingScale;
                  var device = pipeline.device;
                  var renderPass = this._shadowFrameBuffer.renderPass;
                  cmdBuff.begin();
                  cmdBuff.beginRenderPass(renderPass, this._shadowFrameBuffer, this._renderArea, colors$2, camera.clearDepth, camera.clearStencil);
                  cmdBuff.bindDescriptorSet(SetIndex.GLOBAL, pipeline.descriptorSet);

                  this._additiveShadowQueue.recordCommandBuffer(device, renderPass, cmdBuff);

                  cmdBuff.endRenderPass();
                  cmdBuff.end();
                  bufs[0] = cmdBuff;
                  device.queue.submit(bufs);
                }
              }]);

              return ShadowStage;
            }(RenderStage), _class2$x.initInfo = {
              name: 'ShadowStage',
              priority: ForwardStagePriority.FORWARD
            }, _temp$z)) || _class$B));

            var _dec$C, _class$C, _class2$y, _temp$A;
            var _samplerInfo = [GFXFilter.LINEAR, GFXFilter.LINEAR, GFXFilter.NONE, GFXAddress.CLAMP, GFXAddress.CLAMP, GFXAddress.CLAMP];
            /**
             * @en Shadow map render flow
             * @zh 阴影贴图绘制流程
             */

            var ShadowFlow = exports('cL', (_dec$C = ccclass('ShadowFlow'), _dec$C(_class$C = (_temp$A = _class2$y = /*#__PURE__*/function (_RenderFlow) {
              _inherits(ShadowFlow, _RenderFlow);

              function ShadowFlow() {
                var _getPrototypeOf2;

                var _this;

                _classCallCheck(this, ShadowFlow);

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ShadowFlow)).call.apply(_getPrototypeOf2, [this].concat(args)));
                _this._shadowRenderPass = null;
                _this._shadowRenderTargets = [];
                _this._shadowFrameBuffer = null;
                _this._depth = null;
                _this._width = 0;
                _this._height = 0;
                return _this;
              }

              _createClass(ShadowFlow, [{
                key: "initialize",
                value: function initialize(info) {
                  _get(_getPrototypeOf(ShadowFlow.prototype), "initialize", this).call(this, info); // add shadowMap-stages


                  var shadowMapStage = new ShadowStage();
                  shadowMapStage.initialize(ShadowStage.initInfo);

                  this._stages.push(shadowMapStage);

                  return true;
                }
              }, {
                key: "activate",
                value: function activate(pipeline) {
                  _get(_getPrototypeOf(ShadowFlow.prototype), "activate", this).call(this, pipeline);

                  var device = pipeline.device;
                  var shadowMapSize = pipeline.shadows.size;
                  this._width = shadowMapSize.x;
                  this._height = shadowMapSize.y;

                  if (!this._shadowRenderPass) {
                    this._shadowRenderPass = device.createRenderPass({
                      colorAttachments: [{
                        format: GFXFormat.RGBA8,
                        loadOp: GFXLoadOp.CLEAR,
                        // should clear color attachment
                        storeOp: GFXStoreOp.STORE,
                        sampleCount: 1,
                        beginLayout: GFXTextureLayout.UNDEFINED,
                        endLayout: GFXTextureLayout.PRESENT_SRC
                      }],
                      depthStencilAttachment: {
                        format: device.depthStencilFormat,
                        depthLoadOp: GFXLoadOp.CLEAR,
                        depthStoreOp: GFXStoreOp.STORE,
                        stencilLoadOp: GFXLoadOp.CLEAR,
                        stencilStoreOp: GFXStoreOp.STORE,
                        sampleCount: 1,
                        beginLayout: GFXTextureLayout.UNDEFINED,
                        endLayout: GFXTextureLayout.DEPTH_STENCIL_ATTACHMENT_OPTIMAL
                      }
                    });
                  }

                  if (this._shadowRenderTargets.length < 1) {
                    this._shadowRenderTargets.push(device.createTexture({
                      type: GFXTextureType.TEX2D,
                      usage: GFXTextureUsageBit.COLOR_ATTACHMENT | GFXTextureUsageBit.SAMPLED,
                      format: GFXFormat.RGBA8,
                      width: this._width,
                      height: this._height
                    }));
                  }

                  if (!this._depth) {
                    this._depth = device.createTexture({
                      type: GFXTextureType.TEX2D,
                      usage: GFXTextureUsageBit.DEPTH_STENCIL_ATTACHMENT,
                      format: device.depthStencilFormat,
                      width: this._width,
                      height: this._height
                    });
                  }

                  if (!this._shadowFrameBuffer) {
                    this._shadowFrameBuffer = device.createFramebuffer({
                      renderPass: this._shadowRenderPass,
                      colorTextures: this._shadowRenderTargets,
                      depthStencilTexture: this._depth
                    });
                  }

                  for (var i = 0; i < this._stages.length; ++i) {
                    this._stages[i].setShadowFrameBuffer(this._shadowFrameBuffer);
                  }

                  var shadowMapSamplerHash = genSamplerHash(_samplerInfo);
                  var shadowMapSampler = samplerLib.getSampler(device, shadowMapSamplerHash);
                  pipeline.descriptorSet.bindSampler(UNIFORM_SHADOWMAP.binding, shadowMapSampler);
                  pipeline.descriptorSet.bindTexture(UNIFORM_SHADOWMAP.binding, this._shadowRenderTargets[0]);
                }
              }, {
                key: "render",
                value: function render(view) {
                  var pipeline = this._pipeline;
                  var shadowInfo = pipeline.shadows;

                  if (shadowInfo.type !== ShadowType.ShadowMap) {
                    return;
                  }

                  var shadowMapSize = shadowInfo.size;

                  if (this._width !== shadowMapSize.x || this._height !== shadowMapSize.y) {
                    this.resizeShadowMap(shadowMapSize.x, shadowMapSize.y);
                    this._width = shadowMapSize.x;
                    this._height = shadowMapSize.y;
                  }

                  pipeline.updateUBOs(view);

                  _get(_getPrototypeOf(ShadowFlow.prototype), "render", this).call(this, view);
                }
              }, {
                key: "resizeShadowMap",
                value: function resizeShadowMap(width, height) {
                  if (this._depth) {
                    this._depth.resize(width, height);
                  }

                  if (this._shadowRenderTargets.length > 0) {
                    for (var i = 0; i < this._shadowRenderTargets.length; i++) {
                      var renderTarget = this._shadowRenderTargets[i];

                      if (renderTarget) {
                        renderTarget.resize(width, height);
                      }
                    }
                  }

                  if (this._shadowFrameBuffer) {
                    this._shadowFrameBuffer.destroy();

                    this._shadowFrameBuffer.initialize({
                      renderPass: this._shadowRenderPass,
                      colorTextures: this._shadowRenderTargets,
                      depthStencilTexture: this._depth
                    });
                  }
                }
              }, {
                key: "shadowFrameBuffer",

                /**
                 * @en Gets the frame buffer for shadow map
                 * @zh 获取渲染阴影的 Frame Buffer
                 */
                get: function get() {
                  return this._shadowFrameBuffer;
                }
                /**
                 * @en A common initialization info for shadow map render flow
                 * @zh 一个通用的 ShadowFlow 的初始化信息对象
                 */

              }]);

              return ShadowFlow;
            }(RenderFlow), _class2$y.initInfo = {
              name: PIPELINE_FLOW_SHADOW,
              priority: ForwardFlowPriority.SHADOW,
              tag: RenderFlowTag.SCENE
            }, _temp$A)) || _class$C));

            /**
             * @zh
             * 全局雾类型。
             * @en
             * The global fog type
             * @static
             * @enum FogInfo.FogType
             */

            var FogType = Enum({
              /**
               * @zh
               * 线性雾。
               * @en
               * Linear fog
               * @readonly
               */
              LINEAR: 0,

              /**
               * @zh
               * 指数雾。
               * @en
               * Exponential fog
               * @readonly
               */
              EXP: 1,

              /**
               * @zh
               * 指数平方雾。
               * @en
               * Exponential square fog
               * @readonly
               */
              EXP_SQUARED: 2,

              /**
               * @zh
               * 层叠雾。
               * @en
               * Layered fog
               * @readonly
               */
              LAYERED: 3
            });
            var Fog = /*#__PURE__*/function () {
              function Fog() {
                _classCallCheck(this, Fog);

                this._type = FogType.LINEAR;
                this._fogColor = new Color('#C8C8C8');
                this._enabled = false;
                this._fogDensity = 0.3;
                this._fogStart = 0.5;
                this._fogEnd = 300;
                this._fogAtten = 5;
                this._fogTop = 1.5;
                this._fogRange = 1.2;
                this._currType = 0;
                this._colorArray = new Float32Array([0.2, 0.2, 0.2, 1.0]);
              }

              _createClass(Fog, [{
                key: "activate",
                value: function activate() {
                  Color.toArray(this._colorArray, this._fogColor);
                  this._currType = this._enabled ? this._type + 1 : 0;

                  this._updatePipeline();
                }
              }, {
                key: "_updatePipeline",
                value: function _updatePipeline() {
                  var root = legacyCC.director.root;
                  var value = this._currType;
                  var pipeline = root.pipeline;

                  if (pipeline.macros.CC_USE_FOG === value) {
                    return;
                  }

                  pipeline.macros.CC_USE_FOG = value;
                  root.onGlobalPipelineStateChanged();
                }
              }, {
                key: "enabled",

                /**
                 * @zh 是否启用全局雾效
                 * @en Enable global fog
                 */
                set: function set(val) {
                  if (this._enabled === val) {
                    return;
                  }

                  this._enabled = val;

                  if (!val) {
                    this._currType = 0;
                  } else {
                    this._currType = this._type + 1;
                  }

                  this._enabled ? this.activate() : this._updatePipeline();
                },
                get: function get() {
                  return this._enabled;
                }
                /**
                 * @zh 全局雾颜色
                 * @en Global fog color
                 */

              }, {
                key: "fogColor",
                set: function set(val) {
                  this._fogColor.set(val);

                  Color.toArray(this._colorArray, this._fogColor);
                },
                get: function get() {
                  return this._fogColor;
                }
                /**
                 * @zh 全局雾类型
                 * @en Global fog type
                 */

              }, {
                key: "type",
                get: function get() {
                  return this._type;
                },
                set: function set(val) {
                  this._type = val;

                  if (this._enabled) {
                    this._currType = val + 1;

                    this._updatePipeline();
                  }
                }
                /**
                 * @zh 全局雾浓度
                 * @en Global fog density
                 */

              }, {
                key: "fogDensity",
                get: function get() {
                  return this._fogDensity;
                },
                set: function set(val) {
                  this._fogDensity = val;
                }
                /**
                 * @zh 雾效起始位置，只适用于线性雾
                 * @en Global fog start position, only for linear fog
                 */

              }, {
                key: "fogStart",
                get: function get() {
                  return this._fogStart;
                },
                set: function set(val) {
                  this._fogStart = val;
                }
                /**
                 * @zh 雾效结束位置，只适用于线性雾
                 * @en Global fog end position, only for linear fog
                 */

              }, {
                key: "fogEnd",
                get: function get() {
                  return this._fogEnd;
                },
                set: function set(val) {
                  this._fogEnd = val;
                }
                /**
                 * @zh 雾效衰减
                 * @en Global fog attenuation
                 */

              }, {
                key: "fogAtten",
                get: function get() {
                  return this._fogAtten;
                },
                set: function set(val) {
                  this._fogAtten = val;
                }
                /**
                 * @zh 雾效顶部范围，只适用于层级雾
                 * @en Global fog top range, only for layered fog
                 */

              }, {
                key: "fogTop",
                get: function get() {
                  return this._fogTop;
                },
                set: function set(val) {
                  this._fogTop = val;
                }
                /**
                 * @zh 雾效范围，只适用于层级雾
                 * @en Global fog range, only for layered fog
                 */

              }, {
                key: "fogRange",
                get: function get() {
                  return this._fogRange;
                },
                set: function set(val) {
                  this._fogRange = val;
                }
                /**
                 * @zh 当前雾化类型。
                 * @en The current global fog type.
                 * @returns {FogType}
                 * Returns the current global fog type
                 * - 0:Disable global Fog
                 * - 1:Linear fog
                 * - 2:Exponential fog
                 * - 3:Exponential square fog
                 * - 4:Layered fog
                 */

              }, {
                key: "currType",
                get: function get() {
                  return this._currType;
                }
              }, {
                key: "colorArray",
                get: function get() {
                  return this._colorArray;
                }
              }]);

              return Fog;
            }();

            /**
             * @hidden
             */

            var _tempVec3 = new Vec3();

            var roPool = new Pool(function () {
              return {
                model: null,
                depth: 0
              };
            }, 128);
            var shadowPool = new Pool(function () {
              return {
                model: null,
                depth: 0
              };
            }, 128);

            function getRenderObject(model, camera) {
              var depth = 0;

              if (model.node) {
                Vec3.subtract(_tempVec3, model.node.worldPosition, camera.position);
                depth = Vec3.dot(_tempVec3, camera.forward);
              }

              var ro = roPool.alloc();
              ro.model = model;
              ro.depth = depth;
              return ro;
            }

            function getCastShadowRenderObject(model, camera) {
              var depth = 0;

              if (model.node) {
                Vec3.subtract(_tempVec3, model.node.worldPosition, camera.position);
                depth = Vec3.dot(_tempVec3, camera.forward);
              }

              var ro = shadowPool.alloc();
              ro.model = model;
              ro.depth = depth;
              return ro;
            }

            function sceneCulling(pipeline, view) {
              var camera = view.camera;
              var scene = camera.scene;
              var renderObjects = pipeline.renderObjects;
              roPool.freeArray(renderObjects);
              renderObjects.length = 0;
              var shadowObjects = pipeline.shadowObjects;
              shadowPool.freeArray(shadowObjects);
              shadowObjects.length = 0;
              var mainLight = scene.mainLight;
              var shadows = pipeline.shadows;
              var shadowSphere = shadows.sphere;
              shadowSphere.center.set(0.0, 0.0, 0.0);
              shadowSphere.radius = 0.01;

              if (mainLight) {
                mainLight.update();

                if (shadows.type === ShadowType.Planar) {
                  shadows.updateDirLight(mainLight);
                }
              }

              if (pipeline.skybox.enabled && pipeline.skybox.model && camera.clearFlag & SKYBOX_FLAG) {
                renderObjects.push(getRenderObject(pipeline.skybox.model, camera));
              }

              var models = scene.models;

              for (var i = 0; i < models.length; i++) {
                var model = models[i]; // filter model by view visibility

                if (model.enabled) {
                  var vis = view.visibility & Layers.BitMask.UI_2D;

                  if (vis) {
                    if (model.node && view.visibility === model.node.layer || view.visibility === model.visFlags) {
                      renderObjects.push(getRenderObject(model, camera));
                    }
                  } else {
                    if (model.node && (view.visibility & model.node.layer) === model.node.layer || view.visibility & model.visFlags) {
                      // shadow render Object
                      if (model.castShadow) {
                        sphere.mergeAABB(shadowSphere, shadowSphere, model.worldBounds);
                        shadowObjects.push(getCastShadowRenderObject(model, camera));
                      } // frustum culling


                      if (model.worldBounds && !intersect.aabb_frustum(model.worldBounds, camera.frustum)) {
                        continue;
                      }

                      renderObjects.push(getRenderObject(model, camera));
                    }
                  }
                }
              }

              if (shadows.type === ShadowType.Planar) {
                shadows.updateShadowList(scene, camera.frustum, (camera.visibility & Layers.BitMask.DEFAULT) !== 0);
              }
            }

            var _dec$D, _dec2$h, _dec3$c, _dec4$8, _dec5$5, _class$D, _class2$z, _descriptor$u, _descriptor2$m, _temp$B;
            var matShadowView = new Mat4();
            var matShadowViewProj = new Mat4();
            var vec4 = new Vec4();
            /**
             * @en The forward render pipeline
             * @zh 前向渲染管线。
             */

            var ForwardPipeline = exports('cI', (_dec$D = ccclass('ForwardPipeline'), _dec2$h = type([RenderTextureConfig]), _dec3$c = displayOrder(), _dec4$8 = type([MaterialConfig]), _dec5$5 = displayOrder(), _dec$D(_class$D = (_class2$z = (_temp$B = /*#__PURE__*/function (_RenderPipeline) {
              _inherits(ForwardPipeline, _RenderPipeline);

              function ForwardPipeline() {
                var _getPrototypeOf2;

                var _this;

                _classCallCheck(this, ForwardPipeline);

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(ForwardPipeline)).call.apply(_getPrototypeOf2, [this].concat(args)));

                _initializerDefineProperty(_this, "renderTextures", _descriptor$u, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "materials", _descriptor2$m, _assertThisInitialized(_this));

                _this.fog = new Fog();
                _this.ambient = new Ambient();
                _this.skybox = new Skybox();
                _this.shadows = new Shadows();
                _this.renderObjects = [];
                _this.shadowObjects = [];
                _this._isHDR = false;
                _this._shadingScale = 1.0;
                _this._fpScale = 1.0 / 1024.0;
                _this._renderPasses = new Map();
                _this._globalUBO = new Float32Array(UBOGlobal.COUNT);
                _this._shadowUBO = new Float32Array(UBOShadow.COUNT);
                return _this;
              }

              _createClass(ForwardPipeline, [{
                key: "initialize",
                value: function initialize(info) {
                  _get(_getPrototypeOf(ForwardPipeline.prototype), "initialize", this).call(this, info);

                  var shadowFlow = new ShadowFlow();
                  shadowFlow.initialize(ShadowFlow.initInfo);

                  this._flows.push(shadowFlow);

                  var forwardFlow = new ForwardFlow();
                  forwardFlow.initialize(ForwardFlow.initInfo);

                  this._flows.push(forwardFlow);

                  var uiFlow = new UIFlow();
                  uiFlow.initialize(UIFlow.initInfo);

                  this._flows.push(uiFlow);

                  return true;
                }
              }, {
                key: "activate",
                value: function activate() {
                  this._globalDescriptorSetLayout = globalDescriptorSetLayout;
                  this._localDescriptorSetLayout = localDescriptorSetLayout;
                  this._macros = {};

                  if (!_get(_getPrototypeOf(ForwardPipeline.prototype), "activate", this).call(this)) {
                    return false;
                  }

                  if (!this._activeRenderer()) {
                    console.error('ForwardPipeline startup failed!');
                    return false;
                  }

                  return true;
                }
              }, {
                key: "render",
                value: function render(views) {
                  for (var i = 0; i < views.length; i++) {
                    var view = views[i];
                    sceneCulling(this, view);

                    for (var j = 0; j < view.flows.length; j++) {
                      view.flows[j].render(view);
                    }
                  }
                }
              }, {
                key: "getRenderPass",
                value: function getRenderPass(clearFlags) {
                  var renderPass = this._renderPasses.get(clearFlags);

                  if (renderPass) {
                    return renderPass;
                  }

                  var device = this.device;
                  var colorAttachment = new GFXColorAttachment();
                  var depthStencilAttachment = new GFXDepthStencilAttachment();
                  colorAttachment.format = device.colorFormat;
                  depthStencilAttachment.format = device.depthStencilFormat;

                  if (!(clearFlags & GFXClearFlag.COLOR)) {
                    if (clearFlags & SKYBOX_FLAG) {
                      colorAttachment.loadOp = GFXLoadOp.DISCARD;
                    } else {
                      colorAttachment.loadOp = GFXLoadOp.LOAD;
                      colorAttachment.beginLayout = GFXTextureLayout.PRESENT_SRC;
                    }
                  }

                  if ((clearFlags & GFXClearFlag.DEPTH_STENCIL) !== GFXClearFlag.DEPTH_STENCIL) {
                    if (!(clearFlags & GFXClearFlag.DEPTH)) depthStencilAttachment.depthLoadOp = GFXLoadOp.LOAD;
                    if (!(clearFlags & GFXClearFlag.STENCIL)) depthStencilAttachment.stencilLoadOp = GFXLoadOp.LOAD;
                    depthStencilAttachment.beginLayout = GFXTextureLayout.DEPTH_STENCIL_ATTACHMENT_OPTIMAL;
                  }

                  renderPass = device.createRenderPass({
                    colorAttachments: [colorAttachment],
                    depthStencilAttachment: depthStencilAttachment
                  });

                  this._renderPasses.set(clearFlags, renderPass);

                  return renderPass;
                }
                /**
                 * @en Update all UBOs
                 * @zh 更新全部 UBO。
                 */

              }, {
                key: "updateUBOs",
                value: function updateUBOs(view) {
                  this._updateUBO(view);

                  var mainLight = view.camera.scene.mainLight;
                  var device = this.device;
                  var shadowInfo = this.shadows;

                  if (mainLight && shadowInfo.type === ShadowType.ShadowMap) {
                    // light view
                    var shadowCameraView = mainLight.node.getWorldMatrix();
                    Mat4.invert(matShadowView, shadowCameraView); // light proj

                    var x = shadowInfo.orthoSize * shadowInfo.aspect;
                    var y = shadowInfo.orthoSize;
                    var projectionSignY = device.screenSpaceSignY * device.UVSpaceSignY; // always offscreen

                    Mat4.ortho(matShadowViewProj, -x, x, -y, y, shadowInfo.near, shadowInfo.far, device.clipSpaceMinZ, projectionSignY); // light viewProj

                    Mat4.multiply(matShadowViewProj, matShadowViewProj, matShadowView);
                    Mat4.toArray(this._shadowUBO, matShadowViewProj, UBOShadow.MAT_LIGHT_VIEW_PROJ_OFFSET);
                    vec4.set(shadowInfo.pcf);
                    Vec4.toArray(this._shadowUBO, vec4, UBOShadow.SHADOW_PCF_OFFSET);
                    vec4.set(shadowInfo.size.x, shadowInfo.size.y);
                    Vec4.toArray(this._shadowUBO, vec4, UBOShadow.SHADOW_SIZE_OFFSET);
                  } // update ubos


                  this._descriptorSet.getBuffer(UBOGlobal.BLOCK.binding).update(this._globalUBO);

                  this._descriptorSet.getBuffer(UBOShadow.BLOCK.binding).update(this._shadowUBO);
                }
              }, {
                key: "_activeRenderer",
                value: function _activeRenderer() {
                  var device = this.device;

                  this._commandBuffers.push(device.createCommandBuffer({
                    type: GFXCommandBufferType.PRIMARY,
                    queue: this._device.queue
                  }));

                  var globalUBO = device.createBuffer({
                    usage: GFXBufferUsageBit.UNIFORM | GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                    size: UBOGlobal.SIZE
                  });

                  this._descriptorSet.bindBuffer(UBOGlobal.BLOCK.binding, globalUBO);

                  var shadowUBO = device.createBuffer({
                    usage: GFXBufferUsageBit.UNIFORM | GFXBufferUsageBit.TRANSFER_DST,
                    memUsage: GFXMemoryUsageBit.HOST | GFXMemoryUsageBit.DEVICE,
                    size: UBOShadow.SIZE
                  });

                  this._descriptorSet.bindBuffer(UBOShadow.BLOCK.binding, shadowUBO); // update global defines when all states initialized.


                  this.macros.CC_USE_HDR = this._isHDR;
                  this.macros.CC_SUPPORT_FLOAT_TEXTURE = this.device.hasFeature(GFXFeature.TEXTURE_FLOAT);
                  return true;
                }
              }, {
                key: "_updateUBO",
                value: function _updateUBO(view) {
                  this._descriptorSet.update();

                  var root = legacyCC.director.root;
                  var camera = view.camera;
                  var scene = camera.scene;
                  var mainLight = scene.mainLight;
                  var ambient = this.ambient;
                  var fog = this.fog;
                  var fv = this._globalUBO;
                  var device = this.device;
                  var shadingWidth = Math.floor(device.width);
                  var shadingHeight = Math.floor(device.height); // update UBOGlobal

                  fv[UBOGlobal.TIME_OFFSET] = root.cumulativeTime;
                  fv[UBOGlobal.TIME_OFFSET + 1] = root.frameTime;
                  fv[UBOGlobal.TIME_OFFSET + 2] = legacyCC.director.getTotalFrames();
                  fv[UBOGlobal.SCREEN_SIZE_OFFSET] = device.width;
                  fv[UBOGlobal.SCREEN_SIZE_OFFSET + 1] = device.height;
                  fv[UBOGlobal.SCREEN_SIZE_OFFSET + 2] = 1.0 / fv[UBOGlobal.SCREEN_SIZE_OFFSET];
                  fv[UBOGlobal.SCREEN_SIZE_OFFSET + 3] = 1.0 / fv[UBOGlobal.SCREEN_SIZE_OFFSET + 1];
                  fv[UBOGlobal.SCREEN_SCALE_OFFSET] = camera.width / shadingWidth * this.shadingScale;
                  fv[UBOGlobal.SCREEN_SCALE_OFFSET + 1] = camera.height / shadingHeight * this.shadingScale;
                  fv[UBOGlobal.SCREEN_SCALE_OFFSET + 2] = 1.0 / fv[UBOGlobal.SCREEN_SCALE_OFFSET];
                  fv[UBOGlobal.SCREEN_SCALE_OFFSET + 3] = 1.0 / fv[UBOGlobal.SCREEN_SCALE_OFFSET + 1];
                  fv[UBOGlobal.NATIVE_SIZE_OFFSET] = shadingWidth;
                  fv[UBOGlobal.NATIVE_SIZE_OFFSET + 1] = shadingHeight;
                  fv[UBOGlobal.NATIVE_SIZE_OFFSET + 2] = 1.0 / fv[UBOGlobal.NATIVE_SIZE_OFFSET];
                  fv[UBOGlobal.NATIVE_SIZE_OFFSET + 3] = 1.0 / fv[UBOGlobal.NATIVE_SIZE_OFFSET + 1];
                  Mat4.toArray(fv, camera.matView, UBOGlobal.MAT_VIEW_OFFSET);
                  Mat4.toArray(fv, camera.node.worldMatrix, UBOGlobal.MAT_VIEW_INV_OFFSET);
                  Mat4.toArray(fv, camera.matProj, UBOGlobal.MAT_PROJ_OFFSET);
                  Mat4.toArray(fv, camera.matProjInv, UBOGlobal.MAT_PROJ_INV_OFFSET);
                  Mat4.toArray(fv, camera.matViewProj, UBOGlobal.MAT_VIEW_PROJ_OFFSET);
                  Mat4.toArray(fv, camera.matViewProjInv, UBOGlobal.MAT_VIEW_PROJ_INV_OFFSET);
                  Vec3.toArray(fv, camera.position, UBOGlobal.CAMERA_POS_OFFSET);
                  var projectionSignY = device.screenSpaceSignY;

                  if (view.window.hasOffScreenAttachments) {
                    projectionSignY *= device.UVSpaceSignY; // need flipping if drawing on render targets
                  }

                  fv[UBOGlobal.CAMERA_POS_OFFSET + 3] = projectionSignY;
                  var exposure = camera.exposure;
                  fv[UBOGlobal.EXPOSURE_OFFSET] = exposure;
                  fv[UBOGlobal.EXPOSURE_OFFSET + 1] = 1.0 / exposure;
                  fv[UBOGlobal.EXPOSURE_OFFSET + 2] = this._isHDR ? 1.0 : 0.0;
                  fv[UBOGlobal.EXPOSURE_OFFSET + 3] = this._fpScale / exposure;

                  if (mainLight) {
                    Vec3.toArray(fv, mainLight.direction, UBOGlobal.MAIN_LIT_DIR_OFFSET);
                    Vec3.toArray(fv, mainLight.color, UBOGlobal.MAIN_LIT_COLOR_OFFSET);

                    if (mainLight.useColorTemperature) {
                      var colorTempRGB = mainLight.colorTemperatureRGB;
                      fv[UBOGlobal.MAIN_LIT_COLOR_OFFSET] *= colorTempRGB.x;
                      fv[UBOGlobal.MAIN_LIT_COLOR_OFFSET + 1] *= colorTempRGB.y;
                      fv[UBOGlobal.MAIN_LIT_COLOR_OFFSET + 2] *= colorTempRGB.z;
                    }

                    if (this._isHDR) {
                      fv[UBOGlobal.MAIN_LIT_COLOR_OFFSET + 3] = mainLight.illuminance * this._fpScale;
                    } else {
                      fv[UBOGlobal.MAIN_LIT_COLOR_OFFSET + 3] = mainLight.illuminance * exposure;
                    }
                  } else {
                    Vec3.toArray(fv, Vec3.UNIT_Z, UBOGlobal.MAIN_LIT_DIR_OFFSET);
                    Vec4.toArray(fv, Vec4.ZERO, UBOGlobal.MAIN_LIT_COLOR_OFFSET);
                  }

                  var skyColor = ambient.colorArray;

                  if (this._isHDR) {
                    skyColor[3] = ambient.skyIllum * this._fpScale;
                  } else {
                    skyColor[3] = ambient.skyIllum * exposure;
                  }

                  fv.set(skyColor, UBOGlobal.AMBIENT_SKY_OFFSET);
                  fv.set(ambient.albedoArray, UBOGlobal.AMBIENT_GROUND_OFFSET);

                  if (fog.enabled) {
                    fv.set(fog.colorArray, UBOGlobal.GLOBAL_FOG_COLOR_OFFSET);
                    fv[UBOGlobal.GLOBAL_FOG_BASE_OFFSET] = fog.fogStart;
                    fv[UBOGlobal.GLOBAL_FOG_BASE_OFFSET + 1] = fog.fogEnd;
                    fv[UBOGlobal.GLOBAL_FOG_BASE_OFFSET + 2] = fog.fogDensity;
                    fv[UBOGlobal.GLOBAL_FOG_ADD_OFFSET] = fog.fogTop;
                    fv[UBOGlobal.GLOBAL_FOG_ADD_OFFSET + 1] = fog.fogRange;
                    fv[UBOGlobal.GLOBAL_FOG_ADD_OFFSET + 2] = fog.fogAtten;
                  }
                }
              }, {
                key: "destroyUBOs",
                value: function destroyUBOs() {
                  if (this._descriptorSet) {
                    this._descriptorSet.getBuffer(UBOGlobal.BLOCK.binding).destroy();

                    this._descriptorSet.getBuffer(UBOShadow.BLOCK.binding).destroy();
                  }
                }
              }, {
                key: "destroy",
                value: function destroy() {
                  this.destroyUBOs();

                  var rpIter = this._renderPasses.values();

                  var rpRes = rpIter.next();

                  while (!rpRes.done) {
                    rpRes.value.destroy();
                    rpRes = rpIter.next();
                  }

                  return _get(_getPrototypeOf(ForwardPipeline.prototype), "destroy", this).call(this);
                }
              }, {
                key: "isHDR",
                get: function get() {
                  return this._isHDR;
                },
                set: function set(val) {
                  if (this._isHDR === val) {
                    return;
                  }

                  this._isHDR = val;
                  var defaultGlobalUBOData = this._globalUBO;
                  defaultGlobalUBOData[UBOGlobal.EXPOSURE_OFFSET + 2] = this._isHDR ? 1.0 : 0.0;
                }
              }, {
                key: "shadingScale",
                get: function get() {
                  return this._shadingScale;
                }
              }, {
                key: "fpScale",
                get: function get() {
                  return this._fpScale;
                }
                /**
                 * @en Get shadow UBO.
                 * @zh 获取阴影UBO。
                 */

              }, {
                key: "shadowUBO",
                get: function get() {
                  return this._shadowUBO;
                }
              }]);

              return ForwardPipeline;
            }(RenderPipeline), _temp$B), (_descriptor$u = _applyDecoratedDescriptor(_class2$z.prototype, "renderTextures", [_dec2$h, serializable, _dec3$c], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [];
              }
            }), _descriptor2$m = _applyDecoratedDescriptor(_class2$z.prototype, "materials", [_dec4$8, serializable, _dec5$5], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return [];
              }
            })), _class2$z)) || _class$D));

            var _vec2$1 = new Vec2();
            /**
             * @en The touch point class
             * @zh 封装了触点相关的信息。
             */


            var Touch = exports('bf', /*#__PURE__*/function () {
              _createClass(Touch, [{
                key: "lastModified",
                get: function get() {
                  return this._lastModified;
                }
                /**
                 * @param x - x position of the touch point
                 * @param y - y position of the touch point
                 * @param id - The id of the touch point
                 */

              }]);

              function Touch(x, y) {
                var id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

                _classCallCheck(this, Touch);

                this._point = new Vec2();
                this._prevPoint = new Vec2();
                this._lastModified = 0;
                this._id = 0;
                this._startPoint = new Vec2();
                this._startPointCaptured = false;
                this.setTouchInfo(id, x, y);
              }
              /**
               * @en Returns the current touch location in OpenGL coordinates.、
               * @zh 获取当前触点位置。
               * @param out - Pass the out object to avoid object creation, very good practice
               */


              _createClass(Touch, [{
                key: "getLocation",
                value: function getLocation(out) {
                  if (!out) {
                    out = new Vec2();
                  }

                  out.set(this._point.x, this._point.y);
                  return out;
                }
                /**
                 * @en Returns X axis location value.
                 * @zh 获取当前触点 X 轴位置。
                 */

              }, {
                key: "getLocationX",
                value: function getLocationX() {
                  return this._point.x;
                }
                /**
                 * @en Returns Y axis location value.
                 * @zh 获取当前触点 Y 轴位置。
                 */

              }, {
                key: "getLocationY",
                value: function getLocationY() {
                  return this._point.y;
                }
                /**
                 * @en Returns the current touch location in UI coordinates.、
                 * @zh 获取当前触点在 UI 坐标系中的位置。
                 * @param out - Pass the out object to avoid object creation, very good practice
                 */

              }, {
                key: "getUILocation",
                value: function getUILocation(out) {
                  if (!out) {
                    out = new Vec2();
                  }

                  out.set(this._point.x, this._point.y);

                  legacyCC.view._convertPointWithScale(out);

                  return out;
                }
                /**
                 * @en Returns X axis location value in UI coordinates.
                 * @zh 获取当前触点在 UI 坐标系中 X 轴位置。
                 */

              }, {
                key: "getUILocationX",
                value: function getUILocationX() {
                  var viewport = legacyCC.view.getViewportRect();
                  return (this._point.x - viewport.x) / legacyCC.view.getScaleX();
                }
                /**
                 * @en Returns Y axis location value in UI coordinates.
                 * @zh 获取当前触点在 UI 坐标系中 Y 轴位置。
                 */

              }, {
                key: "getUILocationY",
                value: function getUILocationY() {
                  var viewport = legacyCC.view.getViewportRect();
                  return (this._point.y - viewport.y) / legacyCC.view.getScaleY();
                }
                /**
                 * @en Returns the previous touch location.
                 * @zh 获取触点在上一次事件时的位置对象，对象包含 x 和 y 属性。
                 * @param out - Pass the out object to avoid object creation, very good practice
                 */

              }, {
                key: "getPreviousLocation",
                value: function getPreviousLocation(out) {
                  if (!out) {
                    out = new Vec2();
                  }

                  out.set(this._prevPoint.x, this._prevPoint.y);
                  return out;
                }
                /**
                 * @en Returns the previous touch location in UI coordinates.
                 * @zh 获取触点在上一次事件时在 UI 坐标系中的位置对象，对象包含 x 和 y 属性。
                 * @param out - Pass the out object to avoid object creation, very good practice
                 */

              }, {
                key: "getUIPreviousLocation",
                value: function getUIPreviousLocation(out) {
                  if (!out) {
                    out = new Vec2();
                  }

                  out.set(this._prevPoint.x, this._prevPoint.y);

                  legacyCC.view._convertPointWithScale(out);

                  return out;
                }
                /**
                 * @en Returns the start touch location.
                 * @zh 获获取触点落下时的位置对象，对象包含 x 和 y 属性。
                 * @param out - Pass the out object to avoid object creation, very good practice
                 */

              }, {
                key: "getStartLocation",
                value: function getStartLocation(out) {
                  if (!out) {
                    out = new Vec2();
                  }

                  out.set(this._startPoint.x, this._startPoint.y);
                  return out;
                }
                /**
                 * @en Returns the start touch location in UI coordinates.
                 * @zh 获获取触点落下时在 UI 坐标系中的位置对象，对象包含 x 和 y 属性。
                 * @param out - Pass the out object to avoid object creation, very good practice
                 */

              }, {
                key: "getUIStartLocation",
                value: function getUIStartLocation(out) {
                  if (!out) {
                    out = new Vec2();
                  }

                  out.set(this._startPoint.x, this._startPoint.y);

                  legacyCC.view._convertPointWithScale(out);

                  return out;
                }
                /**
                 * @en Returns the delta distance from the previous touche to the current one.
                 * @zh 获取触点距离上一次事件移动的距离对象，对象包含 x 和 y 属性。
                 * @param out - Pass the out object to avoid object creation, very good practice
                 */

              }, {
                key: "getDelta",
                value: function getDelta(out) {
                  if (!out) {
                    out = new Vec2();
                  }

                  out.set(this._point);
                  out.subtract(this._prevPoint);
                  return out;
                }
                /**
                 * @en Returns the delta distance from the previous touche to the current one in UI coordinates.
                 * @zh 获取触点距离上一次事件移动在 UI 坐标系中的距离对象，对象包含 x 和 y 属性。
                 * @param out - Pass the out object to avoid object creation, very good practice
                 */

              }, {
                key: "getUIDelta",
                value: function getUIDelta(out) {
                  if (!out) {
                    out = new Vec2();
                  }

                  _vec2$1.set(this._point);

                  _vec2$1.subtract(this._prevPoint);

                  out.set(legacyCC.view.getScaleX(), legacyCC.view.getScaleY());
                  Vec2.divide(out, _vec2$1, out);
                  return out;
                }
                /**
                 * @en Returns the current touch location in screen coordinates.
                 * @zh 获取当前事件在游戏窗口内的坐标位置对象，对象包含 x 和 y 属性。
                 * @param out - Pass the out object to avoid object creation, very good practice
                 */

              }, {
                key: "getLocationInView",
                value: function getLocationInView(out) {
                  if (!out) {
                    out = new Vec2();
                  }

                  out.set(this._point.x, legacyCC.view._designResolutionSize.height - this._point.y);
                  return out;
                }
                /**
                 * @en Returns the previous touch location in screen coordinates.
                 * @zh 获取触点在上一次事件时在游戏窗口中的位置对象，对象包含 x 和 y 属性。
                 * @param out - Pass the out object to avoid object creation, very good practice
                 */

              }, {
                key: "getPreviousLocationInView",
                value: function getPreviousLocationInView(out) {
                  if (!out) {
                    out = new Vec2();
                  }

                  out.set(this._prevPoint.x, legacyCC.view._designResolutionSize.height - this._prevPoint.y);
                  return out;
                }
                /**
                 * @en Returns the start touch location in screen coordinates.
                 * @zh 获取触点落下时在游戏窗口中的位置对象，对象包含 x 和 y 属性。
                 * @param out - Pass the out object to avoid object creation, very good practice
                 */

              }, {
                key: "getStartLocationInView",
                value: function getStartLocationInView(out) {
                  if (!out) {
                    out = new Vec2();
                  }

                  out.set(this._startPoint.x, legacyCC.view._designResolutionSize.height - this._startPoint.y);
                  return out;
                }
                /**
                 * @en Returns the id of the touch point.
                 * @zh 触点的标识 ID，可以用来在多点触摸中跟踪触点。
                 */

              }, {
                key: "getID",
                value: function getID() {
                  return this._id;
                }
                /**
                 * @en Resets touch point information.
                 * @zh 重置触点相关的信息。
                 * @param id - The id of the touch point
                 * @param x - x position of the touch point
                 * @param y - y position of the touch point
                 */

              }, {
                key: "setTouchInfo",
                value: function setTouchInfo() {
                  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
                  var x = arguments.length > 1 ? arguments[1] : undefined;
                  var y = arguments.length > 2 ? arguments[2] : undefined;
                  this._prevPoint = this._point;
                  this._point = new Vec2(x || 0, y || 0);
                  this._id = id;

                  if (!this._startPointCaptured) {
                    this._startPoint = new Vec2(this._point); // cc.view._convertPointWithScale(this._startPoint);

                    this._startPointCaptured = true;
                  }
                }
                /**
                 * @en Sets touch point location.
                 * @zh 设置触点位置。
                 * @param point - The location
                 */

              }, {
                key: "setPoint",
                value: function setPoint(x, y) {
                  if (_typeof(x) === 'object') {
                    this._point.x = x.x;
                    this._point.y = x.y;
                  } else {
                    this._point.x = x || 0;
                    this._point.y = y || 0;
                  }

                  this._lastModified = legacyCC.director.getCurrentTime();
                }
                /**
                 * @en Sets the location previously registered for the current touch.
                 * @zh 设置触点在前一次触发时收集的位置。
                 * @param point - The location
                 */

              }, {
                key: "setPrevPoint",
                value: function setPrevPoint(x, y) {
                  if (_typeof(x) === 'object') {
                    this._prevPoint = new Vec2(x.x, x.y);
                  } else {
                    this._prevPoint = new Vec2(x || 0, y || 0);
                  }

                  this._lastModified = legacyCC.director.getCurrentTime();
                }
              }]);

              return Touch;
            }());
            legacyCC.Touch = Touch;

            var TOUCH_TIMEOUT = macro.TOUCH_TIMEOUT;
            var LANDSCAPE_LEFT = -90;
            var PORTRAIT_UPSIDE_DOWN = 180;
            var LANDSCAPE_RIGHT = 90;

            var _didAccelerateFun;

            var _vec2$2 = new Vec2();

            var _preLocation = new Vec2();

            /**
             * @en the device accelerometer reports values for each axis in units of g-force.
             * @zh 设备重力传感器传递的各个轴的数据。
             */
            var Acceleration$1 = exports('ba', function Acceleration() {
              var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
              var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
              var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
              var timestamp = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

              _classCallCheck(this, Acceleration);

              this.x = void 0;
              this.y = void 0;
              this.z = void 0;
              this.timestamp = void 0;
              this.x = x;
              this.y = y;
              this.z = z;
              this.timestamp = timestamp;
            });
            legacyCC.internal.Acceleration = Acceleration$1;
            /**
             *  This class manages all events of input. include: touch, mouse, accelerometer, keyboard
             */

            var InputManager = /*#__PURE__*/function () {
              function InputManager() {
                _classCallCheck(this, InputManager);

                this._mousePressed = false;
                this._isRegisterEvent = false;
                this._preTouchPoint = new Vec2();
                this._prevMousePoint = new Vec2();
                this._preTouchPool = [];
                this._preTouchPoolPointer = 0;
                this._touches = [];
                this._touchesIntegerDict = {};
                this._indexBitsUsed = 0;
                this._maxTouches = 8;
                this._accelEnabled = false;
                this._accelInterval = 1 / 5;
                this._accelMinus = 1;
                this._accelCurTime = 0;
                this._acceleration = null;
                this._accelDeviceEvent = null;
                this._glView = null;
                this._pointLocked = false;
              }

              _createClass(InputManager, [{
                key: "handleTouchesBegin",
                value: function handleTouchesBegin(touches) {
                  var handleTouches = [];
                  var locTouchIntDict = this._touchesIntegerDict;

                  for (var i = 0; i < touches.length; ++i) {
                    var touch = touches[i];
                    var touchID = touch.getID();

                    if (touchID === null) {
                      continue;
                    }

                    var _index = locTouchIntDict[touchID];

                    if (_index === undefined) {
                      var unusedIndex = this._getUnUsedIndex();

                      if (unusedIndex === -1) {
                        logID(2300, unusedIndex);
                        continue;
                      } // curTouch = this._touches[unusedIndex] = touch;


                      touch.getLocation(_vec2$2);
                      var curTouch = new Touch(_vec2$2.x, _vec2$2.y, touchID);
                      this._touches[unusedIndex] = curTouch;
                      touch.getPreviousLocation(_vec2$2);
                      curTouch.setPrevPoint(_vec2$2);
                      locTouchIntDict[touchID] = unusedIndex;
                      handleTouches.push(curTouch);
                    }
                  }

                  if (handleTouches.length > 0) {
                    // this._glView!._convertTouchesWithScale(handleTouches);
                    var touchEvent = new EventTouch(handleTouches, false, EventTouch.BEGAN, macro.ENABLE_MULTI_TOUCH ? this._getUsefulTouches() : handleTouches);
                    eventManager.dispatchEvent(touchEvent);
                  }
                }
              }, {
                key: "handleTouchesMove",
                value: function handleTouchesMove(touches) {
                  var handleTouches = [];
                  var locTouches = this._touches;

                  for (var i = 0; i < touches.length; ++i) {
                    var touch = touches[i];
                    var touchID = touch.getID();

                    if (touchID === null) {
                      continue;
                    }

                    var _index2 = this._touchesIntegerDict[touchID];

                    if (_index2 === undefined) {
                      // cc.log("if the index doesn't exist, it is an error");
                      continue;
                    }

                    if (locTouches[_index2]) {
                      touch.getLocation(_vec2$2);

                      locTouches[_index2].setPoint(_vec2$2);

                      touch.getPreviousLocation(_vec2$2);

                      locTouches[_index2].setPrevPoint(_vec2$2);

                      handleTouches.push(locTouches[_index2]);
                    }
                  }

                  if (handleTouches.length > 0) {
                    // this._glView!._convertTouchesWithScale(handleTouches);
                    var touchEvent = new EventTouch(handleTouches, false, EventTouch.MOVED, macro.ENABLE_MULTI_TOUCH ? this._getUsefulTouches() : handleTouches);
                    eventManager.dispatchEvent(touchEvent);
                  }
                }
              }, {
                key: "handleTouchesEnd",
                value: function handleTouchesEnd(touches) {
                  var handleTouches = this.getSetOfTouchesEndOrCancel(touches);

                  if (handleTouches.length > 0) {
                    // this._glView!._convertTouchesWithScale(handleTouches);
                    var touchEvent = new EventTouch(handleTouches, false, EventTouch.ENDED, macro.ENABLE_MULTI_TOUCH ? this._getUsefulTouches() : handleTouches);
                    eventManager.dispatchEvent(touchEvent);
                  }

                  this._preTouchPool.length = 0;
                }
              }, {
                key: "handleTouchesCancel",
                value: function handleTouchesCancel(touches) {
                  var handleTouches = this.getSetOfTouchesEndOrCancel(touches);

                  if (handleTouches.length > 0) {
                    // this._glView!._convertTouchesWithScale(handleTouches);
                    var touchEvent = new EventTouch(handleTouches, false, EventTouch.CANCELLED, macro.ENABLE_MULTI_TOUCH ? this._getUsefulTouches() : handleTouches);
                    eventManager.dispatchEvent(touchEvent);
                  }

                  this._preTouchPool.length = 0;
                }
              }, {
                key: "getSetOfTouchesEndOrCancel",
                value: function getSetOfTouchesEndOrCancel(touches) {
                  var handleTouches = [];
                  var locTouches = this._touches;
                  var locTouchesIntDict = this._touchesIntegerDict;

                  for (var i = 0; i < touches.length; ++i) {
                    var touch = touches[i];
                    var touchID = touch.getID();

                    if (touchID === null) {
                      continue;
                    }

                    var _index3 = locTouchesIntDict[touchID];

                    if (_index3 === undefined) {
                      // cc.log("if the index doesn't exist, it is an error");
                      continue;
                    }

                    if (locTouches[_index3]) {
                      touch.getLocation(_vec2$2);

                      locTouches[_index3].setPoint(_vec2$2);

                      touch.getPreviousLocation(_vec2$2);

                      locTouches[_index3].setPrevPoint(_vec2$2);

                      handleTouches.push(locTouches[_index3]);

                      this._removeUsedIndexBit(_index3);

                      delete locTouchesIntDict[touchID];
                    }
                  }

                  return handleTouches;
                }
              }, {
                key: "getHTMLElementPosition",
                value: function getHTMLElementPosition(element) {
                  var docElem = document.documentElement;
                  var leftOffset = sys.os === sys.OS_IOS && sys.isBrowser ? window.screenLeft : window.pageXOffset;
                  leftOffset -= docElem.clientLeft;
                  var topOffset = sys.os === sys.OS_IOS && sys.isBrowser ? window.screenTop : window.pageYOffset;
                  topOffset -= docElem.clientTop;

                  if (element.getBoundingClientRect) {
                    var box = element.getBoundingClientRect();
                    return {
                      left: box.left + leftOffset,
                      top: box.top + topOffset,
                      width: box.width,
                      height: box.height
                    };
                  } else {
                    if (element instanceof HTMLCanvasElement) {
                      return {
                        left: leftOffset,
                        top: topOffset,
                        width: element.width,
                        height: element.height
                      };
                    } else {
                      return {
                        left: leftOffset,
                        top: topOffset,
                        width: parseInt(element.style.width || '0', undefined),
                        height: parseInt(element.style.height || '0', undefined)
                      };
                    }
                  }
                }
              }, {
                key: "getPreTouch",
                value: function getPreTouch(touch) {
                  var preTouch = null;
                  var locPreTouchPool = this._preTouchPool;
                  var id = touch.getID();

                  for (var i = locPreTouchPool.length - 1; i >= 0; i--) {
                    if (locPreTouchPool[i].getID() === id) {
                      preTouch = locPreTouchPool[i];
                      break;
                    }
                  }

                  if (!preTouch) {
                    preTouch = touch;
                  }

                  return preTouch;
                }
              }, {
                key: "setPreTouch",
                value: function setPreTouch(touch) {
                  var find = false;
                  var locPreTouchPool = this._preTouchPool;
                  var id = touch.getID();

                  for (var i = locPreTouchPool.length - 1; i >= 0; i--) {
                    if (locPreTouchPool[i].getID() === id) {
                      locPreTouchPool[i] = touch;
                      find = true;
                      break;
                    }
                  }

                  if (!find) {
                    if (locPreTouchPool.length <= 50) {
                      locPreTouchPool.push(touch);
                    } else {
                      locPreTouchPool[this._preTouchPoolPointer] = touch;
                      this._preTouchPoolPointer = (this._preTouchPoolPointer + 1) % 50;
                    }
                  }
                }
              }, {
                key: "getTouchByXY",
                value: function getTouchByXY(event, tx, ty, pos) {
                  var locPreTouch = this._preTouchPoint;

                  var location = this._glView.convertToLocationInView(tx, ty, pos);

                  if (this._pointLocked) {
                    location.x = locPreTouch.x + event.movementX;
                    location.y = locPreTouch.y - event.movementY;
                  }

                  var touch = new Touch(location.x, location.y, 0);
                  touch.setPrevPoint(locPreTouch.x, locPreTouch.y);
                  locPreTouch.x = location.x;
                  locPreTouch.y = location.y;
                  return touch;
                }
              }, {
                key: "getMouseEvent",
                value: function getMouseEvent(location, pos, eventType) {
                  var locPreMouse = this._prevMousePoint;
                  var mouseEvent = new EventMouse(eventType, false, locPreMouse);
                  locPreMouse.x = location.x;
                  locPreMouse.y = location.y; // this._glView!._convertMouseToLocationInView(locPreMouse, pos);

                  this._glView._convertMouseToLocation(locPreMouse, pos);

                  mouseEvent.setLocation(locPreMouse.x, locPreMouse.y);
                  return mouseEvent;
                }
              }, {
                key: "getPointByEvent",
                value: function getPointByEvent(event, pos) {
                  if (event.pageX != null) {
                    // not avalable in <= IE8
                    return {
                      x: event.pageX,
                      y: event.pageY
                    };
                  }

                  pos.left -= document.body.scrollLeft;
                  pos.top -= document.body.scrollTop;
                  return {
                    x: event.clientX,
                    y: event.clientY
                  };
                }
              }, {
                key: "getTouchesByEvent",
                value: function getTouchesByEvent(event, position) {
                  var touches = [];
                  var locView = this._glView;
                  var locPreTouch = this._preTouchPoint;
                  var length = event.changedTouches.length;

                  for (var i = 0; i < length; i++) {
                    // const changedTouch = event.changedTouches.item(i);
                    var changedTouch = event.changedTouches[i];

                    if (!changedTouch) {
                      continue;
                    }

                    var _location = void 0;

                    if (sys.BROWSER_TYPE_FIREFOX === sys.browserType) {
                      _location = locView.convertToLocationInView(changedTouch.pageX, changedTouch.pageY, position, _vec2$2);
                    } else {
                      _location = locView.convertToLocationInView(changedTouch.clientX, changedTouch.clientY, position, _vec2$2);
                    }

                    var touch = void 0;

                    if (changedTouch.identifier != null) {
                      touch = new Touch(_location.x, _location.y, changedTouch.identifier); // use Touch Pool

                      this.getPreTouch(touch).getLocation(_preLocation);
                      touch.setPrevPoint(_preLocation.x, _preLocation.y);
                      this.setPreTouch(touch);
                    } else {
                      touch = new Touch(_location.x, _location.y);
                      touch.setPrevPoint(locPreTouch.x, locPreTouch.y);
                    }

                    locPreTouch.x = _location.x;
                    locPreTouch.y = _location.y;
                    touches.push(touch);

                    if (!macro.ENABLE_MULTI_TOUCH) {
                      break;
                    }
                  }

                  return touches;
                }
              }, {
                key: "registerSystemEvent",
                value: function registerSystemEvent(element) {
                  if (this._isRegisterEvent || !element) {
                    return;
                  }

                  this._glView = legacyCC.view;
                  var prohibition = sys.isMobile;
                  var supportMouse = ('mouse' in sys.capabilities);
                  var supportTouches = ('touches' in sys.capabilities); // Register mouse events.

                  if (supportMouse) {
                    this._registerMouseEvents(element, prohibition);
                  } // Register mouse pointer events.


                  if (window.navigator.msPointerEnabled) {
                    this._registerMousePointerEvents(element);
                  } // Register touch events.


                  if (supportTouches) {
                    this._registerTouchEvents(element);
                  }

                  this._registerKeyboardEvent();

                  this._isRegisterEvent = true;
                }
                /**
                 * Whether enable accelerometer event.
                 */

              }, {
                key: "setAccelerometerEnabled",
                value: function setAccelerometerEnabled(isEnable) {
                  if (this._accelEnabled === isEnable) {
                    return;
                  }

                  this._accelEnabled = isEnable;
                  var scheduler = legacyCC.director.getScheduler();
                  scheduler.enableForTarget(this);

                  if (this._accelEnabled) {
                    this._registerAccelerometerEvent();

                    this._accelCurTime = 0;
                    scheduler.scheduleUpdate(this);
                  } else {
                    this._unregisterAccelerometerEvent();

                    this._accelCurTime = 0;
                    scheduler.unscheduleUpdate(this);
                  }
                }
              }, {
                key: "didAccelerate",
                value: function didAccelerate(eventData) {
                  if (!this._accelEnabled) {
                    return;
                  }

                  var mAcceleration = this._acceleration;
                  var x = 0;
                  var y = 0;
                  var z = 0; // TODO
                  // @ts-ignore

                  if (this._accelDeviceEvent === window.DeviceMotionEvent) {
                    var deviceMotionEvent = eventData;
                    var eventAcceleration = deviceMotionEvent.accelerationIncludingGravity;

                    if (eventAcceleration) {
                      x = this._accelMinus * (eventAcceleration.x || 0) * 0.1;
                      y = this._accelMinus * (eventAcceleration.y || 0) * 0.1;
                      z = (eventAcceleration.z || 0) * 0.1;
                    }
                  } else {
                    var deviceOrientationEvent = eventData;
                    x = (deviceOrientationEvent.gamma || 0) / 90 * 0.981;
                    y = -((deviceOrientationEvent.beta || 0) / 90) * 0.981;
                    z = (deviceOrientationEvent.alpha || 0) / 90 * 0.981;
                  }

                  if (legacyCC.view._isRotated) {
                    var tmp = x;
                    x = -y;
                    y = tmp;
                  }

                  mAcceleration.x = x;
                  mAcceleration.y = y;
                  mAcceleration.z = z;
                  mAcceleration.timestamp = eventData.timeStamp || Date.now();
                  var tmpX = mAcceleration.x;

                  if (window.orientation === LANDSCAPE_RIGHT) {
                    mAcceleration.x = -mAcceleration.y;
                    mAcceleration.y = tmpX;
                  } else if (window.orientation === LANDSCAPE_LEFT) {
                    mAcceleration.x = mAcceleration.y;
                    mAcceleration.y = -tmpX;
                  } else if (window.orientation === PORTRAIT_UPSIDE_DOWN) {
                    mAcceleration.x = -mAcceleration.x;
                    mAcceleration.y = -mAcceleration.y;
                  } // fix android acc values are opposite


                  if (legacyCC.sys.os === legacyCC.sys.OS_ANDROID && legacyCC.sys.browserType !== legacyCC.sys.BROWSER_TYPE_MOBILE_QQ) {
                    mAcceleration.x = -mAcceleration.x;
                    mAcceleration.y = -mAcceleration.y;
                  }
                }
              }, {
                key: "update",
                value: function update(dt) {
                  if (this._accelCurTime > this._accelInterval) {
                    this._accelCurTime -= this._accelInterval;
                    eventManager.dispatchEvent(new EventAcceleration(this._acceleration));
                  }

                  this._accelCurTime += dt;
                }
                /**
                 * set accelerometer interval value
                 * @method setAccelerometerInterval
                 * @param {Number} interval
                 */

              }, {
                key: "setAccelerometerInterval",
                value: function setAccelerometerInterval(interval) {
                  if (this._accelInterval !== interval) {
                    this._accelInterval = interval;
                  }
                }
              }, {
                key: "_getUnUsedIndex",
                value: function _getUnUsedIndex() {
                  var temp = this._indexBitsUsed;
                  var now = legacyCC.director.getCurrentTime();

                  for (var i = 0; i < this._maxTouches; i++) {
                    if (!(temp & 0x00000001)) {
                      this._indexBitsUsed |= 1 << i;
                      return i;
                    } else {
                      var touch = this._touches[i];

                      if (now - touch.lastModified > TOUCH_TIMEOUT) {
                        this._removeUsedIndexBit(i);

                        var touchID = touch.getID();

                        if (touchID !== null) {
                          delete this._touchesIntegerDict[touchID];
                        }

                        return i;
                      }
                    }

                    temp >>= 1;
                  } // all bits are used


                  return -1;
                }
              }, {
                key: "_removeUsedIndexBit",
                value: function _removeUsedIndexBit(index) {
                  if (index < 0 || index >= this._maxTouches) {
                    return;
                  }

                  var temp = 1 << index;
                  temp = ~temp;
                  this._indexBitsUsed &= temp;
                }
              }, {
                key: "_registerMouseEvents",
                value: function _registerMouseEvents(element, prohibition) {
                  // HACK
                  //  - At the same time to trigger the ontouch event and onmouse event
                  //  - The function will execute 2 times
                  // The known browser:
                  //  liebiao
                  //  miui
                  this._registerPointerLockEvent();

                  if (!prohibition) {
                    this._registerWindowMouseEvents(element);
                  }

                  this._registerElementMouseEvents(element, prohibition);
                }
              }, {
                key: "_registerPointerLockEvent",
                value: function _registerPointerLockEvent() {
                  var _this = this;

                  var lockChangeAlert = function lockChangeAlert() {
                    var canvas = legacyCC.game.canvas; // @ts-ignore

                    if (document.pointerLockElement === canvas || document.mozPointerLockElement === canvas) {
                      _this._pointLocked = true;
                    } else {
                      _this._pointLocked = false;
                    }
                  };

                  if ('onpointerlockchange' in document) {
                    document.addEventListener('pointerlockchange', lockChangeAlert, false);
                  } else if ('onmozpointerlockchange' in document) {
                    // @ts-ignore
                    document.addEventListener('mozpointerlockchange', lockChangeAlert, false);
                  }
                }
              }, {
                key: "_registerWindowMouseEvents",
                value: function _registerWindowMouseEvents(element) {
                  var _this2 = this;

                  window.addEventListener('mousedown', function () {
                    _this2._mousePressed = true;
                  }, false);
                  window.addEventListener('mouseup', function (event) {
                    if (!_this2._mousePressed) {
                      return;
                    }

                    _this2._mousePressed = false;

                    var position = _this2.getHTMLElementPosition(element);

                    var location = _this2.getPointByEvent(event, position);

                    var positionRect = rect(position.left, position.top, position.width, position.height);

                    if (!positionRect.contains(new Vec2(location.x, location.y))) {
                      _this2.handleTouchesEnd([_this2.getTouchByXY(event, location.x, location.y, position)]);

                      var _mouseEvent = _this2.getMouseEvent(location, position, EventMouse.UP);

                      _mouseEvent.setButton(event.button);

                      eventManager.dispatchEvent(_mouseEvent);
                    }
                  }, false);
                }
              }, {
                key: "_registerElementMouseEvents",
                value: function _registerElementMouseEvents(element, prohibition) {
                  var _this3 = this;

                  // Register canvas mouse events.
                  var listenDOMMouseEvent = function listenDOMMouseEvent(eventName, type, handler) {
                    element.addEventListener(eventName, function (event) {
                      var pos = _this3.getHTMLElementPosition(element);

                      var location = _this3.getPointByEvent(event, pos);

                      var mouseEvent = _this3.getMouseEvent(location, pos, type);

                      mouseEvent.setButton(event.button);
                      handler(event, mouseEvent, location, pos);
                      eventManager.dispatchEvent(mouseEvent);
                      event.stopPropagation();
                      event.preventDefault();
                    });
                  };

                  if (!prohibition) {
                    listenDOMMouseEvent('mousedown', EventMouse.DOWN, function (event, mouseEvent, location, pos) {
                      _this3._mousePressed = true;

                      _this3.handleTouchesBegin([_this3.getTouchByXY(event, location.x, location.y, pos)]);

                      element.focus();
                    });
                    listenDOMMouseEvent('mouseup', EventMouse.UP, function (event, mouseEvent, location, pos) {
                      _this3._mousePressed = false;

                      _this3.handleTouchesEnd([_this3.getTouchByXY(event, location.x, location.y, pos)]);
                    });
                    listenDOMMouseEvent('mousemove', EventMouse.MOVE, function (event, mouseEvent, location, pos) {
                      _this3.handleTouchesMove([_this3.getTouchByXY(event, location.x, location.y, pos)]);

                      if (!_this3._mousePressed) {
                        mouseEvent.setButton(EventMouse.BUTTON_MISSING);
                      }

                      if (event.movementX !== undefined && event.movementY !== undefined) {
                        mouseEvent.movementX = event.movementX;
                        mouseEvent.movementY = event.movementY;
                      }
                    });
                  } // @ts-ignore


                  listenDOMMouseEvent('mousewheel', EventMouse.SCROLL, function (event, mouseEvent, location, pos) {
                    // @ts-ignore
                    mouseEvent.setScrollData(0, event.wheelDelta);
                  });
                  /* firefox fix */
                  // @ts-ignore

                  listenDOMMouseEvent('DOMMouseScroll', EventMouse.SCROLL, function (event, mouseEvent, location, pos) {
                    mouseEvent.setScrollData(0, event.detail * -120);
                  });
                }
              }, {
                key: "_registerMousePointerEvents",
                value: function _registerMousePointerEvents(element) {
                  var _this4 = this;

                  var _pointerEventsMap = {
                    MSPointerDown: this.handleTouchesBegin,
                    MSPointerMove: this.handleTouchesMove,
                    MSPointerUp: this.handleTouchesEnd,
                    MSPointerCancel: this.handleTouchesCancel
                  }; // tslint:disable-next-line: forin

                  var _loop = function _loop(eventName) {
                    var touchEvent = _pointerEventsMap[eventName]; // @ts-ignore

                    element.addEventListener(eventName, function (event) {
                      var pos = _this4.getHTMLElementPosition(element);

                      pos.left -= document.documentElement.scrollLeft;
                      pos.top -= document.documentElement.scrollTop;
                      touchEvent.call(_this4, [_this4.getTouchByXY(event, event.clientX, event.clientY, pos)]);
                      event.stopPropagation();
                    }, false);
                  };

                  for (var eventName in _pointerEventsMap) {
                    _loop(eventName);
                  }
                }
              }, {
                key: "_registerTouchEvents",
                value: function _registerTouchEvents(element) {
                  var _this5 = this;

                  var makeTouchListener = function makeTouchListener(touchesHandler) {
                    return function (event) {
                      if (!event.changedTouches) {
                        return;
                      }

                      var pos = _this5.getHTMLElementPosition(element);

                      var body = document.body;
                      pos.left -= body.scrollLeft || 0;
                      pos.top -= body.scrollTop || 0;
                      touchesHandler(_this5.getTouchesByEvent(event, pos));
                      event.stopPropagation();
                      event.preventDefault();
                    };
                  };

                  element.addEventListener('touchstart', makeTouchListener(function (touchesToHandle) {
                    _this5.handleTouchesBegin(touchesToHandle);

                    element.focus();
                  }), false);
                  element.addEventListener('touchmove', makeTouchListener(function (touchesToHandle) {
                    _this5.handleTouchesMove(touchesToHandle);
                  }), false);
                  element.addEventListener('touchend', makeTouchListener(function (touchesToHandle) {
                    _this5.handleTouchesEnd(touchesToHandle);
                  }), false);
                  element.addEventListener('touchcancel', makeTouchListener(function (touchesToHandle) {
                    _this5.handleTouchesCancel(touchesToHandle);
                  }), false);
                }
              }, {
                key: "_registerKeyboardEvent",
                value: function _registerKeyboardEvent() {
                  var canvas = legacyCC.game.canvas;
                  canvas.addEventListener('keydown', function (event) {
                    eventManager.dispatchEvent(new EventKeyboard(event, true));
                    event.stopPropagation();
                    event.preventDefault();
                  }, false);
                  canvas.addEventListener('keyup', function (event) {
                    eventManager.dispatchEvent(new EventKeyboard(event, false));
                    event.stopPropagation();
                    event.preventDefault();
                  }, false);
                }
              }, {
                key: "_registerAccelerometerEvent",
                value: function _registerAccelerometerEvent() {
                  var _this6 = this;

                  this._acceleration = new Acceleration$1(); // TODO
                  // @ts-ignore

                  this._accelDeviceEvent = window.DeviceMotionEvent || window.DeviceOrientationEvent; // TODO fix DeviceMotionEvent bug on QQ Browser version 4.1 and below.

                  if (legacyCC.sys.browserType === legacyCC.sys.BROWSER_TYPE_MOBILE_QQ) {
                    // TODO
                    // @ts-ignore
                    this._accelDeviceEvent = window.DeviceOrientationEvent;
                  }

                  var _deviceEventType = // TODO
                  // @ts-ignore
                  this._accelDeviceEvent === window.DeviceMotionEvent ? 'devicemotion' : 'deviceorientation'; // @ts-ignore


                  _didAccelerateFun = function _didAccelerateFun() {
                    return _this6.didAccelerate.apply(_this6, arguments);
                  };

                  window.addEventListener(_deviceEventType, _didAccelerateFun, false);
                }
              }, {
                key: "_unregisterAccelerometerEvent",
                value: function _unregisterAccelerometerEvent() {
                  var _deviceEventType = // TODO
                  // @ts-ignore
                  this._accelDeviceEvent === window.DeviceMotionEvent ? 'devicemotion' : 'deviceorientation';

                  if (_didAccelerateFun) {
                    window.removeEventListener(_deviceEventType, _didAccelerateFun, false);
                  }
                }
              }, {
                key: "_getUsefulTouches",
                value: function _getUsefulTouches() {
                  var touches = [];
                  var touchDict = this._touchesIntegerDict;

                  for (var id in touchDict) {
                    var _index4 = parseInt(id);

                    var usedID = touchDict[_index4];

                    if (usedID === undefined || usedID === null) {
                      continue;
                    }

                    var touch = this._touches[usedID];
                    touches.push(touch);
                  }

                  return touches;
                }
              }]);

              return InputManager;
            }();

            var inputManager = exports('d7', new InputManager());
            legacyCC.internal.inputManager = inputManager;

            /**
             * @en An object to boot the game.
             * @zh 包含游戏主体信息并负责驱动游戏的游戏对象。
             */
            var Game = exports('bh', /*#__PURE__*/function (_EventTarget) {
              _inherits(Game, _EventTarget);

              function Game() {
                var _getPrototypeOf2;

                var _this;

                _classCallCheck(this, Game);

                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = arguments[_key];
                }

                _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Game)).call.apply(_getPrototypeOf2, [this].concat(args)));
                _this.frame = null;
                _this.container = null;
                _this.canvas = null;
                _this.renderType = -1;
                _this.eventTargetOn = _get(_getPrototypeOf(Game.prototype), "on", _assertThisInitialized(_this));
                _this.eventTargetOnce = _get(_getPrototypeOf(Game.prototype), "once", _assertThisInitialized(_this));
                _this.config = {};
                _this.onStart = null;
                _this._persistRootNodes = {};
                _this._paused = true;
                _this._configLoaded = false;
                _this._isCloning = false;
                _this._inited = false;
                _this._rendererInitialized = false;
                _this._gfxDevice = null;
                _this._intervalId = null;
                _this._lastTime = null;
                _this._frameTime = null;
                _this._sceneInfos = [];
                _this.collisionMatrix = [];
                _this.groupList = [];
                return _this;
              }

              _createClass(Game, [{
                key: "setFrameRate",
                // @Methods
                //  @Game play control

                /**
                 * @en Set frame rate of game.
                 * @zh 设置游戏帧率。
                 * @param {Number} frameRate
                 */
                value: function setFrameRate(frameRate) {
                  var config = this.config;

                  if (typeof frameRate !== 'number') {
                    frameRate = parseInt(frameRate);

                    if (isNaN(frameRate)) {
                      frameRate = 60;
                    }
                  }

                  config.frameRate = frameRate;
                  this._paused = true;

                  this._setAnimFrame();

                  this._runMainLoop();
                }
                /**
                 * @en Get frame rate set for the game, it doesn't represent the real frame rate.
                 * @zh 获取设置的游戏帧率（不等同于实际帧率）。
                 * @return frame rate
                 */

              }, {
                key: "getFrameRate",
                value: function getFrameRate() {
                  return this.config.frameRate || 0;
                }
                /**
                 * @en Run the game frame by frame.
                 * @zh 执行一帧游戏循环。
                 */

              }, {
                key: "step",
                value: function step() {
                  legacyCC.director.mainLoop();
                }
                /**
                 * @en Pause the game main loop. This will pause:<br>
                 * game logic execution, rendering process, event manager, background music and all audio effects.<br>
                 * This is different with `director.pause` which only pause the game logic execution.<br>
                 * @zh 暂停游戏主循环。包含：游戏逻辑，渲染，事件处理，背景音乐和所有音效。这点和只暂停游戏逻辑的 `director.pause` 不同。
                 */

              }, {
                key: "pause",
                value: function pause() {
                  if (this._paused) {
                    return;
                  }

                  this._paused = true; // Pause main loop

                  if (this._intervalId) {
                    window.cAF(this._intervalId);
                    this._intervalId = 0;
                  } // Because JSB platforms never actually stops the swap chain,
                }
                /**
                 * @en Resume the game from pause. This will resume:<br>
                 * game logic execution, rendering process, event manager, background music and all audio effects.<br>
                 * @zh 恢复游戏主循环。包含：游戏逻辑，渲染，事件处理，背景音乐和所有音效。
                 */

              }, {
                key: "resume",
                value: function resume() {
                  if (!this._paused) {
                    return;
                  }

                  this._paused = false; // Resume main loop

                  this._runMainLoop();
                }
                /**
                 * @en Check whether the game is paused.
                 * @zh 判断游戏是否暂停。
                 */

              }, {
                key: "isPaused",
                value: function isPaused() {
                  return this._paused;
                }
                /**
                 * @en Restart game.
                 * @zh 重新开始游戏
                 */

              }, {
                key: "restart",
                value: function restart() {
                  legacyCC.director.once(legacyCC.Director.EVENT_AFTER_DRAW, function () {
                    // tslint:disable-next-line: forin
                    for (var id in legacyCC.game._persistRootNodes) {
                      legacyCC.game.removePersistRootNode(legacyCC.game._persistRootNodes[id]);
                    } // Clear scene


                    legacyCC.director.getScene().destroy();

                    legacyCC.Object._deferredDestroy();

                    legacyCC.director.reset();
                    legacyCC.game.pause();

                    legacyCC.game._loadRenderPipeline(function () {
                      legacyCC.game.resume();

                      legacyCC.game._safeEmit(legacyCC.Game.EVENT_RESTART);
                    });
                  });
                }
                /**
                 * @en End game, it will close the game window
                 * @zh 退出游戏
                 */

              }, {
                key: "end",
                value: function end() {
                  if (this._gfxDevice) {
                    this._gfxDevice.destroy();

                    this._gfxDevice = null;
                  }

                  close();
                }
                /**
                 * @en
                 * Register an callback of a specific event type on the game object.<br>
                 * This type of event should be triggered via `emit`.<br>
                 * @zh
                 * 注册 game 的特定事件类型回调。这种类型的事件应该被 `emit` 触发。<br>
                 *
                 * @param type - A string representing the event type to listen for.
                 * @param callback - The callback that will be invoked when the event is dispatched.<br>
                 *                              The callback is ignored if it is a duplicate (the callbacks are unique).
                 * @param target - The target (this object) to invoke the callback, can be null
                 * @param once - After the first invocation, whether the callback should be unregistered.
                 * @return - Just returns the incoming callback so you can save the anonymous function easier.
                 */

              }, {
                key: "on",
                value: function on(type, callback, target, once) {
                  // Make sure EVENT_ENGINE_INITED callbacks to be invoked
                  if (this._inited && type === Game.EVENT_ENGINE_INITED) {
                    callback.call(target);
                  } else {
                    this.eventTargetOn(type, callback, target, once);
                  }
                }
                /**
                 * @en
                 * Register an callback of a specific event type on the game object,<br>
                 * the callback will remove itself after the first time it is triggered.<br>
                 * @zh
                 * 注册 game 的特定事件类型回调，回调会在第一时间被触发后删除自身。
                 *
                 * @param type - A string representing the event type to listen for.
                 * @param callback - The callback that will be invoked when the event is dispatched.<br>
                 *                              The callback is ignored if it is a duplicate (the callbacks are unique).
                 * @param target - The target (this object) to invoke the callback, can be null
                 */
                // @ts-ignore

              }, {
                key: "once",
                value: function once(type, callback, target) {
                  // Make sure EVENT_ENGINE_INITED callbacks to be invoked
                  if (this._inited && type === Game.EVENT_ENGINE_INITED) {
                    callback.call(target);
                  } else {
                    this.eventTargetOnce(type, callback, target);
                  }
                }
                /**
                 * @en Init game with configuration object.
                 * @zh 使用指定的配置初始化引擎。
                 * @param config - Pass configuration object
                 */

              }, {
                key: "init",
                value: function init(config) {
                  this._initConfig(config); // Init AssetLibrary


                  if (this.config.assetOptions) {
                    AssetLibrary.init(this.config.assetOptions);
                  }

                  this._initEngine();

                  {
                    this._initEvents();
                  }

                  legacyCC.director.root.dataPoolManager.jointTexturePool.registerCustomTextureLayouts(config.customJointTextureLayouts);
                  return this._inited;
                }
                /**
                 * @en Run game with configuration object and onStart function.
                 * @zh 运行游戏，并且指定引擎配置和 onStart 的回调。
                 * @param onStart - function to be executed after game initialized
                 */

              }, {
                key: "run",
                value: function run(onStart, legacyOnStart) {
                  {
                    this._initEvents();
                  }

                  if (typeof onStart !== 'function' && legacyOnStart) {
                    var config = this.onStart;
                    this.init(config);
                    this.onStart = legacyOnStart;
                  } else {
                    this.onStart = onStart;
                  }

                  this._setAnimFrame();

                  this._runMainLoop(); // register system events


                  if ( game.config.registerSystemEvent) {
                    inputManager.registerSystemEvent(game.canvas);
                  }

                  this._loadRenderPipeline(null);
                } //  @ Persist root node section

                /**
                 * @en
                 * Add a persistent root node to the game, the persistent node won't be destroyed during scene transition.<br>
                 * The target node must be placed in the root level of hierarchy, otherwise this API won't have any effect.
                 * @zh
                 * 声明常驻根节点，该节点不会被在场景切换中被销毁。<br>
                 * 目标节点必须位于为层级的根节点，否则无效。
                 * @param node - The node to be made persistent
                 */

              }, {
                key: "addPersistRootNode",
                value: function addPersistRootNode(node) {
                  if (!legacyCC.Node.isNode(node) || !node.uuid) {
                    warnID(3800);
                    return;
                  }

                  var id = node.uuid;

                  if (!this._persistRootNodes[id]) {
                    var scene = legacyCC.director._scene;

                    if (legacyCC.isValid(scene)) {
                      if (!node.parent) {
                        node.parent = scene;
                      } else if (!(node.parent instanceof legacyCC.Scene)) {
                        warnID(3801);
                        return;
                      } else if (node.parent !== scene) {
                        warnID(3802);
                        return;
                      }
                    }

                    this._persistRootNodes[id] = node;
                    node._persistNode = true;
                  }
                }
                /**
                 * @en Remove a persistent root node.
                 * @zh 取消常驻根节点。
                 * @param node - The node to be removed from persistent node list
                 */

              }, {
                key: "removePersistRootNode",
                value: function removePersistRootNode(node) {
                  var id = node.uuid || '';

                  if (node === this._persistRootNodes[id]) {
                    delete this._persistRootNodes[id];
                    node._persistNode = false;
                  }
                }
                /**
                 * @en Check whether the node is a persistent root node.
                 * @zh 检查节点是否是常驻根节点。
                 * @param node - The node to be checked
                 */

              }, {
                key: "isPersistRootNode",
                value: function isPersistRootNode(node) {
                  return node._persistNode;
                } //  @Engine loading

              }, {
                key: "_initEngine",
                value: function _initEngine() {
                  this._initDevice();

                  legacyCC.director._init(); // Log engine version


                  console.log('Cocos Creator 3D v' + legacyCC.ENGINE_VERSION);
                  this.emit(Game.EVENT_ENGINE_INITED);
                  this._inited = true;
                } // @Methods
                //  @Time ticker section

              }, {
                key: "_setAnimFrame",
                value: function _setAnimFrame() {
                  this._lastTime = new Date();
                  var frameRate = legacyCC.game.config.frameRate;
                  this._frameTime = 1000 / frameRate;

                  {
                    if (this._intervalId) {
                      window.cAF(this._intervalId);
                      this._intervalId = 0;
                    }

                    if (frameRate !== 60 && frameRate !== 30) {
                      window.rAF = this._stTime;
                      window.cAF = this._ctTime;
                    } else {
                      window.rAF = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || this._stTime;
                      window.cAF = window.cancelAnimationFrame || window.cancelRequestAnimationFrame || window.msCancelRequestAnimationFrame || window.mozCancelRequestAnimationFrame || window.oCancelRequestAnimationFrame || window.webkitCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.ocancelAnimationFrame || this._ctTime;
                    }
                  }
                }
              }, {
                key: "_stTime",
                value: function _stTime(callback) {
                  var currTime = new Date().getTime();
                  var elapseTime = Math.max(0, currTime - legacyCC.game._lastTime);
                  var timeToCall = Math.max(0, legacyCC.game._frameTime - elapseTime);
                  var id = window.setTimeout(callback, timeToCall);
                  legacyCC.game._lastTime = currTime + timeToCall;
                  return id;
                }
              }, {
                key: "_ctTime",
                value: function _ctTime(id) {
                  window.clearTimeout(id);
                } // Run game.

              }, {
                key: "_runMainLoop",
                value: function _runMainLoop() {
                  var _this2 = this;

                  var _callback;

                  var config = this.config;
                  var director = legacyCC.director;
                  var skip = true;
                  var frameRate = config.frameRate;
                  setDisplayStats(!!config.showFPS);
                  director.startAnimation();

                  _callback = function callback(time) {
                    if (_this2._paused) {
                      return;
                    }

                    _this2._intervalId = window.rAF(_callback);

                    if ( frameRate === 30) {
                      skip = !skip;

                      if (skip) {
                        return;
                      }
                    }

                    director.mainLoop(time);
                  };

                  if (this._intervalId) {
                    window.cAF(this._intervalId);
                    this._intervalId = 0;
                  }

                  this._intervalId = window.rAF(_callback);
                  this._paused = false;
                } // @Game loading section

              }, {
                key: "_initConfig",
                value: function _initConfig(config) {
                  // Configs adjustment
                  if (typeof config.debugMode !== 'number') {
                    config.debugMode = 0;
                  }

                  config.exposeClassName = !!config.exposeClassName;

                  if (typeof config.frameRate !== 'number') {
                    config.frameRate = 60;
                  }

                  var renderMode = config.renderMode;

                  if (typeof renderMode !== 'number' || renderMode > 2 || renderMode < 0) {
                    config.renderMode = 0;
                  }

                  if (typeof config.registerSystemEvent !== 'boolean') {
                    config.registerSystemEvent = true;
                  }

                  config.showFPS = !!config.showFPS; // Scene parser

                  this._sceneInfos = config.scenes || []; // Collide Map and Group List

                  this.collisionMatrix = config.collisionMatrix || [];
                  this.groupList = config.groupList || [];

                  _resetDebugSetting(config.debugMode);

                  this.config = config;
                  this._configLoaded = true;
                }
              }, {
                key: "_determineRenderType",
                value: function _determineRenderType() {
                  var config = this.config;
                  var userRenderMode = parseInt(config.renderMode); // Determine RenderType

                  this.renderType = Game.RENDER_TYPE_CANVAS;
                  var supportRender = false;

                  if (userRenderMode === 0) {
                    if (legacyCC.sys.capabilities.opengl) {
                      this.renderType = Game.RENDER_TYPE_WEBGL;
                      supportRender = true;
                    } else if (legacyCC.sys.capabilities.canvas) {
                      this.renderType = Game.RENDER_TYPE_CANVAS;
                      supportRender = true;
                    }
                  } else if (userRenderMode === 1 && legacyCC.sys.capabilities.canvas) {
                    this.renderType = Game.RENDER_TYPE_CANVAS;
                    supportRender = true;
                  } else if (userRenderMode === 2 && legacyCC.sys.capabilities.opengl) {
                    this.renderType = Game.RENDER_TYPE_WEBGL;
                    supportRender = true;
                  }

                  if (!supportRender) {
                    throw new Error(getError(3820, userRenderMode));
                  }
                }
              }, {
                key: "_initDevice",
                value: function _initDevice() {
                  // Avoid setup to be called twice.
                  if (this._rendererInitialized) {
                    return;
                  }

                  this.canvas = this.config.adapter.canvas;
                  this.frame = this.config.adapter.frame;
                  this.container = this.config.adapter.container;

                  this._determineRenderType(); // WebGL context created successfully


                  if (this.renderType === Game.RENDER_TYPE_WEBGL) {
                    var ctors = [];

                    {
                      var useWebGL2 = !!window.WebGL2RenderingContext;
                      var userAgent = window.navigator.userAgent.toLowerCase();

                      if (userAgent.indexOf('safari') !== -1 && userAgent.indexOf('chrome') === -1 || sys.browserType === sys.BROWSER_TYPE_UC // UC browser implementation doesn't not conform to WebGL2 standard
                      ) {
                          useWebGL2 = false;
                        }

                      if (useWebGL2 && legacyCC.WebGL2Device) {
                        ctors.push(legacyCC.WebGL2Device);
                      }

                      if (legacyCC.WebGLDevice) {
                        ctors.push(legacyCC.WebGLDevice);
                      }
                    }

                    var opts = {
                      canvasElm: this.canvas,
                      debug: true,
                      isAntialias:  macro.ENABLE_WEBGL_ANTIALIAS,
                      devicePixelRatio: window.devicePixelRatio,
                      nativeWidth: Math.floor(screen.width * window.devicePixelRatio),
                      nativeHeight: Math.floor(screen.height * window.devicePixelRatio),
                      bindingMappingInfo: bindingMappingInfo
                    };

                    for (var i = 0; i < ctors.length; i++) {
                      this._gfxDevice = new ctors[i]();

                      if (this._gfxDevice.initialize(opts)) {
                        break;
                      }
                    }
                  }

                  if (!this._gfxDevice) {
                    // todo fix here for wechat game
                    console.error('can not support canvas rendering in 3D');
                    this.renderType = Game.RENDER_TYPE_CANVAS;
                    return;
                  }

                  this.canvas.oncontextmenu = function () {
                    if (!legacyCC._isContextMenuEnable) {
                      return false;
                    }
                  };
                }
              }, {
                key: "_initEvents",
                value: function _initEvents() {
                  var win = window;
                  var hiddenPropName;

                  if (typeof document.hidden !== 'undefined') {
                    hiddenPropName = 'hidden';
                  } else if (typeof document.mozHidden !== 'undefined') {
                    hiddenPropName = 'mozHidden';
                  } else if (typeof document.msHidden !== 'undefined') {
                    hiddenPropName = 'msHidden';
                  } else if (typeof document.webkitHidden !== 'undefined') {
                    hiddenPropName = 'webkitHidden';
                  }

                  var hidden = false;

                  function onHidden() {
                    if (!hidden) {
                      hidden = true;
                      legacyCC.game.emit(Game.EVENT_HIDE);
                    }
                  }

                  function onShown() {
                    if (hidden) {
                      hidden = false;
                      legacyCC.game.emit(Game.EVENT_SHOW);
                    }
                  }

                  if (hiddenPropName) {
                    var changeList = ['visibilitychange', 'mozvisibilitychange', 'msvisibilitychange', 'webkitvisibilitychange', 'qbrowserVisibilityChange']; // tslint:disable-next-line: prefer-for-of

                    for (var i = 0; i < changeList.length; i++) {
                      document.addEventListener(changeList[i], function (event) {
                        var visible = document[hiddenPropName]; // QQ App
                        // @ts-ignore

                        visible = visible || event.hidden;

                        if (visible) {
                          onHidden();
                        } else {
                          onShown();
                        }
                      });
                    }
                  } else {
                    win.addEventListener('blur', onHidden);
                    win.addEventListener('focus', onShown);
                  }

                  if (window.navigator.userAgent.indexOf('MicroMessenger') > -1) {
                    win.onfocus = onShown;
                  }

                  if ('onpageshow' in window && 'onpagehide' in window) {
                    win.addEventListener('pagehide', onHidden);
                    win.addEventListener('pageshow', onShown); // Taobao UIWebKit

                    document.addEventListener('pagehide', onHidden);
                    document.addEventListener('pageshow', onShown);
                  }

                  this.on(Game.EVENT_HIDE, function () {
                    legacyCC.game.pause();
                  });
                  this.on(Game.EVENT_SHOW, function () {
                    legacyCC.game.resume();
                  });
                }
              }, {
                key: "_loadRenderPipeline",
                value: function _loadRenderPipeline(restart) {
                  var _this3 = this;

                  var useSplash =  legacyCC.internal.SplashScreen; // Load render pipeline if needed

                  var renderPipeline = this.config.renderPipeline;

                  if (renderPipeline) {
                    legacyCC.loader.load({
                      uuid: renderPipeline
                    }, function (err, asset) {
                      // failed load renderPipeline
                      if (err || !(asset instanceof RenderPipeline)) {
                        console.warn("Failed load renderpipeline: ".concat(renderPipeline, ", engine failed to initialize, will fallback to default pipeline"));
                        console.warn(err);

                        _this3._setRenderPipeline();
                      } else {
                        try {
                          _this3._setRenderPipeline(asset);
                        } catch (e) {
                          console.warn(e);
                          console.warn("Failed load renderpipeline: ".concat(renderPipeline, ", engine failed to initialize, will fallback to default pipeline"));

                          _this3._setRenderPipeline();
                        }
                      }

                      _this3._safeEmit(Game.EVENT_GAME_INITED);

                      if (useSplash) {
                        var splashScreen = legacyCC.internal.SplashScreen.instance;
                        splashScreen.main(legacyCC.director.root);
                        splashScreen.setOnFinish(function () {
                          if (_this3.onStart) {
                            _this3.onStart();
                          }

                          if (restart) {
                            restart();
                          }
                        });
                        splashScreen.loadFinish = true;
                      } else {
                        if (_this3.onStart) {
                          _this3.onStart();
                        }

                        if (restart) {
                          restart();
                        }
                      }
                    });
                  } else {
                    this._setRenderPipeline();

                    this._safeEmit(Game.EVENT_GAME_INITED);

                    if (useSplash) {
                      var splashScreen = legacyCC.internal.SplashScreen.instance;
                      splashScreen.main(legacyCC.director.root);
                      splashScreen.setOnFinish(function () {
                        if (_this3.onStart) {
                          _this3.onStart();
                        }

                        if (restart) {
                          restart();
                        }
                      });
                      splashScreen.loadFinish = true;
                    } else {
                      if (this.onStart) {
                        this.onStart();
                      }

                      if (restart) {
                        restart();
                      }
                    }
                  }
                }
              }, {
                key: "_setRenderPipeline",
                value: function _setRenderPipeline(rppl) {
                  if (!legacyCC.director.root.setRenderPipeline(rppl)) {
                    this._setRenderPipeline();
                  }

                  this._rendererInitialized = true;

                  this._safeEmit(Game.EVENT_RENDERER_INITED);
                }
              }, {
                key: "_safeEmit",
                value: function _safeEmit(event) {
                  {
                    this.emit(event);
                  }
                }
              }, {
                key: "inited",

                /**
                 * @en Indicates whether the engine has inited
                 * @zh 引擎是否以完成初始化
                 */
                get: function get() {
                  return this._inited;
                }
              }]);

              return Game;
            }(EventTarget));
            Game.EVENT_HIDE = 'game_on_hide';
            Game.EVENT_SHOW = 'game_on_show';
            Game.EVENT_GAME_INITED = 'game_inited';
            Game.EVENT_ENGINE_INITED = 'engine_inited';
            Game.EVENT_RENDERER_INITED = 'renderer_inited';
            Game.EVENT_RESTART = 'game_on_restart';
            Game.RENDER_TYPE_CANVAS = 0;
            Game.RENDER_TYPE_WEBGL = 1;
            Game.RENDER_TYPE_OPENGL = 2;
            legacyCC.Game = Game;
            var game = exports('bi', legacyCC.game = new Game());

            var _dec$E, _dec2$i, _class$E, _class2$A, _descriptor$v, _descriptor2$n, _descriptor3$h, _temp$C, _dec3$d, _dec4$9, _dec5$6, _class4$4, _class5$4, _descriptor4$a, _descriptor5$7, _descriptor6$3, _descriptor7$3, _temp2$4, _dec6$4, _dec7$3, _dec8$3, _dec9$3, _dec10$2, _dec11$2, _dec12$2, _dec13$2, _dec14$1, _dec15$1, _dec16$1, _dec17$1, _dec18$1, _dec19$1, _dec20$1, _dec21$1, _dec22$1, _dec23$1, _dec24$1, _dec25$1, _dec26$1, _dec27$1, _dec28$1, _dec29$1, _dec30$1, _dec31$1, _dec32, _dec33, _class7$1, _class8$1, _descriptor8$3, _descriptor9$2, _descriptor10$2, _descriptor11$2, _descriptor12$1, _descriptor13$1, _descriptor14$1, _descriptor15$1, _descriptor16$1, _class9, _temp3$1, _dec34, _dec35, _dec36, _dec37, _dec38, _dec39, _dec40, _dec41, _dec42, _dec43, _dec44, _dec45, _dec46, _dec47, _dec48, _dec49, _class10$1, _class11$1, _descriptor17$1, _descriptor18$1, _descriptor19$1, _descriptor20$1, _descriptor21$1, _descriptor22$1, _descriptor23$1, _descriptor24$1, _descriptor25$1, _descriptor26$1, _descriptor27$1, _temp4$1, _dec50, _dec51, _class13$1, _class14$1, _descriptor28$1, _descriptor29$1, _descriptor30$1, _descriptor31$1, _temp5$1;

            var _up$1 = new Vec3(0, 1, 0);

            var _v3$2 = new Vec3();

            var _qt$3 = new Quat();
            /**
             * @en Environment lighting information in the Scene
             * @zh 场景的环境光照相关信息
             */


            var AmbientInfo = (_dec$E = ccclass('cc.AmbientInfo'), _dec2$i = type(CCFloat), _dec$E(_class$E = (_class2$A = (_temp$C = /*#__PURE__*/function () {
              function AmbientInfo() {
                _classCallCheck(this, AmbientInfo);

                _initializerDefineProperty(this, "_skyColor", _descriptor$v, this);

                _initializerDefineProperty(this, "_skyIllum", _descriptor2$n, this);

                _initializerDefineProperty(this, "_groundAlbedo", _descriptor3$h, this);

                this._resource = null;
              }

              _createClass(AmbientInfo, [{
                key: "activate",
                value: function activate(resource) {
                  this._resource = resource;
                  this._resource.skyColor = this._skyColor;
                  this._resource.skyIllum = this._skyIllum;
                  this._resource.groundAlbedo = this._groundAlbedo;
                }
              }, {
                key: "skyColor",

                /**
                 * @en Sky color
                 * @zh 天空颜色
                 */
                set: function set(val) {
                  this._skyColor.set(val);

                  if (this._resource) {
                    this._resource.skyColor = this._skyColor;
                  }
                },
                get: function get() {
                  return this._skyColor;
                }
                /**
                 * @en Sky illuminance
                 * @zh 天空亮度
                 */

              }, {
                key: "skyIllum",
                set: function set(val) {
                  this._skyIllum = val;

                  if (this._resource) {
                    this._resource.skyIllum = this.skyIllum;
                  }
                },
                get: function get() {
                  return this._skyIllum;
                }
                /**
                 * @en Ground color
                 * @zh 地面颜色
                 */

              }, {
                key: "groundAlbedo",
                set: function set(val) {
                  this._groundAlbedo.set(val); // only RGB channels are used, alpha channel are intensionally left unchanged here


                  if (this._resource) {
                    this._resource.groundAlbedo = this._groundAlbedo;
                  }
                },
                get: function get() {
                  return this._groundAlbedo;
                }
              }]);

              return AmbientInfo;
            }(), _temp$C), (_descriptor$v = _applyDecoratedDescriptor(_class2$A.prototype, "_skyColor", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Color(51, 128, 204, 1.0);
              }
            }), _descriptor2$n = _applyDecoratedDescriptor(_class2$A.prototype, "_skyIllum", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return Ambient.SKY_ILLUM;
              }
            }), _descriptor3$h = _applyDecoratedDescriptor(_class2$A.prototype, "_groundAlbedo", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Color(51, 51, 51, 255);
              }
            }), _applyDecoratedDescriptor(_class2$A.prototype, "skyColor", [editable], Object.getOwnPropertyDescriptor(_class2$A.prototype, "skyColor"), _class2$A.prototype), _applyDecoratedDescriptor(_class2$A.prototype, "skyIllum", [editable, _dec2$i], Object.getOwnPropertyDescriptor(_class2$A.prototype, "skyIllum"), _class2$A.prototype), _applyDecoratedDescriptor(_class2$A.prototype, "groundAlbedo", [editable], Object.getOwnPropertyDescriptor(_class2$A.prototype, "groundAlbedo"), _class2$A.prototype)), _class2$A)) || _class$E);
            legacyCC.AmbientInfo = AmbientInfo;
            /**
             * @en Skybox related information
             * @zh 天空盒相关信息
             */

            var SkyboxInfo = (_dec3$d = ccclass('cc.SkyboxInfo'), _dec4$9 = type(TextureCube), _dec5$6 = type(TextureCube), _dec3$d(_class4$4 = (_class5$4 = (_temp2$4 = /*#__PURE__*/function () {
              function SkyboxInfo() {
                _classCallCheck(this, SkyboxInfo);

                _initializerDefineProperty(this, "_envmap", _descriptor4$a, this);

                _initializerDefineProperty(this, "_isRGBE", _descriptor5$7, this);

                _initializerDefineProperty(this, "_enabled", _descriptor6$3, this);

                _initializerDefineProperty(this, "_useIBL", _descriptor7$3, this);

                this._resource = null;
              }

              _createClass(SkyboxInfo, [{
                key: "activate",
                value: function activate(resource) {
                  this._resource = resource;

                  this._resource.activate(); // update global DS first


                  this._resource.enabled = this._enabled;
                  this._resource.isRGBE = this._isRGBE;
                  this._resource.envmap = this._envmap;
                  this._resource.useIBL = this._useIBL;
                }
              }, {
                key: "enabled",

                /**
                 * @en Whether activate skybox in the scene
                 * @zh 是否启用天空盒？
                 */
                set: function set(val) {
                  this._enabled = val;

                  if (this._resource) {
                    this._resource.enabled = this._enabled;
                  }
                },
                get: function get() {
                  return this._enabled;
                }
                /**
                 * @en Whether use environment lighting
                 * @zh 是否启用环境光照？
                 */

              }, {
                key: "useIBL",
                set: function set(val) {
                  this._useIBL = val;

                  if (this._resource) {
                    this._resource.useIBL = this._useIBL;
                  }
                },
                get: function get() {
                  return this._useIBL;
                }
                /**
                 * @en The texture cube used for the skybox
                 * @zh 使用的立方体贴图
                 */

              }, {
                key: "envmap",
                set: function set(val) {
                  this._envmap = val;

                  if (this._resource) {
                    this._resource.envmap = this._envmap;
                  }
                },
                get: function get() {
                  return this._envmap;
                }
                /**
                 * @en Whether enable RGBE data support in skybox shader
                 * @zh 是否需要开启 shader 内的 RGBE 数据支持？
                 */

              }, {
                key: "isRGBE",
                set: function set(val) {
                  this._isRGBE = val;

                  if (this._resource) {
                    this._resource.isRGBE = this._isRGBE;
                  }
                },
                get: function get() {
                  return this._isRGBE;
                }
              }]);

              return SkyboxInfo;
            }(), _temp2$4), (_descriptor4$a = _applyDecoratedDescriptor(_class5$4.prototype, "_envmap", [_dec4$9], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return null;
              }
            }), _descriptor5$7 = _applyDecoratedDescriptor(_class5$4.prototype, "_isRGBE", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return false;
              }
            }), _descriptor6$3 = _applyDecoratedDescriptor(_class5$4.prototype, "_enabled", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return false;
              }
            }), _descriptor7$3 = _applyDecoratedDescriptor(_class5$4.prototype, "_useIBL", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return false;
              }
            }), _applyDecoratedDescriptor(_class5$4.prototype, "enabled", [editable], Object.getOwnPropertyDescriptor(_class5$4.prototype, "enabled"), _class5$4.prototype), _applyDecoratedDescriptor(_class5$4.prototype, "useIBL", [editable], Object.getOwnPropertyDescriptor(_class5$4.prototype, "useIBL"), _class5$4.prototype), _applyDecoratedDescriptor(_class5$4.prototype, "envmap", [editable, _dec5$6], Object.getOwnPropertyDescriptor(_class5$4.prototype, "envmap"), _class5$4.prototype), _applyDecoratedDescriptor(_class5$4.prototype, "isRGBE", [editable], Object.getOwnPropertyDescriptor(_class5$4.prototype, "isRGBE"), _class5$4.prototype)), _class5$4)) || _class4$4);
            legacyCC.SkyboxInfo = SkyboxInfo;
            /**
             * @zh 全局雾相关信息
             * @en Global fog info
             */

            var FogInfo = (_dec6$4 = ccclass('cc.FogInfo'), _dec7$3 = type(FogType), _dec8$3 = visible(), _dec9$3 = type(CCFloat), _dec10$2 = range(), _dec11$2 = rangeStep(), _dec12$2 = displayOrder(), _dec13$2 = visible(), _dec14$1 = type(CCFloat), _dec15$1 = rangeStep(), _dec16$1 = displayOrder(), _dec17$1 = visible(), _dec18$1 = type(CCFloat), _dec19$1 = rangeStep(), _dec20$1 = displayOrder(), _dec21$1 = visible(), _dec22$1 = type(CCFloat), _dec23$1 = rangeMin(), _dec24$1 = rangeStep(), _dec25$1 = displayOrder(), _dec26$1 = visible(), _dec27$1 = type(CCFloat), _dec28$1 = rangeStep(), _dec29$1 = displayOrder(), _dec30$1 = visible(), _dec31$1 = type(CCFloat), _dec32 = rangeStep(), _dec33 = displayOrder(), _dec6$4(_class7$1 = (_class8$1 = (_temp3$1 = _class9 = /*#__PURE__*/function () {
              function FogInfo() {
                _classCallCheck(this, FogInfo);

                _initializerDefineProperty(this, "_type", _descriptor8$3, this);

                _initializerDefineProperty(this, "_fogColor", _descriptor9$2, this);

                _initializerDefineProperty(this, "_enabled", _descriptor10$2, this);

                _initializerDefineProperty(this, "_fogDensity", _descriptor11$2, this);

                _initializerDefineProperty(this, "_fogStart", _descriptor12$1, this);

                _initializerDefineProperty(this, "_fogEnd", _descriptor13$1, this);

                _initializerDefineProperty(this, "_fogAtten", _descriptor14$1, this);

                _initializerDefineProperty(this, "_fogTop", _descriptor15$1, this);

                _initializerDefineProperty(this, "_fogRange", _descriptor16$1, this);

                this._resource = null;
              }

              _createClass(FogInfo, [{
                key: "activate",
                value: function activate(resource) {
                  this._resource = resource;
                  this._resource.enabled = this._enabled;
                  this._resource.fogColor = this._fogColor;
                  this._resource.type = this._type;
                  this._resource.fogDensity = this._fogDensity;
                  this._resource.fogStart = this._fogStart;
                  this._resource.fogEnd = this._fogEnd;
                  this._resource.fogAtten = this._fogAtten;
                  this._resource.fogTop = this._fogTop;
                  this._resource.fogRange = this._fogRange;
                }
              }, {
                key: "enabled",

                /**
                 * @zh 是否启用全局雾效
                 * @en Enable global fog
                 */
                set: function set(val) {
                  this._enabled = val;

                  if (this._resource) {
                    this._resource.enabled = val;
                  }
                },
                get: function get() {
                  return this._enabled;
                }
                /**
                 * @zh 全局雾颜色
                 * @en Global fog color
                 */

              }, {
                key: "fogColor",
                set: function set(val) {
                  this._fogColor.set(val);

                  if (this._resource) {
                    this._resource.fogColor = this._fogColor;
                  }
                },
                get: function get() {
                  return this._fogColor;
                }
                /**
                 * @zh 全局雾类型
                 * @en Global fog type
                 */

              }, {
                key: "type",
                get: function get() {
                  return this._type;
                },
                set: function set(val) {
                  this._type = val;

                  if (this._resource) {
                    this._resource.type = val;
                  }
                }
                /**
                 * @zh 全局雾浓度
                 * @en Global fog density
                 */

              }, {
                key: "fogDensity",
                get: function get() {
                  return this._fogDensity;
                },
                set: function set(val) {
                  this._fogDensity = val;

                  if (this._resource) {
                    this._resource.fogDensity = val;
                  }
                }
                /**
                 * @zh 雾效起始位置，只适用于线性雾
                 * @en Global fog start position, only for linear fog
                 */

              }, {
                key: "fogStart",
                get: function get() {
                  return this._fogStart;
                },
                set: function set(val) {
                  this._fogStart = val;

                  if (this._resource) {
                    this._resource.fogStart = val;
                  }
                }
                /**
                 * @zh 雾效结束位置，只适用于线性雾
                 * @en Global fog end position, only for linear fog
                 */

              }, {
                key: "fogEnd",
                get: function get() {
                  return this._fogEnd;
                },
                set: function set(val) {
                  this._fogEnd = val;

                  if (this._resource) {
                    this._resource.fogEnd = val;
                  }
                }
                /**
                 * @zh 雾效衰减
                 * @en Global fog attenuation
                 */

              }, {
                key: "fogAtten",
                get: function get() {
                  return this._fogAtten;
                },
                set: function set(val) {
                  this._fogAtten = val;

                  if (this._resource) {
                    this._resource.fogAtten = val;
                  }
                }
                /**
                 * @zh 雾效顶部范围，只适用于层级雾
                 * @en Global fog top range, only for layered fog
                 */

              }, {
                key: "fogTop",
                get: function get() {
                  return this._fogTop;
                },
                set: function set(val) {
                  this._fogTop = val;

                  if (this._resource) {
                    this._resource.fogTop = val;
                  }
                }
                /**
                 * @zh 雾效范围，只适用于层级雾
                 * @en Global fog range, only for layered fog
                 */

              }, {
                key: "fogRange",
                get: function get() {
                  return this._fogRange;
                },
                set: function set(val) {
                  this._fogRange = val;

                  if (this._resource) {
                    this._resource.fogRange = val;
                  }
                }
              }]);

              return FogInfo;
            }(), _class9.FogType = FogType, _temp3$1), (_descriptor8$3 = _applyDecoratedDescriptor(_class8$1.prototype, "_type", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return FogType.LINEAR;
              }
            }), _descriptor9$2 = _applyDecoratedDescriptor(_class8$1.prototype, "_fogColor", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Color('#C8C8C8');
              }
            }), _descriptor10$2 = _applyDecoratedDescriptor(_class8$1.prototype, "_enabled", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return false;
              }
            }), _descriptor11$2 = _applyDecoratedDescriptor(_class8$1.prototype, "_fogDensity", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0.3;
              }
            }), _descriptor12$1 = _applyDecoratedDescriptor(_class8$1.prototype, "_fogStart", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0.5;
              }
            }), _descriptor13$1 = _applyDecoratedDescriptor(_class8$1.prototype, "_fogEnd", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 300;
              }
            }), _descriptor14$1 = _applyDecoratedDescriptor(_class8$1.prototype, "_fogAtten", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 5;
              }
            }), _descriptor15$1 = _applyDecoratedDescriptor(_class8$1.prototype, "_fogTop", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 1.5;
              }
            }), _descriptor16$1 = _applyDecoratedDescriptor(_class8$1.prototype, "_fogRange", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 1.2;
              }
            }), _applyDecoratedDescriptor(_class8$1.prototype, "enabled", [editable], Object.getOwnPropertyDescriptor(_class8$1.prototype, "enabled"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "fogColor", [editable], Object.getOwnPropertyDescriptor(_class8$1.prototype, "fogColor"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "type", [editable, _dec7$3], Object.getOwnPropertyDescriptor(_class8$1.prototype, "type"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "fogDensity", [_dec8$3, _dec9$3, _dec10$2, _dec11$2, slide, _dec12$2], Object.getOwnPropertyDescriptor(_class8$1.prototype, "fogDensity"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "fogStart", [_dec13$2, _dec14$1, _dec15$1, _dec16$1], Object.getOwnPropertyDescriptor(_class8$1.prototype, "fogStart"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "fogEnd", [_dec17$1, _dec18$1, _dec19$1, _dec20$1], Object.getOwnPropertyDescriptor(_class8$1.prototype, "fogEnd"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "fogAtten", [_dec21$1, _dec22$1, _dec23$1, _dec24$1, _dec25$1], Object.getOwnPropertyDescriptor(_class8$1.prototype, "fogAtten"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "fogTop", [_dec26$1, _dec27$1, _dec28$1, _dec29$1], Object.getOwnPropertyDescriptor(_class8$1.prototype, "fogTop"), _class8$1.prototype), _applyDecoratedDescriptor(_class8$1.prototype, "fogRange", [_dec30$1, _dec31$1, _dec32, _dec33], Object.getOwnPropertyDescriptor(_class8$1.prototype, "fogRange"), _class8$1.prototype)), _class8$1)) || _class7$1);
            /**
             * @en Scene level planar shadow related information
             * @zh 平面阴影相关信息
             */

            var ShadowsInfo = (_dec34 = ccclass('cc.ShadowsInfo'), _dec35 = type(ShadowType), _dec36 = visible(), _dec37 = type(CCFloat), _dec38 = visible(), _dec39 = type(PCFType), _dec40 = visible(), _dec41 = type(CCFloat), _dec42 = visible(), _dec43 = type(CCFloat), _dec44 = visible(), _dec45 = type(CCFloat), _dec46 = visible(), _dec47 = visible(), _dec48 = type(CCFloat), _dec49 = visible(), _dec34(_class10$1 = (_class11$1 = (_temp4$1 = /*#__PURE__*/function () {
              function ShadowsInfo() {
                _classCallCheck(this, ShadowsInfo);

                _initializerDefineProperty(this, "_type", _descriptor17$1, this);

                _initializerDefineProperty(this, "_enabled", _descriptor18$1, this);

                _initializerDefineProperty(this, "_normal", _descriptor19$1, this);

                _initializerDefineProperty(this, "_distance", _descriptor20$1, this);

                _initializerDefineProperty(this, "_shadowColor", _descriptor21$1, this);

                _initializerDefineProperty(this, "_pcf", _descriptor22$1, this);

                _initializerDefineProperty(this, "_near", _descriptor23$1, this);

                _initializerDefineProperty(this, "_far", _descriptor24$1, this);

                _initializerDefineProperty(this, "_aspect", _descriptor25$1, this);

                _initializerDefineProperty(this, "_orthoSize", _descriptor26$1, this);

                _initializerDefineProperty(this, "_size", _descriptor27$1, this);

                this._resource = null;
              }

              _createClass(ShadowsInfo, [{
                key: "setPlaneFromNode",

                /**
                 * @en Set plane which receives shadow with the given node's world transformation
                 * @zh 根据指定节点的世界变换设置阴影接收平面的信息
                 * @param node The node for setting up the plane
                 */
                value: function setPlaneFromNode(node) {
                  node.getWorldRotation(_qt$3);
                  this.normal = Vec3.transformQuat(_v3$2, _up$1, _qt$3);
                  node.getWorldPosition(_v3$2);
                  this.distance = Vec3.dot(this._normal, _v3$2);
                }
              }, {
                key: "activate",
                value: function activate(resource) {
                  this._resource = resource;
                  this._resource.type = this._type;
                  this._resource.near = this._near;
                  this._resource.far = this._far;
                  this._resource.orthoSize = this._orthoSize;
                  this._resource.size = this._size;
                  this._resource.normal = this._normal;
                  this._resource.distance = this._distance;
                  this._resource.shadowColor = this._shadowColor;
                  this._resource.pcf = this._pcf;
                  this._resource.enabled = this._enabled;
                }
              }, {
                key: "enabled",

                /**
                 * @en Whether activate planar shadow
                 * @zh 是否启用平面阴影？
                 */
                set: function set(val) {
                  this._enabled = val;

                  if (this._resource) {
                    this._resource.enabled = val;
                  }
                },
                get: function get() {
                  return this._enabled;
                }
              }, {
                key: "type",
                set: function set(val) {
                  this._type = val;

                  if (this._resource) {
                    this._resource.type = val;
                  }
                },
                get: function get() {
                  return this._type;
                }
                /**
                 * @en Shadow color
                 * @zh 阴影颜色
                 */

              }, {
                key: "shadowColor",
                set: function set(val) {
                  this._shadowColor.set(val);

                  if (this._resource) {
                    this._resource.shadowColor = val;
                  }
                },
                get: function get() {
                  return this._shadowColor;
                }
                /**
                 * @en The normal of the plane which receives shadow
                 * @zh 阴影接收平面的法线
                 */

              }, {
                key: "normal",
                set: function set(val) {
                  Vec3.copy(this._normal, val);

                  if (this._resource) {
                    this._resource.normal = val;
                  }
                },
                get: function get() {
                  return this._normal;
                }
                /**
                 * @en The distance from coordinate origin to the receiving plane.
                 * @zh 阴影接收平面与原点的距离
                 */

              }, {
                key: "distance",
                set: function set(val) {
                  this._distance = val;

                  if (this._resource) {
                    this._resource.distance = val;
                  }
                },
                get: function get() {
                  return this._distance;
                }
                /**
                 * @en The normal of the plane which receives shadow
                 * @zh 阴影接收平面的法线
                 */

              }, {
                key: "pcf",
                set: function set(val) {
                  this._pcf = val;

                  if (this._resource) {
                    this._resource.pcf = val;
                  }
                },
                get: function get() {
                  return this._pcf;
                }
                /**
                 * @en get or set shadow camera near
                 * @zh 获取或者设置阴影相机近裁剪面
                 */

              }, {
                key: "near",
                set: function set(val) {
                  this._near = val;

                  if (this._resource) {
                    this._resource.near = val;
                  }
                },
                get: function get() {
                  return this._near;
                }
                /**
                 * @en get or set shadow camera far
                 * @zh 获取或者设置阴影相机远裁剪面
                 */

              }, {
                key: "far",
                set: function set(val) {
                  this._far = val;

                  if (this._resource) {
                    this._resource.far = val;
                  }
                },
                get: function get() {
                  return this._far;
                }
                /**
                 * @en get or set shadow camera orthoSize
                 * @zh 获取或者设置阴影相机正交大小
                 */

              }, {
                key: "orthoSize",
                set: function set(val) {
                  this._orthoSize = val;

                  if (this._resource) {
                    this._resource.orthoSize = val;
                  }
                },
                get: function get() {
                  return this._orthoSize;
                }
                /**
                 * @en get or set shadow camera orthoSize
                 * @zh 获取或者设置阴影纹理大小
                 */

              }, {
                key: "shadowMapSize",
                set: function set(val) {
                  this._size.set(val);

                  if (this._resource) {
                    this._resource.size = val;
                  }
                },
                get: function get() {
                  return this._size;
                }
                /**
                 * @en get or set shadow camera orthoSize
                 * @zh 获取或者设置阴影纹理大小
                 */

              }, {
                key: "aspect",
                set: function set(val) {
                  this._aspect = val;

                  if (this._resource) {
                    this._resource.aspect = val;
                  }
                },
                get: function get() {
                  return this._aspect;
                }
              }]);

              return ShadowsInfo;
            }(), _temp4$1), (_descriptor17$1 = _applyDecoratedDescriptor(_class11$1.prototype, "_type", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return ShadowType.Planar;
              }
            }), _descriptor18$1 = _applyDecoratedDescriptor(_class11$1.prototype, "_enabled", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return false;
              }
            }), _descriptor19$1 = _applyDecoratedDescriptor(_class11$1.prototype, "_normal", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Vec3(0, 1, 0);
              }
            }), _descriptor20$1 = _applyDecoratedDescriptor(_class11$1.prototype, "_distance", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 0;
              }
            }), _descriptor21$1 = _applyDecoratedDescriptor(_class11$1.prototype, "_shadowColor", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Color(0, 0, 0, 76);
              }
            }), _descriptor22$1 = _applyDecoratedDescriptor(_class11$1.prototype, "_pcf", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return PCFType.HARD;
              }
            }), _descriptor23$1 = _applyDecoratedDescriptor(_class11$1.prototype, "_near", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 1;
              }
            }), _descriptor24$1 = _applyDecoratedDescriptor(_class11$1.prototype, "_far", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 30;
              }
            }), _descriptor25$1 = _applyDecoratedDescriptor(_class11$1.prototype, "_aspect", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 1;
              }
            }), _descriptor26$1 = _applyDecoratedDescriptor(_class11$1.prototype, "_orthoSize", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return 5;
              }
            }), _descriptor27$1 = _applyDecoratedDescriptor(_class11$1.prototype, "_size", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Vec2(512, 512);
              }
            }), _applyDecoratedDescriptor(_class11$1.prototype, "enabled", [editable], Object.getOwnPropertyDescriptor(_class11$1.prototype, "enabled"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "type", [editable, _dec35], Object.getOwnPropertyDescriptor(_class11$1.prototype, "type"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "shadowColor", [editable], Object.getOwnPropertyDescriptor(_class11$1.prototype, "shadowColor"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "normal", [_dec36], Object.getOwnPropertyDescriptor(_class11$1.prototype, "normal"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "distance", [_dec37, _dec38], Object.getOwnPropertyDescriptor(_class11$1.prototype, "distance"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "pcf", [_dec39, _dec40], Object.getOwnPropertyDescriptor(_class11$1.prototype, "pcf"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "near", [_dec41, _dec42], Object.getOwnPropertyDescriptor(_class11$1.prototype, "near"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "far", [_dec43, _dec44], Object.getOwnPropertyDescriptor(_class11$1.prototype, "far"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "orthoSize", [_dec45, _dec46], Object.getOwnPropertyDescriptor(_class11$1.prototype, "orthoSize"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "shadowMapSize", [_dec47], Object.getOwnPropertyDescriptor(_class11$1.prototype, "shadowMapSize"), _class11$1.prototype), _applyDecoratedDescriptor(_class11$1.prototype, "aspect", [_dec48, _dec49], Object.getOwnPropertyDescriptor(_class11$1.prototype, "aspect"), _class11$1.prototype)), _class11$1)) || _class10$1);
            legacyCC.ShadowsInfo = ShadowsInfo;
            /**
             * @en All scene related global parameters, it affects all content in the corresponding scene
             * @zh 各类场景级别的渲染参数，将影响全场景的所有物体
             */

            var SceneGlobals = (_dec50 = ccclass('cc.SceneGlobals'), _dec51 = type(SkyboxInfo), _dec50(_class13$1 = (_class14$1 = (_temp5$1 = /*#__PURE__*/function () {
              function SceneGlobals() {
                _classCallCheck(this, SceneGlobals);

                _initializerDefineProperty(this, "ambient", _descriptor28$1, this);

                _initializerDefineProperty(this, "shadows", _descriptor29$1, this);

                _initializerDefineProperty(this, "_skybox", _descriptor30$1, this);

                _initializerDefineProperty(this, "fog", _descriptor31$1, this);
              }

              _createClass(SceneGlobals, [{
                key: "activate",
                value: function activate() {
                  var pipeline = legacyCC.director.root.pipeline;
                  this.ambient.activate(pipeline.ambient);
                  this.skybox.activate(pipeline.skybox);
                  this.shadows.activate(pipeline.shadows);
                  this.fog.activate(pipeline.fog);
                }
              }, {
                key: "skybox",

                /**
                 * @en Skybox related information
                 * @zh 天空盒相关信息
                 */
                get: function get() {
                  return this._skybox;
                },
                set: function set(value) {
                  this._skybox = value;
                }
              }]);

              return SceneGlobals;
            }(), _temp5$1), (_descriptor28$1 = _applyDecoratedDescriptor(_class14$1.prototype, "ambient", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new AmbientInfo();
              }
            }), _descriptor29$1 = _applyDecoratedDescriptor(_class14$1.prototype, "shadows", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new ShadowsInfo();
              }
            }), _descriptor30$1 = _applyDecoratedDescriptor(_class14$1.prototype, "_skybox", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new SkyboxInfo();
              }
            }), _descriptor31$1 = _applyDecoratedDescriptor(_class14$1.prototype, "fog", [editable, serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new FogInfo();
              }
            }), _applyDecoratedDescriptor(_class14$1.prototype, "skybox", [editable, _dec51], Object.getOwnPropertyDescriptor(_class14$1.prototype, "skybox"), _class14$1.prototype)), _class14$1)) || _class13$1);
            legacyCC.SceneGlobals = SceneGlobals;

            var _dec$F, _class$F, _class2$B, _descriptor$w, _descriptor2$o, _descriptor3$i, _descriptor4$b, _descriptor5$8, _temp$D;
            /**
             * @en
             * Scene is a subclass of [[BaseNode]], composed by nodes, representing the root of a runnable environment in the game.
             * It's managed by [[Director]] and user can switch from a scene to another using [[Director.loadScene]]
             * @zh
             * Scene 是 [[BaseNode]] 的子类，由节点所构成，代表着游戏中可运行的某一个整体环境。
             * 它由 [[Director]] 管理，用户可以使用 [[Director.loadScene]] 来切换场景
             */

            var Scene = exports('cX', (_dec$F = ccclass("cc.Scene"), _dec$F(_class$F = (_class2$B = (_temp$D = /*#__PURE__*/function (_BaseNode) {
              _inherits(Scene, _BaseNode);

              _createClass(Scene, [{
                key: "renderScene",

                /**
                 * @en The renderer scene, normally user don't need to use it
                 * @zh 渲染层场景，一般情况下用户不需要关心它
                 */
                get: function get() {
                  return this._renderScene;
                }
              }, {
                key: "globals",
                get: function get() {
                  return this._globals;
                }
                /**
                 * @en Indicates whether all (directly or indirectly) static referenced assets of this scene are releasable by default after scene unloading.
                 * @zh 指示该场景中直接或间接静态引用到的所有资源是否默认在场景切换后自动释放。
                 */

              }]);

              function Scene(name) {
                var _this;

                _classCallCheck(this, Scene);

                _this = _possibleConstructorReturn(this, _getPrototypeOf(Scene).call(this, name));

                _initializerDefineProperty(_this, "autoReleaseAssets", _descriptor$w, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_globals", _descriptor2$o, _assertThisInitialized(_this));

                _this._renderScene = null;
                _this.dependAssets = null;
                _this._inited = void 0;
                _this._prefabSyncedInLiveReload = false;
                _this._pos = Vec3.ZERO;
                _this._rot = Quat.IDENTITY;
                _this._scale = Vec3.ONE;
                _this._mat = Mat4.IDENTITY;
                _this._dirtyFlags = 0;

                _initializerDefineProperty(_this, "_lpos", _descriptor3$i, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_lrot", _descriptor4$b, _assertThisInitialized(_this));

                _initializerDefineProperty(_this, "_lscale", _descriptor5$8, _assertThisInitialized(_this));

                _this._activeInHierarchy = false;

                if (legacyCC.director && legacyCC.director.root) {
                  _this._renderScene = legacyCC.director.root.createScene({});
                }

                _this._inited = legacyCC.game ? !legacyCC.game._isCloning : true;
                return _this;
              }
              /**
               * @en Destroy the current scene and all its nodes, this action won't destroy related assets
               * @zh 销毁当前场景中的所有节点，这个操作不会销毁资源
               */


              _createClass(Scene, [{
                key: "destroy",
                value: function destroy() {
                  var success = _get(_getPrototypeOf(Scene.prototype), "destroy", this).call(this);

                  legacyCC.director.root.destroyScene(this._renderScene);
                  this._activeInHierarchy = false;
                  return success;
                }
                /**
                 * @en Only for compatibility purpose, user should not add any component to the scene
                 * @zh 仅为兼容性保留，用户不应该在场景上直接添加任何组件
                 */

              }, {
                key: "addComponent",
                value: function addComponent(typeOrClassName) {
                  throw new Error(getError(3822));
                }
              }, {
                key: "_onHierarchyChanged",
                value: function _onHierarchyChanged() {}
              }, {
                key: "_onBatchCreated",
                value: function _onBatchCreated() {
                  _get(_getPrototypeOf(Scene.prototype), "_onBatchCreated", this).call(this);

                  var len = this._children.length;

                  for (var i = 0; i < len; ++i) {
                    this._children[i]._onBatchCreated();
                  }
                }
              }, {
                key: "_onBatchRestored",
                value: function _onBatchRestored() {
                  this._onBatchCreated();
                } // transform helpers

                /**
                 * Refer to [[Node.getPosition]]
                 */

              }, {
                key: "getPosition",
                value: function getPosition(out) {
                  return Vec3.copy(out || new Vec3(), Vec3.ZERO);
                }
                /**
                 * Refer to [[Node.getRotation]]
                 */

              }, {
                key: "getRotation",
                value: function getRotation(out) {
                  return Quat.copy(out || new Quat(), Quat.IDENTITY);
                }
                /**
                 * Refer to [[Node.getScale]]
                 */

              }, {
                key: "getScale",
                value: function getScale(out) {
                  return Vec3.copy(out || new Vec3(), Vec3.ONE);
                }
                /**
                 * Refer to [[Node.getWorldPosition]]
                 */

              }, {
                key: "getWorldPosition",
                value: function getWorldPosition(out) {
                  return Vec3.copy(out || new Vec3(), Vec3.ZERO);
                }
                /**
                 * Refer to [[Node.getWorldRotation]]
                 */

              }, {
                key: "getWorldRotation",
                value: function getWorldRotation(out) {
                  return Quat.copy(out || new Quat(), Quat.IDENTITY);
                }
                /**
                 * Refer to [[Node.getWorldScale]]
                 */

              }, {
                key: "getWorldScale",
                value: function getWorldScale(out) {
                  return Vec3.copy(out || new Vec3(), Vec3.ONE);
                }
                /**
                 * Refer to [[Node.getWorldMatrix]]
                 */

              }, {
                key: "getWorldMatrix",
                value: function getWorldMatrix(out) {
                  return Mat4.copy(out || new Mat4(), Mat4.IDENTITY);
                }
                /**
                 * Refer to [[Node.getWorldRS]]
                 */

              }, {
                key: "getWorldRS",
                value: function getWorldRS(out) {
                  return Mat4.copy(out || new Mat4(), Mat4.IDENTITY);
                }
                /**
                 * Refer to [[Node.getWorldRT]]
                 */

              }, {
                key: "getWorldRT",
                value: function getWorldRT(out) {
                  return Mat4.copy(out || new Mat4(), Mat4.IDENTITY);
                }
                /**
                 * Refer to [[Node.position]]
                 */

              }, {
                key: "updateWorldTransform",

                /**
                 * Refer to [[Node.updateWorldTransform]]
                 */
                value: function updateWorldTransform() {} // life-cycle call backs

              }, {
                key: "_instantiate",
                value: function _instantiate() {}
              }, {
                key: "_load",
                value: function _load() {
                  if (!this._inited) {

                    this._onBatchCreated();

                    this._inited = true;
                  } // static methode can't use this as parameter type


                  this.walk(BaseNode._setScene);
                }
              }, {
                key: "_activate",
                value: function _activate(active) {
                  active = active !== false;

                  legacyCC.director._nodeActivator.activateNode(this, active);

                  this._globals.activate();
                }
              }, {
                key: "position",
                get: function get() {
                  return Vec3.ZERO;
                }
                /**
                 * Refer to [[Node.worldPosition]]
                 */

              }, {
                key: "worldPosition",
                get: function get() {
                  return Vec3.ZERO;
                }
                /**
                 * Refer to [[Node.rotation]]
                 */

              }, {
                key: "rotation",
                get: function get() {
                  return Quat.IDENTITY;
                }
                /**
                 * Refer to [[Node.worldRotation]]
                 */

              }, {
                key: "worldRotation",
                get: function get() {
                  return Quat.IDENTITY;
                }
                /**
                 * Refer to [[Node.scale]]
                 */

              }, {
                key: "scale",
                get: function get() {
                  return Vec3.ONE;
                }
                /**
                 * Refer to [[Node.worldScale]]
                 */

              }, {
                key: "worldScale",
                get: function get() {
                  return Vec3.ONE;
                }
                /**
                 * Refer to [[Node.eulerAngles]]
                 */

              }, {
                key: "eulerAngles",
                get: function get() {
                  return Vec3.ZERO;
                }
                /**
                 * Refer to [[Node.worldMatrix]]
                 */

              }, {
                key: "worldMatrix",
                get: function get() {
                  return Mat4.IDENTITY;
                }
              }]);

              return Scene;
            }(BaseNode), _temp$D), (_applyDecoratedDescriptor(_class2$B.prototype, "globals", [editable], Object.getOwnPropertyDescriptor(_class2$B.prototype, "globals"), _class2$B.prototype), _descriptor$w = _applyDecoratedDescriptor(_class2$B.prototype, "autoReleaseAssets", [serializable, editable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return false;
              }
            }), _descriptor2$o = _applyDecoratedDescriptor(_class2$B.prototype, "_globals", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new SceneGlobals();
              }
            }), _descriptor3$i = _applyDecoratedDescriptor(_class2$B.prototype, "_lpos", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Vec3();
              }
            }), _descriptor4$b = _applyDecoratedDescriptor(_class2$B.prototype, "_lrot", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Quat();
              }
            }), _descriptor5$8 = _applyDecoratedDescriptor(_class2$B.prototype, "_lscale", [serializable], {
              configurable: true,
              enumerable: true,
              writable: true,
              initializer: function initializer() {
                return new Vec3(1, 1, 1);
              }
            })), _class2$B)) || _class$F));
            legacyCC.Scene = Scene;

            var _dec$G, _class$G;
            // const POSITION_ON = 1 << 0;
            // @ts-ignore

            var HideInHierarchy = CCObject.Flags.HideInHierarchy;
            /**
             * @en
             * Class of private entities in Cocos Creator 3d scenes.<br/>
             * The PrivateNode is hidden in editor, and completely transparent to users.<br/>
             * It's normally used as Node's private content created by components in parent node.<br/>
             * So in theory private nodes are not children, they are part of the parent node.<br/>
             * Private node have two important characteristics:<br/>
             * 1. It has the minimum z index and cannot be modified, because they can't be displayed over real children.<br/>
             * 2. The positioning of private nodes is also special, they will consider the left bottom corner of the parent node's bounding box as the origin of local coordinates.<br/>
             *    In this way, they can be easily kept inside the bounding box.<br/>
             * Currently, it's used by RichText component and TileMap component.
             * @zh
             * Cocos Creator 3d 场景中的私有节点类。<br/>
             * 私有节点在编辑器中不可见，对用户透明。<br/>
             * 通常私有节点是被一些特殊的组件创建出来作为父节点的一部分而存在的，理论上来说，它们不是子节点，而是父节点的组成部分。<br/>
             * 私有节点有两个非常重要的特性：<br/>
             * 1. 它有着最小的渲染排序的 Z 轴深度，并且无法被更改，因为它们不能被显示在其他正常子节点之上。<br/>
             * 2. 它的定位也是特殊的，对于私有节点来说，父节点包围盒的左下角是它的局部坐标系原点，这个原点相当于父节点的位置减去它锚点的偏移。这样私有节点可以比较容易被控制在包围盒之中。<br/>
             * 目前在引擎中，RichText 和 TileMap 都有可能生成私有节点。
             */

            var PrivateNode = exports('c_', (_dec$G = ccclass('cc.PrivateNode'), _dec$G(_class$G = /*#__PURE__*/function (_Node) {
              _inherits(PrivateNode, _Node);

              // @property({
              //     override: true
              // })
              // get x() {
              //     return this._originPos.x;
              // }
              // set x(value) {
              //     var localPosition = this._originPos;
              //     if (value !== localPosition.x) {
              //         localPosition.x = value;
              //         this._posDirty(true);
              //     }
              // }
              // @property({
              //     override: true
              // })
              // get y() {
              //     return this._originPos.y;
              // }
              // set y(value) {
              //     var localPosition = this._originPos;
              //     if (value !== localPosition.y) {
              //         localPosition.y = value;
              //         this._posDirty(true);
              //     }
              // }
              // @property({
              //     override: true
              // })
              // get zIndex() {
              //     return cc.macro.MIN_ZINDEX;
              // }
              // set zIndex(val) {
              //     cc.warnID(1638);
              // }
              function PrivateNode(name) {
                var _this;

                _classCallCheck(this, PrivateNode);

                _this = _possibleConstructorReturn(this, _getPrototypeOf(PrivateNode).call(this, name)); // this._originPos = cc.v2();

                _this._objFlags |= HideInHierarchy;
                return _this;
              } // _posDirty (sendEvent) {
              //     this.setLocalDirty(LocalDirtyFlag.POSITION);
              //     if (sendEvent === true && (this._eventMask & POSITION_ON)) {
              //         this.emit(Node.EventType.POSITION_CHANGED);
              //     }
              // }
              // _updateLocalMatrix() {
              //     if (!this._localMatDirty) return;
              //     let parent = this.parent;
              //     if (parent) {
              //         // Position correction for transform calculation
              //         this._position.x = this._originPos.x - (parent._anchorPoint.x - 0.5) * parent._contentSize.width;
              //         this._position.y = this._originPos.y - (parent._anchorPoint.y - 0.5) * parent._contentSize.height;
              //     }
              //     super._updateLocalMatrix();
              // }
              // getPosition () {
              //     return new cc.Vec2(this._originPos);
              // }
              // setPosition (x, y) {
              //     if (y === undefined) {
              //         x = x.x;
              //         y = x.y;
              //     }
              //     let pos = this._originPos;
              //     if (pos.x === x && pos.y === y) {
              //         return;
              //     }
              //     pos.x = x;
              //     pos.y = y;
              //     this._posDirty(true);
              // }
              // setParent(value) {
              //     let oldParent = this._parent;
              //     super.setParent(value);
              //     if (oldParent !== value) {
              //         if (oldParent) {
              //             oldParent.off(Node.EventType.ANCHOR_CHANGED, this._posDirty, this);
              //         }
              //         if (value) {
              //             value.on(Node.EventType.ANCHOR_CHANGED, this._posDirty, this);
              //         }
              //     }
              // }
              // do not update order of arrival
              // public _updateOrderOfArrival () {}


              return PrivateNode;
            }(Node)) || _class$G)); // cc.js.getset(PrivateNode.prototype, 'parent', PrivateNode.prototype.getParent, PrivateNode.prototype.setParent);
            // cc.js.getset(PrivateNode.prototype, 'position', PrivateNode.prototype.getPosition, PrivateNode.prototype.setPosition);

            legacyCC.PrivateNode = PrivateNode;

            var fastRemoveAt = array.fastRemoveAt; // @ts-ignore

            var IsStartCalled = CCObject.Flags.IsStartCalled; // @ts-ignore

            var IsOnEnableCalled = CCObject.Flags.IsOnEnableCalled; // @ts-ignore

            var IsEditorOnEnableCalled = CCObject.Flags.IsEditorOnEnableCalled;

            function sortedIndex(array, comp) {
              var order = comp.constructor._executionOrder;
              var id = comp._id;
              var l = 0;

              for (var h = array.length - 1, m = h >>> 1; l <= h; m = l + h >>> 1) {
                var test = array[m];
                var testOrder = test.constructor._executionOrder;

                if (testOrder > order) {
                  h = m - 1;
                } else if (testOrder < order) {
                  l = m + 1;
                } else {
                  var testId = test._id;

                  if (testId > id) {
                    h = m - 1;
                  } else if (testId < id) {
                    l = m + 1;
                  } else {
                    return m;
                  }
                }
              }

              return ~l;
            } // remove disabled and not invoked component from array


            function stableRemoveInactive(iterator, flagToClear) {
              var array = iterator.array;
              var next = iterator.i + 1;

              while (next < array.length) {
                var comp = array[next];

                if (comp._enabled && comp.node._activeInHierarchy) {
                  ++next;
                } else {
                  iterator.removeAt(next);

                  if (flagToClear) {
                    comp._objFlags &= ~flagToClear;
                  }
                }
              }
            } // This class contains some queues used to invoke life-cycle methods by script execution order


            var LifeCycleInvoker = function LifeCycleInvoker(invokeFunc) {
              _classCallCheck(this, LifeCycleInvoker);

              this._zero = void 0;
              this._neg = void 0;
              this._pos = void 0;
              this._invoke = void 0;
              var Iterator = MutableForwardIterator; // components which priority === 0 (default)

              this._zero = new Iterator([]); // components which priority < 0

              this._neg = new Iterator([]); // components which priority > 0

              this._pos = new Iterator([]);

              this._invoke = invokeFunc;
            };
            LifeCycleInvoker.stableRemoveInactive = stableRemoveInactive;

            function compareOrder(a, b) {
              return a.constructor._executionOrder - b.constructor._executionOrder;
            } // for onLoad: sort once all components registered, invoke once


            var OneOffInvoker = /*#__PURE__*/function (_LifeCycleInvoker) {
              _inherits(OneOffInvoker, _LifeCycleInvoker);

              function OneOffInvoker() {
                _classCallCheck(this, OneOffInvoker);

                return _possibleConstructorReturn(this, _getPrototypeOf(OneOffInvoker).apply(this, arguments));
              }

              _createClass(OneOffInvoker, [{
                key: "add",
                value: function add(comp) {
                  var order = comp.constructor._executionOrder;
                  (order === 0 ? this._zero : order < 0 ? this._neg : this._pos).array.push(comp);
                }
              }, {
                key: "remove",
                value: function remove(comp) {
                  var order = comp.constructor._executionOrder;
                  (order === 0 ? this._zero : order < 0 ? this._neg : this._pos).fastRemove(comp);
                }
              }, {
                key: "cancelInactive",
                value: function cancelInactive(flagToClear) {
                  stableRemoveInactive(this._zero, flagToClear);
                  stableRemoveInactive(this._neg, flagToClear);
                  stableRemoveInactive(this._pos, flagToClear);
                }
              }, {
                key: "invoke",
                value: function invoke() {
                  var compsNeg = this._neg;

                  if (compsNeg.array.length > 0) {
                    compsNeg.array.sort(compareOrder);

                    this._invoke(compsNeg);

                    compsNeg.array.length = 0;
                  }

                  this._invoke(this._zero);

                  this._zero.array.length = 0;
                  var compsPos = this._pos;

                  if (compsPos.array.length > 0) {
                    compsPos.array.sort(compareOrder);

                    this._invoke(compsPos);

                    compsPos.array.length = 0;
                  }
                }
              }]);

              return OneOffInvoker;
            }(LifeCycleInvoker); // for update: sort every time new component registered, invoke many times

            var ReusableInvoker = /*#__PURE__*/function (_LifeCycleInvoker2) {
              _inherits(ReusableInvoker, _LifeCycleInvoker2);

              function ReusableInvoker() {
                _classCallCheck(this, ReusableInvoker);

                return _possibleConstructorReturn(this, _getPrototypeOf(ReusableInvoker).apply(this, arguments));
              }

              _createClass(ReusableInvoker, [{
                key: "add",
                value: function add(comp) {
                  var order = comp.constructor._executionOrder;

                  if (order === 0) {
                    this._zero.array.push(comp);
                  } else {
                    var _array = order < 0 ? this._neg.array : this._pos.array;

                    var i = sortedIndex(_array, comp);

                    if (i < 0) {
                      _array.splice(~i, 0, comp);
                    }
                  }
                }
              }, {
                key: "remove",
                value: function remove(comp) {
                  var order = comp.constructor._executionOrder;

                  if (order === 0) {
                    this._zero.fastRemove(comp);
                  } else {
                    var iterator = order < 0 ? this._neg : this._pos;
                    var i = sortedIndex(iterator.array, comp);

                    if (i >= 0) {
                      iterator.removeAt(i);
                    }
                  }
                }
              }, {
                key: "invoke",
                value: function invoke(dt) {
                  if (this._neg.array.length > 0) {
                    this._invoke(this._neg, dt);
                  }

                  this._invoke(this._zero, dt);

                  if (this._pos.array.length > 0) {
                    this._invoke(this._pos, dt);
                  }
                }
              }]);

              return ReusableInvoker;
            }(LifeCycleInvoker);


            function createInvokeImplJit(code, useDt, ensureFlag) {
              // function (it) {
              //     let a = it.array;
              //     for (it.i = 0; it.i < a.length; ++it.i) {
              //         let c = a[it.i];
              //         // ...
              //     }
              // }
              var body = 'var a=it.array;' + 'for(it.i=0;it.i<a.length;++it.i){' + 'var c=a[it.i];' + code + '}';
              var fastPath = useDt ? Function('it', 'dt', body) : Function('it', body);
              var singleInvoke = Function('c', 'dt', code);
              return createInvokeImpl(singleInvoke, fastPath, ensureFlag);
            }
            function createInvokeImpl(singleInvoke, fastPath, ensureFlag) {
              return function (iterator, dt) {
                try {
                  fastPath(iterator, dt);
                } catch (e) {
                  // slow path
                  legacyCC._throw(e);

                  var array = iterator.array;

                  if (ensureFlag) {
                    array[iterator.i]._objFlags |= ensureFlag;
                  }

                  ++iterator.i; // invoke next callback

                  for (; iterator.i < array.length; ++iterator.i) {
                    try {
                      singleInvoke(array[iterator.i], dt);
                    } catch (e) {
                      legacyCC._throw(e);

                      if (ensureFlag) {
                        array[iterator.i]._objFlags |= ensureFlag;
                      }
                    }
                  }
                }
              };
            }
            var invokeStart =  createInvokeImplJit('c.start();c._objFlags|=' + IsStartCalled, false, IsStartCalled) ;
            var invokeUpdate =  createInvokeImplJit('c.update(dt)', true) ;
            var invokeLateUpdate =  createInvokeImplJit('c.lateUpdate(dt)', true) ;
            var invokeOnEnable =  function (iterator) {
              var compScheduler = legacyCC.director._compScheduler;
              var array = iterator.array;

              for (iterator.i = 0; iterator.i < array.length; ++iterator.i) {
                var comp = array[iterator.i];

                if (comp._enabled) {
                  comp.onEnable();
                  var deactivatedDuringOnEnable = !comp.node._activeInHierarchy;

                  if (!deactivatedDuringOnEnable) {
                    compScheduler._onEnabled(comp);
                  }
                }
              }
            };
            /**
             * @en The Manager for Component's life-cycle methods.
             * It collaborates with [[NodeActivator]] to schedule and invoke life cycle methods for components
             * @zh 组件生命周期函数的调度器。
             * 它和 [[NodeActivator]] 一起调度并执行组件的生命周期函数。
             */

            var ComponentScheduler = exports('dr', /*#__PURE__*/function () {
              /**
               * @en The invoker of `start` callback
               * @zh `start` 回调的调度器
               */

              /**
               * @en The invoker of `update` callback
               * @zh `update` 回调的调度器
               */

              /**
               * @en The invoker of `lateUpdate` callback
               * @zh `lateUpdate` 回调的调度器
               */
              // components deferred to schedule
              function ComponentScheduler() {
                _classCallCheck(this, ComponentScheduler);

                this._deferredComps = [];
                this.unscheduleAll();
              }
              /**
               * @en Cancel all future callbacks, including `start`, `update` and `lateUpdate`
               * @zh 取消所有未来的函数调度，包括 `start`，`update` 和 `lateUpdate`
               */


              _createClass(ComponentScheduler, [{
                key: "unscheduleAll",
                value: function unscheduleAll() {
                  // invokers
                  this.startInvoker = new OneOffInvoker(invokeStart);
                  this.updateInvoker = new ReusableInvoker(invokeUpdate);
                  this.lateUpdateInvoker = new ReusableInvoker(invokeLateUpdate); // during a loop

                  this._updating = false;
                }
              }, {
                key: "_onEnabled",
                value: function _onEnabled(comp) {
                  legacyCC.director.getScheduler().resumeTarget(comp);
                  comp._objFlags |= IsOnEnableCalled; // schedule

                  if (this._updating) {
                    this._deferredComps.push(comp);
                  } else {
                    this._scheduleImmediate(comp);
                  }
                }
              }, {
                key: "_onDisabled",
                value: function _onDisabled(comp) {
                  legacyCC.director.getScheduler().pauseTarget(comp);
                  comp._objFlags &= ~IsOnEnableCalled; // cancel schedule task

                  var index = this._deferredComps.indexOf(comp);

                  if (index >= 0) {
                    fastRemoveAt(this._deferredComps, index);
                    return;
                  } // unschedule


                  if (comp.start && !(comp._objFlags & IsStartCalled)) {
                    this.startInvoker.remove(comp);
                  }

                  if (comp.update) {
                    this.updateInvoker.remove(comp);
                  }

                  if (comp.lateUpdate) {
                    this.lateUpdateInvoker.remove(comp);
                  }
                }
                /**
                 * @en Enable a component
                 * @zh 启用一个组件
                 * @param comp The component to be enabled
                 * @param invoker The invoker which is responsible to schedule the `onEnable` call
                 */

              }, {
                key: "enableComp",
                value: function enableComp(comp, invoker) {
                  if (!(comp._objFlags & IsOnEnableCalled)) {
                    if (comp.onEnable) {
                      if (invoker) {
                        invoker.add(comp);
                        return;
                      } else {
                        comp.onEnable();
                        var deactivatedDuringOnEnable = !comp.node._activeInHierarchy;

                        if (deactivatedDuringOnEnable) {
                          return;
                        }
                      }
                    }

                    this._onEnabled(comp);
                  }
                }
                /**
                 * @en Disable a component
                 * @zh 禁用一个组件
                 * @param comp The component to be disabled
                 */

              }, {
                key: "disableComp",
                value: function disableComp(comp) {
                  if (comp._objFlags & IsOnEnableCalled) {
                    if (comp.onDisable) {
                      comp.onDisable();
                    }

                    this._onDisabled(comp);
                  }
                }
                /**
                 * @en Process start phase for registered components
                 * @zh 为当前注册的组件执行 start 阶段任务
                 */

              }, {
                key: "startPhase",
                value: function startPhase() {
                  // Start of this frame
                  this._updating = true; // call start

                  this.startInvoker.invoke(); // Start components of new activated nodes during start

                  this._startForNewComps(); // if (PREVIEW) {
                  //     try {
                  //         this.startInvoker.invoke();
                  //     }
                  //     catch (e) {
                  //         // prevent start from getting into infinite loop
                  //         this.startInvoker._neg.array.length = 0;
                  //         this.startInvoker._zero.array.length = 0;
                  //         this.startInvoker._pos.array.length = 0;
                  //         throw e;
                  //     }
                  // }
                  // else {
                  //     this.startInvoker.invoke();
                  // }

                }
                /**
                 * @en Process update phase for registered components
                 * @zh 为当前注册的组件执行 update 阶段任务
                 * @param dt 距离上一帧的时间
                 */

              }, {
                key: "updatePhase",
                value: function updatePhase(dt) {
                  this.updateInvoker.invoke(dt);
                }
                /**
                 * @en Process late update phase for registered components
                 * @zh 为当前注册的组件执行 late update 阶段任务
                 * @param dt 距离上一帧的时间
                 */

              }, {
                key: "lateUpdatePhase",
                value: function lateUpdatePhase(dt) {
                  this.lateUpdateInvoker.invoke(dt); // End of this frame

                  this._updating = false; // Start components of new activated nodes during update and lateUpdate
                  // They will be running in the next frame

                  this._startForNewComps();
                } // Call new registered start schedule immediately since last time start phase calling in this frame
                // See cocos-creator/2d-tasks/issues/256

              }, {
                key: "_startForNewComps",
                value: function _startForNewComps() {
                  if (this._deferredComps.length > 0) {
                    this._deferredSchedule();

                    this.startInvoker.invoke();
                  }
                }
              }, {
                key: "_scheduleImmediate",
                value: function _scheduleImmediate(comp) {
                  if (typeof comp.start === 'function' && !(comp._objFlags & IsStartCalled)) {
                    this.startInvoker.add(comp);
                  }

                  if (typeof comp.update === 'function') {
                    this.updateInvoker.add(comp);
                  }

                  if (typeof comp.lateUpdate === 'function') {
                    this.lateUpdateInvoker.add(comp);
                  }
                }
              }, {
                key: "_deferredSchedule",
                value: function _deferredSchedule() {
                  var comps = this._deferredComps;

                  for (var i = 0, len = comps.length; i < len; i++) {
                    this._scheduleImmediate(comps[i]);
                  }

                  comps.length = 0;
                }
              }]);

              return ComponentScheduler;
            }());

            var MAX_POOL_SIZE = 4; // @ts-ignore

            var IsPreloadStarted = CCObject.Flags.IsPreloadStarted; // @ts-ignore

            var IsOnLoadStarted = CCObject.Flags.IsOnLoadStarted; // @ts-ignore

            var IsOnLoadCalled = CCObject.Flags.IsOnLoadCalled; // @ts-ignore

            var Deactivating$1 = CCObject.Flags.Deactivating;

            var UnsortedInvoker = /*#__PURE__*/function (_LifeCycleInvoker) {
              _inherits(UnsortedInvoker, _LifeCycleInvoker);

              function UnsortedInvoker() {
                _classCallCheck(this, UnsortedInvoker);

                return _possibleConstructorReturn(this, _getPrototypeOf(UnsortedInvoker).apply(this, arguments));
              }

              _createClass(UnsortedInvoker, [{
                key: "add",
                value: function add(comp) {
                  this._zero.array.push(comp);
                }
              }, {
                key: "remove",
                value: function remove(comp) {
                  this._zero.fastRemove(comp);
                }
              }, {
                key: "cancelInactive",
                value: function cancelInactive(flagToClear) {
                  LifeCycleInvoker.stableRemoveInactive(this._zero, flagToClear);
                }
              }, {
                key: "invoke",
                value: function invoke() {
                  this._invoke(this._zero);

                  this._zero.array.length = 0;
                }
              }]);

              return UnsortedInvoker;
            }(LifeCycleInvoker);

            var invokePreload =  createInvokeImplJit('c.__preload();') ;
            var invokeOnLoad =  createInvokeImplJit('c.onLoad();c._objFlags|=' + IsOnLoadCalled, false, IsOnLoadCalled) ;
            var activateTasksPool = new Pool$1(MAX_POOL_SIZE);

            activateTasksPool.get = function getActivateTask() {
              var task = this._get() || {
                preload: new UnsortedInvoker(invokePreload),
                onLoad: new OneOffInvoker(invokeOnLoad),
                onEnable: new OneOffInvoker(invokeOnEnable)
              }; // reset index to -1 so we can skip invoked component in cancelInactive

              task.preload._zero.i = -1;
              var invoker = task.onLoad;
              invoker._zero.i = -1;
              invoker._neg.i = -1;
              invoker._pos.i = -1;
              invoker = task.onEnable;
              invoker._zero.i = -1;
              invoker._neg.i = -1;
              invoker._pos.i = -1;
              return task;
            };

            function _componentCorrupted(node, comp, index) {

              if (comp) {
                node._removeComponent(comp);
              } else {
                array.removeAt(node._components, index);
              }
            }
            /**
             * @en The class used to perform activating and deactivating operations of node and component.
             * @zh 用于执行节点和组件的激活和停用操作的管理器。
             */


            var NodeActivator = exports('c$', /*#__PURE__*/function () {
              function NodeActivator() {
                _classCallCheck(this, NodeActivator);

                this.resetComp = void 0;
                this.reset();
              }
              /**
               * @en Reset all activation or des-activation tasks
               * @zh 重置所有激活或非激活任务
               */


              _createClass(NodeActivator, [{
                key: "reset",
                value: function reset() {
                  // a stack of node's activating tasks
                  this._activatingStack = [];
                }
                /**
                 * @en Activate or des-activate a node
                 * @zh 激活或者停用某个节点
                 * @param node Target node
                 * @param active Which state to set the node to
                 */

              }, {
                key: "activateNode",
                value: function activateNode(node, active) {
                  if (active) {
                    var task = activateTasksPool.get();

                    this._activatingStack.push(task);

                    this._activateNodeRecursively(node, task.preload, task.onLoad, task.onEnable);

                    task.preload.invoke();
                    task.onLoad.invoke();
                    task.onEnable.invoke();

                    this._activatingStack.pop();

                    activateTasksPool.put(task);
                  } else {
                    this._deactivateNodeRecursively(node); // remove children of this node from previous activating tasks to debounce
                    // (this is an inefficient operation but it ensures general case could be implemented in a efficient way)


                    var stack = this._activatingStack;

                    for (var _iterator = _createForOfIteratorHelperLoose(stack), _step; !(_step = _iterator()).done;) {
                      var lastTask = _step.value;
                      lastTask.preload.cancelInactive(IsPreloadStarted);
                      lastTask.onLoad.cancelInactive(IsOnLoadStarted);
                      lastTask.onEnable.cancelInactive();
                    }
                  }

                  node.emit('active-in-hierarchy-changed', node);
                }
                /**
                 * @en Activate or des-activate a component
                 * @zh 激活或者停用某个组件
                 * @param comp Target component
                 * @param preloadInvoker The invoker for `_preload` method, normally from [[ComponentScheduler]]
                 * @param onLoadInvoker The invoker for `onLoad` method, normally from [[ComponentScheduler]]
                 * @param onEnableInvoker The invoker for `onEnable` method, normally from [[ComponentScheduler]]
                 */

              }, {
                key: "activateComp",
                value: function activateComp(comp, preloadInvoker, onLoadInvoker, onEnableInvoker) {
                  if (!(comp._objFlags & IsPreloadStarted)) {
                    comp._objFlags |= IsPreloadStarted;

                    if (comp.__preload) {
                      if (preloadInvoker) {
                        preloadInvoker.add(comp);
                      } else {
                        comp.__preload();
                      }
                    }
                  }

                  if (!(comp._objFlags & IsOnLoadStarted)) {
                    comp._objFlags |= IsOnLoadStarted;

                    if (comp.onLoad) {
                      if (onLoadInvoker) {
                        onLoadInvoker.add(comp);
                      } else {
                        comp.onLoad();
                        comp._objFlags |= IsOnLoadCalled;
                      }
                    } else {
                      comp._objFlags |= IsOnLoadCalled;
                    }
                  }

                  if (comp._enabled) {
                    var deactivatedOnLoading = !comp.node._activeInHierarchy;

                    if (deactivatedOnLoading) {
                      return;
                    }

                    legacyCC.director._compScheduler.enableComp(comp, onEnableInvoker);
                  }
                }
                /**
                 * @en Destroy a component
                 * @zh 销毁一个组件
                 * @param comp Target component
                 */

              }, {
                key: "destroyComp",
                value: function destroyComp(comp) {
                  // ensure onDisable called
                  legacyCC.director._compScheduler.disableComp(comp);

                  if (comp.onDestroy && comp._objFlags & IsOnLoadCalled) {
                    comp.onDestroy();
                  }
                }
              }, {
                key: "_activateNodeRecursively",
                value: function _activateNodeRecursively(node, preloadInvoker, onLoadInvoker, onEnableInvoker) {
                  if (node._objFlags & Deactivating$1) {
                    // en:
                    // Forbid reactive the same node during its deactivating procedure
                    // to avoid endless loop and simplify the implementation.
                    // zh:
                    // 对相同节点而言，无法撤销反激活，防止反激活 - 激活 - 反激活的死循环发生。
                    // 这样设计简化了一些引擎的实现，而且对调用者来说能保证反激活操作都能成功。
                    errorID(3816, node.name);
                    return;
                  }

                  node._activeInHierarchy = true; // component maybe added during onEnable, and the onEnable of new component is already called
                  // so we should record the origin length

                  var originCount = node._components.length; // activate components

                  for (var i = 0; i < originCount; ++i) {
                    var component = node._components[i];

                    if (component instanceof legacyCC.Component) {
                      this.activateComp(component, preloadInvoker, onLoadInvoker, onEnableInvoker);
                    } else {
                      _componentCorrupted(node, component, i);

                      --i;
                      --originCount;
                    }
                  }

                  node._childArrivalOrder = node._children.length; // activate children recursively

                  for (var _i = 0, len = node._children.length; _i < len; ++_i) {
                    var child = node._children[_i];

                    if (child._active) {
                      this._activateNodeRecursively(child, preloadInvoker, onLoadInvoker, onEnableInvoker);
                    }
                  }

                  node._onPostActivated(true);
                }
              }, {
                key: "_deactivateNodeRecursively",
                value: function _deactivateNodeRecursively(node) {

                  node._objFlags |= Deactivating$1;
                  node._activeInHierarchy = false; // component maybe added during onEnable, and the onEnable of new component is already called
                  // so we should record the origin length

                  var originCount = node._components.length;

                  for (var c = 0; c < originCount; ++c) {
                    var component = node._components[c];

                    if (component._enabled) {
                      legacyCC.director._compScheduler.disableComp(component);

                      if (node._activeInHierarchy) {
                        // reactivated from root
                        node._objFlags &= ~Deactivating$1;
                        return;
                      }
                    }
                  }

                  for (var i = 0, len = node._children.length; i < len; ++i) {
                    var child = node._children[i];

                    if (child._activeInHierarchy) {
                      this._deactivateNodeRecursively(child);

                      if (node._activeInHierarchy) {
                        // reactivated from root
                        node._objFlags &= ~Deactivating$1;
                        return;
                      }
                    }
                  }

                  node._onPostActivated(false);

                  node._objFlags &= ~Deactivating$1;
                }
              }]);

              return NodeActivator;
            }());

            /**
             * @hidden
             */
            replaceProperty(BaseNode.prototype, 'BaseNode', [{
              'name': 'childrenCount',
              'newName': 'children.length',
              'customGetter': function customGetter() {
                return this.children.length;
              }
            }]);
            replaceProperty(Node.prototype, 'Node', [{
              'name': 'width',
              'targetName': 'node.getComponent(UITransform)',
              'customGetter': function customGetter() {
                return this._uiProps.uiTransformComp.width;
              },
              'customSetter': function customSetter(value) {
                this._uiProps.uiTransformComp.width = value;
              }
            }, {
              'name': 'height',
              'targetName': 'node.getComponent(UITransform)',
              'customGetter': function customGetter() {
                return this._uiProps.uiTransformComp.height;
              },
              'customSetter': function customSetter(value) {
                this._uiProps.uiTransformComp.height = value;
              }
            }, {
              'name': 'anchorX',
              'targetName': 'node.getComponent(UITransform)',
              'customGetter': function customGetter() {
                return this._uiProps.uiTransformComp.anchorX;
              },
              'customSetter': function customSetter(value) {
                this._uiProps.uiTransformComp.anchorX = value;
              }
            }, {
              'name': 'anchorY',
              'targetName': 'node.getComponent(UITransform)',
              'customGetter': function customGetter() {
                return this._uiProps.uiTransformComp.anchorY;
              },
              'customSetter': function customSetter(value) {
                this._uiProps.uiTransformComp.anchorY = value;
              }
            }, {
              'name': 'getAnchorPoint',
              'targetName': 'node.getComponent(UITransform)',
              'customFunction': function customFunction(out) {
                if (!out) {
                  out = new Vec2();
                }

                out.set(this._uiProps.uiTransformComp.anchorPoint);
                return out;
              }
            }, {
              'name': 'setAnchorPoint',
              'targetName': 'node.getComponent(UITransform)',
              'customFunction': function customFunction(point, y) {
                this._uiProps.uiTransformComp.setAnchorPoint(point, y);
              }
            }, {
              'name': 'getContentSize',
              'targetName': 'node.getComponent(UITransform)',
              'customFunction': function customFunction(out) {
                if (!out) {
                  out = new Size();
                }

                out.set(this._uiProps.uiTransformComp.contentSize);
                return out;
              }
            }, {
              'name': 'setContentSize',
              'targetName': 'node.getComponent(UITransform)',
              'customFunction': function customFunction(size, height) {
                this._uiProps.uiTransformComp.setContentSize(size, height);
              }
            }]);
            removeProperty(Node.prototype, 'Node.prototype', [{
              'name': 'addLayer'
            }, {
              'name': 'removeLayer'
            }]);
            removeProperty(Layers, 'Layers', [{
              'name': 'All'
            }, {
              'name': 'RaycastMask'
            }, {
              'name': 'check'
            }]);
            replaceProperty(Layers, 'Layers', [{
              name: 'Default',
              newName: 'DEFAULT',
              target: Layers.Enum,
              targetName: 'Layers.Enum'
            }, {
              name: 'Always',
              newName: 'ALWAYS',
              target: Layers.Enum,
              targetName: 'Layers.Enum'
            }, {
              name: 'IgnoreRaycast',
              newName: 'IGNORE_RAYCAST',
              target: Layers.Enum,
              targetName: 'Layers.Enum'
            }, {
              name: 'Gizmos',
              newName: 'GIZMOS',
              target: Layers.Enum,
              targetName: 'Layers.Enum'
            }, {
              name: 'Editor',
              newName: 'EDITOR',
              target: Layers.Enum,
              targetName: 'Layers.Enum'
            }, {
              name: 'UI',
              newName: 'UI_3D',
              target: Layers.Enum,
              targetName: 'Layers.Enum'
            }, {
              name: 'UI2D',
              newName: 'UI_2D',
              target: Layers.Enum,
              targetName: 'Layers.Enum'
            }, {
              name: 'SceneGizmo',
              newName: 'SCENE_GIZMO',
              target: Layers.Enum,
              targetName: 'Layers.Enum'
            }, {
              name: 'makeInclusiveMask',
              newName: 'makeMaskInclude',
              target: Layers,
              targetName: 'Layers'
            }, {
              name: 'makeExclusiveMask',
              newName: 'makeMaskExclude',
              target: Layers,
              targetName: 'Layers'
            }]);
            removeProperty(Layers.Enum, 'Layers.Enum', [{
              'name': 'ALWAYS'
            }]);
            removeProperty(Layers.BitMask, 'Layers.BitMask', [{
              'name': 'ALWAYS'
            }]);

        }
    };
});
